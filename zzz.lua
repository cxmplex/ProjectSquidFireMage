local squidFn = function()
	squid_version = 4.69

	AlertFrames = {}
	BigAlertFrames = {}
	soundplayed = {}

	ewt_callbacks = {}
	function AddEWTCallback(callback)
		table.insert(ewt_callbacks,callback)
	end

	local cfe
	local sui
	local sui_bold
	local locale = GetLocale()

	function round(num, numDecimalPlaces)
	  local mult = 10^(numDecimalPlaces or 0)
	  return math.floor(num * mult + 0.5) / mult
	end

	function Squid_GUI_Update()

		local time = GetTime()

		--saved vars modified by gui
		SQUID.gui_coords = SQUID.gui_coords or {}
		SQUID.objects_to_draw = SQUID.objects_to_draw or {}
		SQUID.max_object_finder_dist = SQUID.max_object_finder_dist or 80
		SQUID.alert_after_reload = SQUID.alert_after_reload or {}

		if SQUID.alert_after_reload["segoeuib.ttf"] then
			C_Timer.After(3,function()
				Squid_Alert("Alerts font was updated.")
				Squid_Alert_Big("How do I look? ;)")
				SQUID.alert_after_reload["segoeuib.ttf"] = nil
			end)
		end

		local function same_file(table1,table2)
			if not table1 or not table2 then return false end
			if #table1 ~= #table2 then return false end
			for i=1,#table1 do
				if table1[i] ~= table2[i] then
					print(table1[i], table2[i])
					return false
				end
			end
			return true
		end

		-- cant do this any more ;(
		-- if not squid_media_updated then
		-- 	local dir = Squid_Directory() .. "/media/"
		-- 	if dir then
		-- 		--segoeuib (sui_bold)
		-- 		SendHTTPRequest("ewt://@395E9F176492D6F1B08EC37B37F6C89EB873EB94D90C78F87544ADD1FAB6F413F21160D1047A27166544F251063F0683DCC3CFF452433885E1D82E0DD76A045C",nil,
		-- 			function(x)
		-- 				if x then
		-- 					local current_file = ReadFile(dir .. "segoeuib.ttf", 0x1)
		-- 					if not same_file(current_file,x) then
		-- 						if WriteFile(dir .. "segoeuib.ttf",x) then
		-- 							SQUID.alert_after_reload["segoeuib.ttf"] = true
		-- 							ReloadUI()
		-- 						end
		-- 					end
		-- 				end
		-- 			end,
		-- 			nil,
		-- 			0x2
		-- 		)
		-- 	end
		-- 	squid_media_updated = true
		-- end

		-- if not squid_sounds_updated then
		-- 	local dir = Squid_Directory() .. "/media/"
		-- 	if dir then
		-- 		--sounds.zip
		-- 		SendHTTPRequest("https://www.projectsquid.com/wp-content/sounds.zip",nil,
		-- 			function(x)
		-- 				if x then
		-- 					local current_file = ReadFile(dir .. "sounds.zip", 0x1)
		-- 					if not same_file(current_file,x) then
		-- 						if WriteFile(dir .. "sounds.zip",x) then
		-- 							unzip_and_alert = true
		-- 						end
		-- 					end
		-- 				end
		-- 			end,
		-- 			nil,
		-- 			0x2
		-- 		)
		-- 	end
		-- 	squid_sounds_updated = true
		-- end

		if unzip_and_alert then
			local dir = Squid_Directory() .. "/media/"
			UnzipFile(dir .. "sounds.zip", dir)
			C_Timer.After(2,function() Squid_Alert("Sound Files Updated") end)
			unzip_and_alert = nil
		end

		if locale == "enUS" then
			sui = Squid_Directory() .. "/media/Segoe UI Light.ttf"
			cfe = Squid_Directory() .. "/media/Seguisym.ttf"
			-- cfe = "Fonts\\FRIZQT__.TTF"
		elseif locale == "zhCN" then
			sui = "Fonts\\ARHei.ttf"
			cfe = "Fonts\\ARHei.ttf"
		else
			sui = Squid_Directory() .. "/media/Segoe UI Light.ttf"
			cfe = Squid_Directory() .. "/media/Seguisym.ttf"
		end

		sui_bold = Squid_Directory() .. "/media/segoeuib.ttf"

		SquidFont = CreateFont("SquidFont")
		SquidFont:SetFont(cfe,12,'OUTLINE')

		SquidFontMedium = CreateFont("SquidFontMedium")
		SquidFontMedium:SetFont(cfe,22,'OUTLINE')

		local framerate = GetFramerate()

		--AlertFrames Anchor
		if not AlertFrames_Anchor then
			AlertFrames_Anchor = CreateFrame("Frame", nil, self, "BackdropTemplate")

			local backdrop = {
			bgFile = "Interface/Tooltips/UI-Tooltip-Background",
			tileSize = 256,
			edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
			tile = 1,
			edgeSize = 3,
			insets = {
				top = 0, --2
				right = 0, --2
				left = 0, --3
				bottom = 0, --3
				}
			}

			local f = AlertFrames_Anchor

			if SQUID.alerts_anchor_coords then
				local a1,a2,x,y = SQUID.alerts_anchor_coords.a1,SQUID.alerts_anchor_coords.a2,SQUID.alerts_anchor_coords.x,SQUID.alerts_anchor_coords.y
				f:SetPoint(a1,nil,a2,x,y)
			else
				f:SetPoint("CENTER",0,200)
			end

			f:SetHeight(12)
			f:SetWidth(150)
			f:SetBackdrop(backdrop)

			-- f.texture = f:CreateTexture(nil,"ARTWORK",nil)
			-- f.texture:SetTexture(GetSpellTexture(106898))
			-- f.texture:SetWidth(16)
			-- f.texture:SetHeight(16)
			-- f.texture:SetPoint("CENTER",f,"CENTER",-65,0)

			f.txt = f:CreateFontString(nil,"HIGH",nil)
			f.txt:SetFont(cfe,10,'OUTLINE')
			f.txt:SetText("Alerts Anchor")
			f.txt:SetPoint("CENTER",0,0)

			f:SetFrameStrata("HIGH")
			f:SetMovable(true)
			f:SetScript("OnMouseUp",function(self) self:StopMovingOrSizing() Squid_StopSpamming = false local a1,_,a2,x,y = self:GetPoint() SQUID.alerts_anchor_coords = {a1=a1,a2=a2,x=x,y=y} end)
			f:SetScript("OnMouseDown",function(self) self:StartMoving() Squid_StopSpamming = true end)
		end

		if not BigAlertFrames_Anchor then
			BigAlertFrames_Anchor = CreateFrame("Frame", nil, self, "BackdropTemplate")

			local backdrop = {
			bgFile = "Interface/Tooltips/UI-Tooltip-Background",
			tileSize = 256,
			edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
			tile = 1,
			edgeSize = 3,
			insets = {
				top = 0, --2
				right = 0, --2
				left = 0, --3
				bottom = 0, --3
				}
			}

			local f = BigAlertFrames_Anchor

			if SQUID.big_alerts_anchor_coords then
				local a1,a2,x,y = SQUID.big_alerts_anchor_coords.a1,SQUID.big_alerts_anchor_coords.a2,SQUID.big_alerts_anchor_coords.x,SQUID.big_alerts_anchor_coords.y
				f:SetPoint(a1,nil,a2,x,y)
			else
				f:SetPoint("CENTER",0,200)
			end

			f:SetHeight(12)
			f:SetWidth(150)
			f:SetBackdrop(backdrop)

			-- f.texture = f:CreateTexture(nil,"ARTWORK",nil)
			-- f.texture:SetTexture(GetSpellTexture(106898))
			-- f.texture:SetWidth(16)
			-- f.texture:SetHeight(16)
			-- f.texture:SetPoint("CENTER",f,"CENTER",-65,0)

			f.txt = f:CreateFontString(nil,"HIGH",nil)
			f.txt:SetFont(cfe,10,'OUTLINE')
			f.txt:SetText("Big Alerts Anchor")
			f.txt:SetPoint("CENTER",0,0)

			f:SetFrameStrata("HIGH")
			f:SetMovable(true)
			f:SetScript("OnMouseUp",function(self) self:StopMovingOrSizing() Squid_StopSpamming = false local a1,_,a2,x,y = self:GetPoint() SQUID.big_alerts_anchor_coords = {a1=a1,a2=a2,x=x,y=y} end)
			f:SetScript("OnMouseDown",function(self) self:StartMoving() Squid_StopSpamming = true end)
		end

		if #AlertFrames > 0 then

			table.sort(AlertFrames, function(x,y) return x.Start > y.Start or (x.Start == y.Start and x.index < y.index) end)

			for i=1,#AlertFrames do
				if AlertFrames[i] then
					AlertFrames[i].index = i
				end
				--delete invisible frames
				if AlertFrames[i] and AlertFrames[i].Alpha < 0 then
					AlertFrames[i]:Hide()
					table.remove(AlertFrames,i)
				end
			end

			-- local anchor,_,anchor2,x,y = AlertFrames_Anchor:GetPoint()
			if not Squid_StopSpamming then
				for i=1,#AlertFrames do
					--move new frames
					if i > 1 then
						local dist = 20
						AlertFrames[i]:SetPoint("CENTER",AlertFrames_Anchor,"CENTER",0,i*dist)
					end

				end
			end

		end

		if #BigAlertFrames > 0 then

			table.sort(BigAlertFrames, function(x,y) return x.Start > y.Start or (x.Start == y.Start and x.index < y.index) end)

			for i=1,#BigAlertFrames do
				if BigAlertFrames[i] then
					BigAlertFrames[i].index = i
				end
				--delete invisible frames
				if BigAlertFrames[i] and BigAlertFrames[i].Alpha < 0 then
					BigAlertFrames[i]:Hide()
					table.remove(BigAlertFrames,i)
				end
			end

			-- local anchor,_,anchor2,x,y = BigAlertFrames_Anchor:GetPoint()
			for i=1,#BigAlertFrames do

				--move new frames
				if i > 1 then
					local dist = -25
					BigAlertFrames[i]:SetPoint("CENTER",BigAlertFrames_Anchor,"CENTER",0,i*dist)
				end

			end

			if #BigAlertFrames > 3 then
				for i=4,#BigAlertFrames do
					BigAlertFrames[i]:SetAlpha(0)
				end
			end

		end

		if IsHackEnabled and LibDraw and not libdraw_init then

			--hook libdraw funcs
			-- LubDraw by docbrown on fh-wow.com
			local LibDraw
			local sin, cos, atan, atan2, sqrt, rad = math.sin, math.cos, math.atan, math.atan2, math.sqrt, math.rad
			local tinsert, tremove = tinsert, tremove

			local wf_top = WorldFrame:GetTop()

			local function WorldToScreen (wX, wY, wZ)
				if not wX or not wY or not wZ then return 0, 0 end
				local sX, sY = _G.WorldToScreen(wX, wY, wZ);
				if sX and sY then
					return sX, -(WorldFrame:GetTop() - sY);
				else
					return sX, sY;
				end
			end

			-- if LibStub then
			--     -- LibStub version control
			--     LibDraw = LibStub:NewLibrary("LibDraw-1.0", 3)
			--     if not LibDraw then return end
			-- else
				-- Pretty much LibStub
				LibDraw = {
					version = 69.0
				}
				_G['LibDraw'] = LibDraw
			-- end

			LibDraw.line = LibDraw.line or { r = 0, g = 1, b = 0, a = 1, w = 1 }
			LibDraw.level = "BACKGROUND"
			LibDraw.callbacks = { }

			if not LibDraw.canvas then
				LibDraw.canvas = CreateFrame("Frame", WorldFrame)
				LibDraw.canvas:SetAllPoints(WorldFrame)
				LibDraw.lines = { }
				LibDraw.lines_used = { }
				LibDraw.textures = { }
				LibDraw.textures_used = { }
				LibDraw.fontstrings = { }
				LibDraw.fontstrings_used = { }
			end

			function LibDraw.SetColor(r, g, b, a)
				LibDraw.line.r = r * 0.00390625
				LibDraw.line.g = g * 0.00390625
				LibDraw.line.b = b * 0.00390625
				if a then
					LibDraw.line.a = a * 0.01
				else
					LibDraw.line.a = 1
				end
			end

			function LibDraw.SetColorRaw(r, g, b, a)
				LibDraw.line.r = r
				LibDraw.line.g = g
				LibDraw.line.b = b
				LibDraw.line.a = a
			end

			SQUID.line_scale = SQUID.line_scale or 1
			function LibDraw.SetWidth(w)
				LibDraw.line.w = w * SQUID.line_scale
			end

			function LibDraw.Line(sx, sy, sz, ex, ey, ez)
				if not WorldToScreen then return end

				local sx, sy = WorldToScreen(sx, sy, sz)
				local ex, ey = WorldToScreen(ex, ey, ez)

				LibDraw.Draw2DLine(sx, sy, ex, ey)
			end

			function LibDraw.LineFromGround(sx, sy, sz, ex, ey, ez)
				if not WorldToScreen then return end

				sx, sy, sz = GroundZ(sx, sy, sz)

				local sx, sy = WorldToScreen(sx, sy, sz)
				local ex, ey = WorldToScreen(ex, ey, ez)

				LibDraw.Draw2DLine(sx, sy, ex, ey)
			end

			function LibDraw.rotateX(cx, cy, cz, px, py, pz, r)
				if r == nil then return px, py, pz end
				local s = sin(r)
				local c = cos(r)
				-- center of rotation
				px, py, pz = px - cx,  py - cy, pz - cz
				local x = px + cx
				local y = ((py * c - pz * s) + cy)
				local z = ((py * s + pz * c) + cz)
				return x, y, z
			end

			function LibDraw.rotateY(cx, cy, cz, px, py, pz, r)
				if r == nil then return px, py, pz end
				local s = sin(r)
				local c = cos(r)
				-- center of rotation
				px, py, pz = px - cx,  py - cy, pz - cz
				local x = ((pz * s + px * c) + cx)
				local y = py + cy
				local z = ((pz * c - px * s) + cz)
				return x, y, z
			end

			function LibDraw.rotateZ(cx, cy, cz, px, py, pz, r)
				if r == nil then return px, py, pz end
				local s = sin(r)
				local c = cos(r)
				-- center of rotation
				px, py, pz = px - cx,  py - cy, pz - cz
				local x = ((px * c - py * s) + cx)
				local y = ((px * s + py * c) + cy)
				local z = pz + cz
				return x, y, z
			end

			function LibDraw.Array(vectors, x, y, z, rotationX, rotationY, rotationZ)
				for _, vector in ipairs(vectors) do
					local sx, sy, sz = x+vector[1], y+vector[2], z+vector[3]
					local ex, ey, ez = x+vector[4], y+vector[5], z+vector[6]

					if rotationX then
						sx, sy, sz = LibDraw.rotateX(x, y, z, sx, sy, sz, rotationX)
						ex, ey, ez = LibDraw.rotateX(x, y, z, ex, ey, ez, rotationX)
					end
					if rotationY then
						sx, sy, sz = LibDraw.rotateY(x, y, z, sx, sy, sz, rotationY)
						ex, ey, ez = LibDraw.rotateY(x, y, z, ex, ey, ez, rotationY)
					end
					if rotationZ then
						sx, sy, sz = LibDraw.rotateZ(x, y, z, sx, sy, sz, rotationZ)
						ex, ey, ez = LibDraw.rotateZ(x, y, z, ex, ey, ez, rotationZ)
					end

					local sx, sy = WorldToScreen(sx, sy, sz)
					local ex, ey = WorldToScreen(ex, ey, ez)
					LibDraw.Draw2DLine(sx, sy, ex, ey)
				end
			end

			function LibDraw.Draw2DLine(sx, sy, ex, ey, thickness)

				if not WorldToScreen or not sx or not sy or not ex or not ey then return end

				local L = tremove(LibDraw.lines) or false
				if L == false then
					L = CreateFrame("Frame", LibDraw.canvas)
				L.line = L:CreateLine()
					L.line:SetDrawLayer(LibDraw.level)
				end
				tinsert(LibDraw.lines_used, L)

				L:ClearAllPoints()

				  if sx > ex and sy > ey or sx < ex and sy < ey then
					L:SetPoint("TOPRIGHT", LibDraw.canvas, "TOPLEFT", sx, sy)
					L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", ex, ey)
					L.line:SetStartPoint('TOPRIGHT')
					L.line:SetEndPoint('BOTTOMLEFT')
				  elseif sx < ex and sy > ey then
					L:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
					L:SetPoint("BOTTOMRIGHT", LibDraw.canvas, "TOPLEFT", ex, ey)
					L.line:SetStartPoint('TOPLEFT')
					L.line:SetEndPoint('BOTTOMRIGHT')
				  elseif sx > ex and sy < ey then
					L:SetPoint("TOPRIGHT", LibDraw.canvas, "TOPLEFT", sx, sy)
					L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", ex, ey)
					L.line:SetStartPoint('TOPLEFT')
					L.line:SetEndPoint('BOTTOMRIGHT')
				  else
					-- wat, I don't like this, not one bit
					L:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
					L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", sx, ey)
					L.line:SetStartPoint('TOPLEFT')
					L.line:SetEndPoint('BOTTOMLEFT')
				  end

				L.line:SetThickness(thickness or LibDraw.line.w)
				L.line:SetColorTexture(LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a)

				L:Show()

			end

			local full_circle = rad(365)
			local small_circle_step = rad(3)

			function LibDraw.Circle(x, y, z, size)
				local step = small_circle_step * 2
				local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
				for v=0, full_circle, step do
					nx, ny = WorldToScreen( (x+cos(v)*size), (y+sin(v)*size), z )
					LibDraw.Draw2DLine(lx, ly, nx, ny)
					lx, ly = nx, ny
				end
			end

			local flags = bit.bor(0x100)

			function LibDraw.GroundCircle(x, y, z, size)
				local step = small_circle_step * 3
				size = size / 2
				local lx, ly, nx, ny, fx, fy, fz = false, false, false, false, false, false, false
				for v=0, full_circle, step do
					fx, fy, fz = TraceLine(  (x+cos(v)*size), (y+sin(v)*size), z+100, (x+cos(v)*size), (y+sin(v)*size), z-100, flags )
					if fx == nil then
						fx, fy, fz = (x+cos(v)*size), (y+sin(v)*size), z
					end
					nx, ny = WorldToScreen( (fx+cos(v)*size), (fy+sin(v)*size), fz )
					LibDraw.Draw2DLine(lx, ly, nx, ny)
					lx, ly = nx, ny
				end
			end

			function LibDraw.DeSync(index)
			  tremove(LibDraw.callbacks, index)
			end

			-- local function GetScreenPositionBetweenWorldAndScreenPosition(sx, sy, sz, ex, ey, dist)
			-- 	local wex, wey, wez = ScreenToWorld(ex, ey, 0x100111)
			-- 	if not wex or not wey or not wez then return end
			-- 	local x, y, z = GetPositionBetweenPositions(sx, sy, sz, wex, wey, wez, dist)
			-- 	return WorldToScreen( x, y, z )
			-- end

			function LibDraw.Arc(x, y, z, size, arc, rotation)
				if not x or not y or not z then return false end
				local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
				local half_arc = arc * 0.5
				local ss = (arc/half_arc)
				local as, ae = -half_arc, half_arc
				for v = as, ae, ss do
					nx, ny = WorldToScreen( (x+cos(rotation+rad(v))*size), (y+sin(rotation+rad(v))*size), z )
					if lx and ly then
						LibDraw.Draw2DLine(lx, ly, nx, ny)
					else
						fx, fy = nx, ny
					end
					lx, ly = nx, ny
				end
				local px, py = WorldToScreen(x, y, z)
				if px and py then
					LibDraw.Draw2DLine(px, py, lx, ly)
					LibDraw.Draw2DLine(px, py, fx, fy)
				else
					--figure out some way to draw the lines
				end
			end

			local function Arc(x, y, z, size, arc, rotation,noline)
				local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
				local half_arc = arc * 0.5
				local ss = (arc/half_arc)
				local as, ae = -half_arc, half_arc
				for v = as, ae, ss do
					nx, ny = WorldToScreen( (x+cos(rotation+rad(v))*size), (y+sin(rotation+rad(v))*size), z )
					if lx and ly then
						LibDraw.Draw2DLine(lx, ly, nx, ny)
					else
						fx, fy = nx, ny
					end
					lx, ly = nx, ny
				end
				if not noline then
					local px, py = WorldToScreen(x, y, z)
					LibDraw.Draw2DLine(px, py, lx, ly)
					LibDraw.Draw2DLine(px, py, fx, fy)
				end
			end

			function LibDraw.Crescent(x, y, z, size, arc, rotation, ground)
				if ground then
					x, y, z = GroundZ( x, y, z )
				end
				if not x or not y or not z then return false end
				local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
				local half_arc = arc * 0.5
				local ss = (arc/half_arc)
				local as, ae = -half_arc, half_arc
				for v = as, ae, ss do
					if x and y and z then
						nx, ny = WorldToScreen( (x+cos(rotation+rad(v))*size), (y+sin(rotation+rad(v))*size), z )
						if lx and ly then
							LibDraw.Draw2DLine(lx, ly, nx, ny)
						else
							fx, fy = nx, ny
						end
						lx, ly = nx, ny
					end
				end
				local half = (as+ae)/ss
				local mid_x,mid_y,mid_z = (x+cos(rotation+rad(half))*size), (y+sin(rotation+rad(half))*size), z
				return mid_x,mid_y,mid_z
			end

			function LibDraw.Texture(config, x, y, z, alphaA)

				local texture, width, height = config.texture, config.width, config.height
				local left, right, top, bottom, scale =  config.left, config.right, config.top, config.bottom, config.scale
				local alpha = config.alpha or alphaA

				if not WorldToScreen or not texture or not width or not height or not x or not y or not z then return end
				if not left or not right or not top or not bottom then
					left = 0
					right = 1
					top = 0
					bottom = 1
				end
				if not scale then
					local cx, cy, cz = GetCameraPosition()
					scale = width / LibDraw.Distance(x, y, z, cx, cy, cz)
				end

				local sx, sy = WorldToScreen(x, y, z)
				if not sx or not sy then return end
				local w = width * scale
				local h = height * scale
				sx = sx - w*0.5
				sy = sy + h*0.5
				local ex, ey = sx + w, sy - h

				local T = tremove(LibDraw.textures) or false
				if T == false then
					T = LibDraw.canvas:CreateTexture(nil, "BACKGROUND")
					T:SetDrawLayer(LibDraw.level)
					T:SetTexture(LibDraw.texture)
				end
				tinsert(LibDraw.textures_used, T)
				T:ClearAllPoints()
				T:SetTexCoord(left, right, top, bottom)
				T:SetTexture(texture)
				T:SetWidth(width)
				T:SetHeight(height)
				T:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
				T:SetPoint("BOTTOMRIGHT", LibDraw.canvas, "TOPLEFT", ex, ey)
				T:SetVertexColor(1, 1, 1, 1)
				if alpha then T:SetAlpha(alpha) else T:SetAlpha(1) end
				T:Show()

			end

			function LibDraw.Text(text, font, x, y, z)

				local sx, sy = WorldToScreen(x, y, z)

				if sx and sy then

					local F = tremove(LibDraw.fontstrings) or LibDraw.canvas:CreateFontString(nil, "BACKGROUND")

					F:SetFontObject(font)
					F:SetText(text)
					F:SetTextColor(LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a)

					if p then
						local width = F:GetStringWidth() - 4
						local offsetX = width*0.5
						local offsetY = F:GetStringHeight() + 3.5
						local pwidth = width*p*0.01
						FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX), sy-offsetY, 4, r, g, b, 0.25)
						FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX)-(width-pwidth), sy-offsetY, 4, r, g, b, 1)
					end

					F:SetPoint("TOPLEFT", UIParent, "TOPLEFT", sx-(F:GetStringWidth()*0.5), sy)
					F:Show()

					tinsert(LibDraw.fontstrings_used, F)

				end

			end

			local rad90 = math.rad(-90)

			function LibDraw.Box(x, y, z, width, height, rotation, offset_x, offset_y)

				if not offset_x then offset_x = 0 end
				if not offset_y then offset_y = 0 end

				if rotation then rotation = rotation + rad90 end

				local half_width = width * 0.5
				local half_height = height * 0.5

				local p1x, p1y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y - half_width + offset_y, z, rotation)
				local p2x, p2y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y - half_width + offset_y, z, rotation)
				local p3x, p3y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y + half_width + offset_y, z, rotation)
				local p4x, p4y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y - half_width + offset_y, z, rotation)
				local p5x, p5y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y + half_width + offset_y, z, rotation)
				local p6x, p6y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y - half_width + offset_y, z, rotation)
				local p7x, p7y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y + half_width + offset_y, z, rotation)
				local p8x, p8y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y + half_width + offset_y, z, rotation)

				LibDraw.Line(p1x, p1y, z, p2x, p2y, z)
				LibDraw.Line(p3x, p3y, z, p4x, p4y, z)
				LibDraw.Line(p5x, p5y, z, p6x, p6y, z)
				LibDraw.Line(p7x, p7y, z, p8x, p8y, z)

			end

			local deg45 = math.rad(45)
			local arrowX = {
				{ 0  , 0, 0, 1.5,  0,    0   },
				{ 1.5, 0, 0, 1.2,  0.2, -0.2 },
				{ 1.5, 0, 0, 1.2, -0.2,  0.2 }
			}
			local arrowY = {
				{ 0, 0  , 0,  0  , 1.5,  0   },
				{ 0, 1.5, 0,  0.2, 1.2, -0.2 },
				{ 0, 1.5, 0, -0.2, 1.2,  0.2 }
			}
			local arrowZ = {
				{ 0, 0, 0  ,  0,    0,   1.5 },
				{ 0, 0, 1.5,  0.2, -0.2, 1.2 },
				{ 0, 0, 1.5, -0.2,  0.2, 1.2 }
			}

			function LibDraw.DrawHelper()
				local playerX, playerY, playerZ = ObjectPosition("player")
				local old_red, old_green, old_blue, old_alpha, old_width = LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a, LibDraw.line.w

				-- X
				LibDraw.SetColor(255, 0, 0, 100)
				LibDraw.SetWidth(1)
				LibDraw.Array(arrowX, playerX, playerY, playerZ, deg45, false, false)
				LibDraw.Text('X', "GameFontNormal", playerX + 1.75, playerY, playerZ)
				-- Y
				LibDraw.SetColor(0, 255, 0, 100)
				LibDraw.SetWidth(1)
				LibDraw.Array(arrowY, playerX, playerY, playerZ, false, -deg45, false)
				LibDraw.Text('Y', "GameFontNormal", playerX, playerY + 1.75, playerZ)
				-- Z
				LibDraw.SetColor(0, 0, 255, 100)
				LibDraw.SetWidth(1)
				LibDraw.Array(arrowZ, playerX, playerY, playerZ, false, false, false)
				LibDraw.Text('Z', "GameFontNormal", playerX, playerY, playerZ + 1.75)

				LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a, LibDraw.line.w = old_red, old_green, old_blue, old_alpha, old_width
			end

			function LibDraw.Distance(ax, ay, az, bx, by, bz)
				return math.sqrt(((bx-ax)*(bx-ax)) + ((by-ay)*(by-ay)) + ((bz-az)*(bz-az)))
			end

			function LibDraw.Camera()
				local fX, fY, fZ = ObjectPosition("player")
				local sX, sY, sZ = GetCameraPosition()
				return sX, sY, sZ, atan2(sY - fY, sX - fX), atan((sZ - fZ) / sqrt(((fX - sX) ^ 2) + ((fY - sY) ^ 2)))
			end

			function LibDraw.Sync(callback)
				tinsert(LibDraw.callbacks, callback)
			end

			function LibDraw.clearCanvas()
				-- LibDraw.stats = #LibDraw.textures_used
				for i = #LibDraw.textures_used, 1, -1 do
					LibDraw.textures_used[i]:Hide()
					tinsert(LibDraw.textures, tremove(LibDraw.textures_used))
				end
				for i = #LibDraw.fontstrings_used, 1, -1 do
					LibDraw.fontstrings_used[i]:Hide()
					tinsert(LibDraw.fontstrings, tremove(LibDraw.fontstrings_used))
				end
			  for i = #LibDraw.lines_used, 1, -1 do
					LibDraw.lines_used[i]:Hide()
					tinsert(LibDraw.lines, tremove(LibDraw.lines_used))
				end
			end

			local function OnUpdate()
				LibDraw.clearCanvas()
				for _, callback in ipairs(LibDraw.callbacks) do
					callback()
					if LibDraw.helper then
						LibDraw.DrawHelper()
					end
					LibDraw.helper = false
				end
			end

			function LibDraw.Enable(interval)
				local timer
				if not interval then
					timer = C_Timer.NewTicker(interval, OnUpdate)
				else
					timer = C_Timer.NewTicker(interval, OnUpdate)
				end
				return timer
			end

			local function Line(sx, sy, sz, ex, ey, ez)
				local function WorldToScreen (wX, wY, wZ)
					local sX, sY = _G.WorldToScreen(wX, wY, wZ);
					if sX and sY then
						return sX, -(WorldFrame:GetTop() - sY);
					else
						return sX, sY;
					end
				end
				local startx, starty = WorldToScreen(sx, sy, sz)
				local endx, endy = WorldToScreen(ex, ey, ez)
				if (endx == nil or endy == nil) and startx then
					local i = 1
					while (endx == nil or endy == nil) and i < 300 do
						local zdif = ez - sz
						if zdif > 0 then ez = ez - zdif end
						endx, endy = WorldToScreen(GetPositionBetweenPositions(ex, ey, ez, sx, sy, sz, i))
						i = i + 1
					end
				end
				if (startx == nil or starty == nil) and endx then
					local i = 1
					while (startx == nil or starty == nil) and i < 300 do
						local zdif = sz - ez
						if zdif > 0 then sz = sz - zdif end
						startx, starty = WorldToScreen(GetPositionBetweenPositions(sx, sy, sz, ex, ey, ez, i))
						i = i + 1
					end
				end
				LibDraw.Draw2DLine(startx, starty, endx, endy)
			end

			function LibDraw.Cone(x, y, z, size)
				local lx, ly, nx, ny, fx, fy = false, false, false, false, false
				for h=0, size, size/8 do
					h = size - h
					for v=0, full_circle, small_circle_step*6 do
						nx, ny = WorldToScreen( (x+cos(v)*h), (y+sin(v)*h), z+h )
						LibDraw.Draw2DLine(lx, ly, nx, ny)
						lx, ly = nx, ny
					end
				end
			end

			function LibDraw.Sphere(x, y, z, size)
				local lx, ly, nx, ny, fx, fy = false, false, false, false, false
				local step = small_circle_step*6
				for h=0, size, size/8 do
					h = size - h
					for v=0, full_circle, step do
						nx, ny = WorldToScreen( (x+cos(v)*h), (y+sin(v)*h), z+h )
						LibDraw.Draw2DLine(lx, ly, nx, ny)
						lx, ly = nx, ny
					end
				end
				for h=0, size, size/8 do
					h = size - h
					for v=0, full_circle, step do
						nx, ny = WorldToScreen( (x+cos(v)*h), (y+sin(v)*h), z+size+h )
						LibDraw.Draw2DLine(lx, ly, nx, ny)
						lx, ly = nx, ny
					end
				end
			end

			LibDraw.Sync(function()

				local time = GetTime()
				local px,py,pz = GetPlayerPosition()
				local player_name = UnitName("player")

				-- LibDraw.DrawHelper()

				-- local arrowX = {
				--     { 0  , 0, 0, 1.5,  0,    0   },
				--     { 1.5, 0, 0, 1.2,  0.2, -0.2 },
				--     { 1.5, 0, 0, 1.2, -0.2,  0.2 }
				-- }
				-- local arrowY = {
				--     { 0, 0  , 0,  0  , 1.5,  0   },
				--     { 0, 1.5, 0,  0.2, 1.2, -0.2 },
				--     { 0, 1.5, 0, -0.2, 1.2,  0.2 }
				-- }
				-- local arrowZ = {
				--     { 0, 0, 0  ,  0,    0,   1.5 },
				--     { 0, 0, 1.5,  0.2, -0.2, 1.2 },
				--     { 0, 0, 1.5, -0.2,  0.2, 1.2 }
				-- }

				if target_arrow and UnitIsVisible("target") then
					local angle = GetAnglesBetweenObjects("target","player")
					local arrow_size = 0.25
					local arrow_shape = {
					  {-arrow_size, -arrow_size, 0, 0, 0, 0},
					  {arrow_size, -arrow_size, 0, 0, 0, 0},
					}
					-- target arrow
					LibDraw.SetColor(255, 0, 0, 100)
					LibDraw.SetWidth(2)
					LibDraw.Array(arrow_shape, px - 3 * math.cos(angle), py - 3 * math.sin(angle), pz, nil, nil, math.rad(90) + angle)
				end

				--green / red line around corners of screen? animation for toggles?
				-- green_line_test = true
				if SQUID.toggle_flash then
					if green_line_test and ( not red_line_test or time - red_line_test > time - green_line_test ) then

						local max_x,max_y = LibDraw.canvas:GetWidth(),LibDraw.canvas:GetHeight()
						max_y = max_y - wf_top

						local min_y = -wf_top - 3.34
						local min_x = 0

						local w = 10

						max_x = max_x - .1

						-- min_x = min_x + w
						-- from cursor to top right of screen
						-- local cx,cy = GetCursorPosition()
						-- if cy then
						-- 	cy = cy - wf_top
						-- 	LibDraw.SetColorRaw(.12, 1, .4, 1)
						-- 	LibDraw.SetWidth(15)
						-- 	LibDraw.Draw2DLine(cx, cy, max_x, max_y)
						-- 	print(cx,cy,max_x,max_y)
						-- end

						-- LibDraw.SetColorRaw(.12, 1, .4, 1)
						-- LibDraw.SetWidth(15)
						-- LibDraw.Draw2DLine(91.372,-3.34,1427.6695605469,-3.34)

						local function reset_shit ()
							--starting pos
							top_line_squid = { min_x + (max_x / 5), max_y, max_x, max_y-.01, a = .1 }

							right_line_squid = { max_x, max_y, max_x-.01, max_y-.01, a = .1 }

							bottom_line_squid = { max_x - (max_x / 5), min_y, min_x, min_y+.01, a = .1 }

							left_line_squid = { min_x, min_y, min_x+.01, min_y+.01, a = .1 }
						end

						if not top_line_squid or red_line_test then
							reset_shit()
							red_line_test = nil
						end

						local fps = GetFramerate()

						local done_here

						-- if not line_thing_update or time - line_thing_update > .00001 then
							local line_step = ( max_x / ( fps * .85) )
							local sx, sy, ex, ey = top_line_squid[1], top_line_squid[2], top_line_squid[3], top_line_squid[4]
							local dx, dy = ex - sx, ey - sy
							local l = sqrt((dx * dx) + (dy * dy))

							local animation_completion = 0

							animation_completion = ( max_x - l ) / max_x

							-- print(l)
							if l > 1 then
								if l < max_x then
									top_line_squid[1] = top_line_squid[1] + line_step
									top_line_squid.a = top_line_squid.a + animation_completion
									local rsx, rsy, rex, rey = right_line_squid[1], right_line_squid[2], right_line_squid[3], right_line_squid[4]
									local rdx, rdy = rex - rsx, rey - rsy
									local rl = sqrt((rdx * rdx) + (rdy * rdy))
									if rsy > min_y then
										right_line_squid[2] = right_line_squid[2] - line_step
										right_line_squid.a = right_line_squid.a + animation_completion
									end
								end
							end

							local sx, sy, ex, ey = bottom_line_squid[1], bottom_line_squid[2], bottom_line_squid[3], bottom_line_squid[4]
							local dx, dy = ex - sx, ey - sy
							local l = sqrt((dx * dx) + (dy * dy))
							-- print(l)
							if l > 1 then
								if l < max_x then
									bottom_line_squid[1] = bottom_line_squid[1] - line_step
									bottom_line_squid.a = bottom_line_squid.a + animation_completion
									local rsx, rsy, rex, rey = left_line_squid[1], left_line_squid[2], left_line_squid[3], left_line_squid[4]
									local rdx, rdy = rex - rsx, rey - rsy
									local rl = sqrt((rdx * rdx) + (rdy * rdy))
									if rsy < max_y then--+ (min_y - (min_y / 2)) then
										left_line_squid[2] = left_line_squid[2] + line_step
										left_line_squid.a = left_line_squid.a + animation_completion
									else
										done_here=true
									end
								end
							end

						-- 	line_thing_update = time

						-- end

						--top line ( x 1 )
						local sx, sy, ex, ey = top_line_squid[1], top_line_squid[2], top_line_squid[3], top_line_squid[4]
						local dx, dy = ex - sx, ey - sy
						local l = sqrt((dx * dx) + (dy * dy))
						if l > 0 then
							local a = top_line_squid.a
							LibDraw.SetColorRaw(.12, 1, .4, a)
							LibDraw.SetWidth(15)
							LibDraw.Draw2DLine(sx, sy, ex, ey)
						end

						--right line ( y 1 )
						local sx, sy, ex, ey = right_line_squid[1], right_line_squid[2], right_line_squid[3], right_line_squid[4]
						local dx, dy = ex - sx, ey - sy
						local l = sqrt((dx * dx) + (dy * dy))
						if l > 0 then
							local a = right_line_squid.a
							LibDraw.SetColorRaw(.12, 1, .4, a)
							LibDraw.SetWidth(15)
							LibDraw.Draw2DLine(sx, sy, ex, ey)
						end

						--bottom line ( x 2 )
						local sx, sy, ex, ey = bottom_line_squid[1], bottom_line_squid[2], bottom_line_squid[3], bottom_line_squid[4]
						local dx, dy = ex - sx, ey - sy
						local l = sqrt((dx * dx) + (dy * dy))
						if l > 0 then
							local a = bottom_line_squid.a
							LibDraw.SetColorRaw(.12, 1, .4, a)
							LibDraw.SetWidth(15)
							LibDraw.Draw2DLine(sx, sy, ex, ey)
						end

						--left line ( y 2 )
						local sx, sy, ex, ey = left_line_squid[1], left_line_squid[2], left_line_squid[3], left_line_squid[4]
						local dx, dy = ex - sx, ey - sy
						local l = sqrt((dx * dx) + (dy * dy))
						if l > 0 then
							local a = left_line_squid.a
							LibDraw.SetColorRaw(.12, 1, .4, a)
							LibDraw.SetWidth(15)
							LibDraw.Draw2DLine(sx, sy, ex, ey)
						end

						if done_here then reset_shit() green_line_test = nil red_line_test = nil end

					elseif red_line_test then

						local max_x,max_y = LibDraw.canvas:GetWidth(),LibDraw.canvas:GetHeight()
						max_y = max_y - wf_top

						local min_y = -wf_top - 3.34
						local min_x = 0

						local w = 10

						max_x = max_x - .1

						-- min_x = min_x + w
						-- from cursor to top right of screen
						-- local cx,cy = GetCursorPosition()
						-- if cy then
						-- 	cy = cy - wf_top
						-- 	LibDraw.SetColorRaw(.12, 1, .4, 1)
						-- 	LibDraw.SetWidth(15)
						-- 	LibDraw.Draw2DLine(cx, cy, max_x, max_y)
						-- 	print(cx,cy,max_x,max_y)
						-- end

						-- LibDraw.SetColorRaw(.12, 1, .4, 1)
						-- LibDraw.SetWidth(15)
						-- LibDraw.Draw2DLine(91.372,-3.34,1427.6695605469,-3.34)

						local function reset_shit ()
							--starting pos
							top_line_squid = { min_x + (max_x / 5), max_y, max_x, max_y-.01, a = .1 }

							right_line_squid = { max_x, max_y, max_x-.01, max_y-.01, a = .1 }

							bottom_line_squid = { max_x - (max_x / 5), min_y, min_x, min_y+.01, a = .1 }

							left_line_squid = { min_x, min_y, min_x+.01, min_y+.01, a = .1 }
						end

						if not top_line_squid or green_line_test then
							reset_shit()
							green_line_test = nil
						end

						local fps = GetFramerate()

						local done_here

						-- if not line_thing_update or time - line_thing_update > .00001 then
							local line_step = ( max_x / ( fps * .85) )
							local sx, sy, ex, ey = top_line_squid[1], top_line_squid[2], top_line_squid[3], top_line_squid[4]
							local dx, dy = ex - sx, ey - sy
							local l = sqrt((dx * dx) + (dy * dy))

							local animation_completion = 0

							animation_completion = ( max_x - l ) / max_x

							-- print(l)
							if l > 1 then
								if l < max_x then
									top_line_squid[1] = top_line_squid[1] + line_step
									top_line_squid.a = top_line_squid.a + animation_completion
									local rsx, rsy, rex, rey = right_line_squid[1], right_line_squid[2], right_line_squid[3], right_line_squid[4]
									local rdx, rdy = rex - rsx, rey - rsy
									local rl = sqrt((rdx * rdx) + (rdy * rdy))
									if rsy > min_y then
										right_line_squid[2] = right_line_squid[2] - line_step
										right_line_squid.a = right_line_squid.a + animation_completion
									end
								end
							end

							local sx, sy, ex, ey = bottom_line_squid[1], bottom_line_squid[2], bottom_line_squid[3], bottom_line_squid[4]
							local dx, dy = ex - sx, ey - sy
							local l = sqrt((dx * dx) + (dy * dy))
							-- print(l)
							if l > 1 then
								if l < max_x then
									bottom_line_squid[1] = bottom_line_squid[1] - line_step
									bottom_line_squid.a = bottom_line_squid.a + animation_completion
									local rsx, rsy, rex, rey = left_line_squid[1], left_line_squid[2], left_line_squid[3], left_line_squid[4]
									local rdx, rdy = rex - rsx, rey - rsy
									local rl = sqrt((rdx * rdx) + (rdy * rdy))
									if rsy < max_y then--+ (min_y - (min_y / 2)) then
										left_line_squid[2] = left_line_squid[2] + line_step
										left_line_squid.a = left_line_squid.a + animation_completion
									else
										done_here=true
									end
								end
							end

						-- 	line_thing_update = time

						-- end

						--top line ( x 1 )
						local sx, sy, ex, ey = top_line_squid[1], top_line_squid[2], top_line_squid[3], top_line_squid[4]
						local dx, dy = ex - sx, ey - sy
						local l = sqrt((dx * dx) + (dy * dy))
						if l > 0 then
							local a = top_line_squid.a
							LibDraw.SetColorRaw(1, .1, .4, a)
							LibDraw.SetWidth(15)
							LibDraw.Draw2DLine(sx, sy, ex, ey)
						end

						--right line ( y 1 )
						local sx, sy, ex, ey = right_line_squid[1], right_line_squid[2], right_line_squid[3], right_line_squid[4]
						local dx, dy = ex - sx, ey - sy
						local l = sqrt((dx * dx) + (dy * dy))
						if l > 0 then
							local a = right_line_squid.a
							LibDraw.SetColorRaw(1, .1, .4, a)
							LibDraw.SetWidth(15)
							LibDraw.Draw2DLine(sx, sy, ex, ey)
						end

						--bottom line ( x 2 )
						local sx, sy, ex, ey = bottom_line_squid[1], bottom_line_squid[2], bottom_line_squid[3], bottom_line_squid[4]
						local dx, dy = ex - sx, ey - sy
						local l = sqrt((dx * dx) + (dy * dy))
						if l > 0 then
							local a = bottom_line_squid.a
							LibDraw.SetColorRaw(1, .1, .4, a)
							LibDraw.SetWidth(15)
							LibDraw.Draw2DLine(sx, sy, ex, ey)
						end

						--left line ( y 2 )
						local sx, sy, ex, ey = left_line_squid[1], left_line_squid[2], left_line_squid[3], left_line_squid[4]
						local dx, dy = ex - sx, ey - sy
						local l = sqrt((dx * dx) + (dy * dy))
						if l > 0 then
							local a = left_line_squid.a
							LibDraw.SetColorRaw(1, .1, .4, a)
							LibDraw.SetWidth(15)
							LibDraw.Draw2DLine(sx, sy, ex, ey)
						end

						if done_here then reset_shit() green_line_test = nil red_line_test = nil end

					end
				end

				local player_is_melee = _isMeleeDps("player")

				if player_is_melee then
					if UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and _distance(current_target) < 7 then
						local unit = current_target
						if (UnitBuffID(unit,5277) or UnitBuffID(unit,118038) or UnitBuffID(unit,199754) or UnitBuffID(unit,198589) or UnitChannelInfo(unit) == "Fists of Fury") then
							LibDraw.SetColorRaw(1, 1, .1, .75)
							LibDraw.SetWidth(3)
							local x,y,z = ObjectPosition(current_target)
							local facing = ObjectFacing(current_target)
							local size = UnitDebuffID(current_target,6770) and UnitPower("player",4) > 0 and not UnitDebuffID(current_target,1943,"player") and 5.75 or 1.6
							-- multiple arcs?
							Arc(x,y,z,size,180,mod(facing + math.pi, math.pi * 2))
						end
					end
				end

				-- local countdown = max( _spellCooldown(408), _drRemains(current_focus,"stun") )
				-- if not countdown_val or countdown_val < time then countdown_val = time + 7 end

				-- cc_draw_line = cc_draw_line or {unit="focus", spellID=6770}
				-- cc_draw_line = {unit="focus", spellID=408}
				-- cc_draw_line = {unit="focus", spellID=2094}

				-- rogue back drawing function LibDraw.Arc(x, y, z, size, arc, rotation)
				if select(2,UnitClass("player")) == "ROGUE" and GetSpecialization() == 3 then
					if get_squid_var("Backstab Drawing") then
						if UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and _distance(current_target) < 6 then
							LibDraw.SetColorRaw(1, 1, .1, .4+(UnitDebuffID(current_target,6770) and UnitPower("player",4) > 0 and not UnitDebuffID(current_target,1943,"player") and .5 or 0))
							LibDraw.SetWidth(3)
							local x,y,z = ObjectPosition(current_target)
							local facing = ObjectFacing(current_target)
							local size = UnitDebuffID(current_target,6770) and UnitPower("player",4) > 0 and not UnitDebuffID(current_target,1943,"player") and 5.75 or 1.6
							-- multiple arcs?
							Arc(x,y,z,size,180,mod(facing + math.pi, math.pi * 2))
						end
					end
					-- combat tracker
					for i=1,#Enemies do
						local e = Enemies[i]
						if squid_combat_tracker[e] and (_incapacitateDR(e) == 1 or _drRemains(e, "incapacitate") >= 17) then
							if UnitAffectingCombat(e) then
								local time_since_action = time - squid_combat_tracker[e]
								local time_til_combat_ends = 6 - time_since_action
								local x,y,z = ObjectPosition(e)
								if time_til_combat_ends <= 4 then
									LibDraw.SetColorRaw(.4, 1, .6, 1)
									LibDraw.Text("Combat Ends in " .. (time_til_combat_ends <= 1 and max(0,round(time_til_combat_ends,1)) or math.floor(time_til_combat_ends)), "GameFontNormalLarge", x, y, z+3)
								end
							else
								local time_since_action = time - squid_combat_tracker[e]
								local time_til_combat_ends = 6 - time_since_action
								local x,y,z = ObjectPosition(e)
								if time_since_action <= 11 and time_since_action > 1 then
									LibDraw.SetColorRaw(.1, 1, .2, 1)
									LibDraw.Text("- OUT OF COMBAT -", "GameFontNormalLarge", x, y, z+3)
								end
							end
						end
					end

					-- rogue cc lines
					if cc_draw_line then

						local unit = cc_draw_line.unit
						local spell = cc_draw_line.spellID
						local ready = cc_draw_line.ready

						local range = GetSpellRange(spell)

						if UnitIsVisible(unit) then

							local x,y,z = ObjectPosition(unit)
							local dist = GetDistanceBetweenPositions(x,y,z,px,py,pz)

							local combat_dist = _distance(unit)

							local angle = GetAnglesBetweenObjects(unit,"player")

							local out_of_range = range > 0 and combat_dist > range or range == 0 and not _meleeRange(unit)

							local red_range = range + 8

							if out_of_range then

								if combat_dist > red_range then
									-- red arrow
									local arrow_size = 0.86
									local arrow_shape = {
									  {-arrow_size, -arrow_size, 0, 0, 0, 0},
									  {arrow_size, -arrow_size, 0, 0, 0, 0},
									}
									LibDraw.SetColor(255, 0, 0, 100)
									LibDraw.SetWidth(2)
									LibDraw.Array(arrow_shape, px - 4 * math.cos(angle), py - 4 * math.sin(angle), pz, nil, nil, math.rad(90) + angle)
								end

								-- yellow arrow
								local arrow_size = 0.73
								local arrow_shape = {
								  {-arrow_size, -arrow_size, 0, 0, 0, 0},
								  {arrow_size, -arrow_size, 0, 0, 0, 0},
								}
								LibDraw.SetColor(255, 255, 45, 100)
								LibDraw.SetWidth(2)
								LibDraw.Array(arrow_shape, px - 3.75 * math.cos(angle), py - 3.75 * math.sin(angle), pz, nil, nil, math.rad(90) + angle)
							end

							local super_close_range = range == 0 and 4 or 5

							if dist >= super_close_range then
								-- green arrow
								local arrow_size = 0.59
								local arrow_shape = {
								  {-arrow_size, -arrow_size, 0, 0, 0, 0},
								  {arrow_size, -arrow_size, 0, 0, 0, 0},
								}
								LibDraw.SetColor(0, 255, 0, 100)
								LibDraw.SetWidth(2)

								local greenarrow_dist = min(3.5, dist - 3)
								LibDraw.Array(arrow_shape, px - greenarrow_dist * math.cos(angle), py - greenarrow_dist * math.sin(angle), pz, nil, nil, math.rad(90) + angle)
							end

							local texture = {
								texture = GetSpellTexture(spell),
								width = 34, height = 34,
								alpha = 1,
							}

							local texture_dist = dist < super_close_range and 0 or min(6, dist-2)

							local px,py,pz = px,py,pz
							if dist < super_close_range then angle = ObjectFacing(unit) px,py,pz = x,y,z-3 end

							LibDraw.Texture(texture,px - texture_dist * math.cos(angle), py - texture_dist * math.sin(angle), pz+.25);

							local countdown = cc_draw_line.countdown or countdown or countdown_val-time

							LibDraw.SetColorRaw(1 - (countdown/6),1,0,1)
							LibDraw.Text(round(countdown,1),"GameFontNormal",px - texture_dist * math.cos(angle), py - texture_dist * math.sin(angle), pz+2+(dist < super_close_range and .5 or 0))

							LibDraw.SetColorRaw(.4 + (out_of_range and .6 or 0),1-(combat_dist > red_range and 1 or 0),0,.025 + (not out_of_range and .1 or 0) + (ready and .4 or 0) + (_spellCooldown(36554) > max(0,countdown-.3) and .2 or 0) + ((countdown/6)/2))

							local actual_range = range == 0 and 5.95 or range+UnitCombatReach("player")+UnitCombatReach(unit)

							if out_of_range then
								LibDraw.SetWidth(8)

								-- line to where we are in range
								LibDraw.Line(px,py,pz,GetPositionBetweenPositions(x,y,z,px,py,pz,actual_range+.25))

								LibDraw.SetColorRaw(.4,1,0,.08 + (ready and .4 or 0))
								LibDraw.SetWidth(8)
								-- LibDraw.Circle(x,y,z,actual_range)
								Arc(x,y,z,actual_range,90,GetAnglesBetweenPositions(x,y,z,px,py,pz),true)
							else
								LibDraw.SetWidth(11)
								LibDraw.Circle(x,y,z,actual_range)
							end


						end

					end
				end

				--hardcast flamestrike debug
				if last_flamestrike_pos and unit_casting_info("player") == "Flamestrike" then
					LibDraw.SetColorRaw(1, .25, 0, .25)
					LibDraw.SetWidth(3)
					local x,y,z = last_flamestrike_pos.x,last_flamestrike_pos.y,last_flamestrike_pos.z
					if x and y and z then
						LibDraw.Text("Flamestrike", "GameFontNormalSmall", x, y, z+2)
						LibDraw.Circle(x,y,z,8)
					end
				end

				if stealth_tracker then
					for i=1,#stealth_tracker do if stealth_tracker[i] then
						local elapsed = time - stealth_tracker[i].time
						if UnitIsVisible(stealth_tracker[i].pointer) and UnitBuffID(stealth_tracker[i].pointer,stealth_tracker[i].id) then
							local pointer = stealth_tracker[i].pointer
							stealth_tracker[i].speed = GetUnitSpeed(pointer) or stealth_tracker[i].speed
							stealth_tracker[i].direction = GetMovingDirection(pointer) or stealth_tracker[i].direction
							local x,y,z = ObjectPosition(pointer)
							stealth_tracker[i].x = x or stealth_tracker[i].x
							stealth_tracker[i].y = y or stealth_tracker[i].y
							stealth_tracker[i].z = z or stealth_tracker[i].z
							stealth_tracker[i].time = time
							stealth_tracker[i].update = true
						end
						if elapsed < 2.5 and ( not UnitIsVisible(stealth_tracker[i].pointer) or UnitBuffID(stealth_tracker[i].pointer,stealth_tracker[i].id) and stealth_tracker[i].update ) then
							local x,y,z = stealth_tracker[i].x,stealth_tracker[i].y,stealth_tracker[i].z
							local dir = stealth_tracker[i].direction
							local speed = stealth_tracker[i].speed
							local traveled = speed * elapsed
							if x and y and z and dir and speed then
								local estX,estY,estZ = GroundZ(x + traveled * math.cos(dir), y + traveled * math.sin(dir), z)
								if estX and estY and estZ then
									LibDraw.SetColorRaw(1,.5,.25,math.max(.5,1 - (elapsed/3)))
									LibDraw.Circle(estX,estY,estZ,2.5)
									LibDraw.Text(stealth_tracker[i].name, "GameFontNormalSmall", estX, estY, estZ+2)
								end
							end
						end
						if elapsed > 5 then
							table.remove(stealth_tracker,i)
						end
					end end
				end

				--sphere test
				if sphere_test then

					LibDraw.SetColorRaw(1, .85, .1, 1)
					LibDraw.Cone(px+5,py+5,pz,1.25)
					LibDraw.Text("EXPLOSIVE", SquidFont, px+5,py+5,pz+3)
				end

				--debug draws

				-- blink resulting position by angle
				if blink_pos_debug then
					LibDraw.SetColorRaw(.86, .24, .87, .65)
					LibDraw.SetWidth(3)
					for i=1,math.pi*2,.5 do
						local x,y,z = position_after_blink(i)
						if x and y and z then
							-- LibDraw.Text("Blinking Here", SquidFont, x, y, z+1)
							LibDraw.Circle(x,y,z,1)
						else
							print("no circl?")
						end
					end
				end

				-- target_line=true
				if target_line then
					if current_target then
						local x,y,z = ObjectPosition("target")
						LibDraw.SetColorRaw(1, 0, .87, 1)
						LibDraw.SetWidth(12)
						Line(px,py,pz,x,y,z)
					end
				end

				-- blink_los_debug=true
				if blink_los_debug then
					local x,y,z = blink_los_point(current_focus,100)
					if x and y and z then
						-- x,y,z = GroundZ(x,y,z)
						local texture = {
							texture = GetSpellTexture(1953),
							width = 32, height = 32,
							alpha = 1,
						}
						LibDraw.Texture(texture,x,y,z+2);
						LibDraw.SetColorRaw(.86, .24, .87, .65)
						LibDraw.SetWidth(12)
						-- LibDraw.Text("Blinking Here", SquidFont, x, y, z+1)
						LibDraw.Circle(x,y,z,2)
					end
				end

				--draw LoS blink position
				if blink_los_draw then
					local x,y,z = blink_los_point(blink_los_draw,40)
					if x and y and z then
						local texture = {
							texture = GetSpellTexture(1953),
							width = 32, height = 32,
							alpha = 1,
						}
						LibDraw.Texture(texture,x,y,z+2);
						LibDraw.SetColorRaw(.9, .54, .013, .65)
						LibDraw.SetWidth(2)
						-- LibDraw.Text("Blinking Here", SquidFont, x, y, z+1)
						LibDraw.Circle(x,y,z,2)
						if not player_can_see_coords(x,y,z) then
							LibDraw.SetColorRaw(.9, .54, .013, .85)
							LibDraw.SetWidth(4)
							local dx,dy,dz = GetPositionBetweenPositions(px,py,pz,x,y,z,5)
							LibDraw.Texture(texture,dx,dy,dz+2);
							Line(px,py,pz,x,y,z)
						end
					end
				end

				--explosive draw
				if explosive_draw and UnitIsVisible(explosive_draw) then
					local x,y,z = ObjectPosition(explosive_draw)
					if x and y and z then
						LibDraw.SetColorRaw(1, .85, .1, 1)
						LibDraw.Text("EXPLOSIVE", SquidFont, x, y, z+3)
						LibDraw.Circle(x,y,z,2)
					end
				end

				-- blink_db_debug = true
				if blink_db_debug then
					local x,y,z = blink_db_point(current_focus)
					if x and y and z then
						-- x,y,z = GroundZ(x,y,z)
						LibDraw.SetColorRaw(1, 0, .87, 1)
						LibDraw.Text("Blink DB Position", SquidFont, x, y, z+2)
						LibDraw.Circle(x,y,z,3)
					end
				end

				if squid_alter then
					local x,y,z = unpack(squid_alter["start_pos"])
					if x and y and z and squid_alter["start_hp"] then
						-- x,y,z = GroundZ(x,y,z)
						local hp_change = round ( squid_alter["start_hp"] - _HP("player"), 2)

						local texture = {
							texture = GetSpellTexture(108978),
							width = 42, height = 42,
							alpha = 1,
						}

						local g = min ( 1, min(1, (hp_change / 100) * 2) + .35 )
						local r_add = 0
						if hp_change < 0 then
							r_add = r_add + min(1, ((abs(hp_change)/100)*2.5) + .2 )
						end
						LibDraw.SetColorRaw(r_add, g, .45, 1)

						LibDraw.SetWidth(7)
						local op = hp_change <= 0 and "-" or "+"
						LibDraw.Texture(texture,x,y,z+2.5)
						LibDraw.Circle(x,y,z,2.5)
						LibDraw.SetColorRaw(g, r_add, .45, 1)
						LibDraw.Text(op .. hp_change .. "%","GameFontNormalLarge", x, y, z+2)
					end
				end

				if draw_all_missiles then
					for i=1,#squid_missiles do

						local missile = squid_missiles[i]

						local x,y,z = unpack(missile.dest)
						LibDraw.SetColorRaw(131/255, 236/255, 74/255, .8)
						LibDraw.Text(GetSpellInfo(missile.spellid), SquidFont, x, y, z+2)
						-- spell visual id have size info?
						LibDraw.Circle(x,y,z,5)

						local cx,cy,cz = unpack(missile.pos)
						LibDraw.SetColorRaw(131/255, 236/255, 155/255, .8)
						LibDraw.Circle(cx,cy,cz,2.5)

					end
				end

				--missile drawings
				for i=1,#squid_missiles do
					local missile = squid_missiles[i]
					--infernals
					if missile.spellid == 1122 and UnitIsVisible(missile.caster) and UnitCanAttack("player",missile.caster) then
						local x,y,z = unpack(missile.dest)
						LibDraw.SetColorRaw(131/255, 236/255, 74/255, .8)
						LibDraw.Text("ENEMY INFERNAL!!!", SquidFont, x, y, z+2)
						local cx,cy,cz = unpack(missile.pos)
						local dist = GetDistanceBetweenPositions(x,y,z,cx,cy,cz)
						est_time = round(dist/31, 3)


						LibDraw.Text((est_time * 1000) .. " ms", SquidFont, x, y, z)
						LibDraw.Circle(x,y,z,9)
					end
					--trap
					if missile.spellid == 187650 and UnitIsVisible(missile.caster) and UnitCanAttack("player",missile.caster) then
						local x,y,z = unpack(missile.dest)
						local sx,sy,sz = unpack(missile.source)
						local cx,cy,cz = unpack(missile.pos)
						local angle = GetAnglesBetweenPositions(cx,cy,cz,x,y,z)
						LibDraw.SetColorRaw(80/255, 115/255, 211/255, 1)
						LibDraw.Line(sx,sy,sz,x,y,z)
						LibDraw.Circle(x,y,z,2.5)
						LibDraw.Text("Trap", SquidFont, x,y,z)
						LibDraw.SetColorRaw(80/255, 115/255, 211/255, .3)
						LibDraw.Circle(cx + 1 * math.cos(angle),cy + 1 * math.sin(angle),cz,2.5)
					end
				end

				for i=1,#Enemies do
					if _rootCheck(Enemies[i]) and _isMeleeDps(Enemies[i]) then
						if _distance(Enemies[i]) < 7 then
							local x,y,z = ObjectPosition(Enemies[i])
							LibDraw.SetWidth(6)
							LibDraw.SetColorRaw(1, .3, .47, 1)
							LibDraw.Circle(x,y,z,6)
						end
					end
				end

				-- meteor_debug=true
				if meteor_debug then
					local x,y,z,hit,avg_dist
					if meteor_debug ~= true then
						x,y,z,hit,avg_dist = best_meteor_point(current_target,true)
					else
						x,y,z,hit,avg_dist = best_meteor_point(current_target)
					end
					if x and y and z then
						LibDraw.SetColorRaw(1, 0, .87, 1)
						LibDraw.SetWidth(8)
						LibDraw.Text("Meteor Drop Position", SquidFont, x, y, z+2)
						LibDraw.Text("Hits: " .. hit .. " - AVG: " .. math.floor(avg_dist), SquidFont, x, y, z)
						LibDraw.Circle(x,y,z,8)
						LibDraw.Circle(x,y,z,.5)
					end
				end

				-- rop_debug=true
				if rop_debug then
					local x,y,z = rop_unit_to_unit(current_focus,current_target)
					if x and y and z then
						LibDraw.SetColorRaw(1, 0, .87, 1)
						LibDraw.Text("RoP Position", SquidFont, x, y, z+2)
						LibDraw.Circle(x,y,z,8)
					end
				end

				if groundz_debug then
					local x,y,z = GetGroundZ(px,py,0x100111)
					if x and y and z then
						LibDraw.SetColorRaw(1, 0, .87, 1)
						LibDraw.Circle(x,y,z,2)
					end
					x,y,z = GroundZ(px,py,pz)
					if x and y and z then
						LibDraw.SetColorRaw(.2, 1, .2, 1)
						LibDraw.Circle(x,y,z,3)
					end
				end

				if click_debug then
					local x,y,z = GetLastClickInfo()
					if x and y and z then
						LibDraw.SetColorRaw(1, 0, .87, 1)
						LibDraw.Text("Click Position", SquidFont, x, y, z+2)
						LibDraw.Circle(x,y,z,8)
					end
				end

				-- last_blink_debug=true
				if last_blink_debug then
					local x,y,z
					for i=1,#AreaTriggers do
						if ObjectID(AreaTriggers[i]) == 11513 then
							x,y,z = ObjectPosition(AreaTriggers[i])
							break
						end
					end
					if x and y and z then
						LibDraw.SetColorRaw(1, 0, .87, 1)
						LibDraw.Text("Last Blink", SquidFont, x, y, z+2)
						LibDraw.Circle(x,y,z,1)
					end
				end

				if prediction_debug then
					local x,y,z = PredictUnitPosition("player",prediction_debug or .79)
					if x and y and z and player_can_see_coords(x,y,z) then
						LibDraw.SetColorRaw(1, 0, .87, 1)
						LibDraw.SetWidth(2)
						LibDraw.Circle(x,y,z,.25)
						LibDraw.Circle(px,py,pz,.25)
						LibDraw.Text(GetDistanceBetweenPositions(px,py,pz,x,y,z), SquidFont, x, y, z+2)
						LibDraw.SetWidth(2)
						Line(px,py,pz,x,y,z)
					end
				end

				--draw optimal aggressive position
				if position_draw_debug and UnitIsVisible(current_target) and UnitIsVisible(theirHealer) and not unit_is_unit(theirHealer,current_target) then

					local x,y,z = ObjectPosition(current_target)
					local X,Y,Z = ObjectPosition(theirHealer)
					local dist_between = GetDistanceBetweenPositions(x,y,z,X,Y,Z)

					local BX,BY,BZ
					if dist_between > 15 then

						BX,BY,BZ = GetPositionBetweenPositions(x,y,z,X,Y,Z,dist_between/2)

						local points = {}

						local direction
						for i=0,math.pi*2,.6 do
							local xx,yy,zz = GroundZ (BX + 12 * math.cos(i), BY + 12 * math.sin(i), BZ)
							if xx and yy and zz and not TraceLine(xx,yy,zz+2,x,y,z+2,0x100111) and not TraceLine(xx,yy,zz+2,X,Y,Z+2,0x100111) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
								direction = i
								local mx = xx --+ 7.25 * math.cos(direction)
								local my = yy --+ 7.25 * math.sin(direction)
								local mz = zz

								-- local combined_dist = GetDistanceBetweenPositions(xx,yy,zz,x,y,z) + GetDistanceBetweenPositions(xx,yy,zz,X,Y,Z)
								local combined_dist = GetDistanceBetweenPositions(xx,yy,zz,X,Y,Z)
								table.insert(points,{xx=mx,yy=my,zz=mz,d=combined_dist})
							end
						end

						table.sort(points,function(x,y) return x.d < y.d end)

						if #points > 0 then
							local a,b,c = points[1].xx,points[1].yy,points[1].zz
							BX,BY,BZ = a,b,c
						else
							BX,BY,BZ = nil
						end

					end

					if BX and BY and BZ then
						LibDraw.SetColorRaw(.6, .4, .85, 1)
						LibDraw.SetWidth(4)
						LibDraw.Text("Optimal Position", SquidFont, BX, BY, BZ+2)
						LibDraw.Circle(BX,BY,BZ,5)
					end
				end

				killx,killy,killz = nil
				if squid_killshot and current_target then
					local x,y,z = ObjectPosition(current_target)
					local dist = GetDistanceBetweenPositions(x,y,z,px,py,pz)
					killx,killy,killz = GetPositionBetweenPositions(px,py,pz,x,y,z,dist-22)
					LibDraw.SetColorRaw(1, 0, .87, 1)
					LibDraw.Text("Stand here for a free kill.", SquidFont, killx, killy, killz+2)
					LibDraw.Circle(killx,killy,killz,3)
				end
				-- LibDraw.DrawHelper()

				--awareness
				if arena and not _isHealer("player") and ourHealer and UnitIsVisible(ourHealer) then

					local d = _distance(ourHealer)

					local disable_while_visible = SQUID.disable_while_visible

					local alerts_enabled = SQUID.awareness_alerts_enabled
					local lines_enabled = SQUID.awareness_lines_enabled
					local good_line = SQUID.good_line_enabled

					local can_see_healer = disable_while_visible and player_can_see(ourHealer)

					local x,y,z = ObjectPosition(ourHealer)
					x,y,z = GroundZ(x,y,z)
					local los = _LoS(ourHealer)

					if x and y and z and (not can_see_healer or not disable_while_visible) then

						--ranging the healer alert
						if d > 39.5 then
							if alerts_enabled then
								if not healer_range_alert or GetTime() - healer_range_alert > 15 then
									Squid_Alert_Big("ALERT:","Ranging Healer!",2,nil,201785)
									healer_range_alert = GetTime()
								end
							end
						end
						--ranging the healer line
						if lines_enabled then
							if d > 37.5 then
								local a = (d - 20) / 25
								local range_factor = a
								if a < .2 then a = .2 elseif a > .75 then a = .75  end
								LibDraw.SetColorRaw(1, .2, .2, a)
								LibDraw.SetWidth(1 + min(range_factor*15, 15))
								Line(px,py,pz,x,y,z)
							end
						end
						--losing the healer alert
						if not los then
							if alerts_enabled then
								if not healer_los_alert or GetTime() - healer_los_alert > 15 then
									Squid_Alert_Big("ALERT:","LoS Healer!",2,nil,198838)
									healer_los_alert = GetTime()
								end
							end
							--losing the healer line
							if lines_enabled then
								LibDraw.SetColorRaw(1, .647, 0, .8)
								LibDraw.SetWidth(14)
								Line(px,py,pz,x,y,z)
							end
						end
						--Good line (Green)
						if los and d <= 39.5 then
							if good_line then
								LibDraw.SetColorRaw(.2, .95, .44, .5)
								LibDraw.SetWidth(8)
								Line(px,py,pz,x,y,z)
							end
						end
					end

					--Healer Dist Cone
					if not UnitBuffID("player",32727) and d > 3.5 then
						if SQUID.positioning_help then

							local a = (d < 21 and 1 or .2)
							--red arc
							LibDraw.SetColorRaw(1, .15, .04, a)
							LibDraw.SetWidth(4)
							LibDraw.Arc(x,y,z,24,60,GetAnglesBetweenObjects(ourHealer,"player"))
							a = (d < 30 and d >= 21 and 1 or .2)
							--yellow arc
							LibDraw.SetColorRaw(.7, .7, .15, a)
							LibDraw.SetWidth(4)
							LibDraw.Arc(x,y,z,33,60,GetAnglesBetweenObjects(ourHealer,"player"))
							a = (d < 38 and d >= 30 and 1 or .2)
							--green arc
							LibDraw.SetColorRaw(.16, 1, .21, a)
							LibDraw.SetWidth(4)
							LibDraw.Arc(x,y,z,41,60,GetAnglesBetweenObjects(ourHealer,"player"))


						end
					end

				end

				-- units casting on player
				-- for i=1,#Enemies do
				-- 	local e = Enemies[i]
				-- 	local cast,_,_,_,_,_,_,_,castid = unit_casting_info(e)
				-- 	if cast then
				-- 		local tar = UnitSpellTarget(e)
				-- 		if unit_is_unit("player",tar) then
				-- 			local x,y,z = ObjectPosition(e)
				-- 			local dist = GetDistanceBetweenPositions(x,y,z,px,py,pz)
				-- 			local bx,by,bz = GetPositionBetweenPositions(x,y,z,px,py,pz,dist-4)
				-- 			local pct = _castPctDone(e)
				-- 			local mod = pct / 100
				-- 			-- LibDraw.Text("LoS Blink Position", SquidFont, x, y, z+2)
				-- 			-- LibDraw.Box(bx,by,bz,16,16)
				-- 			local casttexture = {
				-- 			texture = GetSpellTexture(castid),
				-- 			width = 32 * mod, height = 32 * mod,
				-- 			alpha = 1,
				-- 			}
				-- 			local boundingbox = {
				-- 			texture = GetSpellTexture(castid),
				-- 			width = 30, height = 30,
				-- 			alpha = .35,
				-- 			}
				-- 			LibDraw.Texture(boundingbox,bx,by,bz);
				-- 			LibDraw.Texture(casttexture,bx,by,bz);
				-- 			LibDraw.SetColorRaw(.2, .8, .4, 1)
				-- 			LibDraw.Text(math.floor(pct),SquidFontMedium,bx,by,bz+.3)
				-- 			LibDraw.SetColorRaw(1, 0, .4, 1)
				-- 			LibDraw.SetWidth(50)
				-- 			Line(px,py,pz,x,y,z)
				-- 		end
				-- 	end
				-- end

				--draw units out of range
				local flamecannon_stacks = _buffStacks("player",203285)
				local fc_value = flamecannon_stacks*3
				local player_reach = 1.5
				local sheep_range = 30 + fc_value + player_reach
				local gpy_range = 40 + fc_value + player_reach

				if arena and select(2,UnitClass("player")) == "MAGE" then
					--sheep range
					local e
					for i=1,#Enemies do
						e = Enemies[i]
						if _distance(e) > sheep_range-player_reach and not unit_is_unit(e,current_target) and UnitIsPlayer(e) then
							local x,y,z = ObjectPosition(e)
							--blueish arc
							LibDraw.SetColorRaw(.65, .85, .92, .95)
							LibDraw.SetWidth(4)
							local angle = (x and y and z and GetAnglesBetweenPositions(px,py,pz,x,y,z) or 1)
							local lx,ly,lz = LibDraw.Crescent(px,py,z,sheep_range,6,angle,true)
							LibDraw.SetColorRaw(.65, .85, .92, .4)
							LibDraw.SetWidth(2)
							if lx and ly and lz then
								LibDraw.Line(lx,ly,lz,x,y,z)
							end
						end
					end
				end

				--Mage next cc tar
				if UnitIsVisible(mage_next_cc_target) and player_can_see(mage_next_cc_target) then

					local unit = mage_next_cc_target
					local cc = mage_next_cc
					local dr = mage_next_cc_dr
					local remains = mage_next_cc_time

					if remains and dr and cc and unit then

						local x,y,z = ObjectPosition(unit)
						local texture = {
							texture = GetSpellTexture(cc),
							width = 32, height = 32,
							alpha = 1,
						}

						local remains_text

						if remains == 0 then
							remains_text = "Ready!"
						else
							remains_text = math.ceil(remains)
						end

						dr = dr == 1 and "Full" or dr == .5 and "Half" or dr == .25 and "Short" or "Immune"

						-- local x,y,z = GroundZ (ux + dist * math.cos(i), uy + dist * math.sin(i), uz+2)

						local cam_x,cam_y,cam_z = GetCameraPosition()

						local angles
						if px and py and pz and x and y and z then
							angles = GetAnglesBetweenPositions(px,py,pz,x,y,z) + (math.pi / 2)
						else
							angles = 1
						end

						if x and y and z and px and py and pz then
							local draw_x,draw_y,draw_z = GetPositionBetweenPositions(x,y,z,px,py,pz,2.5)

							if draw_x and draw_y and draw_z then
								draw_x = draw_x + 1.5 * math.cos(angles)
								draw_y = draw_y + 1.5 * math.sin(angles)

								-- LibDraw.Texture(texture,x + 2 * math.cos(angles),y + 2 * math.sin(angles),z+1.5);
								LibDraw.Texture(texture,draw_x,draw_y,z+1.5);

								local g = (18 - remains) / 18

								local r = 1 - g

								r = dr == "Full" and 0 or r

								g = dr == "Full" and 1 or g

								LibDraw.SetColorRaw(r, g, 0, 1)
								-- LibDraw.Text(dr .. "  |  " .. remains_text,SquidFont,x + 2 * math.cos(angles),y + 2 * math.sin(angles),z+.5)
								LibDraw.Text(dr .. "  |  " .. remains_text,SquidFont,draw_x,draw_y,z+.5)
							end

						end

					end

				end

				RedSpellBars=true
				if RedSpellBars then
					if TargetFrameSpellBar then
						local bar = TargetFrameSpellBar
						local startcolor = bar.startCastColor
						if UnitIsVisible(current_target) then
							local spell_target = UnitSpellTarget(current_target)
							if unit_is_unit("player",spell_target) then
								startcolor:SetRGB(.9,0,0)
								if not startcolor.iamtarget then local t = current_target ClearTarget() TargetUnit(t) startcolor.iamtarget=true startcolor.iamnottarget=nil end
							else
								startcolor:SetRGB(1,0.7,0)
								if not startcolor.iamnottarget then local t = current_target ClearTarget() TargetUnit(t) startcolor.iamnottarget=true startcolor.iamtarget=nil end
							end
						end
					end
					if FocusFrameSpellBar then
						local bar = FocusFrameSpellBar
						local startcolor = bar.startCastColor
						if UnitIsVisible(current_focus) then
							local spell_target = UnitSpellTarget(current_focus)
							if unit_is_unit("player",spell_target) then
								startcolor:SetRGB(.9,0,0)
								if not startcolor.iamtarget then local t = current_focus ClearFocus() FocusUnit(t) startcolor.iamtarget=true startcolor.iamnottarget=nil end
							else
								startcolor:SetRGB(1,0.7,0)
								if not startcolor.iamnottarget then local t = current_focus ClearFocus() FocusUnit(t) startcolor.iamnottarget=true startcolor.iamtarget=nil end
							end
						end
					end
				end

				local mo_names = SQUID.mouseover_names
				local pow = math.pow

				--end of awareness
				local scx,scy = GetCursorPosition()
				local horrific_vision
				local map_id = GetMapId()
				if map_id == 2212 then -- FIXME (Add Stormwind)
					horrific_vision = "Orgrimmar"
				elseif map_id == 2213 then
					horrific_vision = "Stormwind"
				end
				if horrific_vision then

					-- jump when we have the fucking bugs on us
					if _buffStacks("player",311390) >= 3
					and (not UnitCastingInfo("player") and not UnitChannelInfo("player") and not _isMoving("player") or _buffStacks("player",311390) >= 5) then
						Squid_Alert("Jumping","Bugs",nil,nil,311390)
						JumpOrAscendStart()
						AscendStop()
					end

					local caches = {
						[342135] = true, -- Normal Zone Cache
						[342134] = true, -- Normal Zone Cache
					}

					local crystal_id = 341368

					local vials = {
						[341341] = "Red",
						[341337] = "Black",
						[341338] = "Blue",
						[341339] = "Green",
						[341340] = "Purple",
					}
					local vial_effects = {
						[1] = "Sanity",
						[2] = "Defensive",
						[3] = "Healing",
						[4] = "Fire Breath",
						[5] = "Poison",
					}
					local vial_order = {
						[1] = "Black",
						[2] = "Green",
						[3] = "Red",
						[4] = "Blue",
						[5] = "Purple",
						["Black"] = 1,
						["Green"] = 2,
						["Red"] = 3,
						["Blue"] = 4,
						["Purple"] = 5,
					}
					local opposite_vial = {
						["Black"] = 2,
						["Green"] = 3,
						["Red"] = 4,
						["Blue"] = 5,
						["Purple"] = 1,
					}
					local function vial_effect(colorid)
						if not SQUID.poisoned_vial then return "?" end

						local color_effect = {}

						local sanity_index = opposite_vial[SQUID.poisoned_vial]

						local index = 1
						while index <= 5 do
							if sanity_index <= 5 then
								color_effect[sanity_index] = index
								sanity_index = sanity_index + 1
								if sanity_index > 5 then sanity_index = 1 end
							end
							index = index + 1
						end
						return vial_effects[color_effect[colorid]]
					end

					for i=1,#Objects do
						local o = Objects[i]
						local id = ObjectID(o)
						local name = ObjectName(o)
						local vial_type = vials[id]
						local is_cache = name == "Black Empire Cache"
						local is_crystal = name == "Odd Crystal"
						local is_bomb = id == 334122
						local is_cage = id == 326606
						if vial_type then
							local x,y,z = ObjectPosition(o)
							if not SQUID.poisoned_vial then
								if horrific_vision == "Orgrimmar" then
									local dist_to_spot = x and y and z and GetDistanceBetweenPositions(x, y, z, 1550.026, -4320.7255, 25.96109) or 999
									Squid_Alert("Searching for poisoned vial, please move close to it!")
									if dist_to_spot <= 3 then
										SQUID.poisoned_vial = vial_type
									end
								elseif horrific_vision == "Stormwind" then
									local dist_to_spot = x and y and z and GetDistanceBetweenPositions(x, y, z, -8673.7294, 823.6614, 97.1873) or 999
									Squid_Alert("Searching for poisoned vial, please move close to it!")
									if dist_to_spot <= 3 then
										SQUID.poisoned_vial = vial_type
									end
								end
							else
								local effect = vial_effect(vial_order[vial_type])
								local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

								local a = (100 - dist) / 100
								if a > 1 then a = 1 end
								if a < .3 then a = .3 end

								local s = .65 + max(.5,a)

								local r,g,b

								if vial_type == "Blue" then
									r,g,b = .45,.65,1
								elseif vial_type == "Purple" then
									r,g,b = .576,.439,.858
								elseif vial_type == "Green" then
									r,g,b = .596,.984,.596
								elseif vial_type == "Black" then
									r,g,b = .45,.45,.45
								else
									r,g,b = 1,.1,.1 -- Red, or...
								end

								LibDraw.SetColorRaw(r,g,b,1)

								if x and y and z then
									LibDraw.Text(effect .. " - " .. dist, "GameFontNormal", x, y, z+3.5)

									LibDraw.SetWidth(s * 2)

									if dist > 5 then
										Line(x, y, z+s*1.25, x, y, z)
										Line(x-s, y, z, x+s, y, z)
										Line(x, y-s, z, x, y+s, z)
									else
										local sx,sy = WorldToScreen(x,y,z)
										if sx and sy then
											if scx and scy then
												sy = sy + wf_top
												local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
												if d < max(80 - dist, 35) then
													if GetKeyState(0x02) == true then
														if effect ~= "Poison" then
															InteractUnit(o)
															Squid_Alert("Helping you click " .. effect .. " vial", ":)")
														else
															Squid_Alert("Don't click the poison vials dude!",":(")
														end
													end
												end
											end
										end
									end
								end

							end
						end
						if is_cache then
							local x,y,z = ObjectPosition(o)

							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

							local a = (100 - dist) / 100
							if a > 1 then a = 1 end
							if a < .3 then a = .3 end

							local s = .65 + max(.5,a)

							local r,g,b = 1,1,1

							LibDraw.SetColorRaw(r,g,b,1)

							if x and y and z then
								LibDraw.Text("Cache" .. " - " .. dist, "GameFontNormal", x, y, z+3.5)

								LibDraw.SetWidth(s * 2)

								if dist > 4.9 then
									Line(x, y, z+s*1.25, x, y, z)
									Line(x-s, y, z, x+s, y, z)
									Line(x, y-s, z, x, y+s, z)
								else
									local sx,sy = WorldToScreen(x,y,z)
									if sx and sy then
										if scx and scy then
											sy = sy + wf_top
											local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
											if d < max(80 - dist, 25) then
												if GetKeyState(0x02) == true then
													InteractUnit(o)
													Squid_Alert("Helping you click the cache", ":)")
												end
											end
										end
									end
								end
							end
						end
						if is_bomb then
							local x,y,z = ObjectPosition(o)
							local r,g,b = .4,.4,.7
							LibDraw.SetColorRaw(r,g,b,1)
							if x and y and z then
								LibDraw.Text("Bomb", "GameFontNormal", x, y, z+3.5)
							end
						end
						if is_cage then
							local x,y,z = ObjectPosition(o)
							local r,g,b = .4,.4,.7
							LibDraw.SetColorRaw(r,g,b,1)
							if x and y and z then
								LibDraw.Text("Cage", "GameFontNormal", x, y, z+3.5)
							end
						end
						if is_crystal then
							local x,y,z = ObjectPosition(o)

							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

							local a = (100 - dist) / 100
							if a > 1 then a = 1 end
							if a < .3 then a = .3 end

							local s = .65 + max(.5,a)

							local r,g,b = 1,.749,0

							LibDraw.SetColorRaw(r,g,b,1)

							if x and y and z then
								LibDraw.Text("Crystal" .. " - " .. dist, "GameFontNormal", x, y, z+3.5)

								LibDraw.SetWidth(s * 2)

								if dist > 4.9 then
									Line(x, y, z+s*1.25, x, y, z)
									Line(x-s, y, z, x+s, y, z)
									Line(x, y-s, z, x, y+s, z)
								else
									local sx,sy = WorldToScreen(x,y,z)
									if sx and sy then
										if scx and scy then
											sy = sy + wf_top
											local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
											if d < max(80 - dist, 25) then
												if GetKeyState(0x02) == true then
													InteractUnit(o)
													Squid_Alert("Helping you click the crystal", ":)")
												end
											end
										end
									end
								end
							end
						end
					end
				else
					SQUID.poisoned_vial = nil
				end

				local torghast = map_id == 2162
				if torghast then

					local anima_orbs = {
						[336799] = "Anima Hoard",	-- Common Powers? Rare Powers?
						[330193] = "Anima Cell",	-- Rare Powers?
						[323351] = "Anima Cell",	-- Heart, Heart, Sword - Common, Uncommon, Common
						[325740] = "Plundered Cell",-- Heart, Heart - Uncommon, Common
						[324030] = "Anima Cell", 	-- Common Powers?
						[338483] = "Anima Cell",
						[324031] = "Anima Hoard",
						[325758] = "Prisoner's Anima",
					}

					local vases = {
						[164698] = "Vase", -- normal vase
						[165523] = "Vase", -- normal vase?

						[167986] = "Orb Vase", -- is got a orbz in it
					}

					local souls = {
						[169640] = "Tormented Soul Remnant",
						[169716] = "Tormented Soul Remnant",
						[169787] = "Tormented Soul Remnant",
						-- [169560] = "soul placeholder?",
						[169902] = "Click Me",--"Bound Soul Remnant",
						[157561] = "Click Me",--"Bound Soul Remnant",
						[169785] = "Click Me",--"Bound Soul Remnant",
						[169480] = "Unchain Me",--"Heavily Bound Soul Remnant",
						[171159] = "Walk Over Me",--"Unraveling Soul Remnant",
						[169628] = "Tormented Soul Remnant",
						[169782] = "Click Me",--"Bound Soul Remnant",
						[171166] = "Walk Over Me",--"Unraveling Soul Remnant",
					}

					local random_objects = {
						[166660] = "Lever",
						[167003] = "Lever",
					}

					local vaults = {
						[164624] = "Rune Locked Vault",
					}

					for i=1,#Objects do
						local o = Objects[i]
						local id = ObjectID(o)
						local name = ObjectName(o)
						local is_vase = vases[id]
						local is_anima = anima_orbs[id]
						local is_soul = souls[id]
						local is_vault = vaults[id]
						local replenishment_orb = id == 26911
						local lootable = UnitCanBeLooted(o)
						local is_exit = id == 156480
						local is_key = name == "Spectral Key"

						if is_key then
							local x,y,z = ObjectPosition(o)
							if x and y and z and GetDistanceBetweenPositions(px,py,pz,x,y,z) > 8 then
								local texture = {
									texture = 134248,
									width = 25, height = 25,
									alpha = 1,
								}
								LibDraw.SetColorRaw(0,1,0,1)
								LibDraw.Texture(texture,x,y,z);
							end
						end

						if is_exit then
							local x,y,z = ObjectPosition(o)
							if x and y and z and GetDistanceBetweenPositions(px,py,pz,x,y,z) > 35 + (not TraceLine(px,py,pz+2,x,y,z+2,0x100111) and 100 or 0) then
								local texture = {
									texture = 135743,
									width = 85, height = 85,
									alpha = 1,
								}
								LibDraw.Texture(texture,x,y,z);
							end
						end

						if is_vault and _distance(o) > 5 then
							local x,y,z = ObjectPosition(o)
							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
							local a = (100 - dist) / 100
							if a > 1 then a = 1 end
							if a < .3 then a = .3 end
							local texture = {
								texture = 413587,
								width = 38, height = 38,
								alpha = a,
							}
							LibDraw.SetColorRaw(0,1,0,1)
							LibDraw.Texture(texture,x,y,z);
							LibDraw.Text(name, "GameFontNormal", x,y,z+4)
						end

						if lootable then
							local x,y,z = ObjectPosition(o)
							if x and y and z then
								local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
								local a = (100 - dist) / 100
								if a > 1 then a = 1 end
								if a < .3 then a = .3 end
								local texture = {
									texture = 133784,
									width = 38, height = 38,
									alpha = a,
								}
								LibDraw.Texture(texture,x,y,z);
							end
						end

						if replenishment_orb then
							local x,y,z = ObjectPosition(o)
							if x and y and z then
								local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
								local a = (100 - dist) / 100
								if a > 1 then a = 1 end
								if a < .3 then a = .3 end
								local hp = {
									texture = 136041,
									width = 38, height = 38,
									alpha = a,
								}
								LibDraw.Texture(hp,x,y,z);
							end
						end

						if is_vase then
							local x,y,z = ObjectPosition(o)
							if x and y and z then
								local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
								local a = (100 - dist) / 100
								if a > 1 then a = 1 end
								if a < .3 then a = .3 end
								local vase

								if is_vase == "Vase" then
									vase = {
										texture = 133748,
										width = 35, height = 35,
										alpha = a,
									}
								else
									vase = {
										texture = 1119885,
										width = 45, height = 45,
										alpha = 1,
									}
								end
								LibDraw.Texture(vase,x,y,z);
							end
						end

						if is_anima then
							local x,y,z = ObjectPosition(o)
							if x and y and z then
								local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
								local a = (100 - dist) / 100
								if a > 1 then a = 1 end
								if a < .5 then a = .5 end
								local orb = {
									texture = 348545,
									width = 40 - (a*3), height = 40 - (a*3),
									alpha = a,
								}
								LibDraw.SetColorRaw(0,1,0,1)
								LibDraw.Texture(orb,x,y,z+4);
								LibDraw.Text(name, "GameFontNormal", x,y,z+2)
								if AutoFollow and dist < 5 then
									InteractUnit(o)
								end
							end
						end

						if is_soul then
							local x,y,z = ObjectPosition(o)
							if x and y and z then
								local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
								local a = (100 - dist) / 100
								if a > 1 then a = 1 end
								if a < .5 then a = .5 end
								local soul = {
									texture = 463284,
									width = 42 - (a*3), height = 42 - (a*3),
									alpha = a,
								}
								LibDraw.SetColorRaw(0,1,0,1)
								LibDraw.Texture(soul,x,y,z);
								local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
								if dist < 45 then
									LibDraw.Text(is_soul, "GameFontNormal", x,y,z+3.75)
								end
							end
						end

						if is_cache then
							LibDraw.SetColorRaw(0,1,0,1)
							local x,y,z = ObjectPosition(o)

							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

							local a = (100 - dist) / 100
							if a > 1 then a = 1 end
							if a < .3 then a = .3 end

							local s = .65 + max(.5,a)

							local r,g,b = 1,1,1

							LibDraw.SetColorRaw(r,g,b,1)

							if x and y and z then
								LibDraw.Text("Cache" .. " - " .. dist, "GameFontNormal", x, y, z+3.5)

								LibDraw.SetWidth(s * 2)

								if dist > 4.9 then
									Line(x, y, z+s*1.25, x, y, z)
									Line(x-s, y, z, x+s, y, z)
									Line(x, y-s, z, x, y+s, z)
								else
									local sx,sy = WorldToScreen(x,y,z)
									if sx and sy then
										if scx and scy then
											sy = sy + wf_top
											local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
											if d < max(80 - dist, 25) then
												if GetKeyState(0x02) == true then
													InteractUnit(o)
													Squid_Alert("Helping you click the cache", ":)")
												end
											end
										end
									end
								end
							end
						end
						if is_bomb then
							local x,y,z = ObjectPosition(o)
							local r,g,b = .4,.4,.7
							LibDraw.SetColorRaw(r,g,b,1)
							if x and y and z then
								LibDraw.Text("Bomb", "GameFontNormal", x, y, z+3.5)
							end
						end
						if is_cage then
							local x,y,z = ObjectPosition(o)
							local r,g,b = .4,.4,.7
							LibDraw.SetColorRaw(r,g,b,1)
							if x and y and z then
								LibDraw.Text("Cage", "GameFontNormal", x, y, z+3.5)
							end
						end
						if is_crystal then
							local x,y,z = ObjectPosition(o)

							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

							local a = (100 - dist) / 100
							if a > 1 then a = 1 end
							if a < .3 then a = .3 end

							local s = .65 + max(.5,a)

							local r,g,b = 1,.749,0

							LibDraw.SetColorRaw(r,g,b,1)

							if x and y and z then
								LibDraw.Text("Crystal" .. " - " .. dist, "GameFontNormal", x, y, z+3.5)

								LibDraw.SetWidth(s * 2)

								if dist > 4.9 then
									Line(x, y, z+s*1.25, x, y, z)
									Line(x-s, y, z, x+s, y, z)
									Line(x, y-s, z, x, y+s, z)
								else
									local sx,sy = WorldToScreen(x,y,z)
									if sx and sy then
										if scx and scy then
											sy = sy + wf_top
											local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
											if d < max(80 - dist, 25) then
												if GetKeyState(0x02) == true then
													InteractUnit(o)
													Squid_Alert("Helping you click the crystal", ":)")
												end
											end
										end
									end
								end
							end
						end
					end


				end -- end torghast

				-- draw all objects with names
				if SQUID.draw_objects then
					if #SQUID.objects_to_draw > 0 then
						for i=1,#Objects do if not draw_only_dead_objs or time - draw_only_dead_objs > 3 or UnitIsDead(Objects[i]) then
							local name=ObjectName(Objects[i])
							--RARE FINDER
							if SQUID.rare_finder then
								local classification = UnitClassification(Objects[i])
								if classification == "rareelite" then
									local x,y,z = ObjectPosition(Objects[i])
									local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
									if UnitIsDead(Objects[i]) then
										LibDraw.SetColorRaw(1, .5, .2, .8)
									else
										LibDraw.SetColorRaw(.3, 1, .02, 1)
									end

									if mo_names then
										local sx,sy = WorldToScreen(x,y,z)
										if sx and sy then
											if scx and scy then
												sy = sy + wf_top
												local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
												if d < max(80 - dist, 25) then
													LibDraw.Text(name .. " - " .. dist, "GameFontNormal", x, y, z+4)
													if dist < 4.8 then
														if GetKeyState(0x02) == true then
															InteractUnit(Objects[i])
															Squid_Alert("Interacting with",name)
														end
													end
												end
											end
										end
									else
										LibDraw.Text(name .. " - " .. dist, "GameFontNormal", x, y, z+4)
									end

									local a = (100 - dist) / 100
									local g = a

									if a > 1 then a = 1 end
									if a < .75 then a = .75 end
									local w = 3 + (a * 2)

									LibDraw.SetWidth(w)

									local r = 1
									local g = .87
									local b = 0

									local s = 1 + a

									LibDraw.SetColorRaw(r, g, b, a)

									Line(px,py,pz,x,y,z)

									Line(x, y, z+s*1.5, x, y, z)
									Line(x-s, y, z, x+s, y, z)
									Line(x, y-s, z, x, y+s, z)
								end
							end
							local pow = math.pow
							--OBJECT FINDER
							for n=1,#SQUID.objects_to_draw do
								if name and strmatch(strlower(name):gsub("%s+",""),SQUID.objects_to_draw[n]) then
									local x,y,z = ObjectPosition(Objects[i])
									local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
									if name ~= player_name and dist < SQUID.max_object_finder_dist and x and y and z then

										if UnitIsDead(Objects[i]) then
											LibDraw.SetColorRaw(1, .5, .2, .8)
										else
											LibDraw.SetColorRaw(.3, 1, .02, 1)
										end

										if mo_names then
											local sx,sy = WorldToScreen(x,y,z)
											if sx and sy then
												if scx and scy then
													sy = sy + wf_top
													local d = sqrt( pow(scx - sx, 2) + pow(scy - sy, 2) )
													if d < max(80 - dist, 25) then
														LibDraw.Text(name .. " - " .. dist, "GameFontNormal", x, y, z+3.5)
														if dist < 4.8 then
															if GetKeyState(0x02) == true then
																InteractUnit(Objects[i])
																Squid_Alert("Interacting with",name)
															end
														end
													end
												end
											end
										else
											LibDraw.Text(name .. " - " .. dist, "GameFontNormal", x, y, z+3.5)
										end

										local a = (100 - dist) / 100
										local g = a
										if a > 1 then a = 1 end
										if a < .3 then a = .3 end
										if g > 1 then g = 1 end
										if g < 0 then g = 0 end
										local s = 1 + max(.5,a)
										LibDraw.SetColor(255,0,0)
										LibDraw.SetWidth(s * 2)
										if dist > 4 then
											Line(x, y, z+s*1.5, x, y, z)
											Line(x-s, y, z, x+s, y, z)
											Line(x, y-s, z, x, y+s, z)
										end
										if SQUID.draw_line_to_objects then

											local w = 2 + (a * 4)
											LibDraw.SetWidth(w)
											local r = 1
											r = r - g
											LibDraw.SetColorRaw(r, g, 0, a)
											Line(px,py,pz,x,y,z)
										end
										if SQUID.auto_interact_objects then
											if dist < 10 then
												-- if not OBJECT_INTERACT_TIME or time - OBJECT_INTERACT_TIME > 1.5 then
													Squid_Alert("Interacting with ",name)
													InteractUnit(Objects[i])
													OBJECT_INTERACT_TIME=time
												-- end
											elseif test_move_thing then
												local x,y,z = ObjectPosition(Objects[i])
												MoveTo(x,y,z)
											end
										end
									end
								end
							end
						end end
					else
						-- no
						-- for i=1,#Objects do
						-- 	local name=ObjectName(Objects[i])
						-- 	local x,y,z=ObjectPosition(Objects[i],true)
						-- 	local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
						-- 	if name ~= player_name and dist < SQUID.max_object_finder_dist then
						-- 		LibDraw.SetColorRaw(.2, .8, .4, .6)
						-- 		LibDraw.Text(name .. " - " .. dist, SquidFont, x, y, z+2)
						-- 		if SQUID.draw_line_to_objects then
						-- 			LibDraw.SetWidth(15)
						-- 			LibDraw.SetColorRaw(1, 0, .87, 1)
						-- 			Line(px,py,pz,x,y,z)
						-- 		end
						-- 	end
						-- end
					end
					if ZygorGuidesViewerFrame then
						local already_tracked = {}
						local blacklist = {"Watch","Accept","Turn","to"}
						-- for i=1,6 do
							-- local line = _G["ZygorGuidesViewerPointerArrow_StealthTitle"]
							-- if line then
							-- 	local text = line:GetText()
							-- 	if text then
							-- 		words = {strsplit(" ",text)}
							-- 		for n=1,#words do
							-- 			if string.len(words[n]) >= 5 and not tContains(blacklist,words[n]) then
							-- 				for j=1,#Objects do
							-- 					local t = Objects[j]
							-- 					local name = ObjectName(t)
							-- 					if not tContains(already_tracked,t) and name and strmatch(strlower(name):gsub("%s+",""),strlower(words[n])) then
							-- 						table.insert(already_tracked,t)
							-- 						local x,y,z=ObjectPosition(t,true)
							-- 						local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
							-- 						if UnitIsDead(t) then
							-- 							LibDraw.SetColorRaw(1, .5, .2, .8)
							-- 						else
							-- 							LibDraw.SetColorRaw(.2, .8, .4, .8)
							-- 						end
							-- 						LibDraw.Text(name .. " - " .. dist, SquidFont, x, y, z+2)
							-- 						if SQUID.draw_line_to_objects then
							-- 							LibDraw.SetWidth(3)
							-- 							LibDraw.SetColorRaw(1, 0, .87, 1)
							-- 							Line(px,py,pz,x,y,z)
							-- 						end
							-- 						if SQUID.auto_interact_objects then
							-- 							if dist < 5 then
							-- 								-- if not OBJECT_INTERACT_TIME or time - OBJECT_INTERACT_TIME > 1.5 then
							-- 									Squid_Alert("Interacting with ",name)
							-- 									InteractUnit(t)
							-- 									OBJECT_INTERACT_TIME=time
							-- 								-- end
							-- 							end
							-- 						end
							-- 					end
							-- 				end
							-- 			end
							-- 			-- print(words[n])
							-- 		end
							-- 	end
							-- end
					end
					-- end
					local object_prefixes = {
						"Click",
						"Kill",
						"Collect",
						"Talk to",
						"Use it on",
						"Extinguish"
					}
					local useless_suffixes = {
						"enemies around this area",
						"around this area",
						"around the area",
						"inside the cave",
					}
					local escapes = {
						["|c%x%x%x%x%x%x%x%x"] = "", -- color start
						["|r"] = "", -- color end
						["|H.-|h(.-)|h"] = "%1", -- links
						["|T.-|t"] = "", -- textures
						["{.-}"] = "", -- raid target icons
					}
					local function unescape(str)
						for k, v in pairs(escapes) do
							str = gsub(str, k, v)
						end
						return str
					end

					local index = 1
					local obj_name_cache = {}
					local obj_name = function(obj)
						if obj_name_cache[obj] then return obj_name_cache[obj] end
						local name = ObjectName(obj)
						obj_name_cache[obj] = name
						return name
					end

					local tracking = {}
					Debug_Tracking_Table = tracking
					for step = 1,5 do
						for line = 1,10 do
							local content = _G["ZygorGuidesViewerFrame_Step"..step.."_Line"..line.."Content"]
							if content then
								local label = content.label
								if label then
									label = label:GetText()
									if type(label) == "string" then
										label = unescape(label)
										for i=1,#object_prefixes do
											if string.match(label,object_prefixes[i]) then
												label = string.gsub(label,object_prefixes[i],"")
												for n=1,#useless_suffixes do
													label = string.gsub(label,useless_suffixes[n],"")
												end
												label = string.gsub(label, "%s*", "")
												local amt = strmatch(label,"[0-9]+")
												if amt then amt = tonumber(amt) end
												label = string.gsub(label, "[0-9]", "")
												if amt and amt > 0 then
													label = string.gsub(label, "%([^()]*%)","")
													if string.sub(label,-3) == "ies" then
														label = string.sub(label, 1, -4)
													end
													label = string.gsub(label, "s$", "")
													label = string.gsub(label, "%s*", "")
												end
												-- print(label,amt)
												-- print(label)
												if label and type(label) == "string" and label ~= "" then
													table.insert(tracking,strlower(label))
												end
											end
										end
									end
								end
							end
						end
					end
					local function is_tracked(name)
						for i=1,#tracking do
							if strmatch(name,tracking[i]) or strmatch(tracking[i],name) then return true end
						end
					end
					if #tracking > 0 then
						for i=1,#Objects do
							local t = Objects[i]
							local name
							local og_name = obj_name(t)
							if og_name then
								name = strlower(og_name)
								name = string.gsub(name, "%s*", "")
							end
							if name and is_tracked(name) then
								local x,y,z=ObjectPosition(t)
								local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
								if dist < SQUID.max_object_finder_dist then
									if UnitIsDead(t) then
										LibDraw.SetColorRaw(1, .5, .2, .8)
									else
										LibDraw.SetColorRaw(.2, .8, .4, .8)
									end
									LibDraw.Text(og_name .. " - " .. dist, SquidFont, x, y, z+2)
									if SQUID.draw_line_to_objects then
										local a = (100 - dist) / 100
										if a < .125 then a = .125 end
										if a > 1 then a = 1 end
										LibDraw.SetWidth(a * 3 + (dist < 15 and 1.5 or 0))
										LibDraw.SetColorRaw(a, a/2, 1 - a, a)
										Line(px,py,pz,x,y,z)
									end
									if SQUID.auto_interact_objects then
										if dist < 5 then
											-- if not OBJECT_INTERACT_TIME or time - OBJECT_INTERACT_TIME > 1.5 then
												Squid_Alert("Interacting with ",og_name)
												InteractUnit(t)
												OBJECT_INTERACT_TIME=time
											-- end
										end
									end
								end
							end
						end
					end
				end

				FLOWER_EXISTS = nil
				--flower draw
				for i=1,#Squid_OM do
					local o = Squid_OM[i]
					if ObjectID(o) == 164589 and UnitCanAttack("player",o) then
						-- print("flower found")
						local x,y,z = ObjectPosition(o)
						if x and y and z then
							-- print("xyz good")
							x, y, z = GroundZ(x,y,z) or x, y, z

							LibDraw.SetWidth(18)
							LibDraw.SetColorRaw(1, 0, 1, 1)

							local s = 2
							Line(x, y, z+s*2, x, y, z)
							Line(x, y, z-s*2, x, y, z)
							Line(x-s, y, z, x+s, y, z)
							Line(x, y-s, z, x, y+s, z)

							local wf_top = WorldFrame:GetTop()
							local scx,scy = GetCursorPosition()
							local sx,sy = WorldToScreen(x,y,z)
							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
							if sx and sy then
								if scx and scy then
									sy = sy + wf_top
									local d = sqrt( math.pow(scx - sx, 2) + math.pow(scy - sy, 2) )
									if d < max(200 - dist, 35) then
										LibDraw.Text(name, "GameFontNormalSmall", x, y, z+2)
										if GetKeyState(0x1) and not GetKeyState(0x2) then
											C_Timer.After(.1,function()
												TargetUnit(o)
												Squid_Alert("Podtender Targeted", nil, 6, nil, 267026)
											end)
										end
										if not flower_targeted or GetTime() - flower_targeted > 5 then
											TargetUnit(o)
											Squid_Alert("Podtender Targeted", nil, 6, nil, 267026)
											flower_targeted = GetTime()
										end
									end
								end
							end

							if not flower_targeted or GetTime() - flower_targeted > 8 then
								TargetUnit(o)
								Squid_Alert("Podtender Targeted", nil, 6, nil, 267026)
								flower_targeted = GetTime()
							end
							FLOWER_EXISTS = o
						end
					end
				end

				--Circle at cursor drawing for PetPlayer
				if PetPlayerDraw then
					local x,y,z = WorldPositionFromCursor()
					if x and y and z then
						LibDraw.SetColorRaw(1, 0, 0, 1)
						LibDraw.Circle(x, y, z, 2)
					end
				end

				--circle and text at port location
				if UnitBuffID("player",101643) then
					--coords of port already saved from combat log events
					if portcoords and portcoords.situated then
						local x,y,z = portcoords.x,portcoords.y,portcoords.z
						if x and y and z then
							local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
							--port circle ( red when out of range )
							if dist >= 40 then
								LibDraw.SetColorRaw(.8, .2, .4, .5)
							else
								LibDraw.SetColorRaw(.2, .8, .4, .6)
							end
							LibDraw.Circle(x, y, z, 2)
							--dist text
							LibDraw.Text(dist .. " yds", SquidFont, x, y, z+2)
						end
					else -- otherwise we have to find the object and get its coords
						local playername=UnitName("player")
						for i=1,#Objects do
							local name=ObjectName(Objects[i])
							if name == playername and not unit_is_unit("player",Objects[i]) and UnitCreatureID(Objects[i]) <= 55000 then
								local x,y,z = ObjectPosition(Objects[i])
								local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))
								--port circle ( red when out of range )
								if dist >= 40 then
									LibDraw.SetColorRaw(.8, .2, .4, .5)
								else
									LibDraw.SetColorRaw(.2, .8, .4, .6)
								end
								LibDraw.Circle(x, y, z, 2)
								--dist text
								LibDraw.Text(dist .. " yds", SquidFont, x, y, z+2)

								if _buffRemains("player",101643) < 895 then
									portcoords = {}
									portcoords.x=x
									portcoords.y=y
									portcoords.z=z
									portcoords.situated=true
								end
							end
						end
					end
				end


				--greenscreen
				if squid_greenscreen then
					local green = {
					texture = 1111111,
					width = 5000, height = 5000,
					alpha = 1,
					}
					LibDraw.Texture(green,px,py,pz);
				end

			end)
			LibDraw.Enable(0.01)

			libdraw_init=true
		end

		--gui
		if cfe and not Squid_GUI_Init then

			-- local sq_mm = CreateFrame("Frame")

			--minimap shit
			-- local MiniMapX, MiniMapY = -54.6, 58.8
			-- local minimapShapes = {
			-- 	["ROUND"] = {true, true, true, true},
			-- 	["SQUARE"] = {false, false, false, false},
			-- 	["CORNER-TOPLEFT"] = {true, false, false, false},
			-- 	["CORNER-TOPRIGHT"] = {false, false, true, false},
			-- 	["CORNER-BOTTOMLEFT"] = {false, true, false, false},
			-- 	["CORNER-BOTTOMRIGHT"] = {false, false, false, true},
			-- 	["SIDE-LEFT"] = {true, true, false, false},
			-- 	["SIDE-RIGHT"] = {false, false, true, true},
			-- 	["SIDE-TOP"] = {true, false, true, false},
			-- 	["SIDE-BOTTOM"] = {false, true, false, true},
			-- 	["TRICORNER-TOPLEFT"] = {true, true, true, false},
			-- 	["TRICORNER-TOPRIGHT"] = {true, false, true, true},
			-- 	["TRICORNER-BOTTOMLEFT"] = {true, true, false, true},
			-- 	["TRICORNER-BOTTOMRIGHT"] = {false, true, true, true},
			-- }
			-- sq_mm.MiniMap = CreateFrame("Button", "Minimap", Minimap)
			-- sq_mm.MiniMap:SetFrameStrata("MEDIUM")
			-- sq_mm.MiniMap:SetWidth(31)
			-- sq_mm.MiniMap:SetHeight(31)
			-- sq_mm.MiniMap:RegisterForClicks("AnyUp")
			-- sq_mm.MiniMap:RegisterForDrag("RightButton")
			-- sq_mm.MiniMap:RegisterForDrag("LeftButton")
			-- sq_mm.MiniMap:SetFrameLevel(8)
			-- sq_mm.MiniMap:SetHighlightTexture("Interface\\Minimap\\UI-Minimap-ZoomButton-Highlight")
			-- sq_mm.MiniMap:SetPoint("CENTER", MiniMapX, MiniMapY)
			-- if MinimapDisplay then
			-- 	sq_mm.MiniMap:Show()
			-- end

			-- sq_mm.MinimapOverlay = sq_mm.MiniMap:CreateTexture(nil, "OVERLAY")
			-- sq_mm.MinimapOverlay:SetWidth(53)
			-- sq_mm.MinimapOverlay:SetHeight(53)
			-- sq_mm.MinimapOverlay:SetTexture("Interface\\AddOns\\xenRotations\\Memes\\xrborderoff.blp")
			-- sq_mm.MinimapOverlay:SetPoint("TOPLEFT")
			-- local MinimapOverlay = sq_mm.MinimapOverlay

			-- --Overlay texture changes based on xrStart
			-- function _xrMMoverlay()
			-- 	if SquidLobster and MinimapOverlay:GetTexture() ~= "Interface\\AddOns\\xenRotations\\Memes\\xrborder.blp" then
			-- 		MinimapOverlay:SetTexture("Interface\\AddOns\\xenRotations\\Memes\\xrborder.blp")
			-- 	end
			-- 	if not SquidLobster and MinimapOverlay:GetTexture() ~= "Interface\\AddOns\\xenRotations\\Memes\\xrborderoff.blp" then
			-- 		MinimapOverlay:SetTexture("Interface\\AddOns\\xenRotations\\Memes\\xrborderoff.blp")
			-- 	end
			-- end
			-- MinimapOverlayChange = CreateFrame("Frame")
			-- MinimapOverlayChange:SetScript("OnUpdate",_xrMMoverlay)

			-- MinimapBG = sq_mm.MiniMap:CreateTexture(nil, "BACKGROUND")
			-- MinimapBG:SetWidth(20)
			-- MinimapBG:SetHeight(20)
			-- MinimapBG:SetTexture("Interface\\Minimap\\UI-Minimap-Background")
			-- MinimapBG:SetPoint("TOPLEFT", 7, -5)
			-- MinimapIcon = sq_mm.MiniMap:CreateTexture(nil, "ARTWORK")
			-- MinimapIcon:SetWidth(20)
			-- MinimapIcon:SetHeight(20)
			-- MinimapIcon:SetTexture("Interface\\AddOns\\xenRotations\\Memes\\xroff.blpâ€Ž")
			-- MinimapIcon:SetTexCoord(0.05, 0.95, 0.05, 0.95)
			-- MinimapIcon:SetPoint("TOPLEFT", 7, -5)
			-- sq_mm.MiniMap:SetScript("OnClick", function(self, clickType)
			-- 	if clickType == "LeftButton" then
			-- 		SquidToggle();
			-- 	elseif clickType == "RightButton" then
			-- 		if sq_mm.kickFrame:IsShown() then
			-- 			sq_mm.kickFrame:Hide()
			-- 			sq_mm.kickFrame.kickSlider:Hide()
			-- 		else
			-- 			sq_mm.kickFrame:Show()
			-- 			sq_mm.kickFrame.kickSlider:Show()
			-- 		end
			-- 	end
			-- end)
			-- sq_mm.MiniMap:SetScript("OnDragStart", function(self, btn)
			-- 	self.dragging = true
			-- 	self:LockHighlight()
			-- 	MinimapIcon:SetTexCoord(0, 1, 0, 1)
			-- 	self:SetScript("OnUpdate", function(self, btn)
			-- 		local mx, my = Minimap:GetCenter()
			-- 		local px, py = GetCursorPosition()
			-- 		local scale = Minimap:GetEffectiveScale()
			-- 		px, py = px / scale, py / scale
			-- 		local deg = math.deg(math.atan2(py - my, px - mx)) % 360
			-- 		local angle = math.rad(deg)
			-- 		local x, y, q = math.cos(angle), math.sin(angle), 1
			-- 		if x < 0 then q = q + 1 end
			-- 		if y > 0 then q = q + 2 end
			-- 		local minimapShape = GetMinimapShape and GetMinimapShape() or "ROUND"
			-- 		local quadTable = minimapShapes[minimapShape]
			-- 		if quadTable[q] then
			-- 			x, y = x*80, y*80
			-- 		else
			-- 			local diagRadius = 103.13708498985
			-- 			x = math.max(-80, math.min(x*diagRadius, 80))
			-- 			y = math.max(-80, math.min(y*diagRadius, 80))
			-- 		end
			-- 		self:SetPoint("CENTER", self:GetParent(), "CENTER", x, y)
			-- 		MiniMapX = x
			-- 		MiniMapY = y
			-- 	end)
			-- 	GameTooltip:Hide()
			-- end)
			-- sq_mm.MiniMap:SetScript("OnDragStop", function(self, btn)
			-- 	self.dragging = nil
			-- 	self:SetScript("OnUpdate", nil)
			-- 	MinimapIcon:SetTexCoord(0.05, 0.95, 0.05, 0.95)
			-- 	self:UnlockHighlight()
			-- end)

			local squid_bg = Squid_Directory() .. "/media/squidbgfile.blp"
			local squid_button = Squid_Directory() .. "/media/squidbutton.blp"
			local squid_icon_checked = Squid_Directory() .. "/media/squid_icon_checked.blp"
			local squid_icon_unchecked = Squid_Directory() .. "/media/squid_icon_unchecked.blp"
			local squid_slider_thumb = Squid_Directory() .. "/media/sliderthumb.blp"
			local squid_slider_thumb_new = Squid_Directory() .. "/media/sliderthumb2.blp"
			--init frame (???)
			local init_frame = CreateFrame("Frame")
			init_frame:GetWidth()

			local backdrop = {
			bgFile = squid_bg,
			tileSize = 256,
			edgeFile = nil,--"Interface\\FriendsFrame\\UI-Toast-Border",
			tile = 1,
			edgeSize = 3,
			insets = {
				top = 0, --2
				right = 0, --2
				left = 0, --3
				bottom = 0, --3
				}
			}

			local backdrop2 = {
			bgFile = squid_bg,
			tileSize = 900,
			edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
			tile = 1,
			edgeSize = 2,
			insets = {
				top = 0, --2
				right = 0, --2
				left = 0, --3
				bottom = 0, --3
				}
			}

			local backdrop3 = {
			bgFile = "Interface/Tooltips/UI-Tooltip-Background",
			tileSize = 900,
			edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
			tile = 1,
			edgeSize = 2,
			insets = {
				top = 0, --2
				right = 0, --2
				left = 0, --3
				bottom = 0, --3
				}
			}

			local slider_backdrop = {
			bgFile = nil,
			tileSize = 8,
			edgeFile = "Interface\\FriendsFrame\\UI-Toast-Border",
			tile = 1,
			edgeSize = 4,
			insets = {
				top = 0, --2
				right = 0, --2
				left = 0, --3
				bottom = 0, --3
				}
			}

			local slider_backdrop2 = {
			bgFile = "Interface/Tooltips/UI-Tooltip-Background",
			tileSize = 8,
			edgeFile = nil,--"Interface\\FriendsFrame\\UI-Toast-Border",
			tile = 1,
			edgeSize = 5,
			insets = {
				top = 0, --2
				right = 2, --2
				left = 2, --3
				bottom = 0, --3
				}
			}

			local slider_backdrop3 = {
			bgFile = "Interface/Tooltips/UI-Tooltip-Background",
			tileSize = 8,
			edgeFile = nil,--"Interface\\FriendsFrame\\UI-Toast-Border",
			tile = 1,
			edgeSize = 0,
			insets = {
				top = 0, --2
				right = 12, --2
				left = 12, --3
				bottom = 0, --3
				}
			}

			SQFRAMEHOLDER = CreateFrame("Frame", nil, BackdropTemplate);

			-- create the frame that will hold all other frames/objects:
			local f = SQFRAMEHOLDER or CreateFrame("Frame", nil, BackdropTemplate); -- re-size this to whatever size you wish your ScrollFrame to be, at this point
			Mixin(f, BackdropTemplateMixin)
			f:SetBackdrop(backdrop)
			f:SetHeight(250)
			f:SetWidth(450)
			if SQUID.gui_coords.a1 then -- keep gui pos where user likes it
				local a1,a2,x,y = SQUID.gui_coords.a1,SQUID.gui_coords.a2,SQUID.gui_coords.x,SQUID.gui_coords.y
				f:SetPoint(a1,nil,a2,x,y)
			else
				f:SetPoint("CENTER",230,-20)
			end
			f:SetFrameStrata("HIGH")
			f:SetMovable(true)
			f:SetScript("OnMouseUp",function(self) self:StopMovingOrSizing() local a1,_,a2,x,y = self:GetPoint() SQUID.gui_coords = {a1=a1,a2=a2,x=x,y=y} end)
			f:SetScript("OnMouseDown",function(self) self:StartMoving() end)

			-- logotext
			f.logo_text = f:CreateFontString(f,"HIGH")
			f.logo_text:SetFont(sui,18)
			f.logo_text:SetText("Project LarryExitScam")
			f.logo_text:SetPoint("TOPLEFT",f,"TOPLEFT",8.1,-8.1)
			-- versiontext
			-- f.version_text = f:CreateFontString(f,"HIGH")
			-- f.version_text:SetFont(sui,8)
			-- f.version_text:SetText("v." .. squid_version)
			-- f.version_text:SetPoint("TOPLEFT",f,"TOPLEFT",95.5,-26)

			--epic changey rgb logo squiddo
			local r = 230
			local g = 230
			local b = 250
			local r_dir = "b"
			local g_dir = "f"
			local b_dir = "f"
			local tick = 0
			f:SetScript("OnUpdate",function()
				tick = tick + 1
				if tick >= 15 then
					if r_dir == "f" then
						r = r + 1--math.random(1,2)
					else
						r = r - 1--math.random(1,2)
					end
					if g_dir == "f" then
						g = g + 1--math.random(1,2)
					else
						g = g - 1--math.random(1,2)
					end
					if b_dir == "f" then
						b = b + 1--math.random(1,2)
					else
						b = b - 1--math.random(1,2)
					end

					-- we like lighter color
					-- if math.random(1,6) == 4 then
					-- 	r_dir = "f"
					-- 	b_dir = "f"
					-- end

					if r > 211 then
						r = 211
						r_dir = "b"
					elseif r < 164 then
						r = 164
						r_dir = "f"
					end

					if g > 164 then
						g = 164
						g_dir = "b"
					elseif g < 132 then
						g = 132
						g_dir = "f"
					end

					if b > 244 then
						b = 244
						b_dir = "b"
					elseif b < 182 then
						b = 182
						b_dir = "f"
					end

					-- if r > 230 then
					-- 	r = 230
					-- 	r_dir = "b"
					-- elseif r < 148 then
					-- 	r = 148
					-- 	r_dir = "f"
					-- elseif r > 160 and b < 200 then
					-- 	r_dir = "b"
					-- end
					-- if g > 220 then
					-- 	g = 220
					-- 	g_dir = "b"
					-- elseif g < 72 then
					-- 	g = 72
					-- 	g_dir = "f"
					-- elseif g > 140 and (r < 160 or b < 160) then
					-- 	g_dir = "b"
					-- end
					-- if b > 240 then
					-- 	b = 240
					-- 	b_dir = "b"
					-- elseif b < 140 then
					-- 	b = 140
					-- 	b_dir = "f"
					-- elseif b > 180 and r < 160 then
					-- 	b_dir = "b"
					-- end
					f.logo_text:SetTextColor(r/255,g/255,b/255)
					tick = 0
				end
			end)

			--TAB SECTION
			local tabs = {}
			f.tab_section =  CreateFrame("Frame", f, BackdropTemplate)
			f.tab_section:SetParent(f)
			Mixin(f.tab_section, BackdropTemplateMixin)
			f.tab_section:SetBackdrop(backdrop)
			f.tab_section:SetBackdropColor(0,0,0,0)
			f.tab_section:SetHeight(175)
			f.tab_section:SetWidth(110)
			f.tab_section:SetPoint("BOTTOMLEFT",f,"BOTTOMLEFT",5,20)

			f.tab_section.scroll_position = 1 -- default scroll position
			f.tab_section.input = {} -- holds recent scroll input history (each scroll tick, with the time it was sent allowing for our smooth scrolling to work.)
			f.tab_section.momentum = {} -- momentum of scrolling speed

			f.tab_section.VIEWABLE_HEIGHT = f.tab_section:GetHeight()
			f.tab_section.SCROLLABLE_HEIGHT = f.tab_section:GetHeight()
			f.tab_section.USED_HEIGHT = 0

			local scrollspace_mod = 8

			--current tab text : )
			f.tab_text = f:CreateFontString(f,"HIGH")
			f.tab_text:SetFont(sui_bold,16)
			f.tab_text:SetText(current_tab or "No Tab Selected")
			f.tab_text:SetTextColor(155/255, 155/255, 254/255, 1)
			f.tab_text:SetPoint("TOP",f,"TOP",50,-20)

			local current_tab

			--new populate
			local function populate(name, hide_columns)
				recent_population = GetTime()
				if hide_columns then
					f.c1:Hide()
					f.c2:Hide()
					-- do custom shit that covers the whole GUI ? yeah but make it an element i guess
				else
					f.c1:Show()
					f.c2:Show()
				end
				for i=1,#f.tab_section.tabs do
					local tab = f.tab_section.tabs[i]
					--populate the columns with elements from the tabs
					if tab.name == name then
						current_tab = tab
						tab.selected = true
						tab.adjust_scroll_position = tab.scroll_position
						tab.adjust_scroll_positionc2 = tab.scroll_positionc2
						tab:GetFontString():SetTextColor(255/255, 250/255, 254/255, 1)
						tab:GetFontString():SetFont(sui,18.5,'OUTLINE')
						f.tab_text:SetText(tab.name)
						local matching_elements = 0
						for n=1,#f.c1.elements do
							local e = f.c1.elements[n]
							if e.tab == tab then
								e:Show()
								matching_elements = matching_elements + 1
							end
						end
						for n=1,#f.c2.elements do
							local e = f.c2.elements[n]
							if e.tab == tab then
								e:Show()
								matching_elements = matching_elements + 1
							end
						end
						if matching_elements == 0 then
							f.c1:Hide()
							f.c2:Hide()
							tab.nothing_message:Show()
						end
					else --depopulate the other tabs
						tab:GetFontString():SetVertexColor(155/255, 155/255, 254/255, 1)
						tab:GetFontString():SetFont(sui,17)
						tab.selected = false
						for n=1,#f.c1.elements do
							local e = f.c1.elements[n]
							if e.tab == tab then
								e:Hide()
							end
						end
						for n=1,#f.c2.elements do
							local e = f.c2.elements[n]
							if e.tab == tab then
								e:Hide()
							end
						end
						tab.nothing_message:Hide()
					end
				end
			end

			populate_tab = populate

			--new gui createtab
			function create_gui_tab(properties)
				local text = properties.text
				local func = properties.func
				local parent = properties.parent
				local tab = CreateFrame("Button",nil,parent,nil,"UIPanelButtonTemplate")
				tab:SetFrameStrata("HIGH")

				tab.name=text

				tab:SetText(text)
				tab:SetNormalTexture(squid_button)
				tab:GetNormalTexture():SetVertexColor(1,1,1,0)
				tab:SetHighlightTexture(squid_button)
				tab:SetScript("OnClick",function(self) func(self.name) end)
				tab:GetFontString():SetFont(sui,17,nil)
				tab:GetFontString():SetTextColor(155/255, 155/255, 254/255, 1)

				tab:GetFontString():SetSize(105,17)
				tab:GetFontString():SetJustifyV("MIDDLE")
				tab:GetFontString():SetJustifyH("LEFT")

				tab:SetSize(95,24)

				tab:SetScript("OnEnter", function(self) if not self.selected then self:GetFontString():SetFont(sui,18.25,nil) self:GetFontString():SetTextColor(195/255, 195/255, 254/255, 1) end end)
				tab:SetScript("OnLeave", function(self) if not self.selected then self:GetFontString():SetFont(sui,17,nil) self:GetFontString():SetTextColor(155/255, 155/255, 254/255, 1) end end)

				if not parent.tabs then
					parent.tabs = {}
				end

				local space_between = tab:GetHeight()

				if #parent.tabs > 0 then
					local lta1,_,_,x,y = parent.tabs[#parent.tabs]:GetPoint()
					tab:SetPoint(lta1,x,y-space_between)
					tab.point = {tab:GetPoint()}
				else
					tab:SetPoint("TOP",parent,"TOP",0,0)
					tab.point = {tab:GetPoint()}
				end

				f.tab_alpha = CreateFrame("Frame")
				f.tab_alpha:SetParent(f)
				f.tab_alpha:SetScript("OnUpdate",function()
					local lta1,parent,lta2,x,y = unpack(tab.point)

					local cutoff = tab:GetHeight()
					tab:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
					lta1,_,_,x,y = tab:GetPoint() -- original coordinates
					local parent_height = parent:GetHeight()

					if y < -parent_height + cutoff then
						tab:SetAlpha(max(0, 1 - ((abs(y) - (parent_height-cutoff) ) / cutoff)))
					elseif y > 0 then
						tab:SetAlpha(max(0, 1 - (y/(cutoff+13))))
					else
						tab:SetAlpha(1)
					end

					if tab:GetAlpha() <= 0 then
						tab:Hide()
					else
						tab:Show()
					end
				end)

				tab.nothing_message = f:CreateFontString(f,"HIGH")
				tab.nothing_message:SetFont(sui_bold,11)
				tab.nothing_message:SetText("Sorry, there's nothing on this tab yet ;[\n\nIf you have any suggestions, let us know on discord!")
				tab.nothing_message:SetPoint("CENTER",f,"CENTER",54,0)
				tab.nothing_message:Hide()--nothing message, in case  nothing is in the tab

				tab.space_between = space_between

				tab.c1 = {
					SCROLLABLE_HEIGHT = f.tab_section:GetHeight(),
					USED_HEIGHT = 0
				}
				tab.c2 = {
					SCROLLABLE_HEIGHT = f.tab_section:GetHeight(),
					USED_HEIGHT = 0
				}

				table.insert(parent.tabs,tab)

				parent.USED_HEIGHT = parent.USED_HEIGHT + space_between
				if parent.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
					if parent.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
						parent.SCROLLABLE_HEIGHT = parent.SCROLLABLE_HEIGHT + (parent.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
					else
						parent.SCROLLABLE_HEIGHT = parent.SCROLLABLE_HEIGHT + space_between
					end
				end

				-- return the tab from the parent
				for i=1,#parent.tabs do
					if parent.tabs[i] == tab then
						return parent.tabs[i]
					end
				end

			end

			-- table of all specs
			specs = {}
			for i=1,4 do
				local specname = select(2,GetSpecializationInfo(i))
				if specname then
					table.insert(specs,specname)
				end
			end

			-- get current spec and remove it from list of other specs
			local currentSpec = GetSpecialization()
			local currentSpecName = currentSpec and select(2, GetSpecializationInfo(currentSpec)) or "None"

			if currentSpecName == "" then currentSpecName = "Low" end

			local previous_spec = currentSpecName

			-- refresh + sort tabs on specialization change
			function sort_tabs(specname)

				f.tab_section.VIEWABLE_HEIGHT = f.tab_section:GetHeight()
				f.tab_section.SCROLLABLE_HEIGHT = f.tab_section:GetHeight()
				f.tab_section.USED_HEIGHT = 0

				local current_spec_index
				local class_index
				local old_spec_index

				for i=1,#f.tab_section.tabs do
					local tab = f.tab_section.tabs[i]
					if tab.name == specname then
						current_spec_index = i
					elseif tab.name == UnitClass("player") then
						class_index = i
					elseif tab.name == previous_spec then
						old_spec_index = i
					end
				end

				previous_spec = specname

				-- swap old and new tab indexes
				if old_spec_index then

					table.insert(f.tab_section.tabs, old_spec_index, table.remove(f.tab_section.tabs,current_spec_index))

					table.insert(f.tab_section.tabs, current_spec_index, table.remove(f.tab_section.tabs,old_spec_index+1))

					f.tab_section.tabs[old_spec_index]:Show()

					f.tab_section.tabs[current_spec_index]:Hide()

				end

				-- reposition the tabs
				for i=1,#f.tab_section.tabs do
					local tab = f.tab_section.tabs[i]
					-- position tab
					if i > 1 then
						local lta1,_,_,x,y = f.tab_section.tabs[i-1]:GetPoint()
						tab:SetPoint(lta1,x,y-tab.space_between)
						tab.point = {tab:GetPoint()}
					else
						tab:SetPoint("TOP",f.tab_section,"TOP",0,0)
						tab.point = {tab:GetPoint()}
					end
					-- respace
					f.tab_section.USED_HEIGHT = f.tab_section.USED_HEIGHT + tab.space_between
					if f.tab_section.USED_HEIGHT >= f.tab_section.VIEWABLE_HEIGHT then
						if f.tab_section.USED_HEIGHT - f.tab_section.VIEWABLE_HEIGHT < tab.space_between then
							f.tab_section.SCROLLABLE_HEIGHT = f.tab_section.SCROLLABLE_HEIGHT + (f.tab_section.USED_HEIGHT - f.tab_section.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
						else
							f.tab_section.SCROLLABLE_HEIGHT = f.tab_section.SCROLLABLE_HEIGHT + tab.space_between
						end
					end
				end

			end

			--create all of the default tabs
			local class = UnitClass("player")
			local tabs = {"General", class, currentSpecName, "Utility", "PvE", "Interface", "Cooldowns", "Automation", "Objects", "Awareness",}--"Poopy Shit", "Asshole", "Bong Rip", "Dick Cheese", "Weed", "Asscrack", "Tiddies", "Squiddies"}

			for i=1,#tabs do
				create_gui_tab({text=tabs[i], func=populate, parent=f.tab_section})
			end

			-- create hidden spec tabs
			for i=1,#specs do if specs[i] ~= currentSpecName then
				create_gui_tab({text=specs[i], func=populate, parent=f.tab_section})
			end end

			-- sort_tabs()

			-- print in chat about settings changing
			local function settings_print(var_string,event,element)
				if element == "checkbox" then
					squid_print(not get_squid_var(var_string) and "|cffff6060" .. var_string .. " disabled" or var_string .. " enabled.")
				end
			end

			-- new
			SQUID.settings = SQUID.settings or {} -- init
			function set_squid_var(var_string,event,element)
				if not var_string then return false end
				if element == "slider" then
					if type(event) == "number" then
						SQUID.settings[var_string] = math.floor(event)
					end
				elseif element == "checkbox" then
					SQUID.settings[var_string] = event
					settings_print(var_string, event, element)
				elseif element == "editbox" then
					if var_string == "Object Finder List" then
						if not event then
							SQUID.settings[var_string] = nil
							SQUID.objects_to_draw = {}
						else
							local split = {}
							for i=1,20 do
								split[i] = select(i,strsplit(",",event))
								if split[i] then split[i] = strlower(split[i]):gsub("%s+","") end
							end
							if #split > 0 then
								SQUID.objects_to_draw=split
								SQUID.settings[var_string] = event
							else
								SQUID.objects_to_draw={}
								SQUID.settings[var_string] = nil
								return false -- sets it back to default text , self:SetText(self.text)
							end
						end
					end
				elseif element == "dropdown" then
					--blalala
				end

			end

			-- returns the var set, or saves the default value to that var
			function get_squid_var(var_string,default,element)
				local setting = SQUID.settings[var_string]
				if setting then
					return SQUID.settings[var_string]
				elseif default then
					SQUID.settings[var_string] = default
					return default
				end
			end

			--new header
			local function create_header(properties)

				-- which tab will populate this checkbox?
				local tab = properties.tab

				local color = properties.color

				local column = properties.column
				--which column are we populating this checkbox to?
				local parent
				if column == 1 then
					parent = f.c1
				elseif column == 2 then
					parent = f.c2
				else
					column = 1
					parent = f.c1
				end

				local text = properties.text
				local font = properties.font or sui

				local container = CreateFrame("Frame", parent, BackdropTemplate)
				container:SetParent(parent)
				-- Mixin(container,BackdropTemplateMixin)
				-- container:SetBackdrop(backdrop3)
				container:SetWidth(130)
				container:SetHeight(18)

				container.tab = tab
				container.parent = parent
				container.column = column

				-- local anchor,_,anchor2,x,y = AlertFrames_Anchor:GetPoint()
				-- alert:SetPoint("CENTER",AlertFrames_Anchor,"CENTER",0,20)
				-- alert:SetHeight(125)
				-- alert:SetWidth(400)

				-- local font = cfe
				-- alert:SetClampedToScreen(true)
				-- alert.Text = alert:CreateFontString(nil, "HIGH", nil)
				-- alert.Text:SetFont(font,13,'THICKOUTLINE')

				container.txt = container:CreateFontString(nil,"HIGH")

				container.txt:SetFont(font,18)
				container.txt:SetText(text)
				container.txt:SetSize(130,36)
				container.txt:SetPoint("CENTER",container,"CENTER",0,0)

				container.txt:SetJustifyV("MIDDLE")
				container.txt:SetJustifyH("LEFT")

				if color then
					local r,g,b,a = unpack(color)
					container.txt:SetTextColor(r,g,b,a)
				else
					container.txt:SetTextColor(155/255, 155/255, 254/255, 1)
				end

				local space_between = container:GetHeight() + 6

				local elements_in_tab = 0
				for i=1,#parent.elements do
					local e = parent.elements[i]
					if e.tab == tab then
						elements_in_tab = elements_in_tab + 1
					end
				end

				local original_space_between = space_between

				if elements_in_tab > 0 then
					local e = parent.elements
					local lta1,_,_,x,y = e[#e]:GetPoint()
					container:SetPoint("TOPLEFT",parent,"TOPLEFT",0,y-space_between)
					container.point = {container:GetPoint()}
				else
					container:SetPoint("TOPLEFT",parent,"TOPLEFT",0,-3)
					container.point = {container:GetPoint()}
				end

				f.container_alpha = CreateFrame("Frame")
				f.container_alpha:SetParent(f)
				f.container_alpha:SetScript("OnUpdate",function()
					local lta1,parent,lta2,x,y = unpack(container.point)

					local cutoff = original_space_between
					container:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
					lta1,_,_,x,y = container:GetPoint() -- original coordinates
					local parent_height = parent:GetHeight()

					if y < -parent_height + cutoff then
						container:SetAlpha(max(0, 1 - ((abs(y) - (parent_height-cutoff+12) ) / cutoff)))
					elseif y > 0 then
						container:SetAlpha(max(0, 1 - (y/(cutoff))))
					else
						container:SetAlpha(1)
					end
					if tab.selected then
						if container:GetAlpha() <= 0 then
							container:Hide()
						else
							container:Show()
						end
					end
				end)

				container.space = 5
				local extra_space_mod = container.space / 2

				if column == 1 then
					tab.c1.USED_HEIGHT = tab.c1.USED_HEIGHT + space_between + extra_space_mod
					if tab.c1.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
						if tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
							tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + (tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
						else
							tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + space_between + extra_space_mod
						end
					end
				elseif column == 2 then
					tab.c2.USED_HEIGHT = tab.c2.USED_HEIGHT + space_between + extra_space_mod
					if tab.c2.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
						if tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
							tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + (tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
						else
							tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + space_between + extra_space_mod
						end
					end
				end

				table.insert(parent.elements,container)

			end

			--new header
			local function create_subheader(properties)

				-- which tab will populate this checkbox?
				local tab = properties.tab

				local color = properties.color

				local column = properties.column
				--which column are we populating this checkbox to?
				local parent
				if column == 1 then
					parent = f.c1
				elseif column == 2 then
					parent = f.c2
				else
					column = 1
					parent = f.c1
				end

				local text = properties.text
				local font = properties.font or sui

				local container = CreateFrame("Frame", parent, BackdropTemplate)
				container:SetParent(parent)
				-- Mixin(container,BackdropTemplateMixin)
				-- container:SetBackdrop(backdrop3)
				container:SetWidth(130)
				container:SetHeight(19)

				container.tab = tab
				container.parent = parent
				container.column = column

				-- local anchor,_,anchor2,x,y = AlertFrames_Anchor:GetPoint()
				-- alert:SetPoint("CENTER",AlertFrames_Anchor,"CENTER",0,20)
				-- alert:SetHeight(125)
				-- alert:SetWidth(400)

				-- local font = cfe
				-- alert:SetClampedToScreen(true)
				-- alert.Text = alert:CreateFontString(nil, "HIGH", nil)
				-- alert.Text:SetFont(font,13,'THICKOUTLINE')

				container.txt = container:CreateFontString(nil,"HIGH")

				container.txt:SetFont(font,13)
				container.txt:SetText(text)
				container.txt:SetSize(130,25)
				container.txt:SetPoint("CENTER",container,"CENTER",0,0)

				container.txt:SetJustifyV("MIDDLE")
				container.txt:SetJustifyH("LEFT")

				container.type = "subheader"

				if color then
					local r,g,b,a = unpack(color)
					container.txt:SetTextColor(r,g,b,a)
				else
					container.txt:SetTextColor(155/255, 155/255, 254/255, 1)
				end

				local space_between = container:GetHeight() + 8

				local elements_in_tab = 0
				for i=1,#parent.elements do
					local e = parent.elements[i]
					if e.tab == tab then
						elements_in_tab = elements_in_tab + 1
					end
				end

				local original_space_between = space_between

				if elements_in_tab > 0 then
					local e = parent.elements
					local lta1,_,_,x,y = e[#e]:GetPoint()
					local move_backwards = e[#e].type == "checkbox" and 3 or e[#e].type == "slider" and 3 or 0
					container:SetPoint("TOPLEFT",parent,"TOPLEFT",3,y-space_between)
					container.point = {container:GetPoint()}
				else
					container:SetPoint("TOPLEFT",parent,"TOPLEFT",3,-3)
					container.point = {container:GetPoint()}
				end

				f.container_alpha = CreateFrame("Frame")
				f.container_alpha:SetParent(f)
				f.container_alpha:SetScript("OnUpdate",function()
					local lta1,parent,lta2,x,y = unpack(container.point)

					local cutoff = original_space_between
					container:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
					lta1,_,_,x,y = container:GetPoint() -- original coordinates
					local parent_height = parent:GetHeight()

					if y < -parent_height + cutoff then
						container:SetAlpha(max(0, 1 - ((abs(y) - (parent_height-cutoff+12) ) / cutoff)))
					elseif y > 0 then
						container:SetAlpha(max(0, 1 - (y/(cutoff))))
					else
						container:SetAlpha(1)
					end
					if tab.selected then
						if container:GetAlpha() <= 0 then
							container:Hide()
						else
							container:Show()
						end
					end
				end)

				container.space = 5
				local extra_space_mod = container.space / 2

				if column == 1 then
					tab.c1.USED_HEIGHT = tab.c1.USED_HEIGHT + space_between + extra_space_mod
					if tab.c1.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
						if tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
							tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + (tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
						else
							tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + space_between + extra_space_mod
						end
					end
				elseif column == 2 then
					tab.c2.USED_HEIGHT = tab.c2.USED_HEIGHT + space_between + extra_space_mod
					if tab.c2.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
						if tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
							tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + (tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
						else
							tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + space_between + extra_space_mod
						end
					end
				end

				table.insert(parent.elements,container)

			end

			--new checkbox
			function create_checkbox(properties)

				-- which tab will populate this checkbox?
				local tab = properties.tab

				local column = properties.column
				--which column are we populating this checkbox to?
				local parent
				if column == 1 then
					parent = f.c1
				elseif column == 2 then
					parent = f.c2
				else
					column = 1
					parent = f.c1
				end

				local text = properties.text
				local setting = properties.setting -- hook "SetChecked" function to check &amp; uncheck this box when value changes

				local tooltip = properties.tooltip
				local var = properties.var
				local new_var = properties.new_var

				if new_var then
					var = get_squid_var(new_var)
				end

				local func = properties.func

				local default = properties.default -- default setting (true=checked, false=unchecked)

				local under_subheader = properties.under_subheader

				local box_type = "checkbox"

				local box = CreateFrame("CheckButton",nil,parent)
				box:SetSize(13,13)
				box:SetNormalTexture(squid_icon_unchecked)
				box:SetHighlightTexture(squid_icon_unchecked)
				box:GetHighlightTexture():SetVertexColor(.3,.3,0,.4)
				box:SetCheckedTexture(squid_icon_checked)
				box:SetFrameStrata("HIGH")
				box:SetChecked(var) -- set checked based on current value
				if default == true then
					if var == nil then
						box:SetChecked(default)
						func(new_var,true,box_type)
					end
				end
				box:SetScript("PostClick",function(self,event)
					if new_var then
						if box:GetChecked() then
							func(new_var,true,box_type)
						else
							func(new_var,false,box_type)
						end
					else
						if func then func(self,event) end
					end
					if self:GetChecked() then
						--checked sound
						if not SQUID.sounds_disabled then
							local soundfile = Squid_Directory() .. "/media/checkbox.wav"
							PlaySoundFile(soundfile,"Master")
						end
					else
						--unchecked sound
						if not SQUID.sounds_disabled then
							local soundfile = Squid_Directory() .. "/media/tap.wav"
							PlaySoundFile(soundfile,"Master")
						end
					end
				end)
				if tooltip then
					box:SetScript("OnEnter",function(self)
						if not SQUID.hidetooltips then
							--starting point
							GameTooltip:Show()
							GameTooltip:SetOwner(f,"CENTER",0,0);
							GameTooltip:SetAnchorType("ANCHOR_TOPLEFT",0,0);
							GameTooltip:SetBackdrop(backdrop2)
							GameTooltip:SetBackdropColor(155/255,155/255,254/255,1)
							GameTooltipText:SetFont(sui,4,'OUTLINE')
							GameTooltip:SetText("|cFF8787dd" .. tooltip);
						end
					end)
					box:SetScript("OnLeave",function(self)
						GameTooltipText:SetFont("Fonts\\FRIZQT__.TTF",12)
						GameTooltip:Hide()
					end)
				end

				-- hook "setchecked" and change the box from the outside world
				local setvar_og = set_squid_var
				set_squid_var = function(given_var,event,box_type,...)
					if given_var == new_var then
						box:SetChecked(event)
					end
					setvar_og(given_var,event,box_type,...)
				end

				box:SetScale(1)
				box.tab = tab
				box.parent = parent
				-- parent = box.parent
				box.type = "checkbox"

				local space_between = box:GetHeight() + 3.5
				local elements_in_tab = 0
				for i=1,#parent.elements do
					local e = parent.elements[i]
					if e.tab == tab then
						elements_in_tab = elements_in_tab + 1
					end
				end

				local move_forward = under_subheader and 4 or 0
				if elements_in_tab > 0 then
					local e = parent.elements
					local lta1,_,_,x,y = e[#e]:GetPoint()
					local extra_space = (e[#e].space or 0) + (e[#e].type == "subheader" and 5 or 0)
					space_between = space_between + extra_space
					-- space_between = space_between + prev_height -- adding from previous element's height
					box:SetPoint("TOPLEFT",parent,"TOPLEFT",2 + move_forward,y-space_between)
					box.point = {box:GetPoint()}
				else
					box:SetPoint("TOPLEFT",parent,"TOPLEFT",2 + move_forward,-5.5)
					box.point = {box:GetPoint()}
				end

				f.box_alpha = CreateFrame("Frame")
				f.box_alpha:SetParent(f)
				f.box_alpha:SetScript("OnUpdate",function()
					local lta1,parent,lta2,x,y = unpack(box.point)

					local cutoff = box:GetHeight() + 3.5
					box:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
					lta1,_,_,x,y = box:GetPoint() -- original coordinates
					local parent_height = parent:GetHeight()

					if y < -parent_height + cutoff then
						box:SetAlpha(max(0, 1 - ((abs(y) - (parent_height-cutoff+3.5) ) / cutoff)))
					elseif y > 0 then
						box:SetAlpha(max(0, 1 - (y/(cutoff+11))))
					else
						box:SetAlpha(1)
					end
					if tab.selected then
						if box:GetAlpha() <= 0 then
							box:Hide()
						else
							box:Show()
						end
					end
				end)

				box:SetText(text)
				box:GetFontString():SetFont(sui,11)

				-- box:GetFontString():SetPoint("CENTER",box,"CENTER",w,0)
				local txt = box:GetFontString()
				txt:SetSize(125,20)
				txt:SetPoint("CENTER",box,"CENTER",74,0)
				txt:SetJustifyV("MIDDLE")
				txt:SetJustifyH("LEFT")

				if column == 1 then
					tab.c1.USED_HEIGHT = tab.c1.USED_HEIGHT + space_between
					if tab.c1.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
						if tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
							tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + (tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
						else
							tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + space_between
						end
					end
				elseif column == 2 then
					tab.c2.USED_HEIGHT = tab.c2.USED_HEIGHT + space_between
					if tab.c2.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
						if tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
							tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + (tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
						else
							tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + space_between
						end
					end
				end

				box:Hide()

				table.insert(parent.elements,box)

			end

			--new slider
			function create_slider(properties)

				-- which tab will populate this checkbox?
				local tab = properties.tab

				local value = properties.value
				local min = properties.min
				local max = properties.max
				local step = properties.step
				local low = properties.low
				local high = properties.high
				local text = properties.text
				local tooltip = properties.tooltip
				local var = properties.var -- fix this later
				local new_var = properties.new_var
				local onvaluechanged = properties.onvaluechanged

				local under_subheader = properties.under_subheader

				if new_var then
					var = get_squid_var(new_var)
				end

				if not var then
					set_squid_var(new_var, value, "slider")
					var=value
				end

				local column = properties.column
				--which column are we populating this checkbox to?
				local parent
				if column == 1 then
					parent = f.c1
				elseif column == 2 then
					parent = f.c2
				else
					column = 1
					parent = f.c1
				end

				local setting = properties.setting -- hook "SetChecked" function to check &amp; uncheck this box when value changes

				local randomseed = math.random(1,9999999)

				local slider = CreateFrame("Slider","SquidSlider"..randomseed,parent,"OptionsSliderTemplate")
				Mixin(slider, BackdropTemplateMixin)
				slider:ClearAllPoints()
				slider.text = text
				slider:SetBackdrop(slider_backdrop3)
				slider:SetBackdropColor(.8,.8,.8,.36)
				slider:SetThumbTexture(squid_slider_thumb_new)
				-- slider:SetThumbSize(2)
				slider:SetWidth(120)
				slider:SetHeight(4)
				slider:SetMinMaxValues(min,max)
				slider:SetValue(var or value)
				slider:SetValueStep(step)
				getglobal(slider:GetName().."Low"):SetText(" ")
				getglobal(slider:GetName().."Text"):SetText(text)
				getglobal(slider:GetName().."High"):SetText(var or value)
				getglobal(slider:GetName().."High"):SetFont(sui,11)
				getglobal(slider:GetName().."Text"):SetFont(sui,12)

				getglobal(slider:GetName().."Text"):SetSize(140,20)
				getglobal(slider:GetName().."Text"):SetJustifyV("MIDDLE")
				getglobal(slider:GetName().."Text"):SetJustifyH("LEFT")

				local text_anchor,_,_,text_x,text_y = getglobal(slider:GetName().."Text"):GetPoint()
				getglobal(slider:GetName().."Text"):SetPoint(text_anchor,text_x+21,text_y+6)
				getglobal(slider:GetName().."Text"):SetTextColor(175/255, 176/255, 254/255, 1)

				local text_anchor,_,_,text_x,text_y = getglobal(slider:GetName().."High"):GetPoint()
				getglobal(slider:GetName().."High"):SetPoint(text_anchor,text_x+25,text_y)
				getglobal(slider:GetName().."High"):SetSize(35,10)
				getglobal(slider:GetName().."High"):SetJustifyV("MIDDLE")
				getglobal(slider:GetName().."High"):SetJustifyH("LEFT")
				getglobal(slider:GetName().."High"):SetJustifyH("LEFT")
				getglobal(slider:GetName().."High"):SetTextColor(155/255, 155/255, 254/255, 1)

				slider:SetFrameStrata("HIGH")

				slider.tab = tab
				slider.parent = parent
				slider.type = "slider"

				if tooltip then
					slider:SetScript("OnEnter",function(self)
						if not SQUID.hidetooltips then
							GameTooltip:Show()
							GameTooltip:SetOwner(f,"CENTER",0,0);
							GameTooltip:SetAnchorType("ANCHOR_TOPLEFT",0,0);
							GameTooltip:SetBackdrop(backdrop)
							GameTooltip:SetBackdropColor(155/255,155/255,254/255,1)
							GameTooltipText:SetTextColor(255/255,255/255,255/255,1)
							GameTooltipText:SetFont(sui,4,nil)
							GameTooltip:SetText("|cFF8787dd" .. tooltip);
						end
					end)
					slider:SetScript("OnLeave",function(self)
						GameTooltipText:SetFont("Fonts\\FRIZQT__.TTF",12)
						GameTooltip:Hide()
					end)
				end

				-- slider:SetScript("OnMouseWheel",function(self,event)
				-- 	if event == -1 then
				-- 		self:SetValue(self:GetValue() - self:GetValueStep())
				-- 	else
				-- 		self:SetValue(self:GetValue() + self:GetValueStep())
				-- 	end
				-- end)

				slider.parent = column
				local slider_type = "slider"
				slider.type = slider_type

				slider:SetScript("OnValueChanged",function(self,event)
					if new_var then
						onvaluechanged(new_var,event,"slider")
					else
						onvaluechanged(self,event)
					end
					getglobal(slider:GetName().."High"):SetText(math.floor(self:GetValue()))
					-- getglobal(slider:GetName().."High"):SetPoint(text_anchor,text_x+12-(strlen(self:GetValue())-1),text_y)
					--unchecked sound
					local min_val, max_val = slider:GetMinMaxValues()
					if not SQUID.sounds_disabled and event ~= slider_previous_value and ((not slider_previous_value or abs(event - slider_previous_value) > math.max(slider:GetValueStep(), max_val/75)) or slider_sound and GetTime() - slider_sound > .04 and slider_previous_value and abs(event - slider_previous_value) >= 1) and (not slider_sound or GetTime() - slider_sound > .04) then
						local soundfile = Squid_Directory() .. "/media/tap.wav"
						PlaySoundFile(soundfile,"Master")
						slider_sound_played = GetTime()
						slider_previous_value = event
						slider_sound = GetTime()
					end
				end)

				-- hook function that sets the var and update the slider value when changed
				local setvar_og = set_squid_var
				set_squid_var = function(given_var,event,slider_type,...)
					if given_var == new_var then
						slider:SetValue(event)
					end
					setvar_og(given_var,event,slider_type,...)
				end

				if var and not slider.initial_update then
					getglobal(slider:GetName().."High"):SetText(var)
					if getglobal(slider:GetName().."High"):GetText() == var then
						slider:SetValue(var)
						slider.initial_update = true
					end
				end

				local space_between = slider:GetHeight() + 37

				local elements_in_tab = 0
				for i=1,#parent.elements do
					local e = parent.elements[i]
					if e.tab == tab then
						elements_in_tab = elements_in_tab + 1
					end
				end

				local original_space_between = space_between

				local move_forward = under_subheader and 4 or 0
				if elements_in_tab > 0 then
					local e = parent.elements
					local lta1,_,_,x,y = e[#e]:GetPoint()
					local extra_space = e[#e].space or 0
					space_between = space_between + extra_space
					slider:SetPoint("TOPLEFT",parent,"TOPLEFT",-9 + move_forward,y-space_between)
					slider.point = {slider:GetPoint()}
				else
					slider:SetPoint("TOPLEFT",parent,"TOPLEFT",-9 + move_forward,-20)
					slider.point = {slider:GetPoint()}
				end

				f.slider_alpha = CreateFrame("Frame")
				f.slider_alpha:SetParent(f)
				f.slider_alpha:SetScript("OnUpdate",function()
					local lta1,parent,lta2,x,y = unpack(slider.point)

					local cutoff = original_space_between
					slider:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
					lta1,_,_,x,y = slider:GetPoint() -- original coordinates
					local parent_height = parent:GetHeight()

					if y < -parent_height + cutoff then
						slider:SetAlpha(math.max(0, 1 - ((abs(y) - (parent_height-cutoff+20) ) / cutoff)))
					elseif y > 0 then
						slider:SetAlpha(math.max(0, 1 - (y/(cutoff-28))))
					else
						slider:SetAlpha(1)
					end
					if tab.selected then
						if slider:GetAlpha() <= 0 then
							slider:Hide()
						else
							slider:Show()
						end
					end
				end)

				if column == 1 then
					tab.c1.USED_HEIGHT = tab.c1.USED_HEIGHT + space_between
					if tab.c1.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
						if tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
							tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + (tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
						else
							tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + space_between
						end
					end
				elseif column == 2 then
					tab.c2.USED_HEIGHT = tab.c2.USED_HEIGHT + space_between
					if tab.c2.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
						if tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
							tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + (tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
						else
							tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + space_between
						end
					end
				end

				slider:Hide()

				table.insert(parent.elements,slider)

			end

			-- new editbox
			local function create_editbox(properties)

				local tab = properties.tab

				local title = properties.title -- title of the box
				local text = properties.text -- default text in box
				local lines = properties.lines or 1 -- how many lines for this editbox ( it gets taller, more space to write more shit )

				-- column &amp; parent frame
				local column = properties.column
				local parent
				if column == 1 then
					parent = f.c1
				elseif column == 2 then
					parent = f.c2
				else
					column = 1
					parent = f.c1
				end

				local var = properties.var -- editbox will only work with the new method of saving vars
				local saved_text = get_squid_var(var)

				local under_subheader = properties.under_subheader

				local editbox = CreateFrame("EditBox",nil,parent)
				Mixin(editbox, BackdropTemplateMixin)

				editbox.text = text

				editbox:SetSize(135,13 * lines)

				editbox:SetFont(sui,11)

				if saved_text then
					editbox:SetText(saved_text)
					print(saved_text)
				else
					editbox:SetText(text)
				end

				editbox:SetBackdrop(backdrop3)

				editbox:SetTextInsets(2,2,2,2)

				editbox:SetMultiLine(lines)
				editbox:SetBackdropColor(.71,.71,.96,.64)
				editbox:SetBackdropBorderColor(.7,.7,.7,.4)

				editbox:SetFontObject("GameFontHighlight")
				editbox:SetAutoFocus(false)

				editbox:SetScript("OnEnterPressed",function(self)
					local text = self:GetText()
					if text:gsub("%s+","") ~= "" then
						local var_set = set_squid_var(var, text, "editbox")
						if var_set == false then self:SetText(self.text) end
					else
						set_squid_var(var, nil, "editbox")
						self:SetText(self.text)
					end
					self:ClearFocus()
				end)

				editbox:SetScript("OnEscapePressed",function(self)
					local text = self:GetText()
					if text:gsub("%s+","") ~= "" then
						local var_set = set_squid_var(var, text, "editbox")
						if var_set == false then self:SetText(self.text) end
					else
						set_squid_var(var, text, "editbox")
						self:SetText(self.text)
					end
					self:ClearFocus()
				end)

				editbox:SetScript("OnEditFocusGained",function(self) if self:GetText() == text then self:SetText("") end end)
				editbox:SetScript("OnEditFocusLost",function(self)
					local txt = self:GetText()
					if txt:gsub("%s+", "") == "" then
						self:SetText(self.text)
					end
				end)

				editbox.parent = parent
				editbox.tab = tab
				editbox.type = "editbox"

				if title then
					editbox.title = editbox:CreateFontString(editbox,"HIGH")
					editbox.title:SetFont(sui,14)
					editbox.title:SetText(title)
					editbox.title:SetTextColor(155/255,155/255,254/255,1)
					editbox.title:SetPoint("TOPLEFT",editbox,"TOPLEFT",1,18)
				end

				local space_between = editbox:GetHeight() + (title and 9 or -1)

				local elements_in_tab = 0
				for i=1,#parent.elements do
					local e = parent.elements[i]
					if e.tab == tab then
						elements_in_tab = elements_in_tab + 1
					end
				end

				editbox.space = space_between

				local original_space_between = space_between
				local move_forward = under_subheader and 4 or 0
				if elements_in_tab > 0 then
					local e = parent.elements
					local lta1,_,_,x,y = e[#e]:GetPoint()
					-- local extra_space = e[#e].space or 0
					-- space_between = space_between + extra_space
					editbox:SetPoint("TOPLEFT",parent,"TOPLEFT",0 + move_forward, y - space_between)
					editbox.point = {editbox:GetPoint()}
				else
					editbox:SetPoint("TOPLEFT",parent,"TOPLEFT",0 + move_forward,-20)
					editbox.point = {editbox:GetPoint()}
				end

				f.editbox_alpha = CreateFrame("Frame")
				f.editbox_alpha:SetParent(f)
				f.editbox_alpha:SetScript("OnUpdate",function()
					local lta1,parent,lta2,x,y = unpack(editbox.point)

					local cutoff = original_space_between
					editbox:SetPoint(lta1,parent,lta2,x,y + (parent.scroll_position/scrollspace_mod))
					lta1,_,_,x,y = editbox:GetPoint() -- original coordinates
					local parent_height = parent:GetHeight()

					if y < -parent_height + cutoff then
						editbox:SetAlpha(math.max(0, 1 - ((abs(y) - (parent_height-cutoff-16) ) / cutoff)))
					elseif y > 0 then
						editbox:SetAlpha(math.max(0, 1 - (y/(cutoff-23))))
					else
						editbox:SetAlpha(1)
					end
					if tab.selected then
						if editbox:GetAlpha() <= 0 then
							editbox:Hide()
						else
							editbox:Show()
						end
					end
				end)

				-- space_between = (space_between * 2) + (title and 8 or 0)

				if column == 1 then
					tab.c1.USED_HEIGHT = tab.c1.USED_HEIGHT + space_between
					if tab.c1.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
						if tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
							tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + (tab.c1.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
						else
							tab.c1.SCROLLABLE_HEIGHT = tab.c1.SCROLLABLE_HEIGHT + space_between
						end
					end
				elseif column == 2 then
					tab.c2.USED_HEIGHT = tab.c2.USED_HEIGHT + space_between
					if tab.c2.USED_HEIGHT >= parent.VIEWABLE_HEIGHT then
						if tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT < space_between then
							tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + (tab.c2.USED_HEIGHT - parent.VIEWABLE_HEIGHT) - 2 -- let the bottom element hang off the edge of frame a bit, slightly
						else
							tab.c2.SCROLLABLE_HEIGHT = tab.c2.SCROLLABLE_HEIGHT + space_between
						end
					end
				end

				editbox:Hide()

				table.insert(parent.elements,editbox)

			end

			local extra_scrollable = (f.tab_section.SCROLLABLE_HEIGHT - f.tab_section:GetHeight() + 1) * scrollspace_mod
			CreateFrame("Frame"):SetScript("OnUpdate",function()
				extra_scrollable = (f.tab_section.SCROLLABLE_HEIGHT - f.tab_section:GetHeight() + 1) * scrollspace_mod
				-- print(extra_scrollable)
				if extra_scrollable == scrollspace_mod then extra_scrollable = 1 end
			end)

			-- print(extra_scrollable)

			--slider to display current scroll position and allow for drag scrolling
			f.tab_section.slider = CreateFrame("Slider","SqTabSectionSuperScroller",f.tab_section,"OptionsSliderTemplate")
			local slider = f.tab_section.slider
			Mixin(slider, BackdropTemplateMixin)
			slider:ClearAllPoints()
			slider:SetPoint("RIGHT",f.tab_section,"RIGHT",0,0)
			slider:SetFrameStrata("HIGH")
			slider:SetOrientation('VERTICAL')
			slider:SetBackdrop(slider_backdrop2)
			slider:SetBackdropColor(0,0,0,.28)
			slider:SetBackdropBorderColor(1,1,1,.6)
			slider:SetThumbTexture(squid_slider_thumb)
			slider.Thumb:SetHeight( (f.tab_section:GetHeight() / f.tab_section.SCROLLABLE_HEIGHT) * f.tab_section:GetHeight() )
			-- slider:SetThumbSize(2)
			slider:SetWidth(8)
			slider:SetHeight(f.tab_section:GetHeight())
			slider:SetMinMaxValues(1,extra_scrollable)
			slider:SetValue(f.tab_section.scroll_position)
			slider:SetScript("OnValueChanged",function(self)
				f.tab_section.scroll_position = self:GetValue()
			end)
			slider:SetValueStep(1)
			getglobal(slider:GetName().."Low"):SetText("")
			getglobal(slider:GetName().."High"):SetText("")

			CreateFrame("Frame"):SetScript("OnUpdate",function()
				if (f.tab_section:GetHeight() / f.tab_section.SCROLLABLE_HEIGHT) * f.tab_section:GetHeight() == f.tab_section:GetHeight() then
					slider:Hide()
				else
					slider:Show()
				end
			end)

			-- custom squid super scroller :)
			f.tab_section:SetScript("OnUpdate",function(self)
				-- know if we're hovering the frame
				if MouseIsOver(self) then
					f.tab_section.hovering = true
				else
					f.tab_section.hovering = false
				end

				-- handle momentum
				local momentum_value = 0

				local last_direction
				local momentum_modifier = 0

				local time = GetTime()

				-- iterate backwards for removing tables and resetting momentum if the newest input is different than the previous
				for i = #f.tab_section.momentum, 1, -1 do

					local m = f.tab_section.momentum[i]
					local direction = m.direction
					local ends = m.ends

					local val = (ends - time) / .65

					if val < 0 then
						table.remove(f.tab_section.momentum,i)
					else
						last_direction = direction
						if i == 1 then -- newest input
							if direction == "DOWN" then
								if last_direction ~= "DOWN" then
									momentum_value = 0
									momentum_modifier = 0
									momentum_value = momentum_value + val
								else
									momentum_value = momentum_value + val
									momentum_modifier = momentum_modifier + 1
								end
							else
								if last_direction ~= "UP" then
									momentum_value = 0
									momentum_modifier = 0
									momentum_value = momentum_value - val
								else
									momentum_value = momentum_value - val
									momentum_modifier = momentum_modifier + 1
								end
							end
						else
							if direction == "DOWN" then
								momentum_value = momentum_value + val
								momentum_modifier = momentum_modifier + 1
							else
								momentum_value = momentum_value - val
								momentum_modifier = momentum_modifier + 1
							end
						end
					end

				end

				momentum_value = momentum_value * (3.25+momentum_modifier) -- value multiplier, the amount of scrolling each point of momentum will do!

				if abs(momentum_value) > 0 then
					slider:SetValue(slider:GetValue() + momentum_value)
					-- print(slider:GetValue())
				end

			end)

			f.tab_section:SetScript("OnMouseWheel", function(self,event)
				if event == -1 then -- mouse wheel down
					-- print("MW DOWN!")
					table.insert(f.tab_section.momentum,{direction = "DOWN", ends = GetTime() + .65})
				elseif event == 1 then
					-- print("MW UP!")
					table.insert(f.tab_section.momentum,{direction = "UP", ends = GetTime() + .65})
				end
			end)

			--COLUMN 1
			f.c1 =  CreateFrame("Frame", f, BackdropTemplate)
			f.c1:SetParent(f)
			Mixin(f.c1, BackdropTemplateMixin)
			f.c1:SetBackdrop(backdrop)
			f.c1:SetBackdropColor(0,0,0,0)
			f.c1:SetHeight(175)
			f.c1:SetWidth(160)
			f.c1:SetPoint("BOTTOM",f,"BOTTOM",-25,20)

			f.c1.elements = {}
			f.c1.scroll_position = 1 -- default scroll position
			f.c1.input = {} -- holds recent scroll input history (each scroll tick, with the time it was sent allowing for our smooth scrolling to work.)
			f.c1.momentum = {} -- momentum of scrolling speed

			f.c1.VIEWABLE_HEIGHT = f.c1:GetHeight()
			f.c1.SCROLLABLE_HEIGHT = f.c1:GetHeight()
			f.c1.USED_HEIGHT = 0

			local extra_scrollable = (f.c1.SCROLLABLE_HEIGHT - f.c1:GetHeight() + 1) * scrollspace_mod

			CreateFrame("Frame"):SetScript("OnUpdate",function()
				if current_tab then
					extra_scrollable = (current_tab.c1.SCROLLABLE_HEIGHT - f.c1:GetHeight() + 1) * scrollspace_mod
				else
					extra_scrollable = (f.c1.SCROLLABLE_HEIGHT - f.c1:GetHeight() + 1) * scrollspace_mod
				end
				-- print(extra_scrollable)
				if extra_scrollable == scrollspace_mod then extra_scrollable = 1 end
			end)

			--slider to display current scroll position and allow for drag scrolling
			f.c1.slider = CreateFrame("Slider","SQC1SuperScroller",f.c1,"OptionsSliderTemplate")
			local slider2 = f.c1.slider
			Mixin(slider2, BackdropTemplateMixin)
			slider2:ClearAllPoints()
			slider2:SetPoint("RIGHT",f.c1,"RIGHT",0,0)
			slider2:SetFrameStrata("HIGH")
			slider2:SetOrientation('VERTICAL')
			slider2:SetBackdrop(slider_backdrop2)
			slider2:SetBackdropColor(0,0,0,.28)
			slider2:SetBackdropBorderColor(1,1,1,.6)
			slider2:SetThumbTexture(squid_slider_thumb)
			slider2.Thumb:SetHeight( (f.c1:GetHeight() / f.c1.SCROLLABLE_HEIGHT) * f.c1:GetHeight() )
			-- slider:SetThumbSize(2)
			slider2:SetWidth(8)
			slider2:SetHeight(f.c1:GetHeight())
			slider2:SetMinMaxValues(1,extra_scrollable)
			slider2:SetValue(f.c1.scroll_position)
			slider2:SetScript("OnValueChanged",function(self)
				f.c1.scroll_position = self:GetValue()
			end)
			slider2:SetValueStep(1)
			getglobal(slider2:GetName().."Low"):SetText("")
			getglobal(slider2:GetName().."High"):SetText("")

			slider2:SetScript("OnMouseDown",function()
				if current_tab then
					current_tab.adjust_scroll_position = nil
					current_tab.adjust_scroll_positionc2 = nil
				end
			end)

			CreateFrame("Frame"):SetScript("OnUpdate",function()
				if current_tab and (f.c1:GetHeight() / current_tab.c1.SCROLLABLE_HEIGHT) * f.c1:GetHeight() == f.c1:GetHeight() or not current_tab and (f.c1:GetHeight() / f.c1.SCROLLABLE_HEIGHT) * f.c1:GetHeight() == f.c1:GetHeight() then
					slider2:Hide()
				else
					slider2:Show()
				end
				if not slider2.checked_val or GetTime() - slider2.checked_val > 1 or recent_population and GetTime() - recent_population < .1 then
					if current_tab then
						slider2.Thumb:SetHeight( (f.c1:GetHeight() / current_tab.c1.SCROLLABLE_HEIGHT) * f.c1:GetHeight() )
					else
						slider2.Thumb:SetHeight( (f.c1:GetHeight() / f.c1.SCROLLABLE_HEIGHT) * f.c1:GetHeight() )
					end
					slider2:SetMinMaxValues(1,extra_scrollable)
					slider2.checked_val = GetTime()
				end
				if current_tab then
					if current_tab.adjust_scroll_position then
						if abs(slider2:GetValue() - current_tab.adjust_scroll_position) > 10 then
							local fps = GetFramerate()
							local duration = .175*fps
							local step = (current_tab.adjust_scroll_position - slider2:GetValue()) / duration
							slider2:SetValue(slider2:GetValue() + step)
						else
							current_tab.adjust_scroll_position = nil
						end
					end
					if f.c1.scroll_position ~= 1 then
						current_tab.scroll_position = f.c1.scroll_position
					end
				end
			end)

			-- custom squid super scroller :)
			f.c1:SetScript("OnUpdate",function(self)
				-- know if we're hovering the frame
				if MouseIsOver(self) then
					f.c1.hovering = true
				else
					f.c1.hovering = false
				end

				-- handle momentum
				local momentum_value = 0

				local last_direction
				local momentum_modifier = 0

				local time = GetTime()

				-- iterate backwards for removing tables and resetting momentum if the newest input is different than the previous
				for i = #f.c1.momentum, 1, -1 do

					local m = f.c1.momentum[i]
					local direction = m.direction
					local ends = m.ends

					local val = (ends - time) / .6

					if val < 0 then
						table.remove(f.c1.momentum,i)
					else
						last_direction = direction
						if i == 1 then -- newest input
							if direction == "DOWN" then
								if last_direction ~= "DOWN" then
									momentum_value = 0
									momentum_modifier = 0
									momentum_value = momentum_value + val
								else
									momentum_value = momentum_value + val
									momentum_modifier = momentum_modifier + 1
								end
							else
								if last_direction ~= "UP" then
									momentum_value = 0
									momentum_modifier = 0
									momentum_value = momentum_value - val
								else
									momentum_value = momentum_value - val
									momentum_modifier = momentum_modifier + 1
								end
							end
						else
							if direction == "DOWN" then
								momentum_value = momentum_value + val
								momentum_modifier = momentum_modifier + 1
							else
								momentum_value = momentum_value - val
								momentum_modifier = momentum_modifier + 1
							end
						end
					end

				end

				momentum_value = momentum_value * (4+momentum_modifier)-- value multiplier, the amount of scrolling each point of momentum will do!

				if abs(momentum_value) > 0 then
					slider2:SetValue(slider2:GetValue() + momentum_value)
				end

			end)

			f.c1:SetScript("OnMouseWheel", function(self,event)
				if event == -1 then -- mouse wheel down
					table.insert(f.c1.momentum,{direction = "DOWN", ends = GetTime() + .6})
				elseif event == 1 then
					table.insert(f.c1.momentum,{direction = "UP", ends = GetTime() + .6})
				end
				if current_tab then
					current_tab.adjust_scroll_position = nil
					current_tab.adjust_scroll_positionc2 = nil
				end
			end)

			--COLUMN 2
			f.c2 =  CreateFrame("Frame", f, BackdropTemplate)
			f.c2:SetParent(f)
			Mixin(f.c2, BackdropTemplateMixin)
			f.c2:SetBackdrop(backdrop)
			f.c2:SetBackdropColor(0,0,0,0)
			f.c2:SetHeight(175)
			f.c2:SetWidth(160)
			f.c2:SetPoint("BOTTOMRIGHT",f,"BOTTOMRIGHT",-5,20)

			f.c2.elements = {}
			f.c2.scroll_position = 1 -- default scroll position
			f.c2.input = {} -- holds recent scroll input history (each scroll tick, with the time it was sent allowing for our smooth scrolling to work.)
			f.c2.momentum = {} -- momentum of scrolling speed

			f.c2.VIEWABLE_HEIGHT = f.c2:GetHeight()
			f.c2.SCROLLABLE_HEIGHT = f.c2:GetHeight()
			f.c2.USED_HEIGHT = 0

			local extra_scrollable = (f.c2.SCROLLABLE_HEIGHT - f.c2:GetHeight() + 1) * scrollspace_mod
			CreateFrame("Frame"):SetScript("OnUpdate",function()
				if current_tab then
					extra_scrollable = (current_tab.c2.SCROLLABLE_HEIGHT - f.c2:GetHeight() + 1) * scrollspace_mod
				else
					extra_scrollable = (f.c2.SCROLLABLE_HEIGHT - f.c2:GetHeight() + 1) * scrollspace_mod
				end
				-- print(extra_scrollable)
				if extra_scrollable == scrollspace_mod then extra_scrollable = 1 end
			end)

			--slider to display current scroll position and allow for drag scrolling
			f.c2.slider = CreateFrame("Slider","SQc2SuperScroller",f.c2,"OptionsSliderTemplate")
			local slider3 = f.c2.slider
			Mixin(slider3, BackdropTemplateMixin)
			slider3:ClearAllPoints()
			slider3:SetPoint("RIGHT",f.c2,"RIGHT",0,0)
			slider3:SetFrameStrata("HIGH")
			slider3:SetOrientation('VERTICAL')
			slider3:SetBackdrop(slider_backdrop2)
			slider3:SetBackdropColor(0,0,0,.28)
			slider3:SetBackdropBorderColor(1,1,1,.6)
			slider3:SetThumbTexture(squid_slider_thumb)
			slider3.Thumb:SetHeight( (f.c2:GetHeight() / f.c2.SCROLLABLE_HEIGHT) * f.c2:GetHeight() )
			-- slider:SetThumbSize(2)
			slider3:SetWidth(8)
			slider3:SetHeight(f.c2:GetHeight())
			slider3:SetMinMaxValues(1,extra_scrollable)
			slider3:SetValue(f.c2.scroll_position)
			slider3:SetScript("OnValueChanged",function(self)
				f.c2.scroll_position = self:GetValue()
			end)
			slider3:SetValueStep(1)
			getglobal(slider3:GetName().."Low"):SetText("")
			getglobal(slider3:GetName().."High"):SetText("")

			CreateFrame("Frame"):SetScript("OnUpdate",function()
				if current_tab and (f.c2:GetHeight() / current_tab.c2.SCROLLABLE_HEIGHT) * f.c2:GetHeight() == f.c2:GetHeight() or not current_tab and (f.c2:GetHeight() / f.c2.SCROLLABLE_HEIGHT) * f.c2:GetHeight() == f.c2:GetHeight() then
					slider3:Hide()
				else
					slider3:Show()
				end
				if not slider3.checked_val or GetTime() - slider3.checked_val > 1 or recent_population and GetTime() - recent_population < .1 then
					if current_tab then
						slider3.Thumb:SetHeight( (f.c2:GetHeight() / current_tab.c2.SCROLLABLE_HEIGHT) * f.c2:GetHeight() )
					else
						slider3.Thumb:SetHeight( (f.c2:GetHeight() / f.c2.SCROLLABLE_HEIGHT) * f.c2:GetHeight() )
					end
					slider3:SetMinMaxValues(1,extra_scrollable)
					slider3.checked_val = GetTime()
				end
				if current_tab then
					if current_tab.adjust_scroll_positionc2 then
						-- if slider3:GetValue() ~= current_tab.adjust_scroll_positionc2 then
						-- 	slider3:SetValue(current_tab.adjust_scroll_positionc2)
						if abs(slider3:GetValue() - current_tab.adjust_scroll_positionc2) > 10 then
							local fps = GetFramerate()
							local duration = .175*fps
							local step = (current_tab.adjust_scroll_positionc2 - slider3:GetValue()) / duration
							slider3:SetValue(slider3:GetValue() + step)
						else
							current_tab.adjust_scroll_positionc2 = nil
						end
					end
					if f.c2.scroll_position ~= 1 then
						current_tab.scroll_positionc2 = f.c2.scroll_position
					end
				end
			end)

			-- custom squid super scroller :)
			f.c2:SetScript("OnUpdate",function(self)
				-- know if we're hovering the frame
				if MouseIsOver(self) then
					f.c2.hovering = true
				else
					f.c2.hovering = false
				end

				-- handle momentum
				local momentum_value = 0

				local last_direction

				local time = GetTime()

				local momentum_modifier = 0

				-- iterate backwards for removing tables and resetting momentum if the newest input is different than the previous
				for i = #f.c2.momentum, 1, -1 do

					local m = f.c2.momentum[i]
					local direction = m.direction
					local ends = m.ends

					local val = (ends - time) / .6

					if val < 0 then
						table.remove(f.c2.momentum,i)
					else
						last_direction = direction
						if i == 1 then -- newest input
							if direction == "DOWN" then
								if last_direction ~= "DOWN" then
									momentum_value = 0
									momentum_modifier = 0
									momentum_value = momentum_value + val
								else
									momentum_value = momentum_value + val
									momentum_modifier = momentum_modifier + 1
								end
							else
								if last_direction ~= "UP" then
									momentum_value = 0
									momentum_modifier = 0
									momentum_value = momentum_value - val
								else
									momentum_value = momentum_value - val
									momentum_modifier = momentum_modifier + 1
								end
							end
						else
							if direction == "DOWN" then
								momentum_value = momentum_value + val
								momentum_modifier = momentum_modifier + 1
							else
								momentum_value = momentum_value - val
								momentum_modifier = momentum_modifier + 1
							end
						end
					end

				end

				momentum_value = momentum_value * (4+momentum_modifier) -- value multiplier, the amount of scrolling each point of momentum will do!

				if abs(momentum_value) > 0 then
					slider3:SetValue(slider3:GetValue() + momentum_value)
				end

			end)

			f.c2:SetScript("OnMouseWheel", function(self,event)
				if event == -1 then -- mouse wheel down
					table.insert(f.c2.momentum,{direction = "DOWN", ends = GetTime() + .6})
				elseif event == 1 then
					table.insert(f.c2.momentum,{direction = "UP", ends = GetTime() + .6})
				end
			end)

			-- controls entire frame animation :)
			local dir

			--exit button not tied to tabs
			local exit = CreateFrame("Button",nil,f,nil,"UIPanelButtonTemplate")
			exit:SetText("x")
			exit:SetNormalTexture(squid_button)
			exit:GetNormalTexture():SetVertexColor(1,1,1,.4)
			exit:SetHighlightTexture(squid_button)
			exit:SetScript("OnClick",function(self)
				-- f:Hide()
				dir = -1
			end)
			exit:GetFontString():SetFont(sui_bold,15,nil)
			exit:GetFontString():SetTextColor(155/255, 155/255, 254/255, 1)
			exit:SetSize(28,25)
			exit:SetScript("OnEnter",function(self) self:GetFontString():SetTextColor(1,.2,.2,1) end)
			exit:SetScript("OnLeave",function(self) self:GetFontString():SetTextColor(155/255, 155/255, 254/255, 1) end)
			exit:SetPoint("TOPRIGHT",0,0)

			-- GET RID OF THIS SHIT
			--functions for elements in the gui

			local toggle_object_finder=function(self)
				SQUID.draw_objects = not SQUID.draw_objects
				squid_print(not SQUID.draw_objects and "|cffff6060Object finder disabled." or "Object finder enabled.")
				if SQUID.draw_objects then self:SetChecked(true) else self:SetChecked(false) end
			end
			local toggle_object_finder_lines=function(self)
				SQUID.draw_line_to_objects = not SQUID.draw_line_to_objects
				squid_print(not SQUID.draw_line_to_objects and "|cffff6060Lines to objects disabled." or "Lines to objects enabled.")
				if SQUID.draw_line_to_objects then self:SetChecked(true) else self:SetChecked(false) end
			end
			local toggle_object_finder_auto_interact=function(self)
				SQUID.auto_interact_objects = not SQUID.auto_interact_objects
				squid_print(not SQUID.auto_interact_objects and "|cffff6060Auto interact objects disabled." or "Auto interact objects enabled.")
				if SQUID.auto_interact_objects then self:SetChecked(true) else self:SetChecked(false) end
			end
			local auto_tricks_handler = function(self)
				SQUID.auto_tricks_of_the_trade = not SQUID.auto_tricks_of_the_trade
				squid_print(not SQUID.auto_tricks_of_the_trade and "|cffff6060Auto Tricks Disabled" or "Auto Tricks Enabled.")
			end
			local solo_mode_handler = function(self)
				SQUID.solo_mode = not SQUID.solo_mode
				squid_print(not SQUID.solo_mode and "|cffff6060Solo Mode Disabled" or "Solo Mode Enabled.")
			end
			local obj_onenter=function(self)
				local text = self:GetText()
				if text:gsub("%s+","") ~= "" then
					SQUID.obj_box_saved_text = text
					local split = {}
					for i=20,1,-1 do
						split[i] = select(i,strsplit(",",text))
						if split[i] then split[i] = strlower(split[i]):gsub("%s+","") end
						if split[i] == "" then table.remove(split,i) end
					end
					if #split > 0 then
						SQUID.objects_to_draw=split
					else
						self:SetText(self.text)
						SQUID.objects_to_draw={}
						SQUID.obj_box_saved_text = nil
					end
				else
					self:SetText(self.text)
					SQUID.objects_to_draw={}
					SQUID.obj_box_saved_text = nil
				end
				self:ClearFocus()
			end
			local obj_onescape=function(self)
				local text = self:GetText()
				if text:gsub("%s+","") ~= "" then
					SQUID.obj_box_saved_text = text
				else
					SQUID.obj_box_saved_text = nil
				end
				self:ClearFocus()
			end
			local mindelay_handler=function(self)
				if SQUID.min_mindelay > SQUID.max_mindelay then
					SQUID.min_mindelay = SQUID.max_mindelay
					squid_print("Please make sure min delay value is less than or equal to the max delay.")
					self:SetValue(SQUID.min_mindelay)
				end
				local v=math.floor(self:GetValue())
				SQUID.min_mindelay=v
				if SQUID.min_mindelay > SQUID.max_mindelay then
					SQUID.min_mindelay = SQUID.max_mindelay
					self:SetValue(SQUID.min_mindelay)
				end
			end
			local maxdelay_handler=function(self)
				if SQUID.max_mindelay < SQUID.min_mindelay then
					SQUID.max_mindelay = SQUID.min_mindelay
					squid_print("Please make sure max delay value is greater than or equal to the min delay.")
					self:SetValue(SQUID.max_mindelay)
				end
				local v=math.floor(self:GetValue())
				SQUID.max_mindelay=v
				if SQUID.max_mindelay < SQUID.min_mindelay then
					SQUID.max_mindelay = SQUID.min_mindelay
					self:SetValue(SQUID.max_mindelay)
				end
			end
			local min_combust_hp_handler=function(self)
				local v=math.floor(self:GetValue())
				SQUID.min_combust_hp=v
			end
			local autoblock_handler=function(self)
				local v=math.floor(self:GetValue())
				if v == 0 then
					getglobal(self:GetName().."Text"):SetText(self.text .. " - " .. "DISABLED")
				else
					getglobal(self:GetName().."Text"):SetText(self.text)
				end
				SQUID.auto_block=v
			end
			local auto_vial_handler = function(self)
				SQUID.auto_vial = not SQUID.auto_vial
				squid_print(not SQUID.auto_vial and "|cffff6060Auto Vial disabled" or "Auto Vial enabled.")
			end
			local auto_vial_handler_percent = function(self)
				local v=math.floor(self:GetValue())
				if v == 0 then
					getglobal(self:GetName().."Text"):SetText(self.text .. " - " .. "DISABLED")
				else
					getglobal(self:GetName().."Text"):SetText(self.text)
				end
				SQUID.auto_vial_percent=v
			end
			local block_after_caut_handler=function(self)
				SQUID.block_after_caut = not SQUID.block_after_caut
				squid_print(not SQUID.block_after_caut and "|cffff6060Block after cauterize disabled" or "Block after cauterize enabled.")
			end
			local object_finder_dist_handler=function(self)
				local v=math.floor(self:GetValue())
				SQUID.max_object_finder_dist=v
			end
			local glimmer_everything_handler=function(self)
				SQUID.glimmer_everything = not SQUID.glimmer_everything
			end
			local sound_disabler=function(self)
				SQUID.sounds_disabled = not SQUID.sounds_disabled
				squid_print(not SQUID.sounds_disabled and "|cffff6060Squid sounds disabled" or "Squid sounds enabled.")
			end
			local auto_burst_handler=function(self)
				SQUID.auto_burst = not SQUID.auto_burst
				squid_print(not SQUID.auto_burst and "|cffff6060Auto burst disabled" or "Auto burst enabled.")
			end
			local auto_bs_handler=function(self)
				SQUID.bs_cancel = not SQUID.bs_cancel
				squid_print(not SQUID.bs_cancel and "|cffff6060Auto bs cancel disabled" or "Auto bs cancel enabled.")
			end
			local spread_handler=function(self)
				SQUID.spread_mode = not SQUID.spread_mode
				squid_print(not SQUID.spread_mode and "|cffff6060Spread mode disabled" or "Spread mode enabled.")
			end
			local aura_mastery_handler=function(self)
				SQUID.auto_aura_mastery = not SQUID.auto_aura_mastery
				squid_print(not SQUID.auto_aura_mastery and "|cffff6060Aura mastery disabled" or "Aura mastery enabled.")
			end
			local wings_handler=function(self)
				SQUID.auto_wings = not SQUID.auto_wings
				squid_print(not SQUID.auto_wings and "|cffff6060Auto wings disabled" or "Auto wings enabled.")
			end
			local holy_avenger_handler=function(self)
				SQUID.auto_holy_avenger = not SQUID.auto_holy_avenger
				squid_print(not SQUID.auto_holy_avenger and "|cffff6060Auto holy avenger disabled" or "Auto holy avenger enabled.")
			end
			local unlock_squidalerts=function(self)
				Squid_Alerts_Unlocked = not Squid_Alerts_Unlocked
				squid_print(not Squid_Alerts_Unlocked and "|cffff6060Squid alerts locked." or "Squid alerts unlocked.")
			end
			local auto_cc_handler=function(self)
				SQUID.auto_cc = not SQUID.auto_cc
				squid_print(not SQUID.auto_cc and "|cffff6060Auto cc disabled" or "Auto cc enabled.")
			end
			local auto_leap_handler=function(self)
				SQUID.auto_leap = not SQUID.auto_leap
				squid_print(not SQUID.auto_leap and "|cffff6060Auto leap disabled" or "Auto leap enabled.")
			end
			local auto_charge_handler=function(self)
				SQUID.auto_charge = not SQUID.auto_charge
				squid_print(not SQUID.auto_charge and "|cffff6060Auto charge disabled" or "Auto charge enabled.")
			end
			local auto_chains_handler=function(self)
				SQUID.auto_chains = not SQUID.auto_chains
				squid_print(not SQUID.auto_chains and "|cffff6060Auto chains disabled" or "Auto chains enabled.")
			end
			local anon_handler=function(self)
				SQUID.anon = not SQUID.anon
				squid_print(not SQUID.anon and "|cffff6060Anonymization Disabled" or "Anonymization Enabled")
				ReloadUI()
			end
			local flag_pick_handler=function(self)
				SQUID.flag_pick = not SQUID.flag_pick
				squid_print(not SQUID.flag_pick and "|cffff6060Flag Pick Disabled" or "Flag Pick Enabled")
			end
			local auto_paladin_handler=function(self)
				SQUID.auto_paladin = not SQUID.auto_paladin
				squid_print(not SQUID.auto_paladin and "|cffff6060Auto Paladin Disabled" or "Auto Paladin Enabled")
			end
			local auto_fel_rush_handler=function(self)
				SQUID.AutoFelRush = not SQUID.AutoFelRush
				squid_print(not SQUID.AutoFelRush and "|cffff6060Auto Felrush Disabled" or "Auto Felrush Enabled")
			end
			local disable_while_visible_handler=function(self)
				SQUID.disable_while_visible = not SQUID.disable_while_visible
				squid_print(not SQUID.disable_while_visible and "|cffff6060Smart Mode Disabled" or "Smart Mode Enabled")
			end
			local alerts_enabled_handler=function(self)
				SQUID.awareness_alerts_enabled = not SQUID.awareness_alerts_enabled
				squid_print(not SQUID.awareness_alerts_enabled and "|cffff6060Awareness Alerts Disabled" or "Awareness Alerts Enabled")
			end
			local lines_enabled_handler=function(self)
				SQUID.awareness_lines_enabled = not SQUID.awareness_lines_enabled
				squid_print(not SQUID.awareness_lines_enabled and "|cffff6060Awareness Lines Disabled" or "Awareness Lines Enabled")
			end
			local good_line_handler=function(self)
				SQUID.good_line_enabled = not SQUID.good_line_enabled
				squid_print(not SQUID.good_line_enabled and "|cffff6060Good Line Disabled" or "Good Line Enabled")
			end
			local stop_to_cc_handler=function(self)
				SQUID.stop_to_cc = not SQUID.stop_to_cc
				squid_print(not SQUID.stop_to_cc and "|cffff6060Movement Stopping for CC Disabled" or "Movement Stopping for CC Enabled")
			end
			local positioning_help_handler=function(self)
				SQUID.positioning_help = not SQUID.positioning_help
				squid_print(not SQUID.positioning_help and "|cffff6060Positioning Draws Disabled" or "Positioning Draws Enabled")
			end
			local auto_juke_handler=function(self)
				SQUID.auto_juke = not SQUID.auto_juke
				squid_print(not SQUID.auto_juke and "|cffff6060Fake casting disabled" or "Fake casting enabled")
			end
			local min_jukedelay_handler=function(self)
				if SQUID.min_jukedelay > SQUID.max_jukedelay then
					SQUID.min_jukedelay = SQUID.max_jukedelay
					squid_print("Please make sure min delay value is less than or equal to the max delay.")
					self:SetValue(SQUID.min_jukedelay)
				end
				local v=math.floor(self:GetValue())
				SQUID.min_jukedelay=v
				if SQUID.min_jukedelay > SQUID.max_jukedelay then
					SQUID.min_jukedelay = SQUID.max_jukedelay
					self:SetValue(SQUID.min_jukedelay)
				end
			end
			local max_jukedelay_handler=function(self)
				if SQUID.max_jukedelay < SQUID.min_jukedelay then
					SQUID.max_jukedelay = SQUID.min_jukedelay
					squid_print("Please make sure max delay value is greater than or equal to the min delay.")
					self:SetValue(SQUID.max_jukedelay)
				end
				local v=math.floor(self:GetValue())
				SQUID.max_jukedelay=v
				if SQUID.max_jukedelay < SQUID.min_jukedelay then
					SQUID.max_jukedelay = SQUID.min_jukedelay
					self:SetValue(SQUID.max_jukedelay)
				end
			end
			local max_juke_attempts_handler=function(self)
				local v=math.floor(self:GetValue())
				SQUID.max_juke_attempts=v
			end
			local auto_queue_handler=function(self)
				SQUID.auto_queue = not SQUID.auto_queue
				squid_print(not SQUID.auto_queue and "|cffff6060Auto queue disabled" or "Auto queue enabled")
			end
			local mmr_tank_handler=function(self)
				SQUID.tank_mmr = not SQUID.tank_mmr
				squid_print(not SQUID.tank_mmr and "|cffff6060MMR Tank Disabled" or "MMR Tank Enabled")
			end
			local cap_bot_handler=function(self)
				SQUID.cap_bot = not SQUID.cap_bot
				squid_print(not SQUID.cap_bot and "|cffff6060Arena bot disabled" or "Arena bot enabled")
			end
			local auto_combust_handler=function(self)
				SQUID.auto_combust = not SQUID.auto_combust
				squid_print(not SQUID.auto_combust and "|cffff6060Auto Combustion disabled" or "Auto Combustion enabled")
				if AlertFrames_Anchor then
					if SQUID.auto_combust then
						Squid_Alert("|cFFdecbebAuto Combustion Enabled",nil,nil,.25,190319)
					else
						Squid_Alert("|cFFca2aa5Auto Combustion Disabled",nil,nil,.25,190319)
					end
				end
			end
			local rare_finder_handler=function(self)
				SQUID.rare_finder = not SQUID.rare_finder
				squid_print(not SQUID.rare_finder and "|cffff6060Rare finder disabled" or "Rare finder enabled")
			end
			local kill_healers_handler=function(self)
				SQUID.kill_healers = not SQUID.kill_healers
				squid_print(not SQUID.kill_healers and "|cffff6060Run at healers disabled" or "Run at healers enabled - yee haw")
			end
			local only_skirms_handler=function(self)
				SQUID.only_skirms = not SQUID.only_skirms
				squid_print(not SQUID.only_skirms and "|cffff6060Only skirms disabled" or "Only skirms enabled")
			end
			local only_bgs_handler=function(self)
				SQUID.only_bgs = not SQUID.only_bgs
				squid_print(not SQUID.only_bgs and "|cffff6060Battleground queues disabled" or "Battleground queues enabled")
			end
			local only_cc_healers_handler=function(self)
				SQUID.only_cc_healers = not SQUID.only_cc_healers
				squid_print(not SQUID.only_cc_healers and "|cffff6060CC Only Healers Disabled" or "CC Only Healers Enabled")
			end
			local toggle_flash_handler=function()
				SQUID.toggle_flash = not SQUID.toggle_flash
				squid_print(not SQUID.toggle_flash and "|cffff6060Toggle flash disabled" or "Toggle flash enabled")
			end
			local auto_target_handler=function()
				SQUID.auto_target = not SQUID.auto_target
				squid_print(not SQUID.auto_target and "|cffff6060Auto Targeting Disabled" or "Auto Targeting Enabled")
			end
			local mouseover_names_handler=function()
				SQUID.mouseover_names = not SQUID.mouseover_names
				squid_print(not SQUID.mouseover_names and "|cffff6060Mouseover names disabled" or "Mouseover names enabled")
			end
			local track_quests_handler=function()
				SQUID.track_quests = not SQUID.track_quests
				squid_print(not SQUID.track_quests and "|cffff6060Track quests disabled" or "Track quests enabled")
			end
			local scorch_filler_handler=function()
				SQUID.scorch_filler = not SQUID.scorch_filler
				squid_print(not SQUID.scorch_filler and "|cffff6060Scorch filler disabled" or "Scorch filler enabled")
			end
			local auto_temp_handler=function()
				SQUID.auto_temp = not SQUID.auto_temp
				squid_print(not SQUID.auto_temp and "|cffff6060Auto temp disabled" or "Auto temp enabled")
			end
			local streaming_mode_handler=function()
				SQUID.streaming_mode = not SQUID.streaming_mode
				squid_print(not SQUID.streaming_mode and "|cffff6060Streaming mode disabled" or "Streaming mode enabled")
			end
			local squid_line_scale_handler=function(self)
				local v=math.floor(self:GetValue())
				v=v/100
				SQUID.line_scale=v
			end

			tabs = f.tab_section.tabs

			--Create and populate tabs
			local tabname
			local tab

			--Information Tab
			tabname = "Information"
			for i=1,#tabs do if tabs[i].name == tabname then
				tab = tabs[i]
			end end

			-- testing, want to add patch notes / update information or any notes for customers here :)
			-- create_checkbox({tab=tab,column=1,text="Disable Sounds",tooltip="Disable all sounds from squid's alert system.\n\nWarning: This may result in reduced fun.",var=SQUID.sounds_disabled,func=sound_disabler})
			-- create_checkbox({tab=tab,column=1,text="Incognito Mode",tooltip="Useful for hiding the fact you're using Squid to anyone watching your gameplay.\n\n - Disables on-screen drawings and alerts from Squid\n\n - Keeps the script from casting AoE spells outside of your camera view\n\n - Smart AFK detection will auto-pause the rotation when AFK or tabbed out\n\n - Enables other experimental humanization features\n\nI also recommend hiding cursor on your streaming software if possible.",var=SQUID.streaming_mode,func=streaming_mode_handler})

			--General Tab
			tabname = "General"
			for i=1,#tabs do if tabs[i].name == tabname then
				tab = tabs[i]
			end end

			-- test elements for new settings saving method
			-- create_slider({tab=tab,column=1,text="How many foods?",tooltip="Let us know how many foods you want.",min=1,max=6000,new_var="How Many Foods",value=1000,step=1,onvaluechanged=set_squid_var})
			-- create_checkbox({tab=tab,column=1,text="Disable Sounds",tooltip="Disable all sounds from squid's alert system.\n\nWarning: This may result in reduced fun.",new_var="Disable Sounds",func=set_squid_var})

			-- --mindelaytime sliders
			-- create_header({tab=tab,column=1,text="Real Settings"})

			create_checkbox({tab=tab,column=1,text=locale == "zhCN" and "å…³é—­æ’ä»¶æç¤ºéŸ³" or "Disable Sounds",tooltip="Disable all sounds from squid's alert system.\n\nWarning: This may result in reduced fun.",var=SQUID.sounds_disabled,func=sound_disabler})
			create_checkbox({tab=tab,column=1,text="Incognito Mode",tooltip="Useful for hiding the fact you're using Squid to anyone watching your gameplay.\n\n - Disables on-screen drawings and alerts from Squid\n\n - Keeps the script from casting AoE spells outside of your camera view\n\n - Smart AFK detection will auto-pause the rotation when AFK or tabbed out\n\n - Enables other experimental humanization features\n\nI also recommend hiding cursor on your streaming software if possible.",var=SQUID.streaming_mode,func=streaming_mode_handler})
			-- create_checkbox({tab=tab,text="Paranoid Mode",tooltip="More expiramental features to simulate human-like activity even to those watching your gameplay.\n\n - Keeps the script from using AoE on targets outside of your camera view, among other features",var=SQUID.streaming_mode,func=streaming_mode_handler})
			create_checkbox({tab=tab,column=1,text="Unlock Alert Frames",tooltip="Unlocks Project LarryExitScam's alert frames and displays test alerts.\n\nWith this you can move Big &amp; Small alerts wherever you want\n\nJust drag the anchors to move them!",var=Squid_Alerts_Unlocked,func=unlock_squidalerts})
			create_checkbox({tab=tab,column=1,text="Anonymize Names",tooltip="Anonymize your name, and your party member's names.\n\nUseful for streaming or recording gameplay with squid active.\n\nReloads UI automatically, so be prepared for that.",var=SQUID.anon,func=anon_handler})
			create_checkbox({tab=tab,column=1,text="Grab Flags",tooltip="Quickly auto pick flags and mine carts in BGs.",var=SQUID.flag_pick,func=flag_pick_handler,default=true})
			create_checkbox({tab=tab,column=1,text="Toggle Flash",tooltip="Any toggles are accompanied by an animation around the edge of your screen\n\nGreen / red based on whether you enabled / disabled.",var=SQUID.toggle_flash,func=toggle_flash_handler})
			create_checkbox({tab=tab,column=1,text="Auto Target",tooltip = "Will Automatically acquire a target upon target death.",var=SQUID.auto_target,func=auto_target_handler,default=false})

			-- create_header({tab=tab,column=1,text="Test Elements"})

			-- create_checkbox({tab=tab,column=1,text="For Tests",tooltip="This is a box that will do nothing",func=printobj})
			-- create_checkbox({tab=tab,column=1,text="Only tests",tooltip="This is a box that will do nothing",func=printobj})
			-- create_checkbox({tab=tab,column=1,text="That's all",tooltip="This is a box that will do nothing",func=printobj})
			-- create_checkbox({tab=tab,column=1,text="Simply Tests",tooltip="This is a box that will do nothing",func=printobj})
			-- create_header({tab=tab,column=1,text="More Tests :]",color={155/255,165/255,255/255,1}})
			-- create_checkbox({tab=tab,column=1,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})
			-- create_slider({tab=tab,column=1,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
			-- create_checkbox({tab=tab,column=1,text="Extra Large Test Box",tooltip="This is a box that will do nothing",func=printobj})
			-- create_checkbox({tab=tab,column=1,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})
			-- create_header({tab=tab,column=1,text="Deez Sliders",color={155/255,165/255,255/255,1}})
			-- create_slider({tab=tab,column=1,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
			-- create_slider({tab=tab,column=1,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
			-- create_slider({tab=tab,column=1,text="Testicle Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})

			-- create_header({tab=tab,column=2,text="Test Elements"})
			-- create_checkbox({tab=tab,column=2,text="For Tests",tooltip="This is a box that will do nothing",func=printobj})

			-- create_checkbox({tab=tab,column=2,text="Only tests",tooltip="This is a box that will do nothing",func=printobj})
			-- create_checkbox({tab=tab,column=2,text="That's all",tooltip="This is a box that will do nothing",func=printobj})
			-- create_checkbox({tab=tab,column=2,text="Simply Tests",tooltip="This is a box that will do nothing",func=printobj})
			-- -- create_header({tab=tab,column=2,text="Test Elements :]",color={175/255,200/255,255/255,1}})

			-- create_checkbox({tab=tab,column=2,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})

			-- create_slider({tab=tab,column=2,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
			-- create_checkbox({tab=tab,column=2,text="Extra Large Test Box",tooltip="This is a box that will do nothing",func=printobj})
			-- create_checkbox({tab=tab,column=2,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})
			-- create_header({tab=tab,column=2,text="Deez Sliders"})
			-- create_slider({tab=tab,column=2,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
			-- create_slider({tab=tab,column=2,text="Test Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})
			-- create_slider({tab=tab,column=2,text="Testicle Slider",tooltip="This a test slider",low="0",high="69",min=0,max=69,var=69,value=69,step=1,onvaluechanged=print})

			-- create_checkbox({tab=tab,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})
			-- local function set_keybind(self,keybind)
			-- 	SetBinding(self:GetText(),keybind)
			-- end

			local function find_spec_tab(specName)
				for i=1,#tabs do if tabs[i].name == specName then
					return tabs[i]
				end end
			end

			-- --Class Tab
			local function first_upper(str)
				return (str:gsub("^%l", string.upper))
			end
			local class = first_upper(strlower(select(2,UnitClass("player"))))
			if class == "Demonhunter" then
				class = "Demon Hunter"
			elseif class == "Deathknight" then
				class = "Death Knight"
			end
			tabname = UnitClass("player")

			for i=1,#tabs do if tabs[i].name == tabname then
				tab = tabs[i]
			end end

			-- spec tab update function
			local function on_spec_changed(self, event)
				if event == "PLAYER_SPECIALIZATION_CHANGED" then
					local spec = GetSpecialization()
					local specName = select(2, GetSpecializationInfo(spec))
					sort_tabs(specName)
				end
			end

			--class specific settings
			if class == "Monk" then
				-- create_checkbox({tab=tab,text="Monk Testa",tooltip="This monk test lol",func=printobj})
				-- create_checkbox({tab=tab,text="Test Box",tooltip="This is a box that will do nothing",func=printobj})
			elseif class == "Warrior" then
				if locale == "zhCN" then
					create_checkbox({tab=tab,column=1,text="è‡ªåŠ¨çˆ†å‘",tooltip="è‡ªåŠ¨ä½¿ç”¨çˆ†å‘æŠ€èƒ½",var=SQUID.auto_burst,func=auto_burst_handler})
				else
					create_checkbox({tab=tab,column=1,text="Auto Burst",tooltip="Automate usage of burst (Warbreaker / Avatar)",var=SQUID.auto_burst,func=auto_burst_handler})
					create_checkbox({tab=tab,column=1,text="Auto Charge",tooltip="Automate usage of charge",var=SQUID.auto_charge,func=auto_charge_handler,default=true})
					create_checkbox({tab=tab,column=1,text="Auto Leap",tooltip="Automate usage of leap",var=SQUID.auto_leap,func=auto_leap_handler,default=true})
					create_checkbox({tab=tab,column=1,text="Cancel Bladestorm",tooltip="Automatically cancels bladestorm to interrupt",var=SQUID.bs_cancel,func=auto_bs_handler,default=true})
				end
			elseif class == "Rogue" then

				-- General Rogue Tab
				create_checkbox({tab=tab,column=1,text="Auto Tricks",tooltip="Auto Tricks when you have aggro.",var=SQUID.auto_tricks_of_the_trade,func=auto_tricks_handler, default=true})
				create_checkbox({tab=tab,column=1,text="Auto Vial",tooltip="Auto Vial at % HP",var=SQUID.auto_vial,func=auto_vial_handler, default=true})
				create_slider({tab=tab,column=1,text="Min HP%",tooltip="Min HP% to use Crimson Vial",low="0",high="100",min=0,max=100,var=SQUID.auto_vial_percent,value=50,step=1,onvaluechanged=auto_vial_handler_percent})

				-- Subtlety Tab
				local tab = find_spec_tab("Subtlety")

				-- Subtlety PvP Header
				create_header({tab=tab,column=1,text="PvP Settings"})

				-- Visuals Subheader
				create_subheader({tab=tab,column=1,text="Visuals"})
				local under_subheader = true
				create_checkbox({tab=tab,column=1,text="Backstab Drawing",tooltip="Draws a small arc behind your enemy target for +20% backstab damage.\n\nDrawing will enlarge during sap for easy rupture to the side.",new_var="Backstab Drawing",func=set_squid_var,default=true,under_subheader=under_subheader})

				-- Execute Subheader
				create_subheader({tab=tab,column=1,text="Execute"})
				create_checkbox({tab=tab,column=1,text="Auto Execute",tooltip="Automatically calculates and performs a lethal execution when possible.\n\nWill use cooldowns and step if needed to perform executes.",new_var="SubPvP - Execute",func=set_squid_var,default=true,under_subheader=under_subheader})
				create_checkbox({tab=tab,column=1,text="Don't Step",tooltip="Won't use step for executes, instead only performing them on targets in melee range.",new_var="SubPvP - No Execute Step",func=set_squid_var,default=false,under_subheader=under_subheader})
				create_slider({tab=tab,column=1,text="Execute GCDs",tooltip="Number of GCDS to calculate for available execute damage.\n\nLower is more successful because the enemy will have less time to react.\nHigher will result in more frequent executes on targets with more HP.",min=1,max=2,new_var="SubPvP - Execute GCDs",value=1,step=1,onvaluechanged=set_squid_var,under_subheader=under_subheader})

			elseif class == "Paladin" then
				if locale == "zhCN" then
					create_checkbox({tab=tab,column=1,text="PvP Healing",tooltip="Automatically uses healing abilities in PvP.\r\nThis is useful if you're not a very experienced hpal.",var=SQUID.auto_paladin,func=auto_paladin_handler})
					create_checkbox({tab=tab,column=1,text="Raid Mode",tooltip="Prioritize glimmers on everything in the raid, regardless of hp.\n\Definitely use this in raids, NOT in Mythic+\n\Not recommended in arenas.\r\nIf you don't have glimmer trait, go get 3 of them.",var=SQUID.glimmer_everything,func=glimmer_everything_handler,default=true})
					create_checkbox({tab=tab,column=1,text="Aura Mastery",tooltip="Automatically uses aura mastery in PvE based on raid hp.",var=SQUID.auto_aura_mastery,func=aura_mastery_handler,default=true})
					create_checkbox({tab=tab,column=1,text="Avenging Wrath",tooltip="Automatically uses wings in PvE based on raid hp.",var=SQUID.auto_wings,func=wings_handler,default=true})
					create_checkbox({tab=tab,column=1,text="Holy Avenger",tooltip="Automatically uses Holy Avenger in PvE based on raid hp.",var=SQUID.auto_holy_avenger,func=holy_avenger_handler,default=true})
				else
					create_checkbox({tab=tab,column=1,text="PvP Healing",tooltip="Automatically uses healing abilities in PvP.\r\nThis is useful if you're not a very experienced hpal.",var=SQUID.auto_paladin,func=auto_paladin_handler})
					create_checkbox({tab=tab,column=1,text="Raid Mode",tooltip="Prioritize glimmers on everything in the raid, regardless of hp.\n\Definitely use this in raids, NOT in Mythic+\n\Not recommended in arenas.\r\nIf you don't have glimmer trait, go get 3 of them.",var=SQUID.glimmer_everything,func=glimmer_everything_handler,default=true})
					create_checkbox({tab=tab,column=1,text="Aura Mastery",tooltip="Automatically uses aura mastery in PvE based on raid hp.",var=SQUID.auto_aura_mastery,func=aura_mastery_handler,default=true})
					create_checkbox({tab=tab,column=1,text="Avenging Wrath",tooltip="Automatically uses wings in PvE based on raid hp.",var=SQUID.auto_wings,func=wings_handler,default=true})
					create_checkbox({tab=tab,column=1,text="Holy Avenger",tooltip="Automatically uses Holy Avenger in PvE based on raid hp.",var=SQUID.auto_holy_avenger,func=holy_avenger_handler,default=true})
				end
			elseif class == "Druid" then
				if locale == "zhCN" then
					create_checkbox({tab=tab,column=1,text="è‡ªåŠ¨çˆ†å‘",tooltip="è‡ªåŠ¨ä½¿ç”¨çˆ†å‘æŠ€èƒ½",var=SQUID.auto_burst,func=auto_burst_handler,default=true})
					create_checkbox({tab=tab,column=1,text="AOEæ¨¡å¼",tooltip="åœ¨PVPé‡Œé¢,ç»™æ‰€æœ‰åœ¨è¿‘æˆ˜èŒƒå›´å†…çš„çŽ©å®¶ç›®æ ‡ä¸Šæµè¡€,è¿˜ä¼šå¼ºè¡Œç»™ä½ çš„ç›®æ ‡(ä¸æ˜¯çŽ©å®¶, æ¯”å¦‚å® ç‰©)ä¸Šæµè¡€ã€‚",var=SQUID.spread_mode,func=spread_handler})
				else
					create_checkbox({tab=tab,column=1,text="Auto Burst",tooltip="Automate usage of berserk / incarn\n\This is done so in an intelligent way\n\Checks for CC on healer, and ensures a TF will be ready",var=SQUID.auto_burst,func=auto_burst_handler,default=true})
					create_checkbox({tab=tab,column=1,text="Spread Mode",tooltip="Spread bleeds to enemies in range\n\Only bleeds players (unless targeted) in pvp\n\This mode is not recommended in most cases.",var=SQUID.spread_mode,func=spread_handler})
				end
				--add auto burst for druid - SQUID.auto_burst
				--add spread for druid - SQUID.spread_mode
			elseif class == "Mage" then

				create_header({tab=tab,column=1,text="PvP Settings"})

				create_subheader({tab=tab,column=1,text="Crowd Control"})

				local under_subheader = true
				create_checkbox({tab=tab,column=1,text="Auto CC",tooltip="Automate usage of CC abilities (Ring of Frost, DB, Sheep)\n\nDoes an excellent job getting crowd control off DR consistently.\n\n(Recommend leaving this ENABLED for 99% of players)",new_var="Auto CC",func=set_squid_var,default=true,under_subheader=under_subheader})
				create_checkbox({under_subheader=under_subheader,tab=tab,column=1,text="Stop Moving To Cast CC",tooltip="Will force stop movement to cast CC (Ring of Frost / Sheep)\n\nHelps tremendously if you're not always aware of DRs and how the script plays.",var=SQUID.stop_to_cc,func=stop_to_cc_handler})
				create_checkbox({under_subheader=under_subheader,tab=tab,column=1,text="Only CC Healers",tooltip="Disable auto cc on off dps, and only cc healers.",var=SQUID.only_cc_healers,func=only_cc_healers_handler})

				create_subheader({tab=tab,column=1,text="Defensives"})
				create_slider({under_subheader=under_subheader,tab=tab,column=1,text="Auto Block",tooltip="- LEAVE AT 0% TO DISABLE -\n\nAuto-Block is always DISABLED by default.\n\nIf you wish to have the mage script auto-block for you:\n\nSet slider to HP percentage that you want it to use block (1-50%)",low="OFF",high="50",min=0,max=50,var=SQUID.auto_block,value=0,step=1,onvaluechanged=autoblock_handler})
				create_checkbox({under_subheader=under_subheader,tab=tab,column=1,text="Only After Caut",tooltip="Script will only auto-block after cauterize procs.\n\nAuto block will only happen if the slider is set above zero.",var=SQUID.block_after_caut,func=block_after_caut_handler})
				create_checkbox({under_subheader=under_subheader,tab=tab,column=1,text="Auto Alter Time",tooltip="Automatically use alter time",var=SQUID.auto_temp,func=auto_temp_handler,default=true})

				create_subheader({tab=tab,column=1,text="Fake Casting"})
				create_checkbox({under_subheader=under_subheader,tab=tab,text="Fake Cast",tooltip="Enables automatic fake-casting of cc abilities\n\nThe script will attempt 2-3 jukes if the enemy can interrupt you\n\nAdjust the sliders to change the range of cast % in which it will attempt a juke.\n\nThis can be useful but is sometimes not necessary since you have 3 spell schools, and can blink to avoid interrupts.",var=SQUID.auto_juke,func=auto_juke_handler})
				create_slider({under_subheader=under_subheader,tab=tab,text="Minimum % Cast to Fake",tooltip="The EARLIEST percentage into a cast which the script will attempt to fake cast.\n\nSetting this value higher will result in less quick stopcasts.\n\nThe larger the difference between these values, the less predictable your jukes will be.",low="1",high="80",min=1,max=80,var=SQUID.min_jukedelay,value=1,step=1,onvaluechanged=min_jukedelay_handler})
				create_slider({under_subheader=under_subheader,tab=tab,text="Maximum % Cast to Fake",tooltip="The LATEST percentage into a cast which the script will attempt to fake cast.\n\nSetting this value lower will result in quicker stopcasts.\n\nThe larger the difference between these values, the less predictable your jukes will be.",low="5",high="99",min=5,max=99,var=SQUID.max_jukedelay,value=60,step=1,onvaluechanged=max_jukedelay_handler})
				create_slider({under_subheader=under_subheader,tab=tab,text="Max Fake Cast Attempts",tooltip="The MOST fake casts the script will attempt before just finishing the cast.\n\nSet this value lower to spend less time fake casting.",low="1",high="8",min=1,max=8,var=SQUID.max_juke_attempts,value=2,step=1,onvaluechanged=max_juke_attempts_handler})

				create_subheader({tab=tab,column=1,text="Misc"})
				create_checkbox({under_subheader=under_subheader,tab=tab,text="Scorch Filler",tooltip="Cast scorch as a filler in PvP rotation.\n\nDisabling this is recommended for more experienced mages.",var=SQUID.scorch_filler,func=scorch_filler_handler,default=true})
				create_checkbox({tab=tab,column=1,text="Auto Food",tooltip="Make food automatically",new_var="Auto Food",func=set_squid_var,default=true,under_subheader=under_subheader})

				-- Crowd Control Header

				-- create_checkbox({tab=tab,text="Spread Mode",tooltip="Spread bleeds to enemies in range\n\Only bleeds players (unless targeted) in pvp",var=SQUID.spread_mode,func=spread_handler})
			elseif class == "Death Knight" then
				create_checkbox({tab=tab,text="Chains Peel",tooltip="Automate usage of Chains of Ice to slow melee dps.",var=SQUID.auto_chains,func=auto_chains_handler,default=true})
			elseif class == "Demon Hunter" then
				create_checkbox({tab=tab,text="Auto Fel Rush",tooltip="Automate Fel Rush as a gapcloser when moving towards your target.",var=SQUID.AutoFelRush,func=auto_fel_rush_handler,default=true})
			end

			--clear selected tab
			tab = nil

			--Utility Tab
			tabname = "Utility"
			for i=1,#tabs do if tabs[i].name == tabname then
				tab=tabs[i]
			end end

			create_header({tab=tab,column=1,text="Humanization"})
			create_slider({tab=tab,column=1,text=locale == "zhCN" and "æœ€å°å»¶è¿Ÿ" or "Min Delay",tooltip="This is Squid's 'General' humanization setting.\n\nYou can set a delay (in milliseconds) on bot-like actions.\nBot-like actions include interrupts, totem stomp, dispel, etc.\n\n- For best humanization:\nMin should be at least average human reaction time (120-200)\nMax should be as high as possible (300-600)\n\nThe delay is constantly randomized between your 2 selections.\n\n*Note* Interrupts are 99% of cast until 1-4 jukes are attempted.",low="0",high="600",min=0,max=600,var=SQUID.min_mindelay,value=160,step=1,onvaluechanged=mindelay_handler})
			create_slider({tab=tab,column=1,text=locale == "zhCN" and "æœ€å¤§å»¶è¿Ÿ" or "Max Delay",tooltip="This is Squid's 'General' humanization setting.\n\nYou can set a delay (in milliseconds) on bot-like actions.\nBot-like actions include interrupts, totem stomp, dispel, etc.\n\n- For best humanization:\nMin should be at least average human reaction time (120-200)\nMax should be as high as possible (300-600)\n\nThe delay is constantly randomized between your 2 selections.\n\n*Note* Interrupts are 99% of cast until 1-4 jukes are attempted.",low="0",high="600",min=0,max=600,var=SQUID.max_mindelay,value=310,step=1,onvaluechanged=maxdelay_handler})
			create_slider({tab=tab,column=1,text="Stomp Delay",tooltip="Add an ADDITIONAL delay to totem / psyfiend / banner stomping.\n\nThe random delay from the above sliders already affects totem stomps.\n > This ADDS to that delay.\n\ne.g, 200ms minDelay + 200ms totemDelay = 400ms totemDelay",min=0,max=200,new_var="Totem Stomp Delay",value=0,step=1,onvaluechanged=set_squid_var})

			--PvE Tab
			tabname = "PvE"
			for i=1,#tabs do if tabs[i].name == tabname then
				tab=tabs[i]
			end end

			--general PvE settings

			--class specific PvE settings
			if class == "Monk" then

			elseif class == "Warrior" then

			elseif class == "Paladin" then

			elseif class == "Druid" then

			elseif class == "Mage" then

				--auto combustion checkbox
				-- create_checkbox({tab=tab,text="Auto Combust",tooltip="Toggle automatic usage of Lucid Dreams + Combustion\n\nRotation will pool 1 rune of power, lucid dreams and meteor for combustion.",var=SQUID.auto_combust,func=auto_combust_handler,default=true})

				--auto combust hp slider
				create_slider({tab=tab,text="Combust Min HP",tooltip="Minimum HP of target to auto combust",low="100",high="200000",min=100,max=2000000,var=SQUID.min_combust_hp,value=40000,step=1,onvaluechanged=min_combust_hp_handler})
				create_checkbox({tab=tab,text="Solo Mode",tooltip="- PvE Solo Content Mode\n\nThe script will stop pooling for combust when not in instanced content.\n\nThis makes most solo content like questing much smoother.",var=SQUID.solo_mode,func=solo_mode_handler,default=true})
				-- create_checkbox({tab=tab,text="Disable World PvP",tooltip="Stop squid from changing to PvP mode in open world.",var=SQUID.pve_only,func=pve_only_handler})

			elseif class == "Death Knight" then

			elseif class == "Demon Hunter" then

			end

			--clear selected tab
			tab = nil

			--objects tab
			tabname = "Objects"
			for i=1,#tabs do if tabs[i].name == tabname then
				tab=tabs[i]
			end end

			create_checkbox({tab=tab,text="Draw Line",tooltip="Draws a line to the objects, helping you find them.\n\This may be annoying if you're tracking a lot of objects.",func=toggle_object_finder_lines,var=SQUID.draw_line_to_objects})
			create_checkbox({tab=tab,text="Rare Finder",tooltip="Distinguishable waypoint + line to any rare mobs.\n\nWill draw the line regardless of line setting and objects list",func=rare_finder_handler,var=SQUID.rare_finder})
			create_checkbox({tab=tab,text="Show Names on Mouseover",tooltip="Hides names and only shows waypoints until you mouseover them.\n\nThis can reduce screen clutter a LOT.",func=mouseover_names_handler,var=SQUID.mouseover_names,default=true})
			create_checkbox({tab=tab,text="Auto Interact",tooltip="Automatically interacts with objects you've defined.\n\This is useful for farming herbs when you can do it on your mount.",func=toggle_object_finder_auto_interact,var=SQUID.auto_interact_objects})

			create_slider({tab=tab,column=2,text="Max Range",tooltip="Set the range (in yds) that Object Finder will search for objects.\n\Render distance is typically no more than 150 yards for most dynamic objects.",low="5",high="500",min=5,max=500,var=SQUID.max_object_finder_dist,value=200,step=1,onvaluechanged=object_finder_dist_handler})
			create_checkbox({tab=tab,column=2,text="Track Quest Objects",tooltip="- WARNING: THIS WILL REDUCE FRAMERATE -\n\nAttempts to track any and all quest objectives.",func=track_quests_handler,var=SQUID.track_quests})
			create_checkbox({tab=tab,column=2,text=locale == "zhCN" and "ç›®æ ‡æŸ¥æ‰¾å™¨" or "Object Finder",tooltip=locale == "zhCN" and "å¯ç”¨å¯¹è±¡æŸ¥æ‰¾å™¨, æ˜¾ç¤ºæ‰€é€‰å¯¹è±¡çš„ä½ç½®. å•å‡»ä¸‹é¢å¹¶é”®å…¥è¦æœç´¢çš„ç‰¹å®šå¯¹è±¡.å¯¹è±¡å¯ä»¥æ˜¯æ¸¸æˆä¸­çš„ä»»ä½•ä¸œè¥¿ï¼Œæ¯”å¦‚è¯è‰ã€è§’è‰²ã€NPCã€æŒ–çŸ¿èŠ‚ç‚¹ã€‚è¿™ä¸€åŠŸèƒ½å…è®¸çŽ©å®¶æ‰¾åˆ°ç‰¹å®šçš„å¯¹è±¡." or "- Enable Squid Object Finder -\n\nEasily find any game object or unit using this! (Generally not useful in PvP)\n\nJust enter the name of the object you're looking for in the editbox below\n\nEntries can be full or partial name, and are not case-sensitive!\n\nThe name of the object will be drawn over it's location in the game world,\nwith the distance beside it.",func=toggle_object_finder,var=SQUID.draw_objects})
			create_editbox({tab=tab,column=2,title="Objects List",text="Type object names here, separated by commas.",lines=3,var="Object Finder List"})

			--awareness tab
			tabname = "Awareness"
			for i=1,#tabs do if tabs[i].name == tabname then
				tab=tabs[i]
			end end

			create_slider({tab=tab,text="Line Scale",tooltip="Adjust the scale of lines that make squid's drawings.\n\nDecrease for thinner lines, increase for thicker.\n\nDefault value: 1",low="0.2",high="2",min=20,max=200,var=SQUID.line_scale,value=100,step=10,onvaluechanged=squid_line_scale_handler})
			create_checkbox({tab=tab,text="Smart Mode",tooltip="Awareness features will only trigger when your healer is out of your camera view.\n\nThis is useful to disable drawings and alerts when you're already aware of positioning.",var=SQUID.disable_while_visible,func=disable_while_visible_handler})
			create_checkbox({tab=tab,text="Alerts",tooltip="Big alerts that remind you when you are out of LoS or out of range of your healer.\n\nThis can be annoying but useful for those trying to train better positioning.",var=SQUID.awareness_alerts_enabled,func=alerts_enabled_handler})
			create_checkbox({tab=tab,text="Bad Line",tooltip="Red line drawn to your healer when out of position.\n\nRed line is more transparent when out of range.\n\nLine is more opaque when out of LoS.",var=SQUID.awareness_lines_enabled,func=lines_enabled_handler,default=true})
			create_checkbox({tab=tab,text="Good Line",tooltip="Green line drawn to your healer when in LoS and range.\n\nIf you want to always know your healers positioning this is useful.",var=SQUID.good_line_enabled,func=good_line_handler})
			create_checkbox({tab=tab,text="Positioning",tooltip="Drawings for optimal positioning.\n\nPlay within the green / yellow zones when targeted.\n\nExtremely useful for any class.\n\n35-40 yds from healer is green [best]\n\n30-35 yds is yellow [good]\n\n0-30 yds is red [bad]",var=SQUID.positioning_help,func=positioning_help_handler,default=true})

			--clear selected tab
			tab = nil

			tabname = "Automation"
			for i=1,#tabs do if tabs[i].name == tabname then
				tab=tabs[i]
			end end

			create_checkbox({tab=tab,text="Full AFK",tooltip="Fully automates movement and all cooldowns\n\nUse with auto queue to spam arenas while AFK / asleep",func=cap_bot_handler,var=SQUID.cap_bot})

			create_checkbox({tab=tab,text="Auto Que",tooltip="Automatically queues for arena based on group size (skirmish if alone)\n\nWill also automatically accept ready checks and queue pops",func=auto_queue_handler,var=SQUID.auto_queue})
			create_checkbox({tab=tab,text="MMR Tank",tooltip="Leaves arena immediately after entering combat\n\nOnly works when Full AFK mode is enabled",func=mmr_tank_handler,var=SQUID.tank_mmr})

			create_checkbox({tab=tab,text="Queue BGs",tooltip="Queue for BGs regardless of group size\n\nUse this if you just want to que BGs!",func=only_bgs_handler,var=SQUID.only_bgs})
			create_checkbox({tab=tab,text="Queue Skirms",tooltip="Only queue for skirms regardless of group size\n\nUse this if you just want to que skirmishes!",func=only_skirms_handler,var=SQUID.only_skirms,default=true})
			create_checkbox({tab=tab,text="Always Leave Skirms",tooltip="Automatically leaves after skirms instead of requeueing after victories.",new_var="Leave Skirms",func=set_squid_var})

			create_checkbox({tab=tab,text="Kill Healers",tooltip="MOW THEM DOWNNNN KILL THE HEALERSSSS LETS GOOOO",func=kill_healers_handler,var=SQUID.kill_healers})

			--hide tooltips button not tied to tabs
			-- local stext = locale == "zhCN" and "æ‰“å¼€æ’ä»¶åŠŸèƒ½è¯´æ˜Ž" or "show tooltips"
			-- local htext = locale == "zhCN" and "å…³é—­æ’ä»¶åŠŸèƒ½è¯´æ˜Ž" or "hide tooltips"

			-- local hidetooltips = CreateFrame("Button",nil,f,nil,"UIPanelButtonTemplate")
			-- hidetooltips:SetText(SQUID.hidetooltips and stext or htext)
			-- hidetooltips:SetNormalTexture(squid_button)
			-- hidetooltips:GetNormalTexture():SetVertexColor(1,1,1,.3)
			-- hidetooltips:SetHighlightTexture(squid_button)
			-- hidetooltips:SetScript("OnClick",function(self)
			-- 	SQUID.hidetooltips = not SQUID.hidetooltips
			-- 	self:SetText(SQUID.hidetooltips and stext or htext)
			-- 	GameTooltip:Hide()
			-- end)
			-- hidetooltips:SetScript("OnEnter",function(self)
			-- 	if not SQUID.hidetooltips then
			-- 		GameTooltip:Show()
			-- 		GameTooltip:SetOwner(f,"CENTER",0,0);
			-- 		GameTooltip:SetAnchorType("ANCHOR_TOPLEFT",0,0);
			-- 		GameTooltip:SetBackdrop(backdrop2)
			-- 		GameTooltip:SetBackdropColor(0.2,0.2,0.2,1)
			-- 		GameTooltipText:SetFont(cfe,4,nil)
			-- 		GameTooltip:SetText("Hide Project LarryExitScam's tooltips (like this one) in the GUI.");
			-- 	end
			-- end)
			-- hidetooltips:SetScript("OnLeave",function(self)
			-- 	GameTooltipText:SetFont("Fonts\\FRIZQT__.TTF",12)
			-- 	GameTooltip:Hide()
			-- end)
			-- hidetooltips:GetFontString():SetFont(cfe,8,nil)
			-- hidetooltips:SetSize(enable:GetFontString():GetWidth()+3,25)
			-- hidetooltips:SetPoint("CENTER",90,-60)

			--auto populate the default tab (general)
			populate("General")

			-- do some things on specialization change event
			f:RegisterEvent("PLAYER_SPECIALIZATION_CHANGED")
			f:SetScript("OnEvent",on_spec_changed)

			SQFRAMEHOLDER = f
			f:Hide() -- hide gui initially

			local alpha_frame = CreateFrame("Frame"):SetScript("OnUpdate",function()
				if not dir then
					dir = 1
					f:SetAlpha(0)
				elseif dir == 1 then
					local a = f:GetAlpha()
					local duration = .75*GetFramerate()
					local step = 1/duration
					if a < 1 then
						f:SetAlpha(a + step)
					end
				elseif dir == -1 then
					local a = f:GetAlpha()
					local duration = .45*GetFramerate()
					local step = 1/duration
					if a > 0 then
						f:SetAlpha(a - step)
					else
						f:Hide()
					end
				end
			end)

			local function squid_gui_toggle()
				if f:IsShown() then
					dir = -1
				else

					--show the frame
					dir = nil
					f:Show()


					--set the alpha to 0
					local a = 0
					f:SetAlpha(a)

					--rebuild alpha from 0 to 1
					local fps = 1/GetFramerate()
					for i=0,1,fps do
						a = a + i
						f:SetAlpha(a)
					end

				end
			end

			local function open_meshlink()
				OpenURL("https://mega.nz/file/UtBgFbaA#tHgCl3n_Xn3kDZ2TOW1ngMo1khfgSrbshth56FYHB0U")
			end

			StaticPopupDialogs["OPEN_MESHLINK"] = {
				text = 'Click Yes to download Shadowlands navigation meshes. Extract the "mmaps" folder to the folder containing EWT.',
				button1 = "Yes",
				button2 = "No",
				OnAccept = function()
					open_meshlink()
				end,
				timeout = 0,
				whileDead = true,
				hideOnEscape = true,
				preferredIndex = 3,  -- avoid some UI taint, see http://www.wowace.com/announcements/how-to-avoid-some-ui-taint/
			}

			local function Squid_Mesh_Popup()
				StaticPopup_Show ("OPEN_MESHLINK")
			end

			local function squid_fools()
				print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Hello, " .. UnitName("player") .. ". We have detected an \"UNAUTHORIZED THIRD PARTY PROGRAM\" running on your computer. Your account will be suspended and an email will be sent to you shortly describing the offense in place. Please move to a safe location in game as soon as possible. Thanks for your attention.")
				PlaySound(SOUNDKIT.TELL_MESSAGE);
				C_Timer.After(45,function()
					print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-CallOfDutyBlackOps4:12:12:0:0:32:16:4:28:0:16\124t [Xen]: Yo. It's Xen. I'm detecting GM activity. Is this guy fucking with you? I'm at Burger King right now but it's chill, I'm controlling your game remotely through my microcomputing nano-device. Let me take care of this for you.")
					PlaySound(SOUNDKIT.TELL_MESSAGE);
					C_Timer.After(35,function()
						print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t To [Holinka]: Sir, I strongly deny any such accusations. I am innocent, and you've done nothing to prove me guilty. I must also rebuttal by asking why you have made no significant effort to improve the accessibility and fun of your game? Me and the boys have been grinding out this shitty ass gear system for months, and all we wish to do is queue it up.")
						PlaySound(SOUNDKIT.TELL_MESSAGE);
						C_Timer.After(18,function()
							print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t To [Holinka]: He who is without sin may cast the first stone.")
							PlaySound(SOUNDKIT.TELL_MESSAGE);
							C_Timer.After(25,function()
								print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Sorry, our decision is final. We have sufficient evidence of our findings. You agreed to the Terms of Use when you created your Blizzard account. You will now be removed from the game, as I must suspend your account. We're sorry for any inconvenience this may have caused.")
								PlaySound(SOUNDKIT.TELL_MESSAGE);
								C_Timer.After(25,function()
									print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: But... our decision is final... How is this possible? The ban button isn't working? What the fuck kind of black magic is this?")
									PlaySound(SOUNDKIT.TELL_MESSAGE);
									C_Timer.After(12,function()
										print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Who the fuck are y-")
										PlaySound(SOUNDKIT.TELL_MESSAGE);
										C_Timer.After(16,function()
											print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-CallOfDutyBlackOps4:12:12:0:0:32:16:4:28:0:16\124t [Xen]: Goodnight, sweet Holinka. Aight young Squid, you can get on with your business now. Enjoy the rest of your day this fine April evening, and let me know if any GMs try to fuck with you again. Pce out.")
											PlaySound(SOUNDKIT.TELL_MESSAGE);
										end)
									end)
								end)
							end)
						end)
					end)
				end)
			end

			function squid_slash_cmd(msg,editbox,arg1,arg2)
				if msg == "" then
					squid_gui_toggle()
				end
				if msg == "burst" then
					SquidBurst()
				end
				if msg == "trinket" then
					SquidTrinket()
				end
				if msg == "mesh" then
					Squid_Mesh_Popup()
				end
				if msg == "spread" then
					spread_handler()
				end
				if msg == "fools" then
					squid_fools()
				end
				local action, target = SecureCmdOptionParse(msg);
				if ( action ) then
					local spellExists = DoesSpellExist(action)
					local name, bag, slot = SecureCmdItemParse(action);
					if ( spellExists ) then
						-- now we can pause if spell is on gcd
						if IsSpellOnGCD( action ) and _spellCooldown( action ) <= 1.5 then
							SquidPaused=GetTime()
						end
						if target == "healer" then
							for i=1,#Enemies do
								if _isHealer(Enemies[i]) then
									SQ_CastSpellByName(action,Enemies[i])
								end
							end
						else
							SQ_CastSpellByName(action, target);
						end
						SQ_QueuedSpell = {spell = action, target = target, time = GetTime()}
					elseif ( slot or GetItemInfo(name) ) then
						SecureCmdUseItem(name, bag, slot, target);
					end
				end
			end


			SLASH_Squid1 = "/squid"
			SLASH_Squid2 = "/sq"
			SLASH_Squid3 = "/squ"
			SLASH_Squid4 = "/squi"
			SLASH_Squid5 = "/xr"
			SLASH_Squid6 = "/c"
			SlashCmdList["Squid"] = squid_slash_cmd

			Squid_GUI_Init=true
		end -- end of gui
	end

	function Squid_Alert(message1,message2,sound,fadetime,texture,refresh_old)

		local time = GetTime()
		local framerate = GetFramerate()
		local stop_func

		--no duplicates
		if message2 then
			for i=1,#AlertFrames do
				if AlertFrames[i].Text:GetText() == message1 .. " |cff00ccff" .. message2 then
					AlertFrames[i].Alpha = 1
					AlertFrames[i]:SetAlpha(1)
					AlertFrames[i].newupdate = time + (fadetime or 1)
					return false;
				end
			end
		else
			-- if message1 ~= "|cFFdecbebRotation Enabled"
			-- and message1 ~= "|cFFca2aa5Rotation Disabled"
			-- and message1 ~= "|cFFdecbebAuto Combustion Enabled"
			-- and message1 ~= "|cFFca2aa5Auto Combustion Disabled" then
			local enabled_match = strmatch(message1,"Enabled")
			local disabled_match = strmatch(message1,"Disabled")

			if not enabled_match and not disabled_match then
				for i=1,#AlertFrames do
					if AlertFrames[i].Text:GetText() == message1 then
						AlertFrames[i].Alpha = 1
						AlertFrames[i]:SetAlpha(1)
						AlertFrames[i].newupdate = time + (fadetime or 1)
						return false;
					end
				end
			else
				if enabled_match then
					for i=1,#AlertFrames do
						if AlertFrames[i] then
							if strmatch(AlertFrames[i].Text:GetText(),"Disabled") then
								AlertFrames[i]:Hide()
								tremove(AlertFrames,i)
							elseif strmatch(AlertFrames[i].Text:GetText(),message1) then
								AlertFrames[i].Alpha = 1
								AlertFrames[i]:SetAlpha(1)
								AlertFrames[i].newupdate = time + 1
								stop_func = true
							end
						end
					end
				end
				if disabled_match then
					for i=1,#AlertFrames do
						if AlertFrames[i] then
							if strmatch(AlertFrames[i].Text:GetText(),"Enabled") then
								AlertFrames[i]:Hide()
								tremove(AlertFrames,i)
							elseif strmatch(AlertFrames[i].Text:GetText(),message1) then
								AlertFrames[i].Alpha = 1
								AlertFrames[i]:SetAlpha(1)
								AlertFrames[i].newupdate = time + 1
								stop_func = true
							end
						end
					end
				end
			end
		end

		if stop_func then return false end

		local alert = CreateFrame("Frame")
		local anchor,_,anchor2,x,y = AlertFrames_Anchor:GetPoint()
		alert:SetPoint("CENTER",AlertFrames_Anchor,"CENTER",0,20)
		alert:SetHeight(125)
		alert:SetWidth(400)

		local font = sui_bold
		alert:SetClampedToScreen(true)
		alert.Text = alert:CreateFontString(nil, "HIGH", nil)
		alert.Text:SetFont(font,13,'THICKOUTLINE')

		alert:SetScript("OnMouseUp",nil);
		alert:SetScript("OnMouseDown",nil);

		if message2 then
			alert.Text:SetText(message1 .. " |cff00ccff" .. message2)
		else
			alert.Text:SetText(message1)
		end

		alert.Start = time
		alert.End = time + 2
		alert.Time = 2
		alert.Alpha = 1

		alert.Text:SetPoint("CENTER",alert,"CENTER",0,0) -- +200

		local t = GetSpellTexture(texture)
		if t then
			alert.Texture = alert:CreateTexture(nil,"OVERLAY",nil)
			alert.Texture:SetTexture(t)
			alert.Texture:ClearAllPoints()
			-- alert.Texture:SetParent(alert)
			alert.Texture:SetWidth(19)
			alert.Texture:SetHeight(19)
			if AlertFrames[1] and AlertFrames[1].Texture then
				local pos,parent,pos2,offset = AlertFrames[1].Texture:GetPoint()
				-- no more alternating icon position
				-- if pos == "LEFT" then
				-- 	alert.Texture:SetPoint("RIGHT",alert.Text,"RIGHT",25,0)---(20+(alert.Text:GetWidth()/2)),0)
				-- else
					alert.Texture:SetPoint("LEFT",alert.Text,"LEFT",-25,0)---(20+(alert.Text:GetWidth()/2)),0)
				-- end
			else
				alert.Texture:SetPoint("LEFT",alert.Text,"LEFT",-25,0)
			end

		end

		--initial alert animation
		alert:SetScript("OnUpdate",function(self)
			if self then
				local duration = .08*framerate
				local step = 4/duration
				local desired_size = 12 --desired size of text after the animation is complete
				local size = select(2,self.Text:GetFont())
				if size <= desired_size+2 and not self.switch then
					self.Text:SetFont(font,size+step,"OUTLINE");
				elseif size > desired_size then
					self.Text:SetFont(font,size-step,"OUTLINE");
					self.switch = true
				end
			end
		end)

		--begin fade animation after designated time ( 2.5s default )
		C_Timer.After(fadetime or 2.5,function()
			alert:SetScript("OnUpdate",function(self)
				if not self.newupdate or self.newupdate < GetTime() then
					if self then
						local duration = .7*framerate
						local step = 1/duration
						self:SetAlpha(self.Alpha);
						self.Alpha = self.Alpha - step
					end
				end
			end)
		end)

		alert.index = #AlertFrames+1

		table.insert(AlertFrames,alert)

		--play soundfile
		if not SQUID.sounds_disabled and sound and (not soundplayed[sound] or time - soundplayed[sound] > .3) then

			local cork = Squid_Directory() .. "/media/cork.mp3"
			local danger = Squid_Directory() .. "/media/danger1.mp3"
			local positive = Squid_Directory() .. "/media/positive1.mp3"
			local cork2 = Squid_Directory() .. "/media/cork2.mp3"
			local alert1 = Squid_Directory() .. "/media/alert1.mp3"
			local alert2 = Squid_Directory() .. "/media/alert2.wav"
			local alert3 = Squid_Directory() .. "/media/alert3.mp3"
			local happy_alert = Squid_Directory() .. "/media/happy_alert.mp3"

			--cork sound
			if sound == 1 then
				PlaySoundFile(cork,"Master")
			end
			--danger sound
			if sound == 2 then
				PlaySoundFile(danger,"Master")
			end
			--positive sound
			if sound == 3 then
				PlaySoundFile(positive,"Master")
			end
			--second cork sound
			if sound == 4 then
				PlaySoundFile(cork2,"Master")
			end
			--alert sound
			if sound == 5 then
				PlaySoundFile(alert1,"Master")
			end
			--alert sound 2
			if sound == 6 then
				PlaySoundFile(alert2,"Master")
			end
			--alert sound 3
			if sound == 7 then
				PlaySoundFile(alert3,"Master")
			end
			--happy smiley alert :)
			if sound == 8 then
				PlaySoundFile(happy_alert,"Master")
			end

			soundplayed[sound]=time

		end

		return true

	end

	function Squid_Alert_Big(message1,message2,sound,fadetime,texture)

		local time=GetTime()
		local framerate = GetFramerate()

		--no duplicates
		if message2 then
			for i=1,#BigAlertFrames do
				if BigAlertFrames[i].Text:GetText() == message1 .. " |cff00ccff" .. message2 then
					BigAlertFrames[i].Alpha = 1
					BigAlertFrames[i]:SetAlpha(1)
					BigAlertFrames[i].newupdate = time + (fadetime or 1)
					return false;
				end
			end
		else
			for i=1,#BigAlertFrames do
				if BigAlertFrames[i].Text:GetText() == message1 then
					BigAlertFrames[i].Alpha = 1
					BigAlertFrames[i]:SetAlpha(1)
					BigAlertFrames[i].newupdate = time + (fadetime or 1)
					return false;
				end
			end
		end

		--75 , 115 (+ y axis)

		local alert = CreateFrame("Frame")
		local anchor,_,anchor2,x,y = BigAlertFrames_Anchor:GetPoint()
		alert:SetPoint("CENTER",BigAlertFrames_Anchor,"CENTER",0,-25)
		-- alert:SetPoint("CENTER",15,75)
		alert:SetHeight(125)
		alert:SetWidth(400)

		local font = sui_bold
		alert:SetClampedToScreen(true)
		alert.Text = alert:CreateFontString(nil, "HIGH", nil)
		alert.Text:SetFont(font,18,'OUTLINE')

		alert:SetScript("OnMouseUp",nil);
		alert:SetScript("OnMouseDown",nil);

		if message2 then
			alert.Text:SetText(message1 .. " |cff00ccff" .. message2)
		else
			alert.Text:SetText(message1)
		end

		alert.Start = time
		alert.End = time + 2
		alert.Time = 2
		alert.Alpha = 1

		alert.Text:SetPoint("CENTER",alert,"CENTER",0,0)

		if texture then
			local t=GetSpellTexture(texture)
			alert.Texture = alert:CreateTexture(nil,"OVERLAY",nil)
			alert.Texture:SetTexture(t)
			alert.Texture:ClearAllPoints()
			-- alert.Texture:SetParent(alert)
			alert.Texture:SetWidth(22)
			alert.Texture:SetHeight(22)
			alert.Texture:SetPoint("LEFT",alert.Text,"LEFT",-32,0)
		end

		--initial alert animation
		alert:SetScript("OnUpdate",function(self)
			if self then
				local duration = .08*framerate
				local step = 4/duration
				local desired_size = 18 --desired size of text after the animation is complete
				local size = select(2,self.Text:GetFont())
				if size <= desired_size+2 and not self.switch then
					self.Text:SetFont(font,size+step,"OUTLINE");
				elseif size > desired_size then
					self.Text:SetFont(font,size-step,"OUTLINE");
					self.switch = true
				end
			end
		end)

		--begin fade animation after designated time ( 2.5s default )
		C_Timer.After(fadetime or 2.5,function()
			alert:SetScript("OnUpdate",function(self)
				if not self.newupdate or self.newupdate < GetTime() then
					if self then
						local duration = .7*framerate
						local step = 1/duration
						self:SetAlpha(self.Alpha);
						self.Alpha = self.Alpha - step
					end
				end
			end)
		end)

		alert.index = #BigAlertFrames+1

		table.insert(BigAlertFrames,alert)

		--play soundfile
		if not SQUID.sounds_disabled and sound and (not soundplayed[sound] or time - soundplayed[sound] > .3) then

			local cork = Squid_Directory() .. "/media/cork.mp3"
			local danger = Squid_Directory() .. "/media/danger1.mp3"
			local positive = Squid_Directory() .. "/media/positive1.mp3"
			local cork2 = Squid_Directory() .. "/media/cork2.mp3"
			local alert1 = Squid_Directory() .. "/media/alert1.mp3"
			local alert2 = Squid_Directory() .. "/media/alert2.wav"
			local alert3 = Squid_Directory() .. "/media/alert3.mp3"
			local happy_alert = Squid_Directory() .. "/media/happy_alert.mp3"

			--cork sound
			if sound == 1 then
				PlaySoundFile(cork,"Master")
			end
			--danger sound
			if sound == 2 then
				PlaySoundFile(danger,"Master")
			end
			--positive sound
			if sound == 3 then
				PlaySoundFile(positive,"Master")
			end
			--second cork sound
			if sound == 4 then
				PlaySoundFile(cork2,"Master")
			end
			--alert sound
			if sound == 5 then
				PlaySoundFile(alert1,"Master")
			end
			--alert sound 2
			if sound == 6 then
				PlaySoundFile(alert2,"Master")
			end
			--alert sound 3
			if sound == 7 then
				PlaySoundFile(alert3,"Master")
			end
			--happy smiley alert :)
			if sound == 8 then
				PlaySoundFile(happy_alert,"Master")
			end

			soundplayed[sound]=time

		end

		return true

	end

	--Hook keybinds to display descriptions in tooltips
	local function keybind_description_handler(name)
		return name == "Maim Focus" and "Maim your focus target next time you reach 5 cp\r\n\Command expires 5 seconds after pressing\r\n\Will leap when ready to maim if out of range"
		or name == "Killshot" and "Hold to set up a kill on your target,\r\n\with a full sheep into gpy, ring, gpy,\r\n\ blink DB,meteor, and combust"
		or name == "Maim Target" and "Maim your target next time you reach 5 cp\r\n\Command expires 5 seconds after pressing\r\n\Will leap when ready to maim if out of range"
		or name == "Maim Healer" and "Maim the healer next time you reach 5 cp\r\n\Command expires 5 seconds after pressing\r\n\Will leap when ready to maim if out of range"
		or name == "Squid Toggler" and "Use this as a keybind to easily Enable and Disable the rotation with one button."
		or name == "Burst Key" and "Press to use burst cooldowns + force the rotation to dump available damage."
		or name == "Block Key" and "Hold down to force a manual Ice Block."
		or name == "Combust Toggle" and "Toggle auto combustion phase in PvE. Does not do anything in PvP rotation -yet-."
		or name == "Meteor / Orb" and "Hold to force a Meteor or Frozen Orb on your target."
		or name == "CC Healer" and "Hold to force CC on the enemy Healer."
		or name == "CC Focus" and "Hold to force CC your focus target."
		or name == "CC Off-Target" and "Hold to force CC on the off-target."
		or name == "Blink -> DB Healer" and "Hold to DB the Healer if in range, same key will otherwise blink into DB range if needed."
		or name == "Blink -> DB Focus" and "Hold to DB your focus if in range, same key will otherwise blink into DB range if needed."
		or name == "Blink -> DB Target" and "Hold to DB your target if in range, same key will otherwise blink into DB range if needed."
		or name == "Ring of Frost Healer" and "Hold to force Ring of Frost on the Healer. Will attempt to predict movement if they're moving."
		or name == "Ring of Frost Focus" and "Hold to force Ring of Frost on your focus target. Will attempt to predict movement if they're moving."
		or name == "Ring of Frost Target" and "Hold to force Ring of Frost on your target. Will attempt to predict movement if they're moving."
		or name == "Retreat Forward" and "Press to do a 180 and retreat forward. This action is very smooth and will not affect camera / gameplay."
		or name == "Dmg Key (Healers)" and "Hold to do damage as a healer"
		or name == "Poly > Gpy > Ring > Gpy Setup" and "Hold down to perform this combo. Useful in 1v1 situations."

		or ""
	end

	CreateFrame("Frame"):SetScript("OnUpdate",function()
		if KeyBindingFrame and KeyBindingFrame:IsShown() then
			for i=1,21 do
				local key = _G["KeyBindingFrameKeyBinding"..i]
				local getname = function(self) return self.description:GetText() end
				key.getname = getname
				if key and key:IsShown() then
					local box = _G["KeyBindingFrameKeyBinding"..i.."Key1Button"]
					box:SetScript("OnEnter",function(self)
						local name = _G["KeyBindingFrameKeyBinding"..i]:getname()
						GameTooltip:Show()
						GameTooltip:SetOwner(self,"ANCHOR_CURSOR",0,0);
						GameTooltip:SetAnchorType("ANCHOR_CURSOR",0,0);
						GameTooltip:SetText(keybind_description_handler(name));
					end)
					box:SetScript("OnLeave",function(self)
						GameTooltip:Hide()
					end)
				end
			end
		end
	end)

	local sa_og = Squid_Alert
	local sa_b_og = Squid_Alert_Big
	local LibDraw_line_og
	local LibDraw_text_og
	local LibDraw_texture_og

	function toggle_squid_streaming_mode()
		if not squid_streaming_mode_enabled then

			sa_og = Squid_Alert
			sa_b_og = Squid_Alert_Big
			LibDraw_line_og = LibDraw.Draw2DLine
			LibDraw_text_og = LibDraw.Text
			LibDraw_texture_og = LibDraw.Texture

			Squid_Alert = function() end
			Squid_Alert_Big = function() end
			LibDraw.Draw2DLine = function() end
			LibDraw.Text = function() end
			LibDraw.Texture = function() end

			squid_streaming_mode_enabled = true

		else

			Squid_Alert = sa_og
			Squid_Alert_Big = sa_b_og
			LibDraw.Draw2DLine = LibDraw_line_og
			LibDraw.Text = LibDraw_text_og
			LibDraw.Texture = LibDraw_texture_og

			squid_streaming_mode_enabled = false

		end
	end

	-- $Id: LibStub.lua 76 2007-09-03 01:50:17Z mikk $
	-- LibStub is a simple versioning stub meant for use in Libraries.  http://www.wowace.com/wiki/LibStub for more info
	-- LibStub is hereby placed in the Public Domain
	-- Credits: Kaelten, Cladhaire, ckknight, Mikk, Ammo, Nevcairiel, joshborke
	local LIBSTUB_MAJOR, LIBSTUB_MINOR = "LibStub", 1  -- NEVER MAKE THIS AN SVN REVISION! IT NEEDS TO BE USABLE IN ALL REPOS!
	local LibStub = _G[LIBSTUB_MAJOR]

	-- Check to see is this version of the stub is obsolete
	if not LibStub or LibStub.minor < LIBSTUB_MINOR then
		LibStub = LibStub or {libs = {}, minors = {} }
		_G[LIBSTUB_MAJOR] = LibStub
		LibStub.minor = LIBSTUB_MINOR

		-- LibStub:NewLibrary(major, minor)
		-- major (string) - the major version of the library
		-- minor (string or number ) - the minor version of the library
		--
		-- returns nil if a newer or same version of the lib is already present
		-- returns empty library object or old library object if upgrade is needed
		function LibStub:NewLibrary(major, minor)
			assert(type(major) == "string", "Bad argument #2 to `NewLibrary' (string expected)")
			minor = assert(tonumber(strmatch(minor, "%d+")), "Minor version must either be a number or contain a number.")

			local oldminor = self.minors[major]
			if oldminor and oldminor >= minor then return nil end
			self.minors[major], self.libs[major] = minor, self.libs[major] or {}
			return self.libs[major], oldminor
		end

		-- LibStub:GetLibrary(major, [silent])
		-- major (string) - the major version of the library
		-- silent (boolean) - if true, library is optional, silently return nil if its not found
		--
		-- throws an error if the library can not be found (except silent is set)
		-- returns the library object if found
		function LibStub:GetLibrary(major, silent)
			if not self.libs[major] and not silent then
				error(("Cannot find a library instance of %q."):format(tostring(major)), 2)
			end
			return self.libs[major], self.minors[major]
		end

		-- LibStub:IterateLibraries()
		--
		-- Returns an iterator for the currently registered libraries
		function LibStub:IterateLibraries()
			return pairs(self.libs)
		end

		setmetatable(LibStub, { __call = LibStub.GetLibrary })
	end

	AddEWTCallback(function()
		--[[ $Id: CallbackHandler-1.0.lua 14 2010-08-09 00:43:38Z mikk $ ]]
		local MAJOR, MINOR = "CallbackHandler-1.0", 6
		local CallbackHandler = LibStub:NewLibrary(MAJOR, MINOR)

		if not CallbackHandler then return end -- No upgrade needed

		local meta = {__index = function(tbl, key) tbl[key] = {} return tbl[key] end}

		-- Lua APIs
		local tconcat = table.concat
		local assert, error, loadstring = assert, error, loadstring
		local setmetatable, rawset, rawget = setmetatable, rawset, rawget
		local next, select, pairs, type, tostring = next, select, pairs, type, tostring

		-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
		-- List them here for Mikk's FindGlobals script
		-- GLOBALS: geterrorhandler

		local xpcall = xpcall

		local function errorhandler(err)
			return geterrorhandler()(err)
		end

		local function CreateDispatcher(argCount)
			local code = [[
			local next, xpcall, eh = ...

			local method, ARGS
			local function call() method(ARGS) end

			local function dispatch(handlers, ...)
				local index
				index, method = next(handlers)
				if not method then return end
				local OLD_ARGS = ARGS
				ARGS = ...
				repeat
					xpcall(call, eh)
					index, method = next(handlers, index)
				until not method
				ARGS = OLD_ARGS
			end

			return dispatch
			]]

			local ARGS, OLD_ARGS = {}, {}
			for i = 1, argCount do ARGS[i], OLD_ARGS[i] = "arg"..i, "old_arg"..i end
			code = code:gsub("OLD_ARGS", tconcat(OLD_ARGS, ", ")):gsub("ARGS", tconcat(ARGS, ", "))
			return assert(loadstring(code, "safecall Dispatcher["..argCount.."]"))(next, xpcall, errorhandler)
		end

		local Dispatchers = setmetatable({}, {__index=function(self, argCount)
			local dispatcher = CreateDispatcher(argCount)
			rawset(self, argCount, dispatcher)
			return dispatcher
		end})

		--------------------------------------------------------------------------
		-- CallbackHandler:New
		--
		--   target            - target object to embed public APIs in
		--   RegisterName      - name of the callback registration API, default "RegisterCallback"
		--   UnregisterName    - name of the callback unregistration API, default "UnregisterCallback"
		--   UnregisterAllName - name of the API to unregister all callbacks, default "UnregisterAllCallbacks". false == don't publish this API.

		function CallbackHandler:New(target, RegisterName, UnregisterName, UnregisterAllName, OnUsed, OnUnused)
			-- TODO: Remove this after beta has gone out
			assert(not OnUsed and not OnUnused, "ACE-80: OnUsed/OnUnused are deprecated. Callbacks are now done to registry.OnUsed and registry.OnUnused")

			RegisterName = RegisterName or "RegisterCallback"
			UnregisterName = UnregisterName or "UnregisterCallback"
			if UnregisterAllName==nil then	-- false is used to indicate "don't want this method"
				UnregisterAllName = "UnregisterAllCallbacks"
			end

			-- we declare all objects and exported APIs inside this closure to quickly gain access
			-- to e.g. function names, the "target" parameter, etc


			-- Create the registry object
			local events = setmetatable({}, meta)
			local registry = { recurse=0, events=events }

			-- registry:Fire() - fires the given event/message into the registry
			function registry:Fire(eventname, ...)
				if not rawget(events, eventname) or not next(events[eventname]) then return end
				local oldrecurse = registry.recurse
				registry.recurse = oldrecurse + 1

				Dispatchers[select('#', ...) + 1](events[eventname], eventname, ...)

				registry.recurse = oldrecurse

				if registry.insertQueue and oldrecurse==0 then
					-- Something in one of our callbacks wanted to register more callbacks; they got queued
					for eventname,callbacks in pairs(registry.insertQueue) do
						local first = not rawget(events, eventname) or not next(events[eventname])	-- test for empty before. not test for one member after. that one member may have been overwritten.
						for self,func in pairs(callbacks) do
							events[eventname][self] = func
							-- fire OnUsed callback?
							if first and registry.OnUsed then
								registry.OnUsed(registry, target, eventname)
								first = nil
							end
						end
					end
					registry.insertQueue = nil
				end
			end

			-- Registration of a callback, handles:
			--   self["method"], leads to self["method"](self, ...)
			--   self with function ref, leads to functionref(...)
			--   "addonId" (instead of self) with function ref, leads to functionref(...)
			-- all with an optional arg, which, if present, gets passed as first argument (after self if present)
			target[RegisterName] = function(self, eventname, method, ... --[[actually just a single arg]])
				if type(eventname) ~= "string" then
					error("Usage: "..RegisterName.."(eventname, method[, arg]): 'eventname' - string expected.", 2)
				end

				method = method or eventname

				local first = not rawget(events, eventname) or not next(events[eventname])	-- test for empty before. not test for one member after. that one member may have been overwritten.

				if type(method) ~= "string" and type(method) ~= "function" then
					error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - string or function expected.", 2)
				end

				local regfunc

				if type(method) == "string" then
					-- self["method"] calling style
					if type(self) ~= "table" then
						error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): self was not a table?", 2)
					elseif self==target then
						error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): do not use Library:"..RegisterName.."(), use your own 'self'", 2)
					elseif type(self[method]) ~= "function" then
						error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - method '"..tostring(method).."' not found on self.", 2)
					end

					if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
						local arg=select(1,...)
						regfunc = function(...) self[method](self,arg,...) end
					else
						regfunc = function(...) self[method](self,...) end
					end
				else
					-- function ref with self=object or self="addonId" or self=thread
					if type(self)~="table" and type(self)~="string" and type(self)~="thread" then
						error("Usage: "..RegisterName.."(self or \"addonId\", eventname, method): 'self or addonId': table or string or thread expected.", 2)
					end

					if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
						local arg=select(1,...)
						regfunc = function(...) method(arg,...) end
					else
						regfunc = method
					end
				end


				if events[eventname][self] or registry.recurse<1 then
				-- if registry.recurse<1 then
					-- we're overwriting an existing entry, or not currently recursing. just set it.
					events[eventname][self] = regfunc
					-- fire OnUsed callback?
					if registry.OnUsed and first then
						registry.OnUsed(registry, target, eventname)
					end
				else
					-- we're currently processing a callback in this registry, so delay the registration of this new entry!
					-- yes, we're a bit wasteful on garbage, but this is a fringe case, so we're picking low implementation overhead over garbage efficiency
					registry.insertQueue = registry.insertQueue or setmetatable({},meta)
					registry.insertQueue[eventname][self] = regfunc
				end
			end

			-- Unregister a callback
			target[UnregisterName] = function(self, eventname)
				if not self or self==target then
					error("Usage: "..UnregisterName.."(eventname): bad 'self'", 2)
				end
				if type(eventname) ~= "string" then
					error("Usage: "..UnregisterName.."(eventname): 'eventname' - string expected.", 2)
				end
				if rawget(events, eventname) and events[eventname][self] then
					events[eventname][self] = nil
					-- Fire OnUnused callback?
					if registry.OnUnused and not next(events[eventname]) then
						registry.OnUnused(registry, target, eventname)
					end
				end
				if registry.insertQueue and rawget(registry.insertQueue, eventname) and registry.insertQueue[eventname][self] then
					registry.insertQueue[eventname][self] = nil
				end
			end

			-- OPTIONAL: Unregister all callbacks for given selfs/addonIds
			if UnregisterAllName then
				target[UnregisterAllName] = function(...)
					if select("#",...)<1 then
						error("Usage: "..UnregisterAllName.."([whatFor]): missing 'self' or \"addonId\" to unregister events for.", 2)
					end
					if select("#",...)==1 and ...==target then
						error("Usage: "..UnregisterAllName.."([whatFor]): supply a meaningful 'self' or \"addonId\"", 2)
					end


					for i=1,select("#",...) do
						local self = select(i,...)
						if registry.insertQueue then
							for eventname, callbacks in pairs(registry.insertQueue) do
								if callbacks[self] then
									callbacks[self] = nil
								end
							end
						end
						for eventname, callbacks in pairs(events) do
							if callbacks[self] then
								callbacks[self] = nil
								-- Fire OnUnused callback?
								if registry.OnUnused and not next(callbacks) then
									registry.OnUnused(registry, target, eventname)
								end
							end
						end
					end
				end
			end

			return registry
		end

	end)

	AddEWTCallback(function()

		local MAJOR = "LibInspect"

		LibInspect = {
			version = 69.0
		}

		LibInspect.events = LibInspect.events or LibStub ("CallbackHandler-1.0"):New (LibInspect)
		if not LibInspect.events then error("LibInspect requires CallbackHandler") end

		local UPDATE_EVENT = "GroupInSpecT_Update"
		local REMOVE_EVENT = "GroupInSpecT_Remove"
		local INSPECT_READY_EVENT = "GroupInSpecT_InspectReady"
		local QUEUE_EVENT = "GroupInSpecT_QueueChanged"

		local COMMS_PREFIX = "LGIST11"
		local COMMS_FMT = "1"
		local COMMS_DELIM = "\a"

		local INSPECT_DELAY = 1.5
		local INSPECT_TIMEOUT = 10 -- If we get no notification within 10s, give up on unit

		local MAX_ATTEMPTS = 2

		--[===[@debug@
		lib.debug = false
		local function debug (...)
		  if lib.debug then  -- allow programmatic override of debug output by client addons
			print (...)
		  end
		end
		--@end-debug@]===]

		function LibInspect.events:OnUsed(target, eventname)
		  if eventname == INSPECT_READY_EVENT then
			target.inspect_ready_used = true
		  end
		end

		function LibInspect.events:OnUnused(target, eventname)
		  if eventname == INSPECT_READY_EVENT then
			target.inspect_ready_used = nil
		  end
		end

		-- Frame for events
		local frame = _G[MAJOR .. "_Frame"] or CreateFrame ("Frame", MAJOR .. "_Frame")
		LibInspect.frame = frame
		frame:Hide()
		frame:UnregisterAllEvents ()
		frame:RegisterEvent ("PLAYER_LOGIN")
		frame:RegisterEvent ("PLAYER_LOGOUT")
		if not frame.OnEvent then
		  frame.OnEvent = function(this, event, ...)
			local eventhandler = LibInspect[event]
			return eventhandler and eventhandler (LibInspect, ...)
		  end
		  frame:SetScript ("OnEvent", frame.OnEvent)
		end


		-- Hide our run-state in an easy-to-dump object
		LibInspect.state = {
		  mainq = {}, staleq = {}, -- inspect queues
		  t = 0,
		  last_inspect = 0,
		  current_guid = nil,
		  throttle = 0,
		  tt = 0,
		  debounce_send_update = 0,
		}
		LibInspect.cache = {}
		LibInspect.static_cache = {}


		-- Note: if we cache NotifyInspect, we have to hook before we cache it!
		if not LibInspect.hooked then
		  hooksecurefunc("NotifyInspect", function (...) return LibInspect:NotifyInspect (...) end)
		  LibInspect.hooked = true
		end
		function LibInspect:NotifyInspect(unit)
		  self.state.last_inspect = GetTime()
		end


		-- Get local handles on the key API functions
		local CanInspect                      = _G.CanInspect
		local ClearInspectPlayer              = _G.ClearInspectPlayer
		local GetClassInfo                    = _G.GetClassInfo
		local GetNumSubgroupMembers           = _G.GetNumSubgroupMembers
		local GetNumSpecializationsForClassID = _G.GetNumSpecializationsForClassID
		local GetPlayerInfoByGUID             = _G.GetPlayerInfoByGUID
		local GetInspectSelectedPvpTalent     = _G.C_SpecializationInfo.GetInspectSelectedPvpTalent
		local GetInspectSpecialization        = _G.GetInspectSpecialization
		local GetSpecialization               = _G.GetSpecialization
		local GetSpecializationInfo           = _G.GetSpecializationInfo
		local GetSpecializationInfoForClassID = _G.GetSpecializationInfoForClassID
		local GetSpecializationRoleByID       = _G.GetSpecializationRoleByID
		local GetSpellInfo                    = _G.GetSpellInfo
		local GetPvpTalentInfoByID            = _G.GetPvpTalentInfoByID
		local GetPvpTalentSlotInfo            = _G.C_SpecializationInfo.GetPvpTalentSlotInfo
		local GetTalentInfo                   = _G.GetTalentInfo
		local GetTalentInfoByID               = _G.GetTalentInfoByID
		local IsInRaid                        = _G.IsInRaid
		--local NotifyInspect                   = _G.NotifyInspect -- Don't cache, as to avoid missing future hooks
		local GetNumClasses                   = _G.GetNumClasses
		local UnitExists                      = _G.UnitExists
		local UnitGUID                        = _G.UnitGUID
		local UnitInParty                     = _G.UnitInParty
		local UnitInRaid                      = _G.UnitInRaid
		local UnitIsConnected                 = _G.UnitIsConnected
		local UnitIsPlayer                    = _G.UnitIsPlayer
		local UnitIsUnit                      = _G.UnitIsUnit
		local UnitName                        = _G.UnitName
		local SendAddonMessage                = _G.C_ChatInfo.SendAddonMessage
		local RegisterAddonMessagePrefix      = _G.C_ChatInfo.RegisterAddonMessagePrefix

		local MAX_TALENT_TIERS                = _G.MAX_TALENT_TIERS
		local NUM_TALENT_COLUMNS              = _G.NUM_TALENT_COLUMNS
		local NUM_PVP_TALENT_SLOTS            = 4


		local global_spec_id_roles_detailed = {
		  -- Death Knight
		  [250] = "tank", -- Blood
		  [251] = "melee", -- Frost
		  [252] = "melee", -- Unholy
		  -- Demon Hunter
		  [577] = "melee", -- Havoc
		  [581] = "tank", -- Vengeance
		  -- Druid
		  [102] = "ranged", -- Balance
		  [103] = "melee", -- Feral
		  [104] = "tank", -- Guardian
		  [105] = "healer", -- Restoration
		  -- Hunter
		  [253] = "ranged", -- Beast Mastery
		  [254] = "ranged", -- Marksmanship
		  [255] = "melee", -- Survival
		  -- Mage
		  [62] = "ranged", -- Arcane
		  [63] = "ranged", -- Fire
		  [64] = "ranged", -- Frost
		  -- Monk
		  [268] = "tank", -- Brewmaster
		  [269] = "melee", -- Windwalker
		  [270] = "healer", -- Mistweaver
		  -- Paladin
		  [65] = "healer", -- Holy
		  [66] = "tank", -- Protection
		  [70] = "melee", -- Retribution
		  -- Priest
		  [256] = "healer", -- Discipline
		  [257] = "healer", -- Holy
		  [258] = "ranged", -- Shadow
		  -- Rogue
		  [259] = "melee", -- Assassination
		  [260] = "melee", -- Combat
		  [261] = "melee", -- Subtlety
		  -- Shaman
		  [262] = "ranged", -- Elemental
		  [263] = "melee", -- Enhancement
		  [264] = "healer", -- Restoration
		  -- Warlock
		  [265] = "ranged", -- Affliction
		  [266] = "ranged", -- Demonology
		  [267] = "ranged", -- Destruction
		  -- Warrior
		  [71] = "melee", -- Arms
		  [72] = "melee", -- Fury
		  [73] = "tank", -- Protection
		}

		local class_fixed_roles = {
		  HUNTER = "DAMAGER",
		  MAGE = "DAMAGER",
		  ROGUE = "DAMAGER",
		  WARLOCK = "DAMAGER",
		}

		local class_fixed_roles_detailed = {
		  MAGE = "ranged",
		  ROGUE = "melee",
		  WARLOCK = "ranged",
		}

		-- Inspects only work after being fully logged in, so track that
		function LibInspect:PLAYER_LOGIN ()
		  self.state.logged_in = true

		  self:CacheGameData ()

		  frame:RegisterEvent ("INSPECT_READY")
		  frame:RegisterEvent ("GROUP_ROSTER_UPDATE")
		  frame:RegisterEvent ("PLAYER_ENTERING_WORLD")
		  frame:RegisterEvent ("UNIT_LEVEL")
		  frame:RegisterEvent ("PLAYER_TALENT_UPDATE")
		  frame:RegisterEvent ("PLAYER_SPECIALIZATION_CHANGED")
		  frame:RegisterEvent ("UNIT_SPELLCAST_SUCCEEDED")
		  frame:RegisterEvent ("UNIT_NAME_UPDATE")
		  frame:RegisterEvent ("UNIT_AURA")
		  frame:RegisterEvent ("CHAT_MSG_ADDON")
		  RegisterAddonMessagePrefix (COMMS_PREFIX)

		  local guid = UnitGUID("player")--ObjectPointer("player")
		  local info = self:BuildInfo ("player")
		  self.events:Fire (UPDATE_EVENT, guid, "player", info)
		end

		function LibInspect:PLAYER_LOGOUT ()
		  self.state.logged_in = false
		end


		-- Simple timer
		do
		  LibInspect.state.t = 0
		  if not frame.OnUpdate then -- ticket #4 if the OnUpdate code every changes we should stop borrowing the existing handler
			frame.OnUpdate = function(this, elapsed)
			  LibInspect.state.t = LibInspect.state.t + elapsed
			  LibInspect.state.tt = LibInspect.state.tt + elapsed
			  if LibInspect.state.t > INSPECT_DELAY then
				LibInspect:ProcessQueues ()
				LibInspect.state.t = 0
			  end
			  -- Unthrottle, essentially allowing 1 msg every 3 seconds, but with substantial burst capacity
			  if LibInspect.state.tt > 3 and LibInspect.state.throttle > 0 then
				LibInspect.state.throttle = LibInspect.state.throttle - 1
				LibInspect.state.tt = 0
			  end
			  if LibInspect.state.debounce_send_update > 0 then
				local debounce = LibInspect.state.debounce_send_update - elapsed
				LibInspect.state.debounce_send_update = debounce
				if debounce <= 0 then LibInspect:SendLatestSpecData () end
			  end
			end
			frame:SetScript("OnUpdate", frame.OnUpdate) -- this is good regardless of the handler check above because otherwise a new anonymous function is created every time the OnUpdate code runs
		  end
		end


		-- Internal library functions

		-- Caches to deal with API shortcomings as well as performance
		LibInspect.static_cache.global_specs = {}           -- [gspec]         -> { .idx, .name_localized, .description, .icon, .background, .role }
		LibInspect.static_cache.class_to_class_id = {}      -- [CLASS]         -> class_id

		-- The talents cache can no longer be pre-fetched on login, but is now constructed class-by-class as we inspect people.
		-- This probably means we want to only ever access it through the GetCachedTalentInfo() helper function below.
		LibInspect.static_cache.talents = {}                -- [talent_id]      -> { .spell_id, .talent_id, .name_localized, .icon, .tier, .column }
		LibInspect.static_cache.pvp_talents = {}            -- [talent_id]      -> { .spell_id, .talent_id, .name_localized, .icon }

		function LibInspect:GetCachedTalentInfo (class_id, tier, col, group, is_inspect, unit)
		  local talent_id, name, icon, sel, _, spell_id = GetTalentInfo (tier, col, group, is_inspect, unit)
		  if not talent_id then
			--[===[@debug@
			debug ("GetCachedTalentInfo("..tostring(class_id)..","..tier..","..col..","..group..","..tostring(is_inspect)..","..tostring(unit)..") returned nil") --@end-debug@]===]
			return {}
		  end
		  local class_talents = self.static_cache.talents
		  if not class_talents[talent_id] then
			class_talents[talent_id] = {
			  spell_id = spell_id,
			  talent_id = talent_id,
			  name_localized = name,
			  icon = icon,
			  tier = tier,
			  column = col,
			}
		  end
		  return class_talents[talent_id], sel
		end

		function LibInspect:GetCachedTalentInfoByID (talent_id)
		  local class_talents = self.static_cache.talents
		  if talent_id and not class_talents[talent_id] then
			local _, name, icon, _, _, spell_id, _, row, col = GetTalentInfoByID (talent_id)
			if not name then
			  --[===[@debug@
			  debug ("GetCachedTalentInfoByID("..tostring(talent_id)..") returned nil") --@end-debug@]===]
			  return nil
			end
			class_talents[talent_id] = {
			  spell_id = spell_id,
			  talent_id = talent_id,
			  name_localized = name,
			  icon = icon,
			  tier = row,
			  column = col,
			}
		  end
		  return class_talents[talent_id]
		end

		function LibInspect:GetCachedPvpTalentInfoByID (talent_id)
		  local pvp_talents = self.static_cache.pvp_talents
		  if talent_id and not pvp_talents[talent_id] then
			local _, name, icon, _, _, spell_id = GetPvpTalentInfoByID (talent_id)
			if not name then
			  --[===[@debug@
			  debug ("GetCachedPvpTalentInfo("..tostring(talent_id)..") returned nil") --@end-debug@]===]
			  return nil
			end
			pvp_talents[talent_id] = {
			  spell_id = spell_id,
			  talent_id = talent_id,
			  name_localized = name,
			  icon = icon,
			}
		  end
		  return pvp_talents[talent_id]
		end

		function LibInspect:CacheGameData ()
		  local gspecs = self.static_cache.global_specs
		  gspecs[0] = {} -- Handle no-specialization case
		  for class_id = 1, GetNumClasses () do
			for idx = 1, GetNumSpecializationsForClassID (class_id) do
			  local gspec_id, name, description, icon, background = GetSpecializationInfoForClassID (class_id, idx)
			  gspecs[gspec_id] = {}
			  local gspec = gspecs[gspec_id]
			  gspec.idx = idx
			  gspec.name_localized = name
			  gspec.description = description
			  gspec.icon = icon
			  gspec.background = background
			  gspec.role = GetSpecializationRoleByID (gspec_id)
			end

			local _, class = GetClassInfo (class_id)
			self.static_cache.class_to_class_id[class] = class_id
		  end
		end


		function LibInspect:GuidToUnit (guid)
		  local info = self.cache[guid]
		  if info and info.lku and UnitGUID (info.lku) == guid then return info.lku end

		  for i,unit in ipairs (self:GroupUnits ()) do
			if UnitExists (unit) and UnitGUID (unit) == guid then
			  if info then info.lku = unit end
			  return unit
			end
		  end
		end


		function LibInspect:Query (unit)
		  if not UnitIsPlayer (unit) then return end -- NPC

		  if UnitIsUnit (unit, "player") then
			self.events:Fire (UPDATE_EVENT, UnitGUID("player"), "player", self:BuildInfo ("player"))
			return
		  end

		  local mainq, staleq = self.state.mainq, self.state.staleq

		  local guid = UnitGUID (unit)
		  if not mainq[guid] then
			mainq[guid] = 1
			staleq[guid] = nil
			self.frame:Show () -- Start timer if not already running
			self.events:Fire (QUEUE_EVENT)
		  end
		end


		function LibInspect:Refresh (unit)
		  local guid = UnitGUID (unit)
		  if not guid then return end
		  --[===[@debug@
		  debug ("Refreshing "..unit) --@end-debug@]===]
		  if not self.state.mainq[guid] then
			self.state.staleq[guid] = 1
			self.frame:Show ()
			self.events:Fire (QUEUE_EVENT)
		  end
		end


		function LibInspect:ProcessQueues ()
		  if not self.state.logged_in then return end
		  if InCombatLockdown () then return end -- Never inspect while in combat
		  if UnitIsDead ("player") then return end -- You can't inspect while dead, so don't even try
		  if InspectFrame and InspectFrame:IsShown () then return end -- Don't mess with the UI's inspections

		  local mainq = self.state.mainq
		  local staleq = self.state.staleq

		  if not next (mainq) and next(staleq) then
			--[===[@debug@
			debug ("Main queue empty, swapping main and stale queues") --@end-debug@]===]
			self.state.mainq, self.state.staleq = self.state.staleq, self.state.mainq
			mainq, staleq = staleq, mainq
		  end

		  if (self.state.last_inspect + INSPECT_TIMEOUT) < GetTime () then
			-- If there was an inspect going, it's timed out, so either retry or move it to stale queue
			local guid = self.state.current_guid
			if guid then
			  --[===[@debug@
			  debug ("Inspect timed out for "..guid) --@end-debug@]===]

			  local count = mainq and mainq[guid] or (MAX_ATTEMPTS + 1)
			  if not self:GuidToUnit (guid) then
				--[===[@debug@
				debug ("No longer applicable, removing from queues") --@end-debug@]===]
				mainq[guid], staleq[guid] = nil, nil
			  elseif count > MAX_ATTEMPTS then
				--[===[@debug@
				debug ("Excessive retries, moving to stale queue") --@end-debug@]===]
				mainq[guid], staleq[guid] = nil, 1
			  else
				mainq[guid] = count + 1
			  end
			  self.state.current_guid = nil
			end
		  end

		  if self.state.current_guid then return end -- Still waiting on our inspect data

		  for guid,count in pairs (mainq) do
			local unit = self:GuidToUnit (guid)
			if not unit then
			  --[===[@debug@
			  debug ("No longer applicable, removing from queues") --@end-debug@]===]
			  mainq[guid], staleq[guid] = nil, nil
			elseif not CanInspect (unit) or not UnitIsConnected (unit) then
			  --[===[@debug@
			  debug ("Cannot inspect "..unit..", aka "..(UnitName(unit) or "nil")..", moving to stale queue") --@end-debug@]===]
			  mainq[guid], staleq[guid] = nil, 1
			else
			  --[===[@debug@
			  debug ("Inspecting "..unit..", aka "..(UnitName(unit) or "nil")) --@end-debug@]===]
			  mainq[guid] = count + 1
			  self.state.current_guid = guid
			  NotifyInspect (unit)
			  break
			end
		  end

		  if not next (mainq) and not next (staleq) and self.state.throttle == 0 and self.state.debounce_send_update <= 0 then
			frame:Hide() -- Cancel timer, nothing queued and no unthrottling to be done
		  end
		  self.events:Fire (QUEUE_EVENT)
		end


		function LibInspect:UpdatePlayerInfo (guid, unit, info)
		  info.class_localized, info.class, info.race_localized, info.race, info.gender, info.name, info.realm = GetPlayerInfoByGUID (guid)
		  local class = info.class
		  if info.realm and info.realm == "" then info.realm = nil end
		  info.class_id = class and self.static_cache.class_to_class_id[class]
		  if not info.spec_role then info.spec_role = class and class_fixed_roles[class] end
		  if not info.spec_role_detailed then info.spec_role_detailed = class and class_fixed_roles_detailed[class] end
		  info.lku = unit
		end


		function LibInspect:BuildInfo (unit)
		  local guid = UnitGUID (unit)
		  if not guid then return end

		  local cache = self.cache
		  local info = cache[guid] or {}
		  cache[guid] = info
		  info.guid = guid

		  self:UpdatePlayerInfo (guid, unit, info)
		  -- On a cold login, GetPlayerInfoByGUID() doesn't seem to be usable, so mark as stale
		  local class = info.class
		  if not class and not self.state.mainq[guid] then
			self.state.staleq[guid] = 1
			self.frame:Show ()
			self.events:Fire (QUEUE_EVENT)
		  end

		  local is_inspect = not UnitIsUnit (unit, "player")
		  local spec = GetSpecialization ()
		  local gspec_id = is_inspect and GetInspectSpecialization (unit) or spec and GetSpecializationInfo (spec)

		  local gspecs = self.static_cache.global_specs
		  if not gspec_id or not gspecs[gspec_id] then -- not a valid spec_id
			info.global_spec_id = nil
		  else
			info.global_spec_id = gspec_id
			local spec_info = gspecs[gspec_id]
			info.spec_index          = spec_info.idx
			info.spec_name_localized = spec_info.name_localized
			info.spec_description    = spec_info.description
			info.spec_icon           = spec_info.icon
			info.spec_background     = spec_info.background
			info.spec_role           = spec_info.role
			info.spec_role_detailed  = global_spec_id_roles_detailed[gspec_id]
		  end

		  if not info.spec_role then info.spec_role = class and class_fixed_roles[class] end
		  if not info.spec_role_detailed then info.spec_role_detailed = class and class_fixed_roles_detailed[class] end

		  info.talents = info.talents or {}
		  info.pvp_talents = info.pvp_talents or {}

		  -- Only scan talents when we have player data
		  if info.spec_index then
			info.spec_group = GetActiveSpecGroup (is_inspect)
			wipe (info.talents)
			for tier = 1, MAX_TALENT_TIERS do
			  for col = 1, NUM_TALENT_COLUMNS do
				local talent, sel = self:GetCachedTalentInfo (info.class_id, tier, col, info.spec_group, is_inspect, unit)
				if sel then
				  info.talents[talent.talent_id] = talent
				end
			  end
			end

			wipe (info.pvp_talents)
			if is_inspect then
			  for index = 1, NUM_PVP_TALENT_SLOTS do
				local talent_id = GetInspectSelectedPvpTalent (unit, index)
				if talent_id then
				  info.pvp_talents[talent_id] = self:GetCachedPvpTalentInfoByID (talent_id)
				end
			  end
			else
			  -- C_SpecializationInfo.GetAllSelectedPvpTalentIDs will sometimes return a lot of extra talents
			  for index = 1, NUM_PVP_TALENT_SLOTS do
				local slot_info = GetPvpTalentSlotInfo (index)
				local talent_id = slot_info and slot_info.selectedTalentID
				if talent_id then
				  info.pvp_talents[talent_id] = self:GetCachedPvpTalentInfoByID (talent_id)
				end
			  end
			end
		  end

		  info.glyphs = info.glyphs or {} -- kept for addons that still refer to this

		  if is_inspect and not UnitIsVisible (unit) and UnitIsConnected (unit) then info.not_visible = true end

		  return info
		end


		function LibInspect:INSPECT_READY (guid)
		  local unit = self:GuidToUnit (guid)
		  local finalize = false
		  if unit then
			if guid == self.state.current_guid then
			  self.state.current_guid = nil -- Got what we asked for
			  finalize = true
			  --[===[@debug@
			  debug ("Got inspection data for requested guid "..guid) --@end-debug@]===]
			end

			local mainq, staleq = self.state.mainq, self.state.staleq
			mainq[guid], staleq[guid] = nil, nil

			local gspec_id = GetInspectSpecialization (unit)
			if not self.static_cache.global_specs[gspec_id] then -- Bah, got garbage, flag as stale and try again
			  staleq[guid] = 1
			  return
			end

			self.events:Fire (UPDATE_EVENT, guid, unit, self:BuildInfo (unit))
			self.events:Fire (INSPECT_READY_EVENT, guid, unit)
		  end
		  if finalize then
			ClearInspectPlayer ()
		  end
		  self.events:Fire (QUEUE_EVENT)
		end


		function LibInspect:PLAYER_ENTERING_WORLD ()
		  if self.commScope == "INSTANCE_CHAT" then
			-- Handle moving directly from one LFG to another
			self.commScope = nil
			self:UpdateCommScope ()
		  end
		end


		-- Group handling parts

		local members = {}
		function LibInspect:GROUP_ROSTER_UPDATE ()
		  local group = self.cache
		  local units = self:GroupUnits ()
		  -- Find new members
		  for i,unit in ipairs (self:GroupUnits ()) do
			local guid = UnitGUID (unit)
			if guid then
			  members[guid] = true
			  if not group[guid] then
				self:Query (unit)
				-- Update with what we have so far (guid, unit, name/class/race?)
				self.events:Fire (UPDATE_EVENT, guid, unit, self:BuildInfo (unit))
			  end
			end
		  end
		  -- Find removed members
		  for guid in pairs (group) do
			if not members[guid] then
			  group[guid] = nil
			  self.events:Fire (REMOVE_EVENT, guid, nil)
			end
		  end
		  wipe (members)
		  self:UpdateCommScope ()
		end


		function LibInspect:DoPlayerUpdate ()
		  self:Query ("player")
		  self.state.debounce_send_update = 2.5 -- Hold off 2.5sec before sending update
		  self.frame:Show ()
		end


		function LibInspect:SendLatestSpecData ()
		  local scope = self.commScope
		  if not scope then return end

		  local guid = UnitGUID ("player")
		  local info = self.cache[guid]
		  if not info then return end

		  -- fmt, guid, global_spec_id, talent1 -> MAX_TALENT_TIERS, pvptalent1 -> NUM_PVP_TALENT_SLOTS
		  -- sequentially, allow no gaps for missing talents we decode by index on the receiving end.
		  local datastr = COMMS_FMT..COMMS_DELIM..guid..COMMS_DELIM..(info.global_spec_id or 0)
		  local talentCount = 1
		  for k in pairs(info.talents) do
			datastr = datastr..COMMS_DELIM..k
			talentCount = talentCount + 1
		  end
		  for i=talentCount,MAX_TALENT_TIERS do
			datastr = datastr..COMMS_DELIM..0
		  end
		  talentCount = 1
		  for k in pairs(info.pvp_talents) do
			datastr = datastr..COMMS_DELIM..k
			talentCount = talentCount + 1
		  end
		  for i=talentCount,NUM_PVP_TALENT_SLOTS do
			datastr = datastr..COMMS_DELIM..0
		  end

		  --[===[@debug@
		  debug ("Sending LGIST update to "..scope) --@end-debug@]===]
		  SendAddonMessage(COMMS_PREFIX, datastr, scope)
		end


		function LibInspect:UpdateCommScope ()
		  local scope = (IsInGroup (LE_PARTY_CATEGORY_INSTANCE) and "INSTANCE_CHAT") or (IsInRaid () and "RAID") or (IsInGroup (LE_PARTY_CATEGORY_HOME) and "PARTY")
		  if self.commScope ~= scope then
			self.commScope = scope
			self:DoPlayerUpdate ()
		  end
		end


		-- Indicies for various parts of the split data msg
		local msg_idx = {}
		msg_idx.fmt             = 1
		msg_idx.guid            = msg_idx.fmt + 1
		msg_idx.global_spec_id  = msg_idx.guid + 1
		msg_idx.talents         = msg_idx.global_spec_id + 1
		msg_idx.end_talents     = msg_idx.talents + MAX_TALENT_TIERS
		msg_idx.pvp_talents     = msg_idx.end_talents + 1
		msg_idx.end_pvp_talents = msg_idx.pvp_talents + NUM_PVP_TALENT_SLOTS - 1

		function LibInspect:CHAT_MSG_ADDON (prefix, datastr, scope, sender)
		  if prefix ~= COMMS_PREFIX or scope ~= self.commScope then return end
		  --[===[@debug@
		  debug ("Incoming LGIST update from "..(scope or "nil").."/"..(sender or "nil")..": "..(datastr:gsub(COMMS_DELIM,";") or "nil")) --@end-debug@]===]

		  local data = { strsplit (COMMS_DELIM,datastr) }
		  local fmt = data[msg_idx.fmt]
		  if fmt ~= COMMS_FMT then return end -- Unknown format, ignore

		  local guid = data[msg_idx.guid]

		  local senderguid = UnitGUID(sender)
		  if senderguid and senderguid ~= guid then return end

		  local info = guid and self.cache[guid]
		  if not info then return end -- Never allow random message to create new group member entries!

		  local unit = self:GuidToUnit (guid)
		  if not unit then return end
		  if UnitIsUnit (unit, "player") then return end -- we're already up-to-date, comment out for solo debugging

		  self.state.throttle = self.state.throttle + 1
		  self.frame:Show () -- Ensure we're unthrottling
		  if self.state.throttle > 40 then return end -- If we ever hit this, someone's being "funny"

		  info.class_localized, info.class, info.race_localized, info.race, info.gender, info.name, info.realm = GetPlayerInfoByGUID (guid)
		  if info.realm and info.realm == "" then info.realm = nil end
		  info.class_id = self.static_cache.class_to_class_id[info.class]

		  local gspecs = self.static_cache.global_specs

		  local gspec_id           = data[msg_idx.global_spec_id] and tonumber (data[msg_idx.global_spec_id])
		  if not gspec_id or not gspecs[gspec_id] then return end -- Malformed message, avoid throwing errors by using this nil

		  info.global_spec_id      = gspec_id
		  info.spec_index          = gspecs[gspec_id].idx
		  info.spec_name_localized = gspecs[gspec_id].name_localized
		  info.spec_description    = gspecs[gspec_id].description
		  info.spec_icon           = gspecs[gspec_id].icon
		  info.spec_background     = gspecs[gspec_id].background
		  info.spec_role           = gspecs[gspec_id].role
		  info.spec_role_detailed  = global_spec_id_roles_detailed[gspec_id]

		  local need_inspect = nil -- shouldn't be needed, but just in case
		  info.talents = wipe (info.talents or {})
		  for i = msg_idx.talents, msg_idx.end_talents do
			local talent_id = tonumber (data[i]) or 0
			if talent_id > 0 then
			  local talent = self:GetCachedTalentInfoByID (talent_id)
			  if talent then
				info.talents[talent_id] = talent
			  else
				need_inspect = 1
			  end
			end
		  end

		  info.pvp_talents = wipe (info.pvp_talents or {})
		  for i = msg_idx.pvp_talents, msg_idx.end_pvp_talents do
			local talent_id = tonumber (data[i]) or 0
			if talent_id > 0 then
			  local talent = self:GetCachedPvpTalentInfoByID (talent_id)
			  if talent then
				info.pvp_talents[talent_id] = talent
			  else
				need_inspect = 1
			  end
			end
		  end

		  info.glyphs = info.glyphs or {} -- kept for addons that still refer to this

		  local mainq, staleq = self.state.mainq, self.state.staleq
		  local want_inspect = not need_inspect and self.inspect_ready_used and (mainq[guid] or staleq[guid]) and 1 or nil
		  mainq[guid], staleq[guid] = need_inspect, want_inspect
		  if need_inspect or want_inspect then self.frame:Show () end

		  --[===[@debug@
		  debug ("Firing LGIST update event for unit "..unit..", GUID "..guid..", inspect "..tostring(not not need_inspect)) --@end-debug@]===]
		  self.events:Fire (UPDATE_EVENT, guid, unit, info)
		  self.events:Fire (QUEUE_EVENT)
		end


		function LibInspect:UNIT_LEVEL (unit)
		  if UnitInRaid (unit) or UnitInParty (unit) then
			self:Refresh (unit)
		  end
		  if UnitIsUnit (unit, "player") then
			self:DoPlayerUpdate ()
		  end
		end


		function LibInspect:PLAYER_TALENT_UPDATE ()
		  self:DoPlayerUpdate ()
		end


		function LibInspect:PLAYER_SPECIALIZATION_CHANGED (unit)
		--  This event seems to fire a lot, and for no particular reason *sigh*
		--  if UnitInRaid (unit) or UnitInParty (unit) then
		--    self:Refresh (unit)
		--  end
		  if unit and UnitIsUnit (unit, "player") then
			self:DoPlayerUpdate ()
		  end
		end


		function LibInspect:UNIT_NAME_UPDATE (unit)
		  local group = self.cache
		  local guid = UnitGUID (unit)
		  local info = guid and group[guid]
		  if info then
			self:UpdatePlayerInfo (guid, unit, info)
			if info.name ~= UNKNOWN then
			  self.events:Fire (UPDATE_EVENT, guid, unit, info)
			end
		  end
		end


		-- Always get a UNIT_AURA when a unit's UnitIsVisible() changes
		function LibInspect:UNIT_AURA (unit)
		  local group = self.cache
		  local guid = UnitGUID (unit)
		  local info = guid and group[guid]
		  if info then
			if not UnitIsUnit (unit, "player") then
			  if UnitIsVisible (unit) then
				if info.not_visible then
				  info.not_visible = nil
				  --[===[@debug@
				  debug (unit..", aka "..(UnitName(unit) or "nil")..", is now visible") --@end-debug@]===]
				  if not self.state.mainq[guid] then
					self.state.staleq[guid] = 1
					self.frame:Show ()
					self.events:Fire (QUEUE_EVENT)
				  end
				end
			  elseif UnitIsConnected (unit) then
				--[===[@debug@
				if not info.not_visible then
				  debug (unit..", aka "..(UnitName(unit) or "nil")..", is no longer visible")
				end
				--@end-debug@]===]
				info.not_visible = true
			  end
			end
		  end
		end


		function LibInspect:UNIT_SPELLCAST_SUCCEEDED (unit, _, spell_id)
		  if spell_id == 200749 then -- Activating Specialization
			self:Query (unit) -- Definitely changed, so high prio refresh
		  end
		end


		-- External LibInspectrary functions

		function LibInspect:QueuedInspections ()
		  local q = {}
		  for guid in pairs (self.state.mainq) do
			table.insert (q, guid)
		  end
		  return q
		end


		function LibInspect:StaleInspections ()
		  local q = {}
		  for guid in pairs (self.state.staleq) do
			table.insert (q, guid)
		  end
		  return q
		end


		function LibInspect:IsInspectQueued (guid)
		  return guid and ((self.state.mainq[guid] or self.state.staleq[guid]) and true)
		end


		function LibInspect:GetCachedInfo (guid)
		  local group = self.cache
		  return guid and group[guid]
		end


		function LibInspect:Rescan (guid)
		  local mainq, staleq = self.state.mainq, self.state.staleq
		  if guid then
			local unit = self:GuidToUnit (guid)
			if unit then
			  if UnitIsUnit (unit, "player") then
				self.events:Fire (UPDATE_EVENT, guid, "player", self:BuildInfo ("player"))
			  elseif not mainq[guid] then
				staleq[guid] = 1
			  end
			end
		  else
			for i,unit in ipairs (self:GroupUnits ()) do
			  if UnitExists (unit) then
				if UnitIsUnit (unit, "player") then
				  self.events:Fire (UPDATE_EVENT, UnitGUID("player"), "player", self:BuildInfo ("player"))
				else
				  local guid = UnitGUID (unit)
				  if guid and not mainq[guid] then
					staleq[guid] = 1
				  end
				end
			  end
			end
		  end
		  self.frame:Show () -- Start timer if not already running

		  -- Evict any stale entries
		  self:GROUP_ROSTER_UPDATE ()
		  self.events:Fire (QUEUE_EVENT)
		end


		local unitstrings = {
		  raid = { "player" }, -- This seems to be needed under certain circumstances. Odd.
		  party = { "player" }, -- Player not part of partyN
		  player = { "player" }
		}
		for i = 1,40 do table.insert (unitstrings.raid, "raid"..i) end
		for i = 1,4  do table.insert (unitstrings.party, "party"..i) end


		-- Returns an array with the set of unit ids for the current group
		function LibInspect:GroupUnits ()
		  local units
		  if IsInRaid () then
			units = unitstrings.raid
		  elseif GetNumSubgroupMembers () > 0 then
			units = unitstrings.party
		  else
			units = unitstrings.player
		  end
		  return units
		end


		-- If demand-loaded, we need to synthesize a login event
		if IsLoggedIn () then LibInspect:PLAYER_LOGIN () end

		_G['LibInspect'] = LibInspect

	end)

	--good vs bad area triggers, dispaly good when needs soaked
	Squid_areaTrigger = {

		--Player
		[2947] = {size = 7.75, good = function(obj) return unit_is_unit("player", ObjectCreator(obj)) end}, -- rune of power

		--TESTING
		-- [7020] = {size = 1}, -- monk chi sphere
		-- [3319] = {size = 1} -- monk hp sphere
		--[18040] = {size = 2}, -- trink test
	   -- [10801] = {size = 8, good = true},
	   -- [10801] = {size = 8, good = true}, -- test flame patch

	   --RANDOM SHIT

		-- [48006,48296,48300,48294] = {size = 2, good = true} -- food things from cookie (these are objects not area triggers)

		--BOD
		[20327] = {size = 3}, -- Jaina tornado
		[20310] = {size = 1.5}, -- Jaina cube

		--TOL DAGOR
		[16682] = {size = 3},   -- TD - Sandwwwawd

		-- FREEHOLD
		[18148] = {size = 5}, -- whirlpool of blades shit fh 2nd boss
		-- 130099 -- freehjold pig obj id
		-- 129448 129359 freehold sharks notouch
		-- 161408 combat whitelist little shits on ground with miniboss

		-- SEIGE OF BORALUS
		[18385] = {size = 1.5}, -- SoB - Bananas

		-- KING'S REST
		-- [17933] = {size = 2}, -- KR white tornado swirlies

		-- ATAL DAZAR
		[16644] = {size = 3.5}, -- AD skeleton dinos pre trigger
		[16862] = {size = 3.25}, -- AD green goo circles
		[125868] = {size = 3},  -- AD Spiderz
		-- 16029 AD goo boss green goo ~2.5-3 yd (shit ton of them, too annoying to actually add)
		[17056] = {size = 3.5, good = true}, -- AD eat blood pool
		[16553] = {size = 3.5, good = true}, -- AD eat blood pool
		[16860] = {size = 2}, -- gold balls alunza 2 yd
		[16013] = {size = 4}, -- 16013 purple circles left on ground last boss AD 4 yd (last boss spiders are game objects or units, not aoetriggers)

		-- UNDERROT
		[17026] = {size = 2, good = true}, -- 2nd boss blood ticks
		[138538] = {size = 3.5}, -- faceless tentacle spawns short range cleave

		-- MECHAGON WORKSHOP
		[19739] = {size = 3}, -- blades in mecha ~ 3 yd
		[20025] = {size = 2.5}, -- bomb going off in mecha ~2.5 yd
		[19968] = {size = 2}, -- swirling gears on machinist boss (los whitelist this guy..)
		[20825] = {size = 3, good = true}, -- GOOD shield generator things, stand in this shit
		[20605] = {size = 2},-- little zappy circles phase 1 last boss 2 yds
		-- 20030 i believe is the hidden flame cannon area trigger but it's just the center thing

		-- PLAYERS / PVP
		[10471] = {size = 10, parent = 100943, good = "owner"}, -- earthen wall totem

		-- HORRIFIC VISION OF ORGRIMMAR
		[21726] = {size = 3.5}, -- Rexxar Traps
		[21717] = {size = 3}, -- Rexxar Sha Army
		[21958] = {size = 3.5}, -- Ring of Chaos Orbs (Vez'okk the Lightless)
		[23000] = {size = 1.5, good = true}, -- Promised Power Dmg Buff
		[21175] = {size = 2, good = true}, -- hopelessness gold thing
		-- [4520] = {size = 5}, -- Haunting Shadows Affix (Fears if you stand in it) (shared object id w/ bloodthirsty affix?)

		--HORRIFIC VISION OF STORMWIND


	}

	Squid_cleaveCasts = {

		--test
		-- [2948] = {type = "rect", range = 25, width = 5, targeted=true},

		--randomshit
		[198497] = {type = "rect", range = 25, width = 10},  -- dh starting zone shit
		[200425] = {type = "cone", angle = 50, range = 16},  -- dh starting zone shit
		[250490] = {type = "cone", angle = 45, range = 6},  -- animated strike
		[276876] = {type = "cone", angle = 50, range = 12.75}, -- DH
		[312262] = {type = "rect", range = 8, width = 4},  -- Sonic Scream (Random ass mob idk)
		[309061] = {type = "cone", angle = 180, range = 12}, -- Straight Forward --dire cleave baruk protector (each different spellid is cast at a different angle)
		[309062] = {type = "cone", angle = 180, range = 13, direction = 270}, -- To the right
		[309063] = {type = "cone", angle = 180, range = 13, direction = 90}, -- To the left
		[256709] = {type = "cone", angle = 45, range = 5},-- >.>
		[257036] = {type = "cone", angle = 45, range = 5},-- <.<
		[261488] = {type = "rect", range = 15, width = 5},--random mob charge

		[258864] = {type = "cone", angle = 45, range = 5},-- td thrash  suppression fire
		[256955] = {type = "cone", angle = 45, range = 5},-- td 2nd boss
		[259711] = {type = "cone", angle = 360, range = 6},-- block warden aoe cleave
		[288694] = {type = "cone", angle = 45, range = 5},-- Reaping smash https://www.wowhead.com/spell=288694/shadow-smash

		------------------------Uldir-------------------------------------------
		[273538] = {type = "rect", range = 40, width = 6}, --mytrax
		[274113] = {type = "rect", range = 40, width = 6}, --mytrax transmission lazor
		[272115] = {type = "rect", range = 40, width = 6}, --mytrax p2 beam
		[273282] = {type = "cone", angle = 60, range = 18}, --mytrax
		[265264] = {type = "cone", angle = 60, range = 18},-- zekvoz boss cleave
		[267787] = {type = "cone", angle = 40, range = 15},-- 2nd boss cleave
		[262292] = {type = "cone", angle = 60, range = 20},-- fetid cleave

		------------------------BoD----------------------------------------------
		[285177] = {type = "rect", range = 40, width = 7},-- Jaina https://www.wowhead.com/spell=285177/freezing-blast
		[288345] = {type = "rect", range = 40, width = 5},-- Jaina https://www.wowhead.com/spell=288345/glacial-ray
		[282153] = {type = "rect", range = 40, width = 6},-- High Tinker Mekkatorque https://www.wowhead.com/spell=282153/buster-cannon
		[283606] = {type = "cone", angle = 45, range = 15},-- Opulence https://www.wowhead.com/spell=283606/crush
		[289906] = {type = "cone", angle = 45, range = 15},-- Opulence https://www.wowhead.com/spell=289906/crush
		[282939] = {type = "cone", angle = 40, range = 15},-- Opulence https://www.wowhead.com/spell=282939/flames-of-punishment
		[287659] = {type = "cone", angle = 40, range = 15},-- Opulence https://www.wowhead.com/spell=287659/flames-of-punishment
		[283063] = {type = "cone", angle = 40, range = 15},-- Opulence https://www.wowhead.com/spell=283063/flames-of-punishment
		[287513] = {type = "cone", angle = 40, range = 15},-- Opulence https://www.wowhead.com/spell=287513/flames-of-punishment
		[283587] = {type = "rect", range = 60, width = 5},-- Champion of the Light https://www.wowhead.com/spell=283587/wave-of-light
		[283598] = {type = "rect", range = 60, width = 5},-- Champion of the Light https://ptr.wowhead.com/spell=283598/wave-of-light
		[289572] = {type = "rect", range = 20, width = 3},-- Trash charge https://www.wowhead.com/spell=289572/charge
		[285893] = {type = "cone", angle = 90, range = 10},-- Gonk Wild Maul https://www.wowhead.com/spell=285893/wild-maul
		[289560] = {type = "cone", angle = 90, range = 12},-- Kimbul Lacerating Claws https://www.wowhead.com/spell=282444/lacerating-claws
		[285178] = {type = "rect", range = 45, width = 10},-- Rastakhan Serpent Totem https://www.wowhead.com/spell=285178/serpents-breath
		-- [270833] = {type = "rect", range = 25, width = 10},-- tests
		-- [270839] = {type = "cone", angle = 90, range = 12},-- tests

		------------------------CoS----------------------------------------------
		[282589] = {type = "cone", angle = 30, range = 45},-- The Restless Cabal https://www.wowhead.com/spell=282589/cerebral-assault
		-- [51505] = {type = "cone", angle = 75, range = 30}, -- test bolt
		-- [51505] = {type = "rect", range = 40, width = 3}, -- test bolt

		------------------------Visions-----------------------------------------

		-- Stormwind
		[308481] = {type = "rect", range = 25, width = 5}, -- Rift Strike Tentacle Cone
		[309671] = {type = "cone", angle = 25, range = 15}, -- Empowered Forge Breath

		-- Orgrimmar

		------------------------Ny'Alotha------------------------------------
		[311574] = {type = "rect", range = 30, width = 5}, -- Monstrous Cleave
		[310396] = {type = "rect", range = 35, width = 5, startingpoint = 5}, -- Void Glare Drest'agath
		[309961] = {type = "rect", range = 100, width = 20, startingpoint = 3}, -- Eye of Nzoth Il'gynoth

		------------------------Mythic Plus--------------------------------------

		-- ATAL'DAZAR
		[253239] = {type = "rect", range = 15, width = 5}, -- AD juggernaut merciless assault forward cone dash 5 yd width ~15 yd range
		[253279] = {type = "rect", range = 15, width = 5}, -- AD juggernaut merciless assault forward cone dash 5 yd width ~15 yd range

		-- MECHAGON: JUNKYARD
		[300777] = {type = "rect", range = 35, width = 5}, -- https://www.wowhead.com/spell=300777/slimewave - Green Slime Charge
		[300188] = {type = "rect", range = 35, width = 4, targeted = true}, -- https://www.wowhead.com/spell=300188/scrap-cannon - Crawler Kameha
		[299475] = {type = "rect", range = 30, width = 6.5}, -- https://www.wowhead.com/spell=299475/b-o-r-k - B.O.R.K
		[300424] = {type = "rect", range = 25, width = 5.5}, -- Big Trogg Shockwave (this one sends area triggers forward could add those)
		[299164] = {type = "rect", range = 40, width = 6}, -- Pedal to the Metal (Motorcycle Charge) https://www.wowhead.com/spell=299164/pedal-to-the-metal
		[298651] = {type = "rect", range = 40, width = 6}, -- Pedal to the Metal (Motorcycle Charge 2) https://www.wowhead.com/spell=298651/pedal-to-the-metal

		-- MECHAGON: WORKSHOP
		[291928] = {type = "rect", range = 40, width = 3, targeted = true}, -- giga zap phase 1 = rect 3 yd 40 yd range
		[297128] = {type = "cone", angle = 360, range = 9}, -- short out cast 8 yd circle around unit ( 294185 may be channel id ? )
		[294185] = {type = "cone", angle = 360, range = 9}, -- ^ same
		[293986] = {type = "rect", range = 26, width = 6}, -- 293986 sonic pulse 6 yd rect unknown range check wowhead
		-- 294291 / 294290 Process Waste Channeled? by waste processing unit cone 8 yd 35 degree angle

		-- KING'S REST
		[270487] = {type = "cone", angle = 45, range = 5}, -- https://www.wowhead.com/spell=270487/severing-blade - Berserker Cleave
		[270507] = {type = "cone", angle = 60, range = 20, targeted = true}, -- https://www.wowhead.com/spell=270507/poison-barrage - Poison Barrage
		[270003] = {type = "cone", angle = 65, range = 30}, -- kr robots aoe
		[270502] = {type = "cone", angle = 80, range = 9},  -- hunting leap dinos
		-- [270284] = {type = "rect", range = 55, width = 3}, -- purification beam

		-- WAYCREST MANOR
		[265372] = {type = "cone", angle = 45, range = 5}, -- wm thrash cleave
		[271174] = {type = "cone", angle = 45, range = 5}, --
		[264923] = {type = "cone", angle = 90, range = 25}, -- wm pig boss cleave

		-- THE UNDERROT
		[265540] = {type = "cone", angle = 40, range = 30}, -- https://www.wowhead.com/spell=265540/rotten-bile - Maggot Spit
		[265019] = {type = "cone", angle = 55, range = 7}, -- https://www.wowhead.com/spell=265019/savage-cleave - Matron Cleave
		[260894] = {type = "rect", range = 40, width = 5}, -- https://www.wowhead.com/spell=260894/creeping-rot - 1st Boss Green Kameha
		[272609] = {type = "rect", range = 45, width = 5}, -- https://www.wowhead.com/spell=272609/maddening-gaze - Faceless Fear Kameha
		[260292] = {type = "rect", range = 30, width = 7}, -- 2nd boss charge
		[272457] = {type = "cone", angle = 55, range = 17.5}, -- 3rd boss shockwave
		[269843] = {type = "cone", angle = 45, range = 5}, -- ur last boss upheaval

		-- FREEHOLD
		[257426] = {type = "cone", angle = 60, range = 10}, -- https://www.wowhead.com/spell=257426/brutal-backhand - Enforcer Melee Cleave
		[257784] = {type = "cone", angle = 30, range = 15, targeted=true}, -- https://www.wowhead.com/spell=257784/frost-blast - Bilge Rat Frost Cone
		[274400] = {type = "rect", range = 30, width = 5}, -- https://www.wowhead.com/spell=274400/duelist-dash - Duelist Charge + Stun
		[257870] = {type = "cone", angle = 360, range = 4}, -- https://www.wowhead.com/spell=257870/blade-barrage
		[256589] = {type = "cone", angle = 360, range = 10}, -- https://www.wowhead.com/spell=256589/barrel-smash - Barrel Smash Raoul
		[258381] = {type = "cone", angle = 45, range = 5}, -- https://www.wowhead.com/spell=258381/grapeshot - FIX ME ( Not a cast )
		[258352] = {type = "cone", angle = 45, range = 5}, -- ^ SAME

		-- SHRINE OF THE STORM
		[276268] = {type = "cone", angle = 45, range = 10},-- SotS Templar melee cleave
		[264101] = {type = "rect", range = 30, width = 12},-- SotS aqua boss charge
		[267899] = {type = "cone", angle = 45, range = 5},-- SotS 2nd boss melee cleave
		[267385] = {type = "rect", range = 15, width = 5},-- tentacle cast last boss SotS

		-- THE MOTHERLODE!!
		[257337] = {type = "cone", angle = 45, range = 40},-- ML 1st boss cone
		[268415] = {type = "cone", angle = 45, range = 5},-- ML trash cleave
		[268846] = {type = "cone", angle = 45, range = 5},-- ml trash cleave
		[275907] = {type = "cone", angle = 50, range = 25},-- ML tectonic smash
		[269313] = {type = "cone", angle = 360, range = 8},-- ml final blast
		[268865] = {type = "rect", range = 20, width = 5},-- force cannon
		[262804] = {type = "cone", angle = 45, range = 5},--
		[260669] = {type = "rect", range = 20, width = 3},--ml rixxa pewpew ??

		-- TEMPLE OF SETHRALISS ( cc knot of snakes: added )
		[264574] = {type = "rect", range = 40, width = 3}, -- ToS power shot
		[263309] = {type = "cone", angle = 50, range = 40}, -- ToS 1st boss Cyclone Strike
		[263573] = {type = "cone", angle = 50, range = 40}, --Tos 1st boss stuff
		-- [263912] = {type = "cone", angle = 45, range = 40}, --TOS 2nd boss green poo
		[255741] = {type = "cone", angle = 45, range = 8}, --TOS rider melee
		[273995] = {type = "cone", angle = 360, range = 10}, --TOS Pyrrhic Blast
		[272657] = {type = "cone", angle = 60, range = 20}, -- tos thrashe aoe green stuff
		[272655] = {type = "cone", angle = 45, range = 10}, -- little crab sand blast thing

		-- SIEGE OF BORALUS
		[261563] = {type = "rect", range = 40, width = 6.5, startingpoint = 3}, -- 3rd Boss Kamehameha Ice Shit
		[256627] = {type = "cone", angle = 45, range = 5}, -- SoB Halberd cleave
		[257292] = {type = "rect", range = 45, width = 6}, -- https://www.wowhead.com/spell=257292/heavy-slash SoB 1st boss melee cleave
		[279761] = {type = "rect", range = 45, width = 6}, -- ^ Same
		[272874] = {type = "rect", range = 40, width = 6.5}, -- SoB Horse Trample
		[268260] = {type = "cone", angle = 55, range = 25}, -- SoB Cannoneer bambam
		[269029] = {type = "cone", angle = 45, range = 5}, -- SoB 2nd boss cleave 45
		[272827] = {type = "cone", angle = 45, range = 5}, -- SoB Pillager poison aoe
		[269266] = {type = "cone", angle = 30, range = 27.25}, -- SoB last boss tentacle slam
		[272711] = {type = "rect", range = 45, width = 8}, -- SoB Crushing Slam https://www.wowhead.com/spell=272711/crushing-slam
		[268230] = {type = "cone", angle = 45, range = 5}, -- SoB thrash cleave crimson swipe
		[268391] = {type = "cone", angle = 48, range = 12},-- SoB cultist aoe stun

		------------------------Visions------------------------------------------

		-- Orgrimmar
		[306726] = {type = "rect", range = 35, width = 8}, -- Defiled Ground (Stuns when hit and leaves behind Purple Dmg Things)
		[306828] = {type = "rect", range = 35, width = 8}, -- Defiled Ground (Stuns when hit and leaves behind Purple Dmg Things)
		[297746] = {type = "rect", range = 30, width = 8}, -- Seismic Slam (Thrall Ability, Stuns and drains sanity)
		[300351] = {type = "rect", range = 30, width = 8}, -- Surging Fist (Decimator Shiq'Voth)
		[304969] = {type = "rect", range = 30, width = 3.5}, -- Void Torrent (Inquisitor Gnafhafafk)

		-- Stormwind
		[311456] = {type = "cone", angle = 30, range = 20}, -- Roaring Blast (Old Town Armsmaster Terenson Big Sanity Drain Conal Blast)

		------------SL DUNG-------------------

		-- Plaguefall
		[324667] = {type = "cone", angle = 30, range = 30}, -- Slime Wave (1st boss cone)
		[318949] = {type = "cone", angle = 45, range = 12}, -- Festering Belch Cone

		-- Halls of Atonement
		[346866] = {type = "cone", angle = 45, range = 15}, -- Stone Breath
		[322936] = {type = "rect", range = 8, width = 10}, -- Crumbling Slam

		------------TORGHAST----------------------

		[292903] = {type = "cone", angle = 50, range = 7.5}, -- Massive Strike
		[295932] = {type = "rect", range = 40, width = 5}, -- Hulking Charge

		------------------------PVP----------------------------------------------
		-- [113656] = {type = "cone", angle = 120, range = 8, player = true}, --Fists of Fury (Windwalker Monk)

		 --test
		-- [116] = {type = "cone", angle = 60, range = 20},-- test
		-- [190356] = {type = "rect", range = 40, width = 6.5, startingpoint = 3}, -- test
		-- [116] = {type = "rect", range = 40, width = 6.5, startingpoint = 3}, -- test

		-- random shit
		[346506] = {type = "rect", range = 25, width = 5}, -- Molten Inferno

	}

	for k, v in pairs(Squid_cleaveCasts) do
		v.direction = v.direction or 0
		if v.direction > 0 then v.direction = v.direction * math.pi/180 end
	end


	-- convert api for WoWAdvanced
	if InternetRequest then
		ObjectPosition = GetUnitPosition
		UnitMovementFlags = GetUnitMovementFlags

		ObjectTypes = {
			-- Object = wmbapi.GetObjectTypeFlagsTable().Object,
			-- Item = wmbapi.GetObjectTypeFlagsTable().Item,
			-- Container = wmbapi.GetObjectTypeFlagsTable().Container,
			-- AzeriteEmpoweredItem = wmbapi.GetObjectTypeFlagsTable().AzeriteEmpoweredItem,
			-- AzeriteItem = wmbapi.GetObjectTypeFlagsTable().AzeriteItem,
			-- Unit = wmbapi.GetObjectTypeFlagsTable().Unit,
			-- Player = wmbapi.GetObjectTypeFlagsTable().Player,
			-- ActivePlayer = wmbapi.GetObjectTypeFlagsTable().ActivePlayer,
			-- GameObject = wmbapi.GetObjectTypeFlagsTable().GameObject,
			-- DynamicObject = wmbapi.GetObjectTypeFlagsTable().DynamicObject,
			-- Corpse = wmbapi.GetObjectTypeFlagsTable().Corpse,
			-- AreaTrigger = wmbapi.GetObjectTypeFlagsTable().AreaTrigger,
			-- SceneObject = wmbapi.GetObjectTypeFlagsTable().SceneObject,
			-- ConversationData = wmbapi.GetObjectTypeFlagsTable().Conversation
		}
		ObjectType = ObjectTypes

		MovementFlags = {
			-- Forward = wmbapi.GetUnitMovementFlagsTable().Forward,
			-- Backward = wmbapi.GetUnitMovementFlagsTable().Backward,
			-- StrafeLeft = wmbapi.GetUnitMovementFlagsTable().StrafeLeft,
			-- StrafeRight = wmbapi.GetUnitMovementFlagsTable().StrafeRight,
			-- TurnLeft = wmbapi.GetUnitMovementFlagsTable().TurnLeft,
			-- TurnRight = wmbapi.GetUnitMovementFlagsTable().TurnRight,
			-- PitchUp = wmbapi.GetUnitMovementFlagsTable().PitchUp,
			-- PitchDown = wmbapi.GetUnitMovementFlagsTable().PitchDown,
			-- Walking = wmbapi.GetUnitMovementFlagsTable().Walking,
			-- Immobilized = wmbapi.GetUnitMovementFlagsTable().Immobilized,
			-- Falling = wmbapi.GetUnitMovementFlagsTable().Falling,
			-- FallingFar = wmbapi.GetUnitMovementFlagsTable().FallingFar,
			-- Swimming = wmbapi.GetUnitMovementFlagsTable().Swimming,
			-- Ascending = wmbapi.GetUnitMovementFlagsTable().Ascending,
			-- Descending = wmbapi.GetUnitMovementFlagsTable().Descending,
			-- CanFly = wmbapi.GetUnitMovementFlagsTable().CanFly,
			-- Flying = wmbapi.GetUnitMovementFlagsTable().Flying,
		}
		Types = {
			-- Bool = wmbapi.GetValueTypesTable().Bool,
			-- Char = wmbapi.GetValueTypesTable().Char,
			-- Byte = wmbapi.GetValueTypesTable().Byte,
			-- Short = wmbapi.GetValueTypesTable().Short,
			-- UShort = wmbapi.GetValueTypesTable().UShort,
			-- Int = wmbapi.GetValueTypesTable().Int,
			-- UInt = wmbapi.GetValueTypesTable().UInt,
			-- Long = wmbapi.GetValueTypesTable().Long,
			-- ULong = wmbapi.GetValueTypesTable().ULong,
			-- Float = wmbapi.GetValueTypesTable().Float,
			-- Double = wmbapi.GetValueTypesTable().Double,
			-- String = wmbapi.GetValueTypesTable().String,
			-- GUID = wmbapi.GetValueTypesTable().GUID,
		}
		HitFlags = {
			M2Collision = 0x1,
			M2Render = 0x2,
			WMOCollision = 0x10,
			WMORender = 0x20,
			Terrain = 0x100,
			WaterWalkableLiquid = 0x10000,
			Liquid = 0x20000,
			EntityCollision = 0x100000,
		}
		GetDistanceBetweenPositions = function(X1, Y1, Z1, X2, Y2, Z2) return math.sqrt(math.pow(X2 - X1, 2) + math.pow(Y2 - Y1, 2) + math.pow(Z2 - Z1, 2)) end
		GetAnglesBetweenObjects = function(obj1, obj2) local X1, Y1, Z1 = ObjectPosition(obj1) local X2, Y2, Z2 = ObjectPosition(obj2) return math.atan2(Y2 - Y1, X2 - X1) % (math.pi * 2), math.atan((Z1 - Z2) / math.sqrt(math.pow(X1 - X2, 2) + math.pow(Y1 - Y2, 2))) % math.pi end
		GetPositionBetweenObjects = function(obj1,obj2,dist)
			local X1,Y1,Z1 = ObjectPosition(obj1)
			local X2,Y2,Z2 = ObjectPosition(obj2)
			local AngleXY, AngleXYZ = math.atan2(Y2 - Y1, X2 - X1) % (math.pi * 2), math.atan((Z1 - Z2) / math.sqrt(math.pow(X1 - X2, 2) + math.pow(Y1 - Y2, 2))) % math.pi
			return math.cos(AngleXY) * dist + X1, math.sin(AngleXY) * dist + Y1, math.sin(AngleXYZ) * dist + Z1
		end
		GetPositionFromPosition = function(X, Y, Z, dist, angle) return math.cos(angle) * dist + X, math.sin(angle) * dist + Y, math.sin(0) * dist + Z end
		GetPositionBetweenPositions = function(X1, Y1, Z1, X2, Y2, Z2, DistanceFromPosition1) local AngleXY, AngleXYZ = GetAnglesBetweenPositions(X1, Y1, Z1, X2, Y2, Z2) return GetPositionFromPosition(X1, Y1, Z1, DistanceFromPosition1, AngleXY, AngleXYZ) end
		GetAnglesBetweenPositions = function(X1, Y1, Z1, X2, Y2, Z2)
			return math.atan2(Y2 - Y1, X2 - X1) % (math.pi * 2), math.atan((Z1 - Z2) / math.sqrt(math.pow(X1 - X2, 2) + math.pow(Y1 - Y2, 2))) % math.pi
		end
	end

	local function convert_lb_api()

		function GetMapId()
			return lb.GetMapId()
		end

		function IsMeshLoaded()
			return true
		end

		function GetWoWDirectory()
			return lb.GetGameDirectory()
		end

		function GetSubdirectories(path)
			return lb.GetDirectories(path)
		end

		function ObjectPosition(unit)
			return lb.ObjectPosition(unit)
		end

		function ObjectPointer(unit)
			-- return lb.ObjectPointer(unit) -- can't pass this to any api ???
			if not unit then return end
			return UnitGUID(unit)
		end

		function UnitCastID(unit)
			local castID,castTarget = lb.unit_casting_info(unit)
			local channelID,channelTarget = lb.UnitChannelInfo(unit)
			if castID ~= 0 then
				return castID, 0, castTarget, nil
			end
			if channelID ~= 0 then
				return 0, channelID, nil, channelTarget
			end
			return 0, 0, nil, nil
		end

		function IsForeground()
			return true
		end

		function GetDistanceBetweenPositions(sx, sy, sz, ex, ey, ez)
			return lb.GetDistance3D(sx, sy, sz, ex, ey, ez)
		end

		function GetDistanceBetweenObjects(object1, object2)
			return lb.GetDistance3D(object1, object2)
		end

		function UnitCombatReach(unit)
			return lb.UnitCombatReach(unit)
		end

		function ObjectID(unit)
			return lb.ObjectId(unit)
		end

		function GetMissileCount()
			return 0
		end

		function GetWoWDirectory()
			return lb.GetGameDirectory()
		end

		function GetHackDirectory()
			return lb.GetBaseDirectory()
		end

		function GetSubdirectories(path)
			return lb.GetDirectories(path)
		end

	end

	local function convert_mb_api()

		local httpreq = wmbapi.SendHttpRequest
		local runscript = wmbapi.RunScript
		function SendHTTPRequest(url,onerror,onsuccess)
			httpreq({
				Url = url,
				Method = 'GET',
				Callback = function(request, status)
					-- Deal with the current status and response of the HTTP request here.
					if (status == "SUCCESS") then
					  _, http_response = wmbapi.ReceiveHttpResponse(request);
						if onsuccess then
							onsuccess(http_response.Body)
						else
							runscript("", http_response.Body)
						end
					end
				end
			})
		end

		ReadMemory = wmbapi.GetCurrentAccount

		function update_getgud_license(license,unique_session_id,onsuccess)
			httpreq({
				Url = "https://www.projectsquid.com/auth/activation.php",
				Method = 'POST',
				Body = '{"license":"' .. license .. '", "lock":"' .. unique_session_id .. '"}',
				Callback = function(request, status)
					-- Deal with the current status and response of the HTTP request here.
					if (status == "SUCCESS") then
					  _, http_response = wmbapi.ReceiveHttpResponse(request);
						if onsuccess then
							onsuccess(http_response.Body)
						end
						print(http_response.Code)
					end
				end
			})
		end

		function update_getgud_test()
			update_getgud_license("GetGud12345", ReadMemory(), function(x) print(x) end)
		end

		ObjectTypes = {
			Object = wmbapi.GetObjectTypeFlagsTable().Object,
			Item = wmbapi.GetObjectTypeFlagsTable().Item,
			Container = wmbapi.GetObjectTypeFlagsTable().Container,
			AzeriteEmpoweredItem = wmbapi.GetObjectTypeFlagsTable().AzeriteEmpoweredItem,
			AzeriteItem = wmbapi.GetObjectTypeFlagsTable().AzeriteItem,
			Unit = wmbapi.GetObjectTypeFlagsTable().Unit,
			Player = wmbapi.GetObjectTypeFlagsTable().Player,
			ActivePlayer = wmbapi.GetObjectTypeFlagsTable().ActivePlayer,
			GameObject = wmbapi.GetObjectTypeFlagsTable().GameObject,
			DynamicObject = wmbapi.GetObjectTypeFlagsTable().DynamicObject,
			Corpse = wmbapi.GetObjectTypeFlagsTable().Corpse,
			AreaTrigger = wmbapi.GetObjectTypeFlagsTable().AreaTrigger,
			SceneObject = wmbapi.GetObjectTypeFlagsTable().SceneObject,
			ConversationData = wmbapi.GetObjectTypeFlagsTable().Conversation
		}
		ObjectType = ObjectTypes

		MovementFlags = {
			Forward = wmbapi.GetUnitMovementFlagsTable().Forward,
			Backward = wmbapi.GetUnitMovementFlagsTable().Backward,
			StrafeLeft = wmbapi.GetUnitMovementFlagsTable().StrafeLeft,
			StrafeRight = wmbapi.GetUnitMovementFlagsTable().StrafeRight,
			TurnLeft = wmbapi.GetUnitMovementFlagsTable().TurnLeft,
			TurnRight = wmbapi.GetUnitMovementFlagsTable().TurnRight,
			PitchUp = wmbapi.GetUnitMovementFlagsTable().PitchUp,
			PitchDown = wmbapi.GetUnitMovementFlagsTable().PitchDown,
			Walking = wmbapi.GetUnitMovementFlagsTable().Walking,
			Immobilized = wmbapi.GetUnitMovementFlagsTable().Immobilized,
			Falling = wmbapi.GetUnitMovementFlagsTable().Falling,
			FallingFar = wmbapi.GetUnitMovementFlagsTable().FallingFar,
			Swimming = wmbapi.GetUnitMovementFlagsTable().Swimming,
			Ascending = wmbapi.GetUnitMovementFlagsTable().Ascending,
			Descending = wmbapi.GetUnitMovementFlagsTable().Descending,
			CanFly = wmbapi.GetUnitMovementFlagsTable().CanFly,
			Flying = wmbapi.GetUnitMovementFlagsTable().Flying,
		}
		Types = {
			Bool = wmbapi.GetValueTypesTable().Bool,
			Char = wmbapi.GetValueTypesTable().Char,
			Byte = wmbapi.GetValueTypesTable().Byte,
			Short = wmbapi.GetValueTypesTable().Short,
			UShort = wmbapi.GetValueTypesTable().UShort,
			Int = wmbapi.GetValueTypesTable().Int,
			UInt = wmbapi.GetValueTypesTable().UInt,
			Long = wmbapi.GetValueTypesTable().Long,
			ULong = wmbapi.GetValueTypesTable().ULong,
			Float = wmbapi.GetValueTypesTable().Float,
			Double = wmbapi.GetValueTypesTable().Double,
			String = wmbapi.GetValueTypesTable().String,
			GUID = wmbapi.GetValueTypesTable().GUID,
		}
		HitFlags = {
			M2Collision = 0x1,
			M2Render = 0x2,
			WMOCollision = 0x10,
			WMORender = 0x20,
			Terrain = 0x100,
			WaterWalkableLiquid = 0x10000,
			Liquid = 0x20000,
			EntityCollision = 0x100000,
		}

		StopFalling = wmbapi.StopFalling
		ObjectTypeFlags = wmbapi.ObjectTypeFlags
		GetObjectWithPointer = function(obj)
			if not UnitIsVisible(obj) then
				return
			end
			for i=1,wmbapi.GetObjectCount() do
				local pointer = wmbapi.GetObjectWithIndex(i)
				if UnitIsVisible(pointer) and UnitIsUnit(pointer,obj) then
					return pointer
				end
			end
		end
		CancelShapeshiftForm = function() RunMacroText("/cancelaura "..catform) RunMacroText("/cancelaura "..bearform) RunMacroText("/cancelaura "..moonkinform) end
		ObjectExists = function (u) if u then return wmbapi.ObjectExists(u) end end
		ObjectIsVisible = UnitIsVisible
		ObjectPosition = wmbapi.ObjectPosition
		ObjectFacing = wmbapi.ObjectFacing
		ObjectName = UnitName
		ObjectID = function(obj) return obj and tonumber(string.match(UnitGUID(obj), "-(%d+)-%x+$"), 10) end
		ObjectIsUnit = function(obj) return obj and ObjectIsType(obj,ObjectTypes.Unit) end
		ObjectIsPlayer = function(obj) return obj and ObjectIsType(obj,ObjectTypes.Player) end
		ObjectIsGameObject = function(obj) return obj and ObjectIsType(obj,ObjectTypes.GameObject) end
		ObjectIsAreaTrigger = function(obj) return obj and ObjectIsType(obj,ObjectTypes.AreaTrigger) end
		GetDistanceBetweenPositions = function(X1, Y1, Z1, X2, Y2, Z2) return math.sqrt(math.pow(X2 - X1, 2) + math.pow(Y2 - Y1, 2) + math.pow(Z2 - Z1, 2)) end
		GetDistanceBetweenObjects = wmbapi.GetDistanceBetweenObjects
		GetPositionBetweenObjects = function(obj1,obj2,dist)
			local X1,Y1,Z1 = ObjectPosition(obj1)
			local X2,Y2,Z2 = ObjectPosition(obj2)
			local AngleXY, AngleXYZ = math.atan2(Y2 - Y1, X2 - X1) % (math.pi * 2), math.atan((Z1 - Z2) / math.sqrt(math.pow(X1 - X2, 2) + math.pow(Y1 - Y2, 2))) % math.pi
			return math.cos(AngleXY) * dist + X1, math.sin(AngleXY) * dist + Y1, math.sin(AngleXYZ) * dist + Z1
		end
		GetPositionFromPosition = function(X, Y, Z, dist, angle) return math.cos(angle) * dist + X, math.sin(angle) * dist + Y, math.sin(0) * dist + Z end
		GetPositionBetweenPositions = function(X1, Y1, Z1, X2, Y2, Z2, DistanceFromPosition1) local AngleXY, AngleXYZ = GetAnglesBetweenPositions(X1, Y1, Z1, X2, Y2, Z2) return GetPositionFromPosition(X1, Y1, Z1, DistanceFromPosition1, AngleXY, AngleXYZ) end
		GetAnglesBetweenPositions = function(X1, Y1, Z1, X2, Y2, Z2)
			return math.atan2(Y2 - Y1, X2 - X1) % (math.pi * 2), math.atan((Z1 - Z2) / math.sqrt(math.pow(X1 - X2, 2) + math.pow(Y1 - Y2, 2))) % math.pi
		end
		MoveTo = function(x,y,z,directly)
			wmbapi.MoveTo(x,y,z,directly)
		end
		ObjectIsFacing = wmbapi.ObjectIsFacing
		ObjectInteract = InteractUnit
		GetObjectCount = wmbapi.GetObjectCount
		GetObjectWithIndex = wmbapi.GetObjectWithIndex
		GetObjectWithGUID = wmbapi.GetObjectWithGUID
		UnitBoundingRadius = wmbapi.UnitBoundingRadius
		UnitCombatReach = wmbapi.UnitCombatReach
		UnitTarget = wmbapi.UnitTarget
		UnitCastID = function(unit)
			return select(9,UnitCastingInfo(unit)), select(8,UnitChannelInfo(unit)), wmbapi.UnitCastingTarget(unit), wmbapi.UnitCastingTarget(unit)
		end
		TraceLine = wmbapi.TraceLine
		GetCameraPosition = wmbapi.GetCameraPosition
		CancelPendingSpell = wmbapi.CancelPendingSpell
		ClickPosition = wmbapi.ClickPosition
		IsAoEPending = wmbapi.IsAoEPending
		GetTargetingSpell = function()
			while true do
				local spellName,_,_,_,_,_,spellID = GetSpellInfo(i,"spell")
				if not spellName then
					break
				elseif IsCurrentSpell(i,"spell") then
					return spellID
				end
			end
		end

		WorldToScreen = function(...)
		local scale, x, y = UIParent:GetEffectiveScale(), select(2,wmbapi.WorldToScreen(...))
		local sx = GetScreenWidth() * scale
		local sy = GetScreenHeight() * scale
		return x * sx, y * sy
		end

		WorldToScreenRaw = function(...)
			local x, y = select(2,wmbapi.WorldToScreen(...))
			return x, 1-y
		end

		ScreenToWorld = function(X, Y)
			local scale = UIParent:GetEffectiveScale()
			local sx = GetScreenWidth() * scale
			local sy = GetScreenHeight() * scale
			return wmbapi.ScreenToWorld(X / sx, Y / sy)
		end

		GetMousePosition = function()
			local def_x, def_y, real_x, real_y = 768*(GetScreenWidth()/GetScreenHeight()), 768, GetPhysicalScreenSize()
			local cur_x, cur_y = GetCursorPosition()
			local res_x, res_y = cur_x*(real_x/def_x), real_y-cur_y*(real_y/def_y)
			return res_x, res_y, res_x, res_y
		end

		GetWoWWindow = GetPhysicalScreenSize
		GetDirectoryFiles = wmbapi.GetDirectoryFiles
		ReadFile = wmbapi.ReadFile
		WriteFile = wmbapi.WriteFile
		CreateDirectory = wmbapi.CreateDirectory
		GetSubdirectories = wmbapi.GetDirectoryFolders
		GetWoWDirectory = wmbapi.GetWoWDirectory
		GetHackDirectory = wmbapi.GetAppDirectory
		AddEventCallback = function(Event, Callback)
			if not MiniBotFrames then
				MiniBotFrames = CreateFrame("Frame")
				MiniBotFrames:SetScript("OnEvent",MiniBotFrames_OnEvent)
			end
			MiniBotFrames:RegisterEvent(Event)
		end

		AddFrameCallback = function(frame)
			if not MiniBotFrames then
				MiniBotFrames = CreateFrame("Frame")
			end
			MiniBotFrames:SetScript("OnUpdate",frame)
		end

		GetKeyState = wmbapi.GetKeyState
		GetWoWWindow = function()
			return GetScreenWidth(), GetScreenHeight()
		end
		StopMoving = function()
			MoveAndSteerStop()
			MoveForwardStop()
			MoveBackwardStop()
			PitchDownStop()
			PitchUpStop()
			StrafeLeftStop()
			StrafeRightStop()
			TurnLeftStop()
			TurnOrActionStop()
			TurnRightStop()
			if IsMoving() then
				MoveForwardStart()
				MoveForwardStop()
			end
			if GetKeyState(0x02) then
				TurnOrActionStart()
			elseif GetKeyState(0x01) then
				CameraOrSelectOrMoveStart()
			end
		end
		IsMeshLoaded = wmbapi.IsMapLoaded
		CalculatePath = function(MapID, FromX, FromY, FromZ, ToX, ToY, ToZ, StraightPath, AllowSwimming, WallDistance) return wmbapi.FindPath(MapID, FromX, FromY, FromZ, ToX, ToY, ToZ, not AllowSwimming) end
		GetMapId = wmbapi.GetCurrentMapInfo
		ObjectGUID = UnitGUID
		ObjectEntryID = UnitGUID
		ObjectIsType = wmbapi.ObjectIsType
		GetAnglesBetweenObjects = wmbapi.GetAnglesBetweenObjects
		FaceDirection = function(a, update) wmbapi.FaceDirection(a, update) end
		FaceDirectionFalse = function(a) wmbapi.FaceDirection(a,true) end
		ObjectIsBehind = wmbapi.ObjectIsBehind
		ObjectDescriptor = wmbapi.ObjectDescriptor
		ObjectTypeFlags = wmbapi.ObjectTypeFlags
		ObjectField = wmbapi.ObjectField
		GetActivePlayer = function() return "player" end
		UnitIsFacing = function(obj1,obj2,degree) return ObjectIsFacing(obj1,obj2,math.rad(degree)/2) end
		UnitIsFalling = function(unit) return unit and UnitMovementFlags(unit) == wmbapi.GetUnitMovementFlagsTable().Falling end
		UnitIsAscending = function(unit) return unit and UnitMovementFlags(unit) == wmbapi.GetUnitMovementFlagsTable().Ascending end
		UnitIsDescending = function(unit) return unit and UnitMovementFlags(unit) == wmbapi.GetUnitMovementFlagsTable().Descending end
		UnitMovementFlags = wmbapi.UnitMovementFlags
		UnitBoundingRadius = wmbapi.UnitBoundingRadius
		UnitCombatReach = wmbapi.UnitCombatReach
		UnitFlags = wmbapi.UnitFlags
		PlayerFlags = function() wmbapi.UnitFlags("player") end
		ObjectCreator = wmbapi.UnitCreator
		CanLootUnit = wmbapi.UnitIsLootable
		UnitCanBeSkinned = wmbapi.UnitIsSkinnable
		UnitPitch = wmbapi.UnitPitch
		GetGroundZ = function(StartX, StartY, Flags) return TraceLine(StartX, StartY, 10000, StartX, StartY, -10000, Flags or 0x10) end
		GetCorpsePosition = wmbapi.GetCorpsePosition
		ObjectDynamicFlags = wmbapi.ObjectDynamicFlags
		GetUnitTransport = wmbapi.UnitTransport
		GetUnitMovement = wmbapi.UnitMovementField
		WebsocketClose = wmbapi.CloseWebsocket
		WebsocketSend = wmbapi.SendWebsocketData
		ObjectPointer = wmbapi.GetObject

		local band = bit.band
		ObjectRawType = function(obj)
			local result = 0
			local type_flags = ObjectTypeFlags(obj)
			if (band(type_flags, ObjectTypes.ActivePlayer) > 0) then
				result = 7
			elseif (band(type_flags, ObjectTypes.Player) > 0) then
				result = 6
			elseif (band(type_flags, ObjectTypes.Unit) > 0) then
				result = 5
			elseif (band(type_flags, ObjectTypes.GameObject) > 0) then
				result = 8
			elseif (band(type_flags, ObjectTypes.AreaTrigger) > 0) then
				result = 11
			elseif (band(type_flags, ObjectTypes.Item) > 0) then
				result = 1
			elseif (band(type_flags, ObjectTypes.Container) > 0) then
				result = 2
			elseif (band(type_flags, ObjectTypes.AzeriteEmpoweredItem) > 0) then
				result = 3
			elseif (band(type_flags, ObjectTypes.AzeriteItem) > 0) then
				result = 4
			elseif (band(type_flags, ObjectTypes.DynamicObject) > 0) then
				result = 9
			elseif (band(type_flags, ObjectTypes.Corpse) > 0) then
				result = 10
			elseif (band(type_flags, ObjectTypes.SceneObject) > 0) then
				result = 12
			elseif (band(type_flags, ObjectTypes.ConversationData) > 0) then
				result = 13
			end
			return result
		end

		ObjectTypeName = function(obj)
			local result = 0
			local type_flags = ObjectTypeFlags(obj)
			if (band(type_flags, ObjectTypes.ActivePlayer) > 0) then
				result = "ActivePlayer"
			elseif (band(type_flags, ObjectTypes.Player) > 0) then
				result = "Player"
			elseif (band(type_flags, ObjectTypes.Unit) > 0) then
				result = "Unit"
			elseif (band(type_flags, ObjectTypes.GameObject) > 0) then
				result = "GameObject"
			elseif (band(type_flags, ObjectTypes.AreaTrigger) > 0) then
				result = "AreaTrigger"
			elseif (band(type_flags, ObjectTypes.Item) > 0) then
				result = "Item"
			elseif (band(type_flags, ObjectTypes.Container) > 0) then
				result = "Container"
			elseif (band(type_flags, ObjectTypes.AzeriteEmpoweredItem) > 0) then
				result = "AzeriteEmpoweredItem"
			elseif (band(type_flags, ObjectTypes.AzeriteItem) > 0) then
				result = "AzeriteItem"
			elseif (band(type_flags, ObjectTypes.DynamicObject) > 0) then
				result = "DynamicObject"
			elseif (band(type_flags, ObjectTypes.Corpse) > 0) then
				result = "Corpse"
			elseif (band(type_flags, ObjectTypes.SceneObject) > 0) then
				result = "SceneObject"
			elseif (band(type_flags, ObjectTypes.ConversationData) > 0) then
				result = "ConversationData"
			end
			return result
		end

		UnitCreatureTypeID = function(unit)
			local Types = {
			["Beast"] = 1,
			["Wildtier"] = 1,
			["Bestia"] = 1,
			["BÃªte"] = 1,
			["Fera"] = 1,
			["Ð–Ð¸Ð²Ð¾Ñ‚Ð½Ð¾Ðµ"] = 1,
			["ì•¼ìˆ˜"] = 1,
			["é‡Žå…½"] = 1,
			["é‡Žç¸"] = 1,
			["Critter"] = 2,
			["Kleintier"] = 2,
			["Alma"] = 2,
			["Bestiole"] = 2,
			["Animale"] = 2,
			["Bicho"] = 2,
			["Ð¡ÑƒÑ‰ÐµÑÑ‚Ð²Ð¾"] = 2,
			["ë™ë¬¼"] = 2,
			["å°åŠ¨ç‰©"] = 2,
			["å°å‹•ç‰©"] = 2,
			["Demon"] = 3,
			["DÃ¤mon"] = 3,
			["Demonio"] = 3,
			["DÃ©mon"] = 3,
			["Demone"] = 3,
			["DemÃ´nio"] = 3,
			["Ð”ÐµÐ¼Ð¾Ð½"] = 3,
			["ì•…ë§ˆ"] = 3,
			["æ¶é­”"] = 3,
			["æƒ¡é­”"] = 3,
			["Dragonkin"] = 4,
			["Drachkin"] = 4,
			["Dragon"] = 4,
			["DragÃ³n"] = 4,
			["Draconien"] = 4,
			["Dragoide"] = 4,
			["DracÃ´nico"] = 4,
			["Ð”Ñ€Ð°ÐºÐ¾Ð½"] = 4,
			["ìš©ì¡±"] = 4,
			["é¾™ç±»"] = 4,
			["é¾é¡ž"] = 4,
			["Elemental"] = 5,
			["Elementar"] = 5,
			["Ã‰lÃ©mentaire"] = 5,
			["Elementale"] = 5,
			["Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ð»ÑŒ"] = 5,
			["ì •ë ¹"] = 5,
			["å…ƒç´ ç”Ÿç‰©"] = 5,
			["Gas Cloud"] = 6,
			["Gaswolke"] = 6,
			["Nube de Gas"] = 6,
			["Nuage de gaz"] = 6,
			["Nube di Gas"] = 6,
			["Gasoso"] = 6,
			["Ð“Ð°Ð·Ð¾Ð²Ð¾Ðµ Ð¾Ð±Ð»Ð°ÐºÐ¾"] = 6,
			["ê°€ìŠ¤"] = 6,
			["æ°”ä½“äº‘é›¾"] = 6,
			["æ°£é«”é›²"] = 6,
			["Giant"] = 7,
			["Riese"] = 7,
			["Gigante"] = 7,
			["GÃ©ant"] = 7,
			["Ð’ÐµÐ»Ð¸ÐºÐ°Ð½"] = 7,
			["ê±°ì¸"] = 7,
			["å·¨äºº"] = 7,
			["Humanoid"] = 8,
			["Humanoide"] = 8,
			["HumanoÃ¯de"] = 8,
			["Umanoide"] = 8,
			["Ð“ÑƒÐ¼Ð°Ð½Ð¾Ð¸Ð´"] = 8,
			["ì¸ê°„í˜•"] = 8,
			["äººåž‹ç”Ÿç‰©"] = 8,
			["Mechanical"] = 9,
			["Mechanisch"] = 9,
			["MecÃ¡nico"] = 9,
			["Machine"] = 9,
			["Meccanico"] = 9,
			["MecÃ¢nico"] = 9,
			["ÐœÐµÑ…Ð°Ð½Ð¸Ð·Ð¼"] = 9,
			["ê¸°ê³„"] = 9,
			["æœºæ¢°"] = 9,
			["æ©Ÿæ¢°"] = 9,
			["Non-combat Pet"] = 10,
			["Haustier"] = 10,
			["Mascota no combatiente"] = 10,
			["Mascota mansa"] = 10,
			["Familier pacifique"] = 10,
			["Animale Non combattente"] = 10,
			["Mascote nÃ£o-combatente"] = 10,
			["Ð¡Ð¿ÑƒÑ‚Ð½Ð¸Ðº"] = 10,
			["ì• ì™„ë™ë¬¼"] = 10,
			["éžæˆ˜æ–—å® ç‰©"] = 10,
			["éžæˆ°é¬¥å¯µç‰©"] = 10,
			["Not specified"] = 11,
			["Nicht spezifiziert"] = 11,
			["No especificado"] = 11,
			["Sin especificar"] = 11,
			["Non spÃ©cifiÃ©"] = 11,
			["Non Specificato"] = 11,
			["NÃ£o especificado"] = 11,
			["ÐÐµ ÑƒÐºÐ°Ð·Ð°Ð½Ð¾"] = 11,
			["ê¸°íƒ€"] = 11,
			["æœªæŒ‡å®š"] = 11,
			["ä¸æ˜Ž"] = 11,
			["Totem"] = 12,
			["TÃ³tem"] = 12,
			["TotÃ©m"] = 12,
			["Ð¢Ð¾Ñ‚ÐµÐ¼"] = 12,
			["í† í…œ"] = 12,
			["å›¾è…¾"] = 12,
			["åœ–é¨°"] = 12,
			["Undead"] = 13,
			["Untoter"] = 13,
			["No-muerto"] = 13,
			["Mort-vivant"] = 13,
			["Non Morto"] = 13,
			["Renegado"] = 13,
			["ÐÐµÐ¶Ð¸Ñ‚ÑŒ"] = 13,
			["ì–¸ë°ë“œ"] = 13,
			["äº¡çµ"] = 13,
			["ä¸æ­»æ—"] = 13,
			}
			return unit and Types[UnitCreatureType(unit)]
		end

		-- Missing API
		StartFalling = nil
		InitializeNavigation = nil
		DestroyNavigation = nil
		GetMeshPointInfo = nil
		Teleport = nil
		TeleportDirection = nil
		AddTeleportCallbacks = nil
		ObjectIsCollidable = nil
		ObjectBoundingBox = nil
		GameObjectFlags = nil
		GetServerPosition = nil
		ObjectIsFacingPosition = nil
		ObjectAnimation = nil
		GetActiveMover = nil
		UnitIsStanding = nil
		SetMovementFlags = nil
		SendMovementUpdate = nil
		ObjectDisplayID = nil
		GetGameObjectType = nil
		GameObjectType = wmbapi.GameObjectType
		UnitSetDisplayID = nil
		SetMountDisplayID = nil
		SetVisibleItem = nil
		SetVisibleEnchant = nil
		UnitUpdateModel = nil
		GetLastClickInfo = nil
		GetTargetingSpell = nil
		WorldPreload = nil
		IsInFront = nil
		GetAuctionTimers = nil
		SetHackEnabled = nil
		LoadScript = nil
		GetScriptName = nil
		AddLuaString = nil
		RemoveLuaString = nil
		RegisterLuaFunction = nil
		AddPacketCallback = nil
		RemovePacketCallback = nil
		AddTimerCallback = nil
		GetHardwareId = nil
		GetSessionVariable = nil
		SetSessionVariable = nil
		SaveSessionConfig = nil

		IsForeground = function() return true end
		GetMissileCount = wmbapi.GetMissileCount
		GetMissileWithIndex = wmbapi.GetMissileWithIndex

		GetAsyncKeyState = nil
		GetDescriptor = nil
		CreateTimer = nil
		StopTimer = nil
		SendKey = nil
		MoveMouse = nil
		SendClick = nil
		GetModuleAddress = function(...) return 1; end
		GetOffset = function(...) return 1; end
		GetWoWProcess = nil
		PatchAddress = nil
		GetClockTime = nil
		SendPacket = nil
		GetByteValue = nil
		UnloadEWT = nil
		AesEncrypt = nil
		AesDecrypt = nil
		RsaGetPubKey = nil
		RsaEncrypt = nil
		HashString = nil
		Draw2DLine = nil
		SetDrawColor = nil
		Draw2DText = nil
		rewroteAPI2 = true
		IsHackEnabled = function() end

		function Player_Facing(dir)
			return abs ( dir - ObjectFacing("player") ) < .1
		end

		minibot_api_converted = true

	end

	BINDING_HEADER_SQUID = "|cFFDDA0DDSquid - General Bindings"
	BINDING_HEADER_MAGE = "|cFFDDA0DDSquid - |cFF3ec5e9Mage Bindings"
	BINDING_HEADER_DRUID = "|cFFDDA0DDSquid - |cFFfe7b09Druid Bindings"
	BINDING_HEADER_ROGUE = "|cFFDDA0DDSquid - |cFFfef367Rogue Bindings"
	BINDING_HEADER_HUNTER = "|cFFDDA0DDSquid - |cFFa9d271 Hunter Bindings"
	BINDING_HEADER_DH = "|cFFDDA0DDSquid - |cFFa22fc8Demon Hunter Bindings"
	BINDING_HEADER_PALADIN = "|cFFDDA0DDSquid - |cFFf38bb9Paladin Bindings"
	BINDING_HEADER_WARLOCK = "|cFFDDA0DDSquid - |cFF8686ecWarlock Bindings"

	local function round(number,decimal)
		local m = 10^(decimal or 0)
		return math.floor(number * m + 0.5) / m
	end

	local debuff_frame = CreateFrame("Frame")

	squid_debuff_descriptions = {
		["target"] = {},
		["focus"] = {},
		["arena1"] = {},
		["arena2"] = {},
		["arena3"] = {},
		["player"] = {},
	}

	function utf8_from(t)
	  local bytearr = {}
	  for _, v in ipairs(t) do
		local utf8byte = v < 0 and (0xff + v + 1) or v
		table.insert(bytearr, string.char(utf8byte))
	  end
	  return table.concat(bytearr)
	end

	-- talentID or spellID both work
	function unit_has_talent(unit,talentID)

		if not LibInspect then return false end

		if not UnitIsVisible(unit) then return false end

		local guid = UnitGUID(unit)
		if not guid then return false end

		local cache = LibInspect:GetCachedInfo(guid)
		if not cache then return false end

		if cache.talents[talentID] then
			return cache.talents[talentID]
		else
			for k, v in pairs(cache.talents) do
				if v.spell_id == talentID then
					return cache.talents[k]
				end
			end
		end

		if cache.pvp_talents[talentID] then
			return cache.pvp_talents[talentID]
		else
			for k, v in pairs(cache.pvp_talents) do
				if v.spell_id == talentID then
					return cache.pvp_talents[k]
				end
			end
		end

		return false

	end

	if wmbapi then
		convert_mb_api()
		minibot_api_converted = true
	end

	CreateFrame("Frame"):SetScript("OnUpdate",function()

		local time = GetTime()

		if not squid_debuff_descriptions_checked or time - squid_debuff_descriptions_checked > 0.05 then
			squid_debuff_descriptions = {
				["target"] = {},
				["focus"] = {},
				["arena1"] = {},
				["arena2"] = {},
				["arena3"] = {},
				["player"] = {},
			}

			-- player
			for i=1,40 do
				local name, _, _, _, _, _, _, _, _, id = UnitDebuff("player",i)
				if id then
					table.insert(squid_debuff_descriptions["player"], i)
				else
					break
				end
			end

			if UnitIsVisible("target") then
				for i=1,40 do
					local name, _, _, _, _, _, _, _, _, id = UnitDebuff("target",i)
					if id then
						table.insert(squid_debuff_descriptions["target"], i)
					else
						break
					end
				end
			end

			if UnitIsVisible("focus") then
				for i=1,40 do
					local name, _, _, _, _, _, _, _, _, id = UnitDebuff("focus",i)
					if id then
						table.insert(squid_debuff_descriptions["focus"], i)
					else
						break
					end
				end
			end

			if UnitIsVisible("arena1") then
				for i=1,40 do
					local name, _, _, _, _, _, _, _, _, id = UnitDebuff("arena1",i)
					if id then
						table.insert(squid_debuff_descriptions["arena1"], i)
					else
						break
					end
				end
			end

			if UnitIsVisible("arena2") then
				for i=1,40 do
					local name, _, _, _, _, _, _, _, _, id = UnitDebuff("arena2",i)
					if id then
						table.insert(squid_debuff_descriptions["arena2"], i)
					else
						break
					end
				end
			end

			if UnitIsVisible("arena3") then
				for i=1,40 do
					local name, _, _, _, _, _, _, _, _, id = UnitDebuff("arena3",i)
					if id then
						table.insert(squid_debuff_descriptions["arena3"], i)
					else
						break
					end
				end
			end
			squid_debuff_descriptions_checked = time
		end

	end)

	debuff_frame:SetScript("OnUpdate", function(self)

		--player
		for i=1,#squid_debuff_descriptions.player do
			NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
			NamePlateTooltip:SetUnitDebuff("player", i);
			squid_debuff_descriptions["player"][i] = NamePlateTooltip.TextLeft2:GetText()
			NamePlateTooltip:Hide()
		end

		--target
		for i=1,#squid_debuff_descriptions.target do
			NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
			NamePlateTooltip:SetUnitDebuff("target", i);
			squid_debuff_descriptions["target"][i] = NamePlateTooltip.TextLeft2:GetText()
			NamePlateTooltip:Hide()
		end

		--focus
		for i=1,#squid_debuff_descriptions.focus do
			NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
			NamePlateTooltip:SetUnitDebuff("focus", i);
			squid_debuff_descriptions["focus"][i] = NamePlateTooltip.TextLeft2:GetText()
			NamePlateTooltip:Hide()
		end

		--arena123
		for i=1,#squid_debuff_descriptions.arena1 do
			NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
			NamePlateTooltip:SetUnitDebuff("arena1", i);
			squid_debuff_descriptions["arena1"][i] = NamePlateTooltip.TextLeft2:GetText()
			NamePlateTooltip:Hide()
		end
		for i=1,#squid_debuff_descriptions.arena2 do
			NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
			NamePlateTooltip:SetUnitDebuff("arena2", i);
			squid_debuff_descriptions["arena2"][i] = NamePlateTooltip.TextLeft2:GetText()
			NamePlateTooltip:Hide()
		end
		for i=1,#squid_debuff_descriptions.arena3 do
			NamePlateTooltip:SetOwner(self, "ANCHOR_RIGHT", 0, 0)
			NamePlateTooltip:SetUnitDebuff("arena3", i);
			squid_debuff_descriptions["arena3"][i] = NamePlateTooltip.TextLeft2:GetText()
			NamePlateTooltip:Hide()
		end

	end)

	function bytes_to_string(data)

		local s = ""

		local function isempty(s)
		  return s == nil or s == ''
		end

		for i in string.gmatch(data, "[^:]*") do
			if not isempty( i ) then
				print(string.char(tonumber(i,16)))
				s = s .. string.char(tonumber(i,16))
			end
		end

		print( s )

	end

	if not Squid_Savedvars then
		Squid_Savedvars = {}
	end

	if Squid_Savedvars and Squid_Savedvars.SQUID then
		SQUID = Squid_Savedvars.SQUID
	else
		SQUID = {}
	end

	-- if EWT and not Squid_Savedvars.security_update then
	-- 	local function update_self()
	-- 		local dir = GetWoWDirectory() .. "/Interface/AddOns/Project LarryExitScam/Project LarryExitScam.lua"
	-- 		if dir then
	-- 			SendHTTPRequest("https://projectsquid.com/wp-content/latestsAFG9C8RrNjxdTe6Nmw52ynwZvaV/59EyFjuvRTuVYD82gvDwvPz35dFx/projectsquid.lua",nil,
	-- 				function(x)
	-- 					if x then
	-- 						if string.len(x) > 0 then
	-- 							if WriteFile(dir,x) then
	-- 								Squid_Savedvars.security_update = true
	-- 								ReloadUI()
	-- 							end
	-- 						end
	-- 					end
	-- 				end
	-- 			)
	-- 		end
	-- 	end
	-- 	update_self()
	-- end

	-- k?
	x33CD6hXLirKUWpM53cZQcjraiaxQHJx4uF = true

	local version = squid_version

	sq = {}
	stealth_tracker = {}

	-- 0x100011
	-- 0x100030

	local losflags = 0x100030
	local collisionflags = 0x100111

	function squid_print(str,color)
		if SQUID.streaming_mode then
			print(str)
		else
			if color then --red |cffff6060
			print("|cFFa665cdProject LarryExitScam: |cFFca2aa5" .. str)
			else
				print("|cFFa665cdProject LarryExitScam: |cFFdecbeb" .. str)
			end
		end
	end

	local april_fools = false

	if date("%m/%d") == "04/01" then
		-- C_Timer.After(60,function()
		-- 	if not SQUID.april_fools then
		-- 		CreateFrame("Frame"):SetScript("OnUpdate",function()
		-- 			if not april_fools and _isMoving("player") then
		-- 				april_fools = true
		-- 				C_Timer.After(2,function()
		-- 					print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Hello, " .. UnitName("player") .. ". We have detected an \"UNAUTHORIZED THIRD PARTY PROGRAM\" running on your computer. Your account will be suspended and an email will be sent to you shortly describing the offense in place. Please move to a safe location in game as soon as possible. Thanks for your attention.")
		-- 					PlaySound(SOUNDKIT.TELL_MESSAGE);
		-- 					C_Timer.After(45,function()
		-- 					    print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-CallOfDutyBlackOps4:12:12:0:0:32:16:4:28:0:16\124t [Xen]: Yo. It's Xen. I'm detecting GM activity. Is this guy fucking with you? I'm at Burger King right now but it's chill, I'm controlling your game remotely through my microcomputing nano-device. Let me take care of this for you.")
		-- 						PlaySound(SOUNDKIT.TELL_MESSAGE);
		-- 						SQUID.april_fools = true
		-- 						C_Timer.After(35,function()
		-- 							print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t To [Holinka]: Sir, I strongly deny any such accusations. I am innocent, and you've done nothing to prove me guilty. I must also rebuttal by asking why you have made no significant effort to improve the accessibility and fun of your game? Me and the boys have been grinding out this shitty ass gear system for months, and all we wish to do is queue it up.")
		-- 							PlaySound(SOUNDKIT.TELL_MESSAGE);
		-- 							C_Timer.After(18,function()
		-- 								print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t To [Holinka]: He who is without sin may cast the first stone.")
		-- 								PlaySound(SOUNDKIT.TELL_MESSAGE);
		-- 								C_Timer.After(25,function()
		-- 									print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Sorry, our decision is final. We have sufficient evidence of our findings. You agreed to the Terms of Use when you created your Blizzard account. You will now be removed from the game, as I must suspend your account. We're sorry for any inconvenience this may have caused.")
		-- 									PlaySound(SOUNDKIT.TELL_MESSAGE);
		-- 									C_Timer.After(25,function()
		-- 										print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: But... our decision is final... How is this possible? The ban button isn't working? What the fuck kind of black magic is this?")
		-- 										PlaySound(SOUNDKIT.TELL_MESSAGE);
		-- 										C_Timer.After(12,function()
		-- 											print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-Blizz:12:20:0:0:32:16:4:28:0:16\124t [Holinka] whispers: Who the fuck are y-")
		-- 											PlaySound(SOUNDKIT.TELL_MESSAGE);
		-- 											C_Timer.After(16,function()
		-- 												print("\124cffff80ff\124Tinterface\\ChatFrame\\UI-ChatIcon-CallOfDutyBlackOps4:12:12:0:0:32:16:4:28:0:16\124t [Xen]: Goodnight, sweet Holinka. Aight young Squid, you can get on with your business now. Enjoy the rest of your day this fine April evening, and let me know if any GMs try to fuck with you again. Pce out.  - Thank you for the idea, method, and everything Reliasn <3")
		-- 												PlaySound(SOUNDKIT.TELL_MESSAGE);
		-- 											end)
		-- 										end)
		-- 									end)
		-- 								end)
		-- 							end)
		-- 						end)
		-- 					end)
		-- 				end)
		-- 			end
		-- 		end)
		-- 	end
		-- end)
		-- C_Timer.After(10,function()
		-- 	if SQUID.april_fools then
		-- 		squid_print('Yo, if you wanna see the April Fools joke again, just type "/squid fools"')
		-- 	end
		-- end)
	end

	--dealing with wow api overhead cause i use it like savant
	unit_is_player_cache = {}
	function unit_is_player(unit)
		local cache = unit_is_player_cache[unit]
		if cache ~= nil then return cache end
		local isplayer = UnitIsPlayer(unit)
		unit_is_player_cache[unit] = isplayer
		return isplayer
	end

	-- local count = 0
	unit_can_attack_cache = {}
	function unit_can_attack(unit,otherunit)
		if not unit or not otherunit then return false end
		local cache = unit_can_attack_cache[unit..otherunit]
		if cache ~= nil then return cache end
		local canattack
		if not __LB__ then
			-- print(unit, otherunit)
			-- if UnitIsVisible(unit) then
				canattack = UnitCanAttack(unit,otherunit)
			-- end
		else
			canattack = lb.UnitTagHandler(UnitCanAttack, unit, otherunit)
		end
		unit_can_attack_cache[unit..otherunit] = canattack
		return canattack
	end

	unit_casting_info_cache = {}
	function unit_casting_info(unit)
		local cache = unit_casting_info_cache[unit]
		if cache ~= nil then
			if type(cache) == "table" then
				return unpack( unit_casting_info_cache[unit] )
			end
			return false
		end
		local castinginfo = { UnitCastingInfo(unit) }
		if #castinginfo > 2 then
			unit_casting_info_cache[unit] = castinginfo
			return unpack(castinginfo)
		else
			unit_casting_info_cache[unit] = false
			return nil
		end
	end

	WAe = {}
	local WAe = WAe
	WAe.areaTriggers = {}
	WAe.om = {}
	WAe.waUnits = {}
	WAe.waUnitTimers = {}
	local sqrt, rad = math.sqrt, math.rad
	local areaTriggers = WAe.areaTriggers
	local waUnits = WAe.waUnits
	local om = WAe.om
	local pX, pY, pZ, playerCR, inInstance
	local drawCleave = true
	local trackQuests = false
	local trackObjects = false
	local dumpstuff = false

	local initNavigation = false

	squid_path = nil
	squid_pathindex = 1
	local stuckCount = 0
	local lastX, lastY, lastZ = 0, 0, 0

	local function Squid_UpdateNav()
		if not ObjectPointer or not player_has_control() then return end
		if squid_path ~= nil then
			local PlayerX, PlayerY, PlayerZ = ObjectPosition("Player");
			local destX = squid_path[squid_pathindex][1]
			local destY = squid_path[squid_pathindex][2]
			local destZ = squid_path[squid_pathindex][3]
			if GetDistanceBetweenPositions(PlayerX, PlayerY, PlayerZ, destX, destY, destZ) < 1.5 then
				squid_pathindex = squid_pathindex + 1
				if squid_pathindex > #squid_path then
					squid_pathindex = 1
					squid_path = nil
				end
			else
				if lastX == PlayerX and lastY == PlayerY and lastZ == PlayerZ then
					stuckCount = stuckCount + 1
					if stuckCount > 100 then
						print('Stuck jumping...')
						JumpOrAscendStart()
						stuckCount = 0
					end
				end
				MoveTo(destX, destY, destZ)
				lastX = PlayerX
				lastY = PlayerY
				lastZ = PlayerZ
			end
		end
	end

	function Squid_Nav(toX, toY, toZ)

		if not player_afk_short then Squid_Alert("Auto Movement Disabled","(Manual Override)") return false end
		if UnitBuffID("player",32727) then return false end

		squid_pathindex = 1
		squid_path = nil

		if not UnitBuffID("player",44521) then
			local PlayerX, PlayerY, PlayerZ = ObjectPosition("Player");
			squid_path, totalDist = CalculatePath(GetMapId(), PlayerX, PlayerY, PlayerZ, toX, toY, toZ, true, false, 2)
			-- print('Created path ' .. #squid_path)
		end

	end

	function Squid_StopNav()
		if not player_has_control() then return end
		squid_path = nil
		squid_pathindex = 1
		local px,py,pz = GetPlayerPosition()
		StopMoving()
		MoveTo(px,py,pz)
	end

	local locale = GetLocale()

	--localization table
	local L = {}
	if locale == "zhCN" then
		L["Training Dummy"] = "è®­ç»ƒå‡äºº"
		L["Raider's Training Dummy"] = "å›¢é˜Ÿå‰¯æœ¬è®­ç»ƒå‡äºº"
		L["Dungeoneer's Training Dummy"] = "åœ°ä¸‹åŸŽè®­ç»ƒå‡äºº"
		L["Gladiator's Medallion"] = "è§’æ–—å£«å‹‹ç« "
	else
		L["Training Dummy"] = "Training Dummy"
		L["Raider's Training Dummy"] = "Raider's Training Dummy"
		L["Dungeoneer's Training Dummy"] = "Dungeoneer's Training Dummy"
		L["Gladiator's Medallion"] = "Gladiator's Medallion"
	end

	Objects = {}
	Enemies = {}
	Friends = {}
	Pets = {}
	unit_buff_cache = {}
	unit_debuff_cache = {}

	function UnitIsPet(unit)
		return UnitIsOtherPlayersPet(unit)
	end

	function perpetual_retardation()
		C_Timer.After(SQUID.tank_mmr and 900 or 2000,function()
			SQUID.tank_mmr = not SQUID.tank_mmr
			retardation_repeater()
		end)
	end

	function retardation_repeater()
		perpetual_retardation()
	end

	function UnitIsHunterPet(unit)
		for i=1,GetNumArenaOpponents() do
			local pet = "arena"..i.."pet"
			local owner = "arena"..i
			if UnitIsVisible(pet) and unit_is_unit(unit,pet) and UnitIsVisible(owner) then
				if select(2,UnitClass(owner)) == "HUNTER" then
					return true
				end
			end
		end
	end

	function Squid_Directory()

		if Squid_Dir then return Squid_Dir end -- global var defined once after ewt funcs registered

		local wow_dir = GetWoWDirectory()
		local addons_subdirectory = "Interface\\AddOns"
		local addons_folder = wow_dir .. "\\" .. addons_subdirectory

		local addons = GetSubdirectories(addons_folder)

		for i=1,#addons do
			local dir = strlower(addons[i])
			if dir == "shalouie" then
				return addons_subdirectory.."\\"..addons[i]
			end
		end
		for i=1,#addons do
			local dir = strlower(addons[i])
			if strmatch(dir,"zzz") or custom_addon_name and strmatch(dir,strlower(custom_addon_name)) then
				return addons_subdirectory.."\\"..addons[i]
			end
		end
	end

	local function tohex(num)
		local hexstr = '0123456789abcdef'
		local s = ''
		while num > 0 do
			local mod = math.fmod(num, 16)
			s = string.sub(hexstr, mod+1, mod+1) .. s
			num = math.floor(num / 16)
		end
		if s == '' then s = '0' end
		return s
	end


	function rgbtoluahex(r,g,b,bool)
		if not bool then
			r = r * 255
			g = g * 255
			b = b * 255
		end
		local hexr = tohex(r)
		if string.len(hexr) < 2 then
			hexr = "0" .. hexr
			if string.len(hexr) < 2 then
				hexr = "0" .. hexr
			end
		end
		local hexg = tohex(g)
		if string.len(hexg) < 2 then
			hexg = "0" .. hexg
			if string.len(hexg) < 2 then
				hexg = "0" .. hexg
			end
		end
		local hexb = tohex(b)
		if string.len(hexb) < 2 then
			hexb = "0" .. hexb
			if string.len(hexb) < 2 then
				hexb = "0" .. hexb
			end
		end
		return "cFF" .. hexr .. hexg .. hexb
	end


	function hexclasscolor(class)
		local r,g,b
		if RAID_CLASS_COLORS[class] then
			r,g,b = RAID_CLASS_COLORS[class].r,RAID_CLASS_COLORS[class].g,RAID_CLASS_COLORS[class].b
		else
			r,g,b = 211,223,14
		end
		return rgbtoluahex(r,g,b)
	end

	C_Timer.After(3,function()
		squid_print("Version " .. version .. " loaded")
	end)

	--hide red txt errors
	-- UIErrorsFrame:Hide()

	--Default State
	SquidLobster=nil;
	function SquidToggle()
		SquidLobster = not SquidLobster

		if SquidLobster then
			if AlertFrames_Anchor then
				green_line_test = GetTime()
				Squid_Alert("|cFFdecbebRotation Enabled",nil,nil,.35)
			end
			squid_print("Squidward Engaged")
		else
			if AlertFrames_Anchor then
				red_line_test = GetTime()
				Squid_Alert("|cFFca2aa5Rotation Disabled",nil,nil,.35)
			end
			squid_print("Squidward Offline",true)
		end

	end

	--Squid Burst
	function SquidBurst()
		Squid_Burst = GetTime()
	end

	gcd_spells_cache = {}

	function IsSpellOnGCD(spell)
		if gcd_spells_cache[spell] then return gcd_spells_cache[spell] end
		spellname=GetSpellInfo(spell)
		if spellname then
			local basecd,gcd = GetSpellBaseCooldown(spellname)
			if gcd then
				if gcd > 0 then gcd_spells_cache[spell] = true return true end
			end
			gcd_spells_cache[spell] = false
		end
	end

	function GetCurrentGCD()
		return _spellCooldown(61304)
	end

	GetGCD=GetCurrentGCD

	function GetPlayerPosition()
		if player_position then
			local pos = player_position
			return pos.x,pos.y,pos.z
		end
	end

	function Free_Bag_Slots()
		count=0;
		for i=0,5 do
			count=count+GetContainerNumFreeSlots(i);
		end
		return count;
	end


	--hide player name
	-- local player_name = UnitName("player")
	local custom_name = "ä¹Œè´¼" -- squid in chinese lmao


	function GetGladMount()
		--57552 LOL BIG CRAB THING
		--39297 huge red infernal thing
		--33791 FUCKING DEATHWING, THE REAL ONE.
		--44663 LMAO FISH THING
		--74674 URSOC BRO
		--78889 MASSIVE FUCKING BRONTO THING
		--75959 INSANE SQUID WITH AN ASSHOLE FULL OF TEETH
		--27481 RIDING ON LICH KING'S SWORD ROFLLLL
		local gladmounts = {
		38757,	--Cataclysmic Glad
		38756,	--Purple Cata Glad
		38755,	--Blue Cata Glad
		25593,	--Furious Glad
		73317,	--Cruel Glad
		47976,	--Malev Glad
		51361,	--Tyrannical Glad
		20344,	--Swift Nether Drake(s1)
		76533,	--Demonic Glad
		82804,	--Sinister Glad
		73320,	--Fierce Glad
		}

		local mount = gladmounts[math.random(1,#gladmounts)]
		SetMountDisplayID("player",mount)
		-- print(mount)
	end

	function SetCustomName(unit, fontString)
		fontString:SetText(custom_name)
	end

	local pname = UnitName("player")
	CreateFrame("Frame"):SetScript("OnUpdate",function()
		if not pname or pname == "Unknown" then
			pname = UnitName("player")
		end
		if SQUID.anon then
			local name = PlayerName:GetText()
			if name == pname then
				PlayerName:SetText(custom_name)
			end
		end
	end)

	-- hooksecurefunc("UnitFrame_Update", function(frame, isParty)
	--     if frame.name and SQUID.anon then
	--         local unit = frame.overrideName or frame.unit
	--         if unit and UnitPlayerControlled(unit) then
	--         	if unit_is_unit("player",unit) then
	--            		SetCustomName(unit, frame.name)
	--            	elseif UnitIsFriend("player",unit) or UnitInParty(unit) then
	--            		frame.name:SetText("Friend of Squid")
	--            	end
	--         end
	--     end
	-- end)

	-- unit_is_unit_cache = {}

	function unit_is_unit(unit,otherunit)
		if not unit or not otherunit then return false end
		if unit == otherunit then return true end
		-- local cache = unit_is_unit_cache[unit..otherunit]
		-- if cache ~= nil then return cache end
		local r = UnitIsUnit(unit,otherunit)
		-- unit_is_unit_cache[unit..otherunit] = r
		return r--or UnitExists(unit) and UnitExists(otherunit) and UnitGUID(unit) == UnitGUID(otherunit)
	end

	function new_floor(decimal)
		local new = math.floor(decimal)
		return new, decimal - new
	end

	function unit_disarmed(unit)

		local unit_tag
		if not unit_tag and unit_is_unit(unit,"player") then unit_tag = "player" end
		if not unit_tag and unit_is_unit(unit,"target") then unit_tag = "target" end
		if not unit_tag and unit_is_unit(unit,"focus") then unit_tag = "focus" end
		if not unit_tag and unit_is_unit(unit,"arena1") then unit_tag = "arena1" end
		if not unit_tag and unit_is_unit(unit,"arena2") then unit_tag = "arena2" end
		if not unit_tag and unit_is_unit(unit,"arena3") then unit_tag = "arena3" end
		if not unit_tag then return false end

		local desc = squid_debuff_descriptions[unit_tag]

		for i=1,#desc do
			local str = desc[i]
			if str and strmatch(str, "Disarmed.") then
				return true
			end
		end

	end

	-- returns duration of dot, time remaining and time to next tick :)
	function unit_has_dot(unit,remains)

		local unit_tag
		if not unit_tag and unit_is_unit(unit,"player") then unit_tag = "player" end
		if not unit_tag and unit_is_unit(unit,"target") then unit_tag = "target" end
		if not unit_tag and unit_is_unit(unit,"focus") then unit_tag = "focus" end
		if not unit_tag and unit_is_unit(unit,"arena1") then unit_tag = "arena1" end
		if not unit_tag and unit_is_unit(unit,"arena2") then unit_tag = "arena2" end
		if not unit_tag and unit_is_unit(unit,"arena3") then unit_tag = "arena3" end
		if not unit_tag then return false end

		local desc = squid_debuff_descriptions[unit_tag]

		for i=1,#desc do
			local str = desc[i]
			if str and (strmatch(str, "sec.") or strmatch(str, "seconds.")) then
				if remains then
					local tick_rate = string.match(str, "every(.*)")
					if tick_rate then tick_rate = strmatch(tick_rate, "%s+(%S+)") else tick_rate = nil end
					if tick_rate then tick_rate = tonumber(tick_rate) end
					if tick_rate then
						local _,_,_,_,_,ends = UnitDebuff(unit, i)
						if ends then
							local last_tick = ends
							local ticks_remain, excess = new_floor( (last_tick - GetTime()) / tick_rate )
							local ticks = {}
							for i=last_tick-(ticks_remain * tick_rate),last_tick,tick_rate do
								local tick = i - GetTime()
								if tick > 0 then
									table.insert(ticks,tick)
								end
							end
							table.sort(ticks, function(x,y) return x < y end)
							local next_tick = ticks[1]
							return last_tick, next_tick, ticks
						end
					end
				else
					return true
				end
			end
		end

	end

	function unit_has_klepto(unit)
		if (select(2,UnitClass(unit)) ~= "MAGE") then return false end
		if (squid_klepto_tracker[unit] == nil) then return true end

		if (squid_klepto_tracker[unit]["running_klepto"] == false) then
			return false
		elseif (GetTime() - squid_klepto_tracker[unit]["last_cast"] < 27) then
			return false
		else
			return true
		end
	end

	local function LockoutDuration(spell)
		if spell == "Disrupt" then
			return 3
		elseif spell == "Pummel" then
			return 4
		elseif spell == "Rebuke" then
			return 4
		elseif spell == "Counter Shot" then
			return 3
		elseif spell == "Kick" then
			return 5
		elseif spell == "Mind Freeze" then
			return 4
		elseif spell == "Wind Shear" then
			return 3
		elseif spell == "Optical Blast" then
			return 6
		elseif spell == "Spell Lock" then
			return 6
		elseif spell == "Shadow Lock" then
			return 6
		elseif spell == "Counterspell" then
			return 6
		elseif spell == "Spear Hand Strike" then
			return 4
		elseif spell == "Skull Bash" then
			return 4
		elseif spell == "Solar Beam" then
			return 5
		elseif spell == "Muzzle" then
			return 3
		end
		return 4
	end

	local chan_delay = math.random(1,3)
	function SetMinDelay()
		SQUID.min_mindelay = SQUID.min_mindelay or 155
		SQUID.max_mindelay = SQUID.max_mindelay or 325
		if not minDelayTime then -- init mindelay
			minDelayTime = ((math.random(SQUID.min_mindelay,SQUID.max_mindelay))/1000);
		end
		C_Timer.After(5,function()
			minDelayTime = ((math.random(SQUID.min_mindelay,SQUID.max_mindelay))/1000);
			chan_delay = math.random(1,3)
			mindelayrepeater()
		end)
		SQUID.max_juke_attempts = SQUID.max_juke_attempts or 2
		SQUID.min_jukedelay = SQUID.min_jukedelay or 1
		SQUID.max_jukedelay = SQUID.max_jukedelay or 60
	end
	function mindelayrepeater()
		SetMinDelay()
	end

	SetMinDelay()

	local function set_net_delay()
		local delay_min = 0
		local delay_max = 100
		if not SQUID.extra_net_delay then
			SQUID.extra_net_delay = math.random(delay_min, delay_max) / 1000
		else
			C_Timer.After(4,function()
				SQUID.extra_net_delay = math.random(delay_min, delay_max) / 1000
				set_net_delay()
			end)
		end
	end

	function GetNetCorruption()
		local c, r = GetCorruption(), GetCorruptionResistance()
		return max (0, c - r)
	end

	--Track Attempted Jukes (Self Interrupted Spells)
	jukeList = {}
	function OnJuke(self,event,...)

		if not ObjectPointer then return end

		local sourceName = select(1,...);
		local spellName = select(2,...);
		local sourceGUID = select(4,...)
		local spellID = select(5,...);

		local sourcePointer = ObjectPointer (sourceName);

		local time = GetTime()

		if sourcePointer then
			if not jukeList[sourcePointer] or not jukeList[sourcePointer]["Jukes"] then
				jukeList[sourcePointer] = {};
				jukeList[sourcePointer]["Jukes"] = 1;
				jukeList[sourcePointer]["MaxJukes"] = math.random(2,5);
				jukeList[sourcePointer]["Reset"] = time+1.4;
				return
			end
			if jukeList[sourcePointer] then
				if not jukeList[sourcePointer]["Fired"] or GetTime()-jukeList[sourcePointer]["Fired"] > .5 then
					jukeList[sourcePointer]["Jukes"] = jukeList[sourcePointer]["Jukes"] + 1;
					jukeList[sourcePointer]["Reset"] = time+1.4;
					jukeList[sourcePointer]["Fired"] = time;
				end
			end
		end

	end

	JukeFrame = CreateFrame("Frame");
	JukeFrame:RegisterEvent("UNIT_SPELLCAST_STOP");
	JukeFrame:SetScript("OnEvent",OnJuke);

	local function get_unit_buffs(unit)
		local Buffs = {}
		for i = 1, 40 do
			local Infos = { UnitBuff(unit, i) }
			if not Infos[10] then
				break
			end
			Buffs[i] = Infos
		end
		return unpack(Buffs)
	end

	local function get_unit_debuffs(unit)
		local Buffs = {}
		for i = 1, 40 do
			local Infos = { UnitDebuff(unit, i) }
			if not Infos[10] then
				break
			end
			Buffs[i] = Infos
		end
		return unpack(Buffs)
	end

	function find_aura(unit,spellid,filter)

		local unpack = unpack
		local spellname = type(spellid) ~= "number" and spellid or " "

		if filter == "HARMFUL" then
			local cache = unit_debuff_cache[unit]
			if not cache then
				unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
				cache = unit_debuff_cache[unit]
				for i=1,#cache do
					if cache[i][10] == spellid or cache[i][1] == spellname then
						return cache[i]
					end
				end
			else
				for i=1,#cache do
					if cache[i][10] == spellid or cache[i][1] == spellname then
						return cache[i]
					end
				end
			end
		end

		if filter == "HELPFUL" then
			local cache = unit_buff_cache[unit]
			if not cache then
				unit_buff_cache[unit] = {get_unit_buffs(unit)}
				cache = unit_buff_cache[unit]
				for i=1,#cache do
					if cache[i][10] == spellid or cache[i][1] == spellname then
						return cache[i]
					end
				end
			else
				for i=1,#cache do
					if cache[i][10] == spellid or cache[i][1] == spellname then
						return cache[i]
					end
				end
			end
		end

	end

	function UnitBuffID(unit, spellID, source)
		if not unit then return end
		local spellName = type(spellID) == "number" and GetSpellInfo(spellID) or spellID
		local buff = find_aura(unit, spellID, "HELPFUL")
		local buffsource = buff and buff[7]
		if buff and buff[1] == spellName and (not source or unit_is_unit(source,buffsource)) then
			return unpack(buff)
		end
	end

	function UnitDebuffID(unit, spellID, source)
		if not unit then return end
		local spellName = type(spellID) == "number" and GetSpellInfo(spellID) or spellID
		local debuff = find_aura(unit, spellID, "HARMFUL")
		local debuffsource = debuff and debuff[7]
		if debuff and debuff[1] == spellName and (not source or unit_is_unit(source,debuffsource)) then
			return unpack(debuff)
		end
	end

	function _debuffStacks(...)
		local debuff = select(3,UnitDebuffID(...));
		return debuff or 0;
	end

	function _buffStacks(...)
		local buff = select(3,UnitBuffID(...));
		return buff or 0;
	end

	function _debuffRemains(unit,spellid,source)
		local debuff,_,_,_,_,t = UnitDebuffID(unit,spellid,source)
		if debuff then
			local remain = t - GetTime()
			if remain > 0 then
				return remain
			else
				return -1
			end
		end
		return 0
	end

	function _buffRemains(unit,spellid,source)
		local buff,_,_,_,_,t = UnitBuffID(unit,spellid,source)
		if buff then
			local remain = t - GetTime()
			if remain > 0 then
				return remain
			else
				return -1
			end
		end
		return 0
	end

	function _buffUptime(unit,spellid,time)
		local duration,expiration = select(5,UnitBuffID(unit,spellid))
		if duration and expiration then
			if time then
				if time == 0 or expiration-GetTime() < duration-time then
					return true;
				end
			else
				return duration-(expiration-GetTime());
			end
		end
		return 0;
	end

	function _debuffUptime(unit,spellid,time)
		local duration,expiration = select(5,UnitDebuffID(unit,spellid))
		if duration and expiration then
			if time then
				if time == 0 or expiration-GetTime() < duration-time then
					return true;
				end
			else
				return duration-(expiration-GetTime());
			end
		end
		return 0;
	end


	function _realDistance(unit,unit2)

		if not unit then return 9999 end

		if not unit2 then

			unit2 = "player"

			if distance_cache[unit] then
				return distance_cache[unit]
			end

			local dist = GetDistanceBetweenObjects(unit,unit2)

			distance_cache[unit] = dist

			return dist

		elseif unit_is_unit("player",unit) then

			if distance_cache[unit2] then
				return distance_cache[unit2]
			end

			local dist = GetDistanceBetweenObjects(unit,unit2)

			distance_cache[unit2] = dist

			return dist

		else

			return GetDistanceBetweenObjects(unit,unit2)

		end

	end

	distance_cache = {}

	function _distance(unit,unit2)

		if not UnitIsVisible(unit) then return 9999 end

		if not unit2 then

			unit2 = "player"

			if distance_cache[unit] then
				return distance_cache[unit]-UnitCombatReach(unit2)-UnitCombatReach(unit)
			end

			local dist = GetDistanceBetweenObjects(unit,unit2)

			if not dist then print("Dist not found for " .. unit1 or "NO UNIT" .. " and " .. unit2 or "NO UNIT 2") return 999 end

			distance_cache[unit] = dist

			return dist-UnitCombatReach(unit2)-UnitCombatReach(unit)

		elseif unit_is_unit("player",unit) then

			if distance_cache[unit2] then
				return distance_cache[unit2]-UnitCombatReach(unit2)-UnitCombatReach(unit)
			end

			local dist = GetDistanceBetweenObjects(unit,unit2)

			distance_cache[unit2] = dist

			return dist-UnitCombatReach(unit2)-UnitCombatReach(unit)

		else

			return GetDistanceBetweenObjects(unit,unit2)-UnitCombatReach(unit2)-UnitCombatReach(unit)

		end

	end

	function _meleeRange(unit,otherUnit)
		otherUnit = otherUnit or "player";
		if not unit or not otherUnit then return false end
		if not IsPlayerSpell(197488) then
			return _realDistance(otherUnit,unit) <= (math.max(UnitCombatReach(otherUnit) + UnitCombatReach(unit) + 4 / 3 + ((_isMoving(otherUnit) and _isMoving(unit)) and 8 / 3 or .5), 5)) + 1;
		else
			return _realDistance(otherUnit,unit) <= (math.max(UnitCombatReach(otherUnit) + UnitCombatReach(unit) + 4 / 3 + ((_isMoving(otherUnit) and _isMoving(unit)) and 8 / 3 or .5), 5)) + 4;
		end
	end

	function _distanceToCoord(sx,sy,sz,tx,ty,tz)
		if not tx then
			tx,ty,tz = GetPlayerPosition()
		end
		return math.sqrt(((tx-sx)^2)+((ty-sy)^2)+((tz-sz)^2));
	end

	function _kickTravelTime(unit)
		local traveltime = 0

		if InterruptID == 147362 then
			traveltime = _distance(unit)*.009;
		end
		if InterruptID == 106839 then
			traveltime = .05 + (_distance(unit)*.0085);
		end
		if InterruptID == 1766 and not _meleeRange(unit) then
			traveltime = .375 + squid_avg_latency + 1/GetFramerate()
		end

		if InterruptID == 2139 and not _LoS(unit) then
			traveltime = squid_avg_latency + squid_avg_home_latency + .1
		end

		return traveltime;
	end

	function _castTime(spellid)

		if spellid=="Summon Terrorguard" and not UnitBuffID("player",74434) then return 4.5; end

		if not spellid or not GetSpellInfo(spellid) then return nil; end

		if IsPlayerSpell(60103) or IsPlayerSpell(61882) then if UnitPower("player") >= 20 then return 0; end end

		return select(4, GetSpellInfo(spellid)) / 1000

	end

	--start end ..  cast = 4,5 channel = 4,5
	function _castTimeComplete(unit,total)
		if total then
			if unit_casting_info(unit) then
				local spellName, _, _, castStartTime, castEndTime, _, _, notInterruptible = unit_casting_info(unit)
				local realCastEndTime = castEndTime/1000
				local realCastStartTime = castStartTime/1000
				local totalCastTime = realCastEndTime - realCastStartTime
				return totalCastTime
			end
			if UnitChannelInfo(unit) then
				local spellName, _, _, channelStartTime, channelEndTime, _, _, notInterruptible = UnitChannelInfo(unit)
				local realChannelEndTime = channelEndTime/1000
				local realChannelStartTime = channelStartTime/1000
				local totalChannelTime = realChannelEndTime - realChannelStartTime
				return totalChannelTime
			end
			return 0;
		else
			if unit_casting_info(unit) then
				local spellName, _, _, castStartTime, castEndTime, _, _, notInterruptible = unit_casting_info(unit)
				local realCastEndTime = castEndTime/1000
				local realCastStartTime = castStartTime/1000
				local castTimeCompleted = GetTime()-realCastStartTime
				return castTimeCompleted
			end
			if UnitChannelInfo(unit) then
				local spellName, _, _, channelStartTime, channelEndTime, _, _, notInterruptible = UnitChannelInfo(unit)
				local realChannelEndTime = channelEndTime/1000
				local realChannelStartTime = channelStartTime/1000
				local channelTimeCompleted = GetTime()-realChannelStartTime
				return channelTimeCompleted
			end
			return 0;
		end
	end

	function _totalCastTime(unit)
		if unit_casting_info(unit) then
			local spellName, _, _, castStartTime, castEndTime, _, _, notInterruptible = unit_casting_info(unit)
			local realCastEndTime = castEndTime/1000
			local realCastStartTime = castStartTime/1000
			local totalCastTime = realCastEndTime-realCastStartTime
			return totalCastTime
		end
		return 0;
	end

	function _castTimeLeft(unit)
		if unit_casting_info(unit) then
			local frame = (1/GetFramerate())*1000
			return ((select(5, unit_casting_info(unit)) - frame) - (GetTime()*1000)) / 1000
		end
		if UnitChannelInfo(unit) then
			local frame = (1/GetFramerate())*1000
			return ((select(5, UnitChannelInfo(unit)) - frame) - (GetTime()*1000)) / 1000
		end
		return 0
	end

	function _castPctDone(unit)
		if unit_casting_info(unit) then
			local spellName, _, _, castStartTime, castEndTime, _, _, notInterruptible = unit_casting_info(unit)
			local castPercentDone = (((GetTime() - castStartTime/1000)) / (castEndTime/1000 - castStartTime/1000) ) * 100
			return castPercentDone
		end
		if UnitChannelInfo(unit) then
			local spellName, _, _, channelStartTime, channelEndTime, _, _, notInterruptible = UnitChannelInfo(unit)
			local channelPercentDone = (((GetTime() - channelStartTime/1000)) / (channelEndTime/1000 - channelStartTime/1000) ) * 100
			return channelPercentDone
		end
		return 0;
	end

	function _getMovingDirection(unit)

		local R = ObjectFacing(unit);

		local mod = 0;

		local flags = UnitMovementFlags(unit)

		if not flags then return false
		else flags = bit.band(flags, 0xF) end

		if flags == 0x2 then
			mod = math.pi;
		elseif flags == 0x4 then
			mod = math.pi * 0.5;
		elseif flags == 0x8 then
			mod = math.pi * 1.5;
		elseif flags == bit.bor(0x1, 0x4) then
			mod = math.pi * (1 / 8) * 2;
		elseif flags == bit.bor(0x1, 0x8) then
			mod = math.pi * (7 / 8) * 2;
		elseif flags == bit.bor(0x2, 0x4) then
			mod = math.pi * (3 / 8) * 2;
		elseif flags == bit.bor(0x2, 0x8) then
			mod = math.pi * (5 / 8) * 2;
		end

		return (R + mod) % (math.pi * 2);
	end
	GetMovingDirection = _getMovingDirection

	moving_towards_table = {}

	function _movingTowards(unit,amount,otherUnit,general,nostrafe)
		if not unit then return false end
		if not otherUnit then otherUnit="player" end
		local amount = amount or .102
		local X,Y,Z = ObjectPosition(unit);
		local pX,pY,pZ = ObjectPosition(otherUnit);
		local direction = _getMovingDirection(otherUnit);
		local distance = GetUnitSpeed(otherUnit)*amount
		if UnitIsVisible(unit) then
			local yes = _distanceToCoord(pX + distance * math.cos(direction), pY + distance * math.sin(direction), pZ, X, Y, Z)+(GetUnitSpeed(otherUnit)/10) < _distanceToCoord(pX,pY,pZ,X,Y,Z);
			local flags = {
			1,
			5,
			9,
			8,
			4,
			}
			local playerflags = UnitMovementFlags("player")
			if yes and (not nostrafe or playerflags == 1 or playerflags == 5 or playerflags == 9) and (general or tContains(flags,playerflags)) then
				for i=1,#moving_towards_table do
					local m = moving_towards_table[i]
					if m then
						if m.unit == unit and m.amount == amount and m.otherUnit == otherUnit and m.general == general then
							return true
						end
					end
				end
				table.insert(moving_towards_table,{unit=unit,amount=amount,otherUnit=otherUnit,general=general,time=GetTime()})
				return true
			else
				for i=1,#moving_towards_table do
					local m = moving_towards_table[i]
					if m then
						if m.unit == unit and m.amount == amount and m.otherUnit == otherUnit and m.general == general then
							table.remove(moving_towards_table,i)
						end
					end
				end
			end
		end
	end

	function moving_towards_unit_duration(unit,amount,otherUnit,general,directly,nostrafe)
		if not otherUnit then otherUnit="player" end
		local amount = amount or .102
		for i=1,#moving_towards_table do
			local m = moving_towards_table[i]
			if m.unit == unit and m.amount == amount and m.otherUnit == otherUnit and m.general == general then
				return GetTime()-m.time
			end
		end
		return 0
	end

	function _movingAwayFrom(unit,amount,otherUnit,general,nostrafe)
		if not otherUnit then otherUnit="player" end
		local amount = amount or .102
		local X,Y,Z = ObjectPosition(unit);
		local pX,pY,pZ = ObjectPosition(otherUnit);
		local direction = _getMovingDirection(otherUnit);
		local distance = GetUnitSpeed(otherUnit)*amount
		local yes = _distanceToCoord(pX + distance * math.cos(direction), pY + distance * math.sin(direction), pZ, X, Y, Z) > _distanceToCoord(pX,pY,pZ,X,Y,Z);
		local flags = {
		1,
		5,
		9
		}
		local playerflags = UnitMovementFlags(otherUnit)
		if yes and (not nostrafe or playerflags == 1) and (general or tContains(flags,playerflags)) then
			return true
		end
	end

	function predict_distance_from_unit(unit,time)
		if not time then time = 1 end
		local px,py,pz = PredictUnitPosition("player",time)
		local x,y,z = PredictUnitPosition(unit,time)
		if px and py and pz and x and y and z then
			local d = GetDistanceBetweenPositions(px,py,pz,x,y,z)
			return d
		else
			return -1
		end
	end

	function moving_away_from(unit,extra)
		extra = extra or 0
		local d = _realDistance(unit)
		if d < 5.5 and _amIfacing(unit) then return false end
		if predict_distance_from_unit(unit) > d + extra then return true end
	end

	los_cache = {}

	local los_whitelist = {
		[56754] = true, -- Azure Serpent (Shado'pan Monestary)
		[56895] = true, -- Weak Spot - Raigon (Gate of the Setting Sun)
		[76585] = true, -- Ragewing
		[77692] = true, -- Kromog
		[77182] = true, -- Oregorger
		-- 86644, 	-- Ore Crate from Oregorger boss
		[96759] = true, -- Helya
		[100360] = true, -- Grasping Tentacle (Helya fight)
		[100354] = true, -- Grasping Tentacle (Helya fight)
		[100362] = true, -- Grasping Tentacle (Helya fight)
		[98363] = true, -- Grasping Tentacle (Helya fight)
		[99803] = true, -- Destructor Tentacle (Helya fight)
		[99801] = true, -- Destructor Tentacle (Helya fight)
		[98696] = true, -- Illysanna Ravencrest (Black Rook Hold)
		[114900] = true, -- Grasping Tentacle (Trials of Valor)
		[114901] = true, -- Gripping Tentacle (Trials of Valor)
		[116195] = true, -- Bilewater Slime (Trials of Valor)
		[120436] = true, -- Fallen Avatar (Tomb of Sargeras)
		[116939] = true, -- Fallen Avatar (Tomb of Sargeras)
		[118462] = true, -- Soul Queen Dejahna (Tomb of Sargeras)
		[119072] = true, -- Desolate Host (Tomb of Sargeras)
		[118460] = true, -- Engine of Souls (Tomb of Sargeras)
		[122450] = true, -- Garothi Worldbreaker (Antorus the Burning Throne - Confirmed in game)
		[123371] = true, -- Garothi Worldbreaker (Antorus the Burning Throne)
		[122778] = true, -- Annihilator - Garothi Worldbreaker (Antorus the Burning Throne)
		[122773] = true, -- Decimator - Garothi Worldbreaker (Antorus the Burning Throne)
		[122578] = true, -- Kin'garoth (Antorus the Burning Throne - Confirmed in game)
		[125050] = true, -- Kin'garoth (Antorus the Burning Throne)
		[131863] = true, -- Raal the Gluttonous (Waycrest Manor)
		[134691] = true, -- Static-charged Dervish (Temple of Sethraliss)
		[137405] = true, -- Gripping Terror (Siege of Boralus)
		[140447] = true, -- Demolishing Terror (Siege of Boralus)
		[137119] = true, -- Taloc (Uldir1)
		[137578] = true, -- Blood shtorm (Uldir - Taloc's fight)
		[138959] = true, -- Coalesced Blood (Uldir - Taloc's fight)
		[138017] = true, -- Cudgel of Gore (Uldir - Taloc's fight)
		[130217] = true, -- Nazmani Weevil (Uldir - Taloc's fight)
		[140286] = true, -- Uldir Defensive Beam *Uldir)
		[138530] = true, -- Volatile Droplet (Uldir - Taloc's fight)
		[133392] = true, -- Sethraliss
		[146256] = true, -- Laminaria
		[150773] = true, -- Blackwater Behemoth Mob
		[152364] = true, -- Radiance of Azshara
		[152671] = true, -- Wekemara
		[157602] = true, -- Drest'agath - Ny'alotha
		[158343] = true, -- Organ of Corruption - Ny'alotha
		[157486] = true, -- Horrific Hemorrhage - Ny'alotha
		[158041] = true, -- N'zoth the Corruptor - Ny'alotha
		[166608] = true, -- Mueh'Zala (De'Other Side)
		[168326] = true, -- Shattered Visage (De'Other Side)
	}

	local index = 1

	los_checked = {

	}

	function _LoS(unit,otherUnit,not_for_cast)

		if not otherUnit then otherUnit = "player"; end

		if UnitIsVisible(unit) then

			if los_cache[unit..otherUnit] ~= nil then return los_cache[unit..otherUnit] end
			if los_cache[otherUnit..unit] ~= nil then return los_cache[otherUnit..unit] end

			local unit_is_player = unit_is_unit("player",unit)
			local other_unit_is_player = unit_is_unit("player",otherUnit)

			if unit_is_player and other_unit_is_player then return true end

			-- if not unit_is_player and not other_unit_is_player then print(name,name2) end

			local id = ObjectID(unit)
			local id2 = ObjectID(otherUnit)

			--LoS Whitelist
			if los_whitelist[id] or los_whitelist[id2] then return true end

			local time = GetTime()

			local X1,Y1,Z1
			if unit_is_player then
				X1,Y1,Z1 = GetPlayerPosition()
			else
				X1,Y1,Z1 = ObjectPosition(unit)
			end

			local X2,Y2,Z2
			if other_unit_is_player then
				X2,Y2,Z2 = GetPlayerPosition()
			else
				X2,Y2,Z2 = ObjectPosition(otherUnit)
			end

			--buffs and debuffs which affect los

			--smoke cloud
			-- local smoke_cloud_one = UnitDebuffID(unit,298602)
			-- local smoke_cloud_two = UnitDebuffID(otherUnit,298602)

			-- if smoke_cloud_one then
			-- 	return smoke_cloud_two
			-- elseif smoke_cloud_two then
			-- 	return smoke_cloud_one
			-- end

			if not not_for_cast then
				-- --smoke bomb
				local smoke_bomb_one,_,_,_,_,_,source_one = UnitDebuffID(unit,212183)
				local smoke_bomb_two,_,_,_,_,_,source_two = UnitDebuffID(otherUnit,212183)

				--check if units are within smoke bomb, unless it's friendly to the opposing unit
				if source_one then
					if not UnitIsFriend(otherUnit,source_one) then
						-- los_checked[unit] = {los=not smoke_bomb_two, time=GetTime()}
						return smoke_bomb_two
					end
				end
				if source_two then
					if not UnitIsFriend(unit,source_two) then
						-- los_checked[unit] = {los=not smoke_bomb_one, time=GetTime()}
						return smoke_bomb_one
					end
				end
			end

			local los = not TraceLine(X1,Y1,Z1+1.8,X2,Y2,Z2+1.8,losflags)

			los_cache[unit..otherUnit] = los

			-- local frame = 1/GetFramerate()
			-- los_checked[unit] = {los=los, time=GetTime()}

			return los

		end

	end

	-- time_in_los
	function time_in_los(unit)

		if not unit then return 0 end

		local los = _LoS(unit)

		local thisunit
		if not los_checked[unit] then
			los_checked[unit] = {los=los, time=GetTime()}
			thisunit = los_checked[unit]
		else
			thisunit = los_checked[unit]
			if thisunit.los ~= los then
				thisunit.los = los
				thisunit.time = GetTime()
			end
		end

		if thisunit then
			return thisunit.los and GetTime() - thisunit.time or 0
		end

	end

	function los_coords(x,y,z,X,Y,Z)
		return not TraceLine(x,y,z+2,X,Y,Z+2, losflags);
	end

	hp_cache = {}

	function _HP(unit)
		if hp_cache[unit] then return hp_cache[unit] end
		if not unit or not UnitIsVisible(unit) then return 100 end
		if UnitIsDeadOrGhost(unit) then return 100 end
		if UnitIsVisible(unit) and UnitExists(unit) then
			local hp = (100 * UnitHealth(unit) / UnitHealthMax(unit));
			hp_cache[unit] = hp
			return hp
		end
		return 100
	end

	unit_role_cache = {}

	function GetUnitRole(unit)
		if unit_role_cache[unit] then return unit_role_cache[unit] end
		local unit_visible = UnitIsVisible(unit)

		if unit_visible and not unit_is_player(unit) then return "pet" end
		if unit_visible then
			if UnitGroupRolesAssigned(unit) == "HEALER" then
				unit_role_cache[unit] = "healer"
				return "healer";
			end
		end
		if arena then
			for i=1,GetNumArenaOpponents() do if unit_is_unit("arena"..i,unit) then
				local specid = GetArenaOpponentSpec(i)
				if not specid then return nil end
				if select(5,GetSpecializationInfoByID(specid)) == "HEALER" then
					unit_role_cache[unit] = "healer"
					return "healer"
				end
				if select(5,GetSpecializationInfoByID(specid)) == "DAMAGER" or select(5,GetSpecializationInfoByID(specid)) == "TANK" then
					local class = select(6,GetSpecializationInfoByID(specid))
					local spec = select(2,GetSpecializationInfoByID(specid))
					local TankSpecs = {
					"Guardian",
					"Vengeance",
					"Blood",
					"Protection",
					"Brewmaster",
					}
					local MeleeSpecs = {
					"Frost",
					"Unholy",
					"Havoc",
					"Feral",
					"Guardian",
					"Vengeance",
					"Survival",
					"Brewmaster",
					"Windwalker",
					"Protection",
					"Retribution",
					"Assassination",
					"Outlaw",
					"Subtlety",
					"Enhancement",
					"Arms",
					"Fury",
					}; -- frost dk / mage ,
					local RangedSpecs = {
					"Frost",
					"Fire",
					"Arcane",
					"Beast Mastery",
					"Marskmanship",
					"Shadow",
					"Elemental",
					"Affliction",
					"Destruction",
					"Demonology",
					"Balance",
					} -- frost dk / mage
					local HealerSpecs = {
					"Holy",
					"Restoration",
					"Mistweaver",
					"Discipline"
					}
					if tContains(TankSpecs,spec) then
						unit_role_cache[unit] = "tank"
						return "tank"
					end
					if tContains(MeleeSpecs,spec) then
						if spec ~= "Frost" or class ~= "MAGE" then
							unit_role_cache[unit] = "melee"
							return "melee"
						end
					end
					if tContains(RangedSpecs,spec) then
						if spec ~= "Frost" or class ~= "DEATHKNIGHT" then
							unit_role_cache[unit] = "ranged"
							return "ranged"
						end
					end
					if tContains(HealerSpecs,spec) then
						unit_role_cache[unit] = "healer"
						return "healer"
					end
				end
			end end
		end
		local class = select(2,UnitClass(unit));
		if class  == "DRUID" and (UnitPower(unit,8) > 0 or UnitBuffID(unit,24858)) then unit_role_cache[unit] = "ranged" return "ranged"; end
		if class == "DRUID" and UnitPowerMax(unit,0) <= 20000 then unit_role_cache[unit] = "melee" return "melee"; end
		if class == "SHAMAN" and UnitPowerMax(unit,0) <= 20000 then unit_role_cache[unit] = "melee" return "melee"; end
		if class == "DEATHKNIGHT" then return "melee"; end
		if class == "MONK" and UnitPowerMax(unit) < 1000 then unit_role_cache[unit] = "melee" return "melee"; end
		if class == "ROGUE" then unit_role_cache[unit] = "melee" return "melee"; end
		if class == "WARRIOR" then unit_role_cache[unit] = "melee" return "melee"; end
		if class == "PALADIN" and UnitPowerMax(unit,0) <= 20000 then unit_role_cache[unit] = "melee" return "melee"; end
		if class == "DEMONHUNTER" then unit_role_cache[unit] = "melee" return "melee"; end
		if class == "MAGE" then unit_role_cache[unit] = "ranged" return "ranged"; end
		if class == "HUNTER" then unit_role_cache[unit] = "melee" return "melee"; end

		if class == "PALADIN" and UnitPowerMax(unit,0) >= 100000 then unit_role_cache[unit] = "healer" return "healer"; end

		if class == "PRIEST" then
			if UnitPower(unit,13) > 0 or UnitBuffID(unit,232698) then
				unit_role_cache[unit] = "ranged"
				return "ranged"
			else
				--don't cache priests as healers
				return "healer"
			end
		end

		--boomy fallthru
		if class == "DRUID" then unit_role_cache[unit] = "ranged" return "ranged"; end

	end

	function arena_unit_tag(unit)
		for i=1,GetNumArenaOpponents() do
			if unit_is_unit(unit, "arena"..i) then
				return "arena"..i
			end
		end
	end

	function _isTank(unit)
		return GetUnitRole(unit) == "tank";
	end

	function _isMeleeDps(unit)
		local role = GetUnitRole(unit)
		return role == "melee" or role == "tank";
	end

	function _isHealer(unit)
		return GetUnitRole(unit) == "healer"-- or arena_unit_tag(unit);
	end

	function _isDps(unit)
		local role = GetUnitRole(unit)
		return role == "melee" or role == "ranged"
	end

	function _isRangedDps(unit)
		return GetUnitRole(unit) == "ranged";
	end

	function _spellCooldown(spellid)
		local start, duration
		if spellid == 2061 then
			start, duration = GetSpellCooldown(605)
		elseif spellid == 1784 then
			start, duration = GetSpellCooldown(IsPlayerSpell(108208) and 115191 or 1784)
		else
			start, duration = GetSpellCooldown(spellid)
		end
		local time = GetTime()
		if not start then return 0 end
		if duration + (start - time) > 0 then
			return duration + (start - time)
		else
			return 0
		end
	end

	function _spellChargeFrac(spellid)
		if GetTime() - select(3,GetSpellCharges(spellid)) > 0 then
			return GetSpellCharges(spellid) + ((GetTime() - select(3,GetSpellCharges(spellid)))/select(4,GetSpellCharges(spellid)));
		else
			return GetSpellCharges(spellid);
		end
	end

	function _getRecharge(spellID,chargeMax)
		local charges,maxCharges,chargeStart,chargeDuration = GetSpellCharges(spellID)
		if chargeMax then return chargeDuration end
		if charges then
			if charges < maxCharges then
				local chargeEnd = chargeStart + chargeDuration
				return chargeEnd - GetTime()
			end
			return 0
		end
	end

	function _getFullRechargeTime(spellID)
		local charges,maxCharges,chargeStart,chargeDuration = GetSpellCharges(spellID)
		if charges then
			local currentChargeTime = (charges or 0) < (maxCharges or 0) and chargeDuration - (GetTime() - (chargeStart or 0)) or 0
			local leftChargesTotalTime = (maxCharges - charges - 1) * chargeDuration
			if charges ~= maxCharges then
				return currentChargeTime + leftChargesTotalTime
			end
		end
		return 0
	end

	function _buffFromTable(unit,t,remains,returnid)
		if remains then
			local cc = {0};
			if returnid then
				cc={{id=0,r=0}};
			else
				cc={0};
			end
			local time = GetTime()
			if not unit_buff_cache[unit] then
				unit_buff_cache[unit] = {get_unit_buffs(unit)}
				local cache = unit_buff_cache[unit]
				for i=1,#cache do
					for n=1,#t do
						local id = t[n]
						if cache[i][10] == id then
							local end_time = cache[i][6]
							local r = end_time - time
							if r > 0 or end_time == 0 then
								if returnid then
									if end_time == 0 then
										table.insert(cc,{id=id,r=999})
									else
										table.insert(cc,{id=id,r=r})
									end
								else
									if end_time == 0 then
										table.insert(cc,999)
									else
										table.insert(cc,r)
									end
								end
							end
						end
					end
				end
			else
				local cache = unit_buff_cache[unit]
				for i=1,#cache do
					for n=1,#t do
						local id = t[n]
						if cache[i][10] == id then
							local end_time = cache[i][6]
							local r = end_time - time
							if r > 0 or end_time == 0 then
								if returnid then
									if end_time == 0 then
										table.insert(cc,{id=id,r=999})
									else
										table.insert(cc,{id=id,r=r})
									end
								else
									if end_time == 0 then
										table.insert(cc,999)
									else
										table.insert(cc,r)
									end
								end
							end
						end
					end
				end
			end
			return cc;
		else
			if not unit_buff_cache[unit] then
				unit_buff_cache[unit] = {get_unit_buffs(unit)}
				local cache = unit_buff_cache[unit]
				for i=1,#cache do
					for n=1,#t do
						local id = t[n]
						if cache[i][10] == id then
							return true,id
						end
					end
				end
			else
				local cache = unit_buff_cache[unit]
				for i=1,#cache do
					for n=1,#t do
						local id = t[n]
						if cache[i][10] == id then
							return true,id
						end
					end
				end
			end
		end
	end


	function _debuffFromTable(unit,t,remains,returnid)
		if remains then

			local cc = {};

			if returnid then
				cc={{id=0,r=0}};
			else
				cc={0};
			end

			local time = GetTime()

			local cache = unit_debuff_cache[unit]
			if not cache then
				unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
				cache = unit_debuff_cache[unit]
				for i=1,#cache do
					for n=1,#t do
						local id = t[n]
						if cache[i][10] == id then
							local end_time = cache[i][6]
							local r = end_time - time
							if r > 0 then
								if returnid then
									table.insert(cc,{id=id,r=r})
								else
									table.insert(cc,r)
								end
							end
						end
					end
				end
			else
				for i=1,#cache do
					for n=1,#t do
						local id = t[n]
						if cache[i][10] == id then
							local end_time = cache[i][6]
							local r = end_time - time
							if r > 0 then
								if returnid then
									table.insert(cc,{id=id,r=r})
								else
									table.insert(cc,r)
								end
							end
						end
					end
				end
			end

			return cc

		else
			if not unit_debuff_cache[unit] then
				unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
				local cache = unit_debuff_cache[unit]
				for i=1,#cache do
					for n=1,#t do
						local id = t[n]
						if cache[i][10] == id then
							return true,id
						end
					end
				end
			else
				local cache = unit_debuff_cache[unit]
				for i=1,#cache do
					for n=1,#t do
						local id = t[n]
						if cache[i][10] == id then
							return true,id
						end
					end
				end
			end
		end
	end

	local ccIDs = {
	--[[ SILENCES ]]--

	--------------------
	--[[ DISORIENTS ]]--
	--------------------
	-- Druid
	99, -- Disorienting Roar (talent)
	2637,	-- Hibernate
	-- Hunter
	3355, -- Freezing Trap
	19386, -- Wyvern Sting
	-- Mage
	28272,		-- Pig
	118,		-- Sheep
	277792,		-- Bee
	161354,		-- Monkey
	277787,		-- Direhorn
	161355,		-- Penguin
	161353,		-- Polar Bear
	120140,		-- Porcupine
	61305,		-- Cat
	61721,		-- Rabbit
	61780,		-- Turkey
	28271,		-- Turtle
	82691,		-- Ring of Frost
	31661,		-- Dragon's Breath
	-- Monk
	115078, -- Paralysis
	198909,	-- Song of Chi Ji
	-- Paladin
	105421, -- Blinding Light
	20066, -- Repentance
	-- Priest
	9484, -- Shackle Undead
	-- Rogue
	1776, -- Gouge
	6770, -- Sap
	-- Shaman
	51514,  -- Hex
	-- Pandaren
	107079, -- Quaking Palm
	--------------
	--[[ FEAR ]]--
	--------------
	-- Hunter
	-- Paladin
	10326, -- Turn Evil
	-- Priest
	8122, -- Psychic Scream
	-- Rogue
	2094, -- Blind
	-- Warlock
	118699, -- Fear -- new SpellID in MoP, Blood Fear uses same ID
	5484, -- Howl of Terror
	6358, -- Seduction (Succubus)
	115268, -- Mesmerize (Shivarra) -- FIXME: verify this is the correct category
	-- Warrior
	5246, -- Intimidating Shout (main target)
	-----------------------
	--[[ CONTROL STUNS ]]--
	-----------------------
	-- Death Knight
	108194, -- Asphyxiate (talent)
	91800, -- Gnaw (Ghoul)
	91797, -- Monstrous Blow (Dark Transformation Ghoul)
	-- Druid
	22570, -- Maim
	203123,	-- Maim

	5211, -- Mighty Bash (talent)
	113801, -- Bash (treants in feral spec) (Bugged by blizzard - it instantly applies all 3 levels of DR right now, making any target instantly immune to ctrlstuns)
	-- 163505, --rake stun
	-- Hunter
	24394, -- Intimidation
	50519, -- Sonic Blast (Bat)
	-- Mage
	44572, -- Deep Freeze
	157997, -- New ice nova
	-- Monk
	119392, -- Charging Ox Wave (talent)
	119381, -- Leg Sweep (talent)
	120086, -- Fists of Fury (Windwalker)
	-- Paladin
	853, -- Hammer of Justice
	119072, -- Holy Wrath (Protection)
	105593, -- Fist of Justice (talent)
	10326,  -- Turn evil
	-- Rogue
	1833, -- Cheap Shot
	408, -- Kidney Shot
	199804, -- Between the eyes
	-- Shaman
	118905, -- Static Charge (Capacitor Totem)
	-- Warlock
	30283, -- Shadowfury
	89766, -- Axe Toss (Felguard)
	22703, -- Infernal Awakening (Infernal)
	-- Warrior
	132168, -- Shockwave
	107570,	--Storm Bolt
	132169,	-- Storm Bolt (New SpellID)
	-- Demon Hunter
	179057, -- Chaos Nova
	191427, -- Metamorphosis (Might not be a thing any more.)
	211881, -- Fel Eruption
	217832,	-- Imprison
	221527,	-- Imprison (detainment)
	-- Tauren
	20549, -- War Stomp
	----------------
	--[[ HORROR ]]--
	----------------
	--- Priest
	64044, -- Psychic Horror (Stun)

	-- Warlock
	6789, -- Mortal Coil
	--------------
	--[[ MISC ]]--
	--------------
	-- Druid
	33786,  --Cyclone
	-- Hunter
	-- Mage
	31661,  --Dragon's Breath
	-- Priest
	605,	--MC
	-- Shaman
	-- Warlock
	710,    --Banish
	-- Warrior
	105771, -- Warbringer (talent)
	7922	--Charge
	}

	local bigDmg =
	{
	210714,	--Icefury
	214634,	--Ebonbolt
	116858,	--Chaos Bolt
	203286, --Greater Pyroblast
	}

	local csOnlyChannel =
	{
	293491, --Cyclotronic Blast
	299336, --Focused Azerite Beam
	305483,	--Lightning Lasso
	-- 198013,	--Eye Beam
	}

	local mageCS =
	{
		28272,		-- Pig
		118,		-- Sheep
		61305,		-- Cat
		61721,		-- Rabbit
		61780,		-- Turkey
		28271,		-- Turtle
		82691,		-- Ring of Frost
		-- 102051,		-- Frostjaw

	}

	local csHeals = {
		740,            -- Tranquility
		8936,           -- Regrowth
		48438,          -- Wild Growth
		33786,          -- Cyclone
		5185,           -- Healing Touch
		5176,           -- Wrath--
		82326,          -- Holy Light
		19750,          -- Flash of Light
		82326,          -- Holy Light
		85222,          -- Light of Dawn
		2061,           -- Flash Heal
		32546,          -- Binding Heal
		2060,           -- Greater Heal
		47540,          -- Penanace --Never kick penance.
		64843,          -- Divine Hymn
		8004,           -- Healing Surge
		77472,          -- Healing Wave
		51514,          -- Hex
		116670,         -- Uplift(monk)
		116694,         -- Effuse
		-- 123273,         -- Surging Mist
		-- 85673,          -- Word of Glory
		114163,         -- Eternal Flame
		33076,          -- Prayer of Mending
		152118,         -- Clarity of will
		-- 152116,         -- Saving Grace
		186263,			-- Shadow Mend
		124682,			-- Enveloping Mist
		115175,			-- Soothing Mist
		32375,			-- Mass Dispel
		47540,
		186263,
		1064,			-- Chain Heal
		214621,			-- Schism
		-- 585,			-- Smite
		289666,			-- Greater Heal
		-- 2061,			-- Flash heal
		-- 33786,			-- Cyclone
		198909,			-- Song of Chi Ji
		289022,			-- Nourish
	}
	local csAlways = {
		--111771,     -- Demonic Gateway
		--Resurrections--
		2006,
		7328,
		2008,
		50769,
		115310,
		982,    -- revive pet
		203286, -- greater pyroblast
		-- 209789,	-- freezing arrow
		202771,	-- full moon
		-- 211714, -- thal'kiel's consumption
		199786, -- glacial spike
		116858,	-- chaos bolt
		-- 210726,	-- mark of aluneth . . .
		323764,	-- convoke the spirits
		323673,	-- mindgames
	}

	local csCCdisorient = {
		--Druid--
		33786,	-- Cyclone

		--Warlock--
		5782,		-- Fear
		118699,		-- Fear
		205367,		-- Dominate Mind

		--Priest--
		605,		-- Mind Control
	}

	local csCCincapacitate = {
		--Mage--
		28272,		-- Pig
		118,		-- Sheep
		61305,		-- Cat
		61721,		-- Rabbit
		61780,		-- Turkey
		28271,		-- Turtle
		82691,		-- Ring of Frost

		--Shaman--
		51514,		-- Hex

		--Paladin
		20066,		-- Repentance

		--Druid--
		2637,		-- Hibernate
	}

	local csCCPolymorphs = {
		--Mage--
		28272,		-- Pig
		118,		-- Sheep
		277792,		-- Bee
		161354,		-- Monkey
		277787,		-- Direhorn
		161355,		-- Penguin
		161353,		-- Polar Bear
		120140,		-- Porcupine
		61305,		-- Cat
		61721,		-- Rabbit
		61780,		-- Turkey
		28271,		-- Turtle
		82691,		-- Ring of Frost
	}


	local csCCsilence = {
		-- 102051,		-- Frostjaw
	}

	local castedDMG	= {
		202771,		-- Full Moon
		203286,		-- Greater Pyroblast
		116858,		-- Chaos Bolt
		-- 157695,   	-- Demon bolt
		199786,		-- Glacial Spike
		214634,		-- Ebonbolt
		-- 19434,		-- Aimed Shot
		--324536,	    -- Malefic Rapture -- This CANNOT be reflected
		323673, 	--Mindgames
	}

	local csWarlock = {
		30108,    -- UA
		48181,    -- Haunt
		5782,	  -- Fear
		116858,   -- chaos bolt
		157695,   -- Demon bolt
		198590,	  -- Drain Soul
		193396,	  -- Demonic Empowerment
		324536,	  -- Malefic Rapture
	}

	local csMageDamage = {
		82691,		-- Ring of Frost
		116,		-- Frostbolt
		44614,		-- Flurry
		199786,		-- Glacial Spike
	}

	local csArcaneDamage = {
		30451,		-- arcane blast
		5143,		-- arcane missiles
		307443,		-- radiant spark
	}

	local csList = {
		740,		--Tranquility
		8936,		--Regrowth
		82326,		-- Divine Light
		19750,		-- Flash of Light
		2061,		-- Flash Heal
		32546,		-- Binding Heal
		2060,		-- Greater Heal
		47540,		-- Penanace
		64843,		-- Divine Hymn
		8004,		-- Healing Surge
		77472,		-- Greater Healing Wave
		33786,		--Cyclone

		--Paladin--
		-- 10326,		-- Turn evil
		20066,		-- Repentance
		-- 115750,		-- Blinding Light

		--Priest--
		605,		-- Mind Control
		32375,		-- Mass Dispel

		--Shaman--
		--51514,		-- Hex

		--Warlock--
		5782,		-- Fear
		118699,		-- Fear
		111771,     -- Demonic Gateway
		116858,     -- chaos bolt

		--Resurrections--
		2006,
		7328,
		2008,
		50769,
		115310
	}

	function _CCcheck(unit)
		if not UnitIsVisible(unit) then return false; end
		local debuffs = _debuffFromTable(unit,ccIDs,true,true);
		if debuffs then
			table.sort(debuffs,function(x,y) return x.r > y.r end);
		end
		if #debuffs > 0 then
			return debuffs[1].id ~= 0 and debuffs[1].id or nil;
		end
	end

	function player_has_control()
		return not (_CCcheck("player") or not HasFullControl())
	end

	cc_remains_cache = {}

	function _CCremains(unit,clone)

		if not UnitIsVisible(unit) then return 0; end

		if cc_remains_cache[unit] then return cc_remains_cache[unit] end

		local cconunit={};
		local debuffs = _debuffFromTable(unit,ccIDs,true);

		if clone then
			local cloneRemains = _debuffRemains(33786,unit);
			table.insert(debuffs,cloneRemains);
		end

		-- local silenced = ((_isCasterDps(unit) or _isHealer(unit)) and _silenceRemains(unit)) or 0;
		-- if silenced > 0 then
		-- 	table.insert(debuffs,silence);
		-- end

		local rake = _rakeStunRemains(unit)

		if rake > 0 then
			table.insert(debuffs,rake)
		end

		table.sort(debuffs,function(x,y) return x > y end);

		local ccr = debuffs[1]
		if ccr == math.huge then ccr = 0 end
		if not ccr then ccr = 0 end

		cc_remains_cache[unit] = ccr

		return ccr

	end

	--trapCCremains
	local trapcc ={
	-----------------------
	--[[ CONTROL STUNS ]]--
	-----------------------
	--Death Knight
	108194, -- Asphyxiate (talent)
	91800, -- Gnaw (Ghoul)
	91797, -- Monstrous Blow (Dark Transformation Ghoul)
	--Druid
	22570, -- Maim
	5211, -- Mighty Bash (talent)
	2637,	-- Hibernate
	--Hunter
	24394, -- Intimidation
	50519, -- Sonic Blast (Bat)
	117526, -- Binding Shot (talent)
	213619,	-- Scatter Shot

	--Mage
	44572, -- Deep Freeze
	157997, -- New ice nova
	102051, -- Frostjaw
	--Monk
	119392, -- Charging Ox Wave (talent)
	119381, -- Leg Sweep (talent)
	120086, -- Fists of Fury (Windwalker)
	--Paladin
	853, -- Hammer of Justice
	119072, -- Holy Wrath (Protection)
	105593, -- Fist of Justice (talent)
	--Rogue
	1833, -- Cheap Shot
	408,  -- Kidney Shot
	199804, -- Between the eyes
	2094, -- Blind
	1776,  -- Gouge
	6770,  -- Sap
	--Shaman
	118905, -- Static Charge (Capacitor Totem)
	118345, -- Pulverize (primal earth elemental)
	--Warlock
	30283, -- Shadowfury
	89766, -- Axe Toss (Felguard)
	22703, -- Infernal Awakening (Infernal)
	--Warrior
	132168,	--shockwave
	132169, --stormbolt
	5246,	--intimidating shout
	-- Demon Hunter
	179057, -- Chaos Nova
	191427, -- Metamorphosis (Might not be a thing any more.)
	211881, -- Fel Eruption
	-- Tauren
	20549, -- War Stomp
	-- other
	19386, --wyvern
	3355, --Trap
	64803,	--snakes
	224729,	--Bursting Shot
	238559,	--Bursting Shot (new?)
	105421, -- Blinding Light
	198909,	-- Song of Chi Ji
	}
	function trap_cc_remains(unit)
		if not UnitIsVisible(unit) then return 0; end
		if not UnitDebuffID(unit,5246) or not _isMoving(unit) then
			local cconunit={};
			local debuffs = _debuffFromTable(unit,trapcc,true);
			local rake = _rakeStunRemains(unit);
			if rake then
				table.insert(debuffs,rake)
			end
			table.sort(debuffs,function(x,y) return x>y end);
			if #debuffs > 0 then
				return debuffs[1];
			end
		end
		return 0;
	end

	function trap_cc(unit)
		for i=1,#trapcc do
			if UnitDebuffID(unit,trapcc[i]) and (trapcc[i] ~= 5246 or not _isMoving(unit)) then
				if _debuffRemains(unit,trapcc[i]) < 0 then
					--do nothing
				else
					return trapcc[i];
				end
			end
		end
		if _rakeStunned(unit) then
			return 1822;
		end
		return nil;
	end

	local magic_defensives = {
		--RoS
		53480,
		--Feint
		1966,
		--Sham Wall
		108271,
		--Lock Wall
		104773,
		--Warr Parry
		118038,
		--Survival Instincts
		61336,
		--Ironbark (maybe still just blow whole load into skin always)
		102342,
		--Barkskin
		22812,
		--Temp Shield
		198111,
		--Pris Cloak
		198065,
		--Anti-Magic Zone
		145629,
		--Icebound Fortitude
		48792,
		--Diffuse Magic (maybe add fort brew later, just such long duration hard to tell if worth holding the load)
		122783,
		-- ultimate sac
		199448,
	}

	function magic_defensive_remains(unit)
		local buffs =  _buffFromTable(unit,magic_defensives,true)
		table.sort(buffs,function(x,y) return x>y end)
		if #buffs > 0 then
			return buffs[1]
		end
		return 0
	end

	function trap_travel_time(unit,otherunit)
		otherunit = otherunit or "player";
		if _realDistance(otherunit,unit) < 3 then return -.05 end
		return _realDistance(otherunit,unit)/14.5
	end

	function perfectTravelDist(unit)
		local dist = (GetUnitSpeed(unit)*trap_travel_time(unit))*.9
		return dist < 5 and dist or 5
	end

	function immune_trap(unit,remains)
		local no = {
		213610,	--Holy ward
		8178,	--Grounding Totem
		216890,	--Spell Reflection
		236321,	--War Banner
		213602,	--Greater Fade
		}
		--Nono Buffs
		for i=1,#no do
			if UnitBuffID(unit,no[i]) then
				if remains then
					return _buffRemains(unit,no[i]);
				else
					return no[i];
				end
			end
		end
		--Immune Magic
		local immunemagic = _immuneMagic(unit,magic)
		if immunemagic ~= nil then
			if GetSpellInfo(immunemagic) ~= "Touch of Karma" then
				if remains then
					return _debuffRemains(unit,immunemagic);
				else
					return immunemagic;
				end
			end
		end
		if remains then return 0; end
		if not hunter then
			--Pally with Sac
			if select(2,UnitClass(unit)) == "PALADIN" then
				for i=1,#Enemies do if UnitBuffID(Enemies[i],6940) then
					return 6940;
				end end
			end
		end
	end

	local stunImmunities = {
		227847,	-- Bladestorm
		48792,	-- Icebound
		213610,	-- Holy Ward
		188499, -- blade dance
	}

	function _immuneStuns(unit, cheap_shot)
		local hasbuff,buff = _buffFromTable(unit,stunImmunities)
		--Evasion / Die by the Sword / Parry / Blur / Fists--
		if (UnitBuffID(unit,5277) or UnitBuffID(unit,118038) or UnitBuffID(unit,199754) or UnitBuffID(unit,198589) or UnitChannelInfo(unit) == "Fists of Fury") and not cheap_shot then
			if not unit_is_unit("player",unit) and _isFacingMe(unit) then
				return true;
			end
		end
		return hasbuff
	end

	local ccImmunities = {
		227847,	-- Bladestorm
	}

	function _immuneCC(unit)
		local hasbuff,buff = _buffFromTable(unit,ccImmunities)
		return hasbuff
	end

	function cc_immunity_remains(unit)

		local debuffs = _debuffFromTable(unit,ccImmunities,true,true);
		local buffs = _buffFromTable(unit,ccImmunities,true,true);

		local all = debuffs
		for k,v in pairs(buffs) do table.insert(debuffs, v) end

		table.sort(all,function(x,y) return x.r > y.r end);

		return all[1].r or 0, all[1].id;

	end

	local immuneID			=
	{
		642,	-- Divine Shield
		45438, 	--Ice Block
		19263, 	--Deterrence
		97417,	--BrittleBarrier
		33786,  --Cyclone
		186265, --Aspect of the Turtle
		221527, --Imprison
		710,	--Banish
		213602,	--Greater Fade

		-- seed?

	}
	function _immuneCheck(unit,cyclone,sac)

		local hasdebuff,debuff = _debuffFromTable(unit,immuneID);
		local hasbuff,buff     = _buffFromTable(unit,immuneID);

		--meta
		if _buffRemains(unit,162264) > 28 then
			return 162264
		end

		if not cyclone then
			--clone
			if UnitDebuffID(unit,33786) then
				return 33786
			end
			--imprison
			if UnitDebuffID(unit,221527) then
				return 221527
			end
		end

		if sac then
			if UnitDebuffID(unit,199448) then
				return 199448
			end
		end

		-- if cyclone and (hasbuff or hasdebuff) and (buff == 33786 or debuff == 33786) then return nil end
		return (hasdebuff and debuff) or (hasbuff and buff)

	end

	function immunity_remains(unit,cyclone)

		local debuffs = _debuffFromTable(unit,immuneID,true,true);
		local buffs = _buffFromTable(unit,immuneID,true,true);

		local all = debuffs
		for k,v in pairs(buffs) do table.insert(debuffs, v) end

		-- for i=1,#debuffs do
		-- 	table.insert(all,debuffs[i])
		-- end
		-- for i=1,#buffs do
		-- 	table.insert(all,buffs[i])
		-- end

		-- table.insert(all,_debuffRemains(unit,33786))
		-- table.insert(all,_debuffRemains(unit,221527))

		table.sort(all,function(x,y) return x.r > y.r end);

		return all[1].r or 0, all[1].id;

	end

	local immuneMagic  =
	{
	  642,    --Divine Shield
	  45438,  --Ice Block
	  31224,  --Cloak of Shadows
	  19263,  --Deterrance
	  97417,  --BrittleBarrier
	  33786,  --Cyclone
	  221527, --Imprison
	  48707,  --AMS
	  6990,   --Spell Reflect
	  216890, --Spell Reflect (new)
	  114028, --MassSpellReflect
	  186265, --Aspect of the Turtle
	  212295, --Nether Ward
	  204018, --Spell warding
	}

	function _immuneMagic(unit,ignoreams)
		local fullyimmune = _immuneCheck(unit,cyclone)
		--immune in general
		if fullyimmune then return fullyimmune; end

		--mind controlled
		if UnitDebuffID(unit,605) then return 605; end

		local immunes = immuneMagic

		if ignoreams then
			for i=1,#immunes do if immunes[i] == 48707 then
				table.remove(immunes,i)
			end end
		end

		-- if not cyclone then
		-- 	--karma
		-- 	if UnitBuffID(unit,122470)
		-- 	or UnitBuffID(unit,125174) then
		-- 		return 122470;
		-- 	end
		-- 	--clone
		-- 	-- if UnitDebuffID(unit,33786) then
		-- 	-- 	return 33786
		-- 	-- end
		-- 	-- --imprison
		-- 	-- if UnitDebuffID(unit,221527) then
		-- 	-- 	return 221527
		-- 	-- end
		-- end

		local hasdebuff,debuff = _debuffFromTable(unit,immunes);
		local hasbuff,buff     = _buffFromTable(unit,immunes);

		if hasdebuff or hasbuff then return true; end
	end

	function magic_immunity_remains(unit,ignoreams)

		local fully_immune = immunity_remains(unit,cyclone)

		local all = {}

		local immunes = immuneMagic

		if ignoreams then
			for i=1,#immunes do if immunes[i] == 48707 then
				table.remove(immunes,i)
			end end
		end

		local debuffs = _debuffFromTable(unit,immunes,true);
		local buffs = _buffFromTable(unit,immunes,true);

		for i=1,#debuffs do
			table.insert(all,debuffs[i])
		end

		for i=1,#buffs do
			table.insert(all,buffs[i])
		end

		table.insert(all,fully_immune)

		table.sort(all,function(x,y) return x > y end);

		-- for i=1,#all do print(all[i]) end

		return all[1] or 0;

	end

	function _unitIsFacingUnit(firstUnit,secondUnit,degree)
		if not degree then degree = 0; end
		if UnitIsVisible(firstUnit) and UnitIsVisible(secondUnit) then
			local X,Y = unit_is_unit("player",firstUnit) and GetPlayerPosition() or ObjectPosition(firstUnit);
			local Rotation = ObjectFacing(firstUnit);
			local unitX,unitY = unit_is_unit("player",secondUnit) and GetPlayerPosition() or ObjectPosition(secondUnit);
			return ((X-unitX)*math.cos(-Rotation))-((Y-unitY)*math.sin(-Rotation))<degree or _realDistance(firstUnit,secondUnit) < 1.5;
		end
	end

	function _isFacingMe(unit)
		return _unitIsFacingUnit(unit,"player");
	end

	local immunePhysical =
	{
		642, --Divine Shield
		1022, 	--Hand of Protection
		45438, 	--Ice Block
		19263, 	--Deterrence
		97417,	--BrittleBarrier
		33786,  --Cyclone
		186265, -- Aspect of the Turtle
		221527, -- imprison
		188499, -- blade dance
	}
	function _immunePhysical(unit,dmg)

		--immune in general
		if _immuneCheck(unit) then return true; end

		--mind controlled
		if UnitDebuffID(unit,605) then return 605; end

		--karma
		if UnitBuffID(unit,122470) or UnitBuffID(unit,125174) then
			return true;
		end

		if not dmg then
			if not _CCcheck(unit) then
				--Evasion / Die by the Sword / Parry / Blur / Fists--
				if (UnitBuffID(unit,5277) or UnitBuffID(unit,118038) or UnitBuffID(unit,199754) or UnitBuffID(unit,198589) or UnitChannelInfo(unit) == "Fists of Fury") then
					if not unit_is_unit("player",unit) and _isFacingMe(unit) then
						return true;
					end
				end
			end
		end

		local hasdebuff,debuff = _debuffFromTable(unit,immunePhysical);
		local hasbuff,buff     = _buffFromTable(unit,immunePhysical);
		if hasdebuff or hasbuff then return true; end
	end

	function physical_immunity_remains(unit,cyclone)

		local fully_immune,fully_immune_id = immunity_remains(unit,cyclone)

		local all = {}

		local immunes = immunePhysical

		local debuffs = _debuffFromTable(unit,immunes,true,true);
		local buffs = _buffFromTable(unit,immunes,true,true);

		local all = debuffs
		for k,v in pairs(buffs) do table.insert(debuffs, v) end

		table.insert(all,{r=fully_immune,id=fully_immune_id})

		if #all > 0 then
			table.sort(all,function(x,y) return x.r > y.r end);
		end

		-- for i=1,#all do print(all[i]) end

		return all[1] and all[1].r or 0, all[1].id

	end

	function _inDispellableCC(unit)
		if not UnitIsVisible(unit) then return false; end
		local debuffs =	_debuffFromTable(unit,csCCPolymorphs,true,true);
		if debuffs then
			table.sort(debuffs,function(x,y) return x.r > y.r end);
		end
		if #debuffs > 0 then
			return debuffs[1].id ~= 0 and debuffs[1].r > 1.5 and debuffs[1].id or nil;
		end
	end

	-- function GetSpellTargetOffset()
	-- 	local GUID = UnitGUID("Target")
	-- 	for Offset = 0x1000, 0x2000, 0x4 do
	-- 		if ObjectField("Player", Offset, Types.GUID) == GUID then
	-- 			print(("%X"):format(Offset))
	-- 		end
	-- 	end
	-- end

	function UnitSpellTarget(unit)
		if not UnitIsVisible(unit) then return false end
		local cast,channel,castobj,channelobj = UnitCastID(unit)
		return (cast and castobj) or (channel and channelobj)
	end

	function _purgeCount(unit)

		if not unit then return end

		local buffCount = 0

		if not unit_buff_cache[unit] then
			unit_buff_cache[unit] = {get_unit_buffs(unit)}
			local cache = unit_buff_cache[unit]
			for i=1,#cache do
				local bufftype,count = cache[i][4],cache[i][3]
				if bufftype == "Magic" then
					if count > 0 then
						buffCount = buffCount + count
					else
						buffCount = buffCount + 1
					end
				end
			end
		else
			local cache = unit_buff_cache[unit]
			for i=1,#cache do
				local bufftype,count = cache[i][4],cache[i][3]
				if bufftype == "Magic" then
					if count > 0 then
						buffCount = buffCount + count
					else
						buffCount = buffCount + 1
					end
				end
			end
		end

		return buffCount

	end

	function _purgeAnything(unit)
		if _purgeCount(unit) > 0 then return true; end
	end

	local canZerk = {
		8122, -- Psychic Scream
		118699, -- Fear -- new SpellID in MoP, Blood Fear uses same ID
		5782, --FEAR
		5484, -- Howl of Terror
		6358, -- Seduction (Succubus)
		115268, -- Mesmerize (Shivarra) -- FIXME: verify this is the correct category
		5246, --Intimidating Shout
		99, -- Incapacitating Roar
		1776, --gouge
		20066, --Repentance
		115078, --Paralysis
		221527,	--Imprison
		-- 236025,	--Incap Maim
	}

	function _shouldZerk()
		local delay = minDelayTime/1.6
		for i=1,#canZerk do
			if _debuffRemains("player",canZerk[i]) >= 2 then
				if delay == 0 or _debuffUptime("player",canZerk[i]) >= delay then
					return true;
				end
			end
		end
		-- add sap only when valid target or rogue is visible nearby
	end

	local reflectspells = {
	"Polymorph",
	"Greater Pyroblast",
	"Chaos Bolt",
	"Cyclone",
	}
	function _shouldReflect()
		local buffer = ((1000/GetFramerate())/1000)*10 --ms per frame * 10 (10 fps buffer)
		local latency = squid_avg_latency+buffer+.09 --90ms + fps buffer, since latency only updates every 30s, and script only runs once per frame.
		local delay = latency+buffer
		for i=1,#Enemies do
			local cast = unit_casting_info(Enemies[i])
			if cast and tContains(reflectspells,cast) and _castTimeLeft(Enemies[i]) <= delay then
				local et = UnitSpellTarget(Enemies[i])
				if et and unit_is_unit("player",et) then
					return true;
				end
			end
		end
	end
	function get_spell_school(id)
		-- return id == 16 and "Frost"
		-- or id == 4 and "Fire"
		-- or id == 64 and "Arcane"
		return CombatLog_String_SchoolString(id)
	end

	-- /run t="target" if UnitExists(t) and (UnitChannelInfo(t) or unit_casting_info(t)) then if select(8,unit_casting_info(unit)) == false or select(7,UnitChannelInfo(unit)) == false then SQ_CastSpellByName("Skull Bash",t); end end
	-- /run t="focus" if UnitExists(t) and (UnitChannelInfo(t) or unit_casting_info(t)) then if select(8,unit_casting_info(unit)) == false or select(7,UnitChannelInfo(unit)) == false then SQ_CastSpellByName("Skull Bash",t); end end

	--Interrupts (New)
	--param unit, unit to check interrupt prio
	--param pct, override percentage cast completion value
	--param phys, whether or not the interrupt is physical
	--param custombuffer, override the minimum cast remaining buffer
	local function i(unit,pct,int,physical,custombuffer)

		--stop the function if the unit isn't valid
		if not UnitIsVisible(unit) or UnitIsDead(unit) or UnitIsDeadOrGhost(unit) then return false end

		local magic_interrupt_absorbs = {
		8178,	--grounding totem
		212295,	--nether ward
		}

		local protection,protection_buff = not physical and _buffFromTable(unit,magic_interrupt_absorbs) or nil

		--only players in arena, and never into magical interrupt protection
		if (not arena or unit_is_player(unit)) then

			local channel,_,_,_,_,_,channelInterruptable = UnitChannelInfo(unit)
			local cast,_,_,_,_,_,_,castInterruptable = unit_casting_info(unit)



		end

	end

	function PvE_Interrupt(unit)
		if not UnitIsVisible(unit) or UnitIsDeadOrGhost(unit) then return false end
		-- if not unit_is_player(unit) then
			local channel,_,_,_,_,_,channel_protected,channelid = UnitChannelInfo(unit)
			local cast,_,_,_,_,_,_,cast_protected,castid = unit_casting_info(unit)

			if not channel and not cast then return false end

			--latency &amp; travel time delay
			local frame_buffer = 2 / GetFramerate() -- 2 frame buffer
			local background_delay = (not IsForeground() and frame_buffer or 0)
			local interruptNetDelay = squid_avg_latency + frame_buffer + background_delay + _kickTravelTime(unit) + .108 + (SQUID.extra_net_delay or 0) -- latency + frame buffer + interrupt travel time + 90 ms safety net

			local int_only = {
				late = {

					-- S4 M+ AFFIX
					314406, -- Crippling Pestilence (Huge Damage + Disease Slow)
					314411, -- Lingering Doubt (Huge Damage + Curse Cast Speed Reduction)

					-- NY'ALOTHA
					311576, -- https://www.wowhead.com/spell=311576/void-bolt-volley
					313652, -- https://www.wowhead.com/spell=313652/mind-numbing-nova

					-- MECHAGON
					299588, -- https://www.wowhead.com/spell=299588/overclock
					298669, -- https://www.wowhead.com/spell=298669/taze
					300414, -- https://www.wowhead.com/spell=300414/enrage
					300436, -- https://www.wowhead.com/spell=300436/grasping-hex
					300514, -- https://www.wowhead.com/spell=300514/stoneskin
					301088, -- https://www.wowhead.com/spell=301088/detonate
					293827, --  https://www.wowhead.com/spell=293827/giga-wallop

					-- ATAL DAZAR
					250096,	-- https://www.wowhead.com/spell=250096/wracking-pain

					-- TEMPLE OF SETHRALISS
					263318,	-- https://www.wowhead.com/spell=263318/jolt
					263775,	-- https://www.wowhead.com/spell=263775/gust
					268061, -- https://www.wowhead.com/spell=268061/chain-lightning

					-- KING'S REST
					267308,	-- https://www.wowhead.com/spell=267308/lightning-bolt
					267273, -- https://www.wowhead.com/spell=267273/poison-nova
					270901, -- https://www.wowhead.com/spell=270901/induce-regeneration
					270923, -- https://www.wowhead.com/spell=270923/shadow-bolt

					-- THE UNDERROT
					260879,	-- https://www.wowhead.com/spell=260879/blood-bolt
					-- 265523, -- https://www.wowhead.com/spell=265523/summon-spirit-drain-totem
					265433,	-- https://www.wowhead.com/spell=265433/withering-curse
					265487,	-- https://www.wowhead.com/spell=265487/shadow-bolt-volley

					-- WAYCREST MANOR
					265876, -- https://www.wowhead.com/spell=265876/ruinous-volley
					266225,	-- https://www.wowhead.com/spell=266225/darkened-lightning
					260701, -- https://www.wowhead.com/spell=260701/bramble-bolt
					260699, -- https://www.wowhead.com/spell=260699/soul-bolt
					260700, -- https://www.wowhead.com/spell=260700/ruinous-bolt
					263959,	-- https://www.wowhead.com/spell=263959/soul-volley

					-- TOL'DAGOR
					257791,	-- https://www.wowhead.com/spell=257791/howling-fear
					258313,	-- https://www.wowhead.com/spell=258313/handcuff
					258935,	-- https://www.wowhead.com/spell=258935/inner-flames

					-- THE MOTHERLODE!!
					262092,	-- https://www.wowhead.com/spell=262092/inhale-vapors
					268797,	-- https://www.wowhead.com/spell=268797/transmute-enemy-to-goo

					-- SHRINE OF THE STORM
					267818,	-- https://www.wowhead.com/spell=267818/slicing-blast
					268309, -- https://www.wowhead.com/spell=268309/unending-darkness
					268347, -- https://www.wowhead.com/spell=268347/void-bolt

					-- TEMPLE OF SETHRALISS
					272820,	-- https://www.wowhead.com/spell=272820/shock


					--------------------SL---------------------------


					-- HALLS OF ATONEMENT
					323552,	-- Volley of Power
					326607, -- Turn to Stone
					323552, -- Volley of Power

					-- MISTS OF TIRNA SCITHE
					323057,
					326046,
					337235,
					337249,
					337255,

					-- PLAGUEFALL
					329239,
					328094,

					-- SANGUINE DEPTHS
					322433,
					326837,
					335305,

					-- SPIRES OF ASCENTION
					327413,
					327481,
					328137,

					-- THE NECROTIC WAKE
					324293,

					-- THEATER OF PAIN
					320120,
					320300,
					333231,
					342139,
					330875,

					-- TORGHAST
					294165,	-- Accursed Strength
					296523, -- Deafening Howl

					-- RANDOMSHIT
					229083, -- Burning Blast https://www.wowhead.com/spell=229083/burning-blast
					227592,
					229307,
					198495,
					208165,

				},

				early = {

					-- AFFIXES

					-- FREEHOLD
					256060,	-- Revitalizing Brew (FH First Boss Heal) https://www.wowhead.com/spell=256060/revitalizing-brew
					257736,	-- https://www.wowhead.com/spell=257736/thundering-squall

					-- THE UNDERROT
					-- 265433,	-- https://www.wowhead.com/spell=265433/withering-curse

					-- ATAL'DAZAR
					250368,	-- https://www.wowhead.com/spell=250368/noxious-stench
					259572, -- https://www.wowhead.com/spell=259572/noxious-stench

					-- DE OTHER SIDE
					334076, -- {"Shadowcore"} 1b / Death Speaker
					332612, -- {"Healing Wave"} 1b / Atal'ai Hoodoo Hexxer
					323064,	-- {"Blood Barrage"}
					331379, -- {"Lubricate"}
					332084,	-- {"Self-cleaning Cycle"}
					320008, -- {"Frostbolt"}

					-- MISTS OF TIRNA SCITHE
					340544,

					-- SANGUINE DEPTHS
					319654,

					-- THE NECROTIC WAKE
					334748,

					-- RANDOMSHIT
					203957,
					204243,

				},
			}

			local int_or_cc = {

				early = {

					--test
					-- 152108, -- cataclysm test

					-- MECHAGON
					301689, -- https://www.wowhead.com/spell=301689/charged-coil
					293729, -- https://www.wowhead.com/spell=293729/tune-up

					-- THE MOTHERLODE!!
					268702,	-- https://www.wowhead.com/spell=268702/furious-quake
					280604, -- https://www.wowhead.com/spell=280604/iced-spritzer

					-- Vision of Orgrimmar
					298033,	-- Touch of the Abyss
					304251,	-- Void Quills (yikes man just remove this from the fucking GAME man MANANNMNNNNNNNnhnfifuiujfuiojfewrjiuoafjiuhrewajionufio)

					-- MISTS OF TIRNA
					322938,

					-- SANGUINE DEPTHS
					334653,

					-- THE NECROTIC WAKE
					327130,

					-- THEATER OF PAIN
					330810,

					-- TORGHAST
					329783,	-- Shadow Storm
				},

				-- Vision of Orgrimmar
				-- 298033,	-- Touch of the Abyss (STUN)

				-- test
				-- 116858, -- bolt test

				-- AFFIXES
				-- 314592, -- MIND FLAY TENTACLE EYEBALLS

				-- NY'ALOTHA
				-- 310839,	-- https://www.wowhead.com/spell=310839/dirge-from-below

				-- MECHAGON
				300764, -- https://www.wowhead.com/spell=300764/slimebolt
				300650, -- https://www.wowhead.com/spell=300650/suffocating-smog
				300171, -- https://www.wowhead.com/spell=300171/repair-protocol
				300087, -- https://www.wowhead.com/spell=300087/repair

				-- FREEHOLD
				257397,	-- https://www.wowhead.com/spell=257397/healing-balm
				257732,	-- https://www.wowhead.com/spell=257732/shattering-bellow
				257784,	-- https://www.wowhead.com/spell=257784/frost-blast
				-- 257899, -- (45% Dmg Increase + -3% HP/s) https://www.wowhead.com/spell=257899/painful-motivation
				258777, -- https://www.wowhead.com/spell=258777/sea-spout

				-- ATAL DAZAR
				255824,	-- Fanatic's Rage (AD Drazar'ai Juggernaut) https://www.wowhead.com/spell=255824/fanatics-rage
				255041,	-- Terrifying Screech (AD Fear Ptero) https://www.wowhead.com/spell=255041/terrifying-screech
				253583,	-- Fiery Enchant (AD Mob Dmg Increase) https://www.wowhead.com/spell=253583/fiery-enchant
				253517, -- Mending Word AD Heal https://www.wowhead.com/spell=253517/mending-word
				253562,	-- Wildfire (AD / BoD Mob Dmg) https://www.wowhead.com/spell=253562/wildfire
				252781,	-- Unstable Hex (AD Mob Hex) https://www.wowhead.com/spell=252781/unstable-hex
				256849,	-- Dino Might https://www.wowhead.com/spell=256849/dino-might

				-- THE UNDERROT
				265089,	-- https://www.wowhead.com/spell=265089/dark-reconstitution
				265091,	-- https://www.wowhead.com/spell=265091/gift-of-ghuun
				266106, -- https://www.wowhead.com/spell=266106/sonic-screech
				272183, -- https://www.wowhead.com/spell=272183/raise-dead
				278961, -- https://www.wowhead.com/spell=278961/decaying-mind
				272180, -- https://www.wowhead.com/spell=272180/death-bolt

				-- SIEGE OF BORALUS
				256957,	-- https://www.wowhead.com/spell=256957/watertight-shell
				272571, -- https://www.wowhead.com/spell=272571/choking-waters
				274569, -- https://www.wowhead.com/spell=274569/revitalizing-mist

				-- THE MOTHERLODE!!
				263202,	-- https://www.wowhead.com/spell=263202/rock-lance
				262540, -- https://www.wowhead.com/spell=262540/overcharge (This can be purged / spellstolen. Blacklist as a mage?)
				263066, -- https://www.wowhead.com/spell=263066/transfiguration-serum
				263103,	-- https://www.wowhead.com/spell=263103/blowtorch
				268129, -- https://www.wowhead.com/spell=268129/kajacola-refresher
				268709, -- https://www.wowhead.com/spell=268709/earth-shield
				269090, -- https://www.wowhead.com/spell=269090/artillery-barrage
				269302, -- https://www.wowhead.com/spell=269302/toxic-blades

				-- TEMPLE OF SETHRALISS
				261635,	-- https://www.wowhead.com/spell=261635/stoneshield-potion
				265968,	-- https://www.wowhead.com/spell=265968/healing-surge
				272700, -- https://www.wowhead.com/spell=272700/greater-healing-potion

				-- WAYCREST MANOR
				265368,	-- https://www.wowhead.com/spell=265368/spirited-defense
				265407, -- https://www.wowhead.com/spell=265407/dinner-bell
				266036,	-- https://www.wowhead.com/spell=266036/drain-essence
				278551, -- https://www.wowhead.com/spell=278551/soul-fetish
				278444,	-- https://www.wowhead.com/spell=278444/infest

				-- SHRINE OF THE STORM
				267977,	-- https://www.wowhead.com/spell=267977/tidal-surge
				268030, -- https://www.wowhead.com/spell=268030/mending-rapids
				-- 268050, -- https://www.wowhead.com/spell=268050/anchor-of-binding (maybe don't interrupt this and save it for the heal)
				268317, -- https://www.wowhead.com/spell=268317/rip-mind
				268322, -- https://www.wowhead.com/spell=268322/touch-of-the-drowned
				268375, -- https://www.wowhead.com/spell=268375/detect-thoughts
				274437, -- https://www.wowhead.com/spell=274437/tempest
				276767, -- https://www.wowhead.com/spell=276767/consuming-void

				-- KING'S REST
				269973,	-- https://www.wowhead.com/spell=269973/deathly-chill
				267763, -- https://www.wowhead.com/spell=267763/wretched-discharge
				270492, -- https://www.wowhead.com/spell=270492/hex

				-- TOL DAGOR
				258128,	-- https://www.wowhead.com/spell=258128/debilitating-shout
				258153,	-- https://www.wowhead.com/spell=258153/watery-dome
				258634,	-- https://www.wowhead.com/spell=258634/fuselighter
				258779, -- https://www.wowhead.com/spell=258779/sea-spout
				258869, -- https://www.wowhead.com/spell=258869/blaze

				-----------------SL-----------------------

				-- Halls of Atonement
				325876,	-- Curse of Obliteration
				326607,	-- Turn to Stone
				338003, -- Wicked Bolt
				325700, -- Collect Sins

				-- DE OTHER SIDE
				328707,	-- Scribe
				332706, -- Heal
				332705, -- Smite

				-- MISTS OF TIRNA
				322767, -- spirit bolt
				324776, -- bramblethorn coat
				324914, -- nourish the forest

				-- PLAGUEFALL
				328016,
				329917,
				319070,
				328180,
				328094,
				328429,
				321999,
				328475,

				-- SANGUINE DEPTHS
				324609,
				321105,
				326836,
				321038,
				336277,
				322169,
				326952,

				-- SPIRES OF ASCENSION
				317936,
				317963,
				317959,
				317661,
				317648,
				317331,
				328295,

				-- THE NECROTIC WAKE
				323190,
				328667,
				320571,
				320822,
				335143,
				333623,
				338353,

				-- THEATER OF PAIN
				330784,
				341902,
				330562,
				342675,
				341771,
				330868,
				341969,
				330703,

				-- TORGHAST

				295929,	-- Rats!
				242391,	-- Terror
				304946,	-- Shadow Rip
				305136,	-- Shadow Spear

				-- RANDOMSHIT
				226206,	-- Arcane Reconstitution (Arcway Mob Heal) https://www.wowhead.com/spell=226206/arcane-reconstitution
				228625,	-- Banshee Wail
				253544,
				226285,
				227616,
				232115,
				227545,
				228280,
				227917,
				246505,
				236384,
				234179,
				226316,
				228279,
				198962,
				225047,
				210684,
				200658,
				202181,
				228239,
				226269,
				199514,
				200631,
				199726,
				224460,
				199589,
				262090, -- https://www.wowhead.com/spell=262090/cower
			}

			local cc_only = {
				early = {

					-- 234153,--drain life test

					-- ATAL'DAZAR
					253721, -- Bulwark of Juju

					-- FREEHOLD
					274400, -- Duelist Dash
					257756, -- goin' bananas

					-- KINGS REST
					270502, -- dino hunting leap

					-- SHRINE OF THE STORM
					276292, -- https://www.wowhead.com/spell=276292/whirling-slam

					-- MECHAGON
					300818, -- https://www.wowhead.com/spell=300818/acid-splash
					300525, -- https://www.wowhead.com/spell=300525/throw-trash
					-- 300560, -- https://www.wowhead.com/spell=300560/throw-trash AoE trash dodgeable

					-- WAYCREST MANOR
					268202, -- https://www.wowhead.com/spell=268202/death-lens

					-- SIEGE OF BORALUS
					272546, -- https://www.wowhead.com/spell=272546/banana-rampage

					-- TOL DAGOR
					258317, -- https://www.wowhead.com/spell=258317/riot-shield

					-- TEMPLE OF SETHRALISS
					263958, -- a knot of snakes

					-- VISION OF STORMWIND
					298584, -- repel


					---------SHADOWLANDS

					-- PLAGUEFALL
					336451,

				},
				mid = {
					-- SHRINE OF THE STORM
					268050, -- https://www.wowhead.com/spell=268050/anchor-of-binding (maybe don't interrupt this and save it for the heal)

					-- HALLS OF ATONEMENT
					325876,	-- Curse of Obliteration
					325523,	-- Deadly Thrust

					-- DE OTHER SIDE
					332671, -- BLADESTORM

					-- TORGH
					294165, -- Accursed  Strenght
					296523,	-- Deafening Howl

					-- MISTS OF TIRNA SCITHE
					324987,

					-- PLAGUEFALL
					321935,
					328651,
					328400,

					-- SPIRES OF ASCENSION
					323682,

					-- NECROTIC WAKE
					338022,
					334747,

					-- THEATER OF PAIN
					330586,

				},
				late = {

				},
			}

			local early_channels = {
				int_or_cc = {

					-- Halls of Atonement
					325700,	-- Collect Sins


					----------------------------------
					314592, -- Mind flay tentacle eyeball affix
					300650, -- Suffocating Smog Mechagon

					-- NY'A
					310839,	-- https://www.wowhead.com/spell=310839/dirge-from-below

					-- TORGH
					329783,	-- Shjadow Storm
				},
				int_only = {
					265433,	-- https://www.wowhead.com/spell=265433/withering-curse
				},
				cc_only = {

					-- Halls of Atonement
					325797,	-- Rapid Fire

					-- Plaguefall
					336451,	-- Bulwark of Maldraxxus

					298584, -- sw vision repel
					257756,	-- goin' bananas
				},
			}

			local mage_blacklist = {
				[299588] = true, -- Overclock, spellstealable haste buff
				[262540] = true, -- Overcharge, spellstealable haste buff
				[293729] = true, -- Tune Up, spellstealable haste buff
			}

			-- int_only.late, int_only.early, int_or_cc, int_or_cc.early, cc_only.early, cc_only.mid, cc_only.late

			--face away from blinding sand
			if castid and castid == 263914 and _castTimeLeft(unit) <= interruptNetDelay and _amIfacing(unit) then
				_faceAwayFromUnit(unit)
			end

			--casts
			if castid then

				if mage_blacklist[castid] and squid_player_class == "MAGE" then return false end

				local cast_time_left = _castTimeLeft(unit)

				local solo_mode = SQUID.solo_mode_enabled

				if not cast_protected then

					-- no instance interrupt anything
					if solo_mode then
						if cast_time_left <= interruptNetDelay then
							return "int_late_or_cc",castid
						elseif cast_time_left <= GetGCD() + interruptNetDelay + .15 then
							return "cc"
						end
					end

					-- late cast interrupt only
					if ( tContains(int_only.late,castid) and cast_time_left <= interruptNetDelay ) then -- ( _castPctDone(unit) >= 99 or cast_time_left <= interruptNetDelay ) ) then
						-- if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
							return "int",castid
						-- end
					end

					-- early cast interrupt only
					if ( tContains(int_only.early,castid) and  _castTimeComplete(unit) >= minDelayTime and not tContains(early_channels.int_only,castid) and not tContains(early_channels.int_or_cc,castid) ) then -- ( _castPctDone(unit) >= 0 or cast_time_left <= interruptNetDelay ) ) then
						-- if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
							return "int",castid
						-- end
					end

				end

				-- int or cc
				if tContains(int_or_cc,castid) and not tContains(early_channels.int_or_cc,castid) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						if not cast_protected then
							return "int_late_or_cc",castid
						else
							return "cc",castid
						end
					end
				end

				-- int or cc early
				if tContains(int_or_cc.early,castid) and not tContains(early_channels.int_or_cc,castid) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						if not cast_protected then
							return "int_early_or_cc",castid
						else
							return "cc",castid
						end
					end
				end

				-- early cast cc only
				if tContains(cc_only.early,castid) and not tContains(early_channels.cc_only,castid) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						return "cc",castid
					end
				end

				-- mid cast cc only
				if ( tContains(cc_only.mid,castid) and ( _castPctDone(unit) >= 40 or cast_time_left <= interruptNetDelay ) ) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						return "cc",castid
					end
				end

				-- late cast cc only
				if ( tContains(cc_only.late,castid) and ( _castPctDone(unit) >= 80 or cast_time_left <= interruptNetDelay ) ) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						return "cc",castid
					end
				end

			end

			--channels
			if channelid then

				if mage_blacklist[channelid] and squid_player_class == "MAGE" then return false end

				local cast_time_left = _castTimeLeft(unit)

				if not channel_protected then
					-- late cast interrupt only
					if ( tContains(int_only.late,channelid) and ( _castPctDone(unit) >= 99 or cast_time_left <= interruptNetDelay ) ) then
						if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
							return "int",channelid
						end
					end

					-- early cast interrupt only
					if ( ( tContains(int_only.early,channelid) or tContains(early_channels.int_only) ) and ( _castPctDone(unit) >= 0 or cast_time_left <= interruptNetDelay ) ) then
						if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
							return "int",channelid
						end
					end
				end

				-- int or cc
				if tContains(int_or_cc,channelid) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						if not channel_protected then
							return "int_late_or_cc",channelid
						else
							return "cc",channelid
						end
					end
				end

				-- int or cc early
				if tContains(int_or_cc.early,channelid) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						if not channel_protected then
							return "int_early_or_cc",channelid
						else
							return "cc",channelid
						end
					end
				end

				-- int or cc only channeled early
				if tContains(early_channels.int_or_cc,channelid) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						if not channel_protected then
							return "int_early_or_cc",channelid
						else
							return "cc",channelid
						end
					end
				end

				-- early cast cc only
				if tContains(cc_only.early,channelid) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						return "cc",channelid
					end
				end

				-- early channel cc
				if tContains(early_channels.cc_only,channelid) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						return "cc",channelid
					end
				end

				-- mid cast cc only
				if ( tContains(cc_only.mid,channelid) and ( _castPctDone(unit) >= 40 or cast_time_left <= interruptNetDelay ) ) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						return "cc",channelid
					end
				end

				-- late cast cc only
				if ( tContains(cc_only.late,channelid) and ( _castPctDone(unit) >= 80 or cast_time_left <= interruptNetDelay ) ) then
					if _castTimeComplete(unit) >= minDelayTime or cast_time_left <= interruptNetDelay then
						return "cc",channelid
					end
				end

			end

		-- end
	end

	function Friends_Around_Unit(unit,range)
		local count = 0
		for i=1,#Friends do
			if not unit_is_unit(unit,Friends[i]) and _distance(Friends[i],unit) <= range then
				count = count + 1
			end
		end
		return count
	end

	local dispels = {
		[143579] = {stacks = 3 }, -- Immersius
		[143434] = {stacks = 3 }, -- Fallen Protectors
		[144514] = {stacks = 0 }, -- Norushen
		[144351] = {stacks = 0 }, -- Sha of Pride
		[146902] = {stacks = 0 }, -- Galakras(Korga Poisons)
		[143432] = {stacks = 0 }, -- General Nazgrim
		[142913] = {stacks = 0, range = 10}, -- Malkorok(Displaced Energy)
		[115181] = {stacks = 0 }, -- Spoils of Pandaria(Breath of Fire)
		[143791] = {stacks = 0 }, -- Thok(Corrosive Blood)
		[145206] = {stacks = 0 }, -- Aqua Bomb(Proving Grounds)
		[138733] = {stacks = 0 , range = 8}, -- Jin'rokh the Breaker (Ionization)
		-- Ko'ragh
		[142913] = {stacks = 0, range = 5}, -- http://www.wowhead.com/spell=162185/expel-magic-fire
		[185066] = {stacks = 0}, -- Mark of Necromancer red level
		-- Xavius
		[206651] = {stacks = 3}, -- Xavius Darkening Soul
		[209158] = {stacks = 3}, -- Xavius Blackening Soul
		-- Belac
		[233983] = {stacks = 0, range = 8}, -- Echoing Anguish http://www.wowhead.com/spell=233983/echoing-anguish
		-- Antoran High Command (Antorus)
		[257974] = {stacks = 9}, -- http://www.wowhead.com/spell=257974/chaos-pulse
		-- Imonar the Soulhunter
		[247552] = {stacks = 0, range = 15}, -- http://www.wowhead.com/spell=247552/sleep-canister
		-- Jadefire Masters
		[286988] = {stacks = 0}, -- https://www.wowhead.com/spell=286988/searing-embers
		-- Opulence
		[284470] = {stacks = 0}, -- https://www.wowhead.com/spell=284470/hex-of-lethargy
		-- Conclave of the Chosen
		--[282135] = {stacks = 0, range = 12}, -- https://www.wowhead.com/spell=282135/crawling-hex
		[285879] = {stacks = 0}, --https://www.wowhead.com/spell=285879/mind-wipe
		-- Mekkatorque
		[287167] = {stacks = 0}, -- https://www.wowhead.com/spell=287167/discombobulation
		-- Jaina Proudmoore
		[287626] = {stacks = 0}, -- https://www.wowhead.com/spell=287626/grasp-of-frost
		-- Siege of Boralis
		[275014] = { stacks = 0, range = 7 }, --https://www.wowhead.com/spell=274991/putrid-waters
		[257168] = { stacks = 0 }, --https://www.wowhead.com/spell=257168/cursed-slash
		[272571] = { stacks = 0 }, --https://www.wowhead.com/spell=272571/choking-waters
		[275835] = { stacks = 0 }, --https://www.wowhead.com/spell=275835/stinging-venom-coating
		-- Waycrest Manor
		[261440] = { stacks = 0, range = 8 }, --https://www.wowhead.com/spell=261439/virulent-pathogen
		[261439] = { stacks = 0, range = 8 }, --https://www.wowhead.com/spell=261439/virulent-pathogen
		[264378] = { stacks = 0 }, --https://www.wowhead.com/spell=264378/fragment-soul
		[263891] = { stacks = 0 }, --https://www.wowhead.com/spell=263891/grasping-thorns
		[265352] = { stacks = 0 }, --https://www.wowhead.com/spell=265352/toad-blight
		-- Temple of Sethraliss
		[268008] = { stacks = 0 }, --https://www.wowhead.com/spell=268008/snake-charm
		[268013] = { stacks = 0 }, --https://www.wowhead.com/spell=268013/flame-shock
		[268013] = { stacks = 0 }, --https://www.wowhead.com/spell=268013/flame-shock
		[273563] = { stacks = 0 }, --https://www.wowhead.com/spell=273563/neurotoxin
		[272657] = { stacks = 0 }, --https://www.wowhead.com/spell=272657/noxious-breath
		[267027] = { stacks = 0 }, --https://www.wowhead.com/spell=267027/cytotoxin
		[272699] = { stacks = 0 }, --https://www.wowhead.com/spell=272699/venomous-spit

		-- Tol Dagor
		[258128] = { stacks = 0 }, --https://www.wowhead.com/spell=258128/debilitating-shout
		[265889] = { stacks = 0 }, --https://www.wowhead.com/spell=265889/torch-strike
		[258864] = { stacks = 0 }, --https://www.wowhead.com/spell=258864/suppression-fire
		[257028] = { stacks = 0 }, --https://www.wowhead.com/spell=257028/fuselighter
		[257777] = { stacks = 0 }, --https://www.wowhead.com/spell=257777/crippling-shiv
		-- The Motherloads
		[280605] = { stacks = 0 }, --https://www.wowhead.com/spell=280605/brain-freeze
		[262268] = { stacks = 0 }, --https://www.wowhead.com/spell=262268/caustic-compound
		[268797] = { stacks = 0 }, --https://www.wowhead.com/spell=268797/transmute-enemy-to-goo
		[259853] = { stacks = 0 }, --https://www.wowhead.com/spell=259853/chemical-burn
		[269298] = { stacks = 0 }, --https://www.wowhead.com/spell=269298/widowmaker-toxin
		-- Atal'Dazar
		[252781] = { stacks = 0, range = 9 }, -- https://www.wowhead.com/spell=252781/unstable-hex
		[250096] = { stacks = 0 }, -- https://www.wowhead.com/spell=250096/wracking-pain
		[253562] = { stacks = 0 }, -- https://www.wowhead.com/spell=253562/wildfire
		[255582] = { stacks = 0 }, -- https://www.wowhead.com/spell=255582/molten-gold
		[255041] = { stacks = 0 }, -- https://www.wowhead.com/spell=255041/terrifying-screech
		[255371] = { stacks = 0 }, -- https://www.wowhead.com/spell=255371/terrifying-visage
		[250372] = { stacks = 2 }, --https://www.wowhead.com/spell=250372/lingering-nausea
		[252687] = { stacks = 0 }, --venomfang strike
		[255620] = { stacks = 0 }, --festering eruption
		-- Freehold
		[257908] = { stacks = 0 }, -- https://www.wowhead.com/spell=257908/oiled-blade
		[257436] = { stacks = 0 }, -- https://www.wowhead.com/spell=257436/poisoning-strike
		-- Shrine of the storm
		[264560] = { stacks = 0 }, -- https://www.wowhead.com/spell=264560/choking-brine
		[268233] = { stacks = 0 }, -- https://www.wowhead.com/spell=268233/electrifying-shock
		[268322] = { stacks = 0 }, -- https://www.wowhead.com/spell=268322/touch-of-the-drowned
		[268391] = { stacks = 0 }, -- https://www.wowhead.com/spell=268391/mental-assault
		[268896] = { stacks = 0 }, -- https://www.wowhead.com/spell=268896/mind-rend
		[269104] = { stacks = 0 }, --https://www.wowhead.com/spell=269104/explosive-void
		-- Kings Rest
		[276031] = { stacks = 0 }, -- https://www.wowhead.com/spell=276031/pit-of-despair
		[270492] = { stacks = 0 }, -- https://www.wowhead.com/spell=270492/hex
		[270499] = { stacks = 0 }, -- https://www.wowhead.com/spell=270499/frost-shock
		[270865] = { stacks = 0 }, --https://www.wowhead.com/spell=270865/hidden-blade
		[271563] = { stacks = 0 }, -- https://www.wowhead.com/spell=271563/embalming-fluid
		[270507] = { stacks = 0 }, -- https://www.wowhead.com/spell=270507/poison-barrage
		-- Underrot
		[276031] = { stacks = 2 }, -- https://www.wowhead.com/spell=265468/withering-curse
		[266209] = { stacks = 0 }, -- https://www.wowhead.com/spell=266209/wicked-frenzy
		[272180] = { stacks = 0 }, -- https://www.wowhead.com/spell=272180/death-bolt
		[272609] = { stacks = 0 }, -- https://www.wowhead.com/spell=272609/maddening-gaze
		[269301] = { stacks = 3 }, -- https://www.wowhead.com/spell=269301/putrid-blood
		[278961] = { stacks = 0 }, -- https://www.wowhead.com/spell=278961/decaying-mind
		-- Eternal Palace
		[296737] = { stacks = 0, range = 10}, -- https://www.wowhead.com/spell=296737/arcane-bomb
		[295327] = { stacks = 0}, --https://www.wowhead.com/spell=295327/shattered-psyche
		-- Mechagon
		[300659] = {stacks = 0}, --https://www.wowhead.com/spell=300659/consuming-slime
		[298124] = {stacks = 0}, --https://www.wowhead.com/spell=298124/gooped
		[300414] = {stacks = 0}, --https://www.wowhead.com/spell=300414/enrage
		[294929] = {stacks = 0}, --https://www.wowhead.com/spell=294929/blazing-chomp
		[294195] = {stacks = 0}, --https://www.wowhead.com/spell=294195/arcing-zap
		[284219] = {stacks = 0}, --https://www.wowhead.com/spell=284219/shrink
		-- Trash (Ny'alotha)
		[310224] = {stacks = 10}, --https://www.wowhead.com/spell=307421/annihilation
		-- Maut
		[314993] = {stacks = 0}, --https://www.wowhead.com/spell=314992/drain-essence
		-- S4 M+ AFfix
		[314411] = {stacks = 0}, --https://www.wowhead.com/spell=314411/lingering-doubt
		[314592] = {stacks = 0}, --tentacle mind flay
		[314406] = {stacks = 0},


		-- FUCKING CANCER VISION CANCER CANCER CANCER CANCER CANCCER CANCER CANCER
		[297146] = {stacks = 0},	-- CURSE INFINITELY HEALS THE FUCKING BERSERKERS
		[298510] = {stacks = 3},	-- POISON STUNS YOU AT 5 STACKS GOOD LUCK ANYONE WITHOUT POISON DISP


		--test
		-- [12654] = {stacks = 0},
	}

	function PvE_Dispel(unit,types)

		if not UnitIsVisible(unit) or UnitIsDeadOrGhost(unit) then return false end

		if not types then return false end

		local cache = unit_debuff_cache[unit]
		if not cache then
			unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
			cache = unit_debuff_cache[unit]
			for i=1,#cache do
				local name,count,debuffType,spellID = cache[i][1],cache[i][3],cache[i][4],cache[i][10]
				local should_dispel = tContains(types,debuffType) and dispels[spellID]
				if should_dispel then
					local min_stacks = should_dispel.stacks
					local range = should_dispel.range
					if range then
						if Friends_Around_Unit(unit,range) == 0 and count >= min_stacks then
							return spellID
						end
					else
						if count >= min_stacks then
							return spellID
						end
					end
				end
			end
		else
			local cache = unit_debuff_cache[unit]
			for i=1,#cache do
				local name,count,debuffType,spellID = cache[i][1],cache[i][3],cache[i][4],cache[i][10]
				local should_dispel = tContains(types,debuffType) and dispels[spellID]
				if should_dispel then
					local min_stacks = should_dispel.stacks
					local range = should_dispel.range
					if range then
						if Friends_Around_Unit(unit,range) == 0 and count >= min_stacks then
							return spellID
						end
					else
						if count >= min_stacks then
							return spellID
						end
					end
				end
			end
		end

	end

	--Interrupts
	function Interrupt(unit,int,forcedpct,physical,onlyint,nochannel)

		if not UnitIsVisible(unit) or UnitIsDeadOrGhost(unit) then return false end

		if (not arena or unit_is_player(unit)) and (physical or not UnitBuffID(unit,8178)) and (physical or not UnitBuffID(unit,212295)) and (int or not UnitBuffID(unit,289655)) and not UnitBuffID(unit,104773) then

			local channel,_,_,_,_,_,channelInterruptable = UnitChannelInfo(unit)
			local cast,_,_,_,_,_,_,castInterruptable = unit_casting_info(unit)

			if not channel and not cast then return false end

			if nochannel and channel then return false end

			if physical and _immunePhysical(unit) then return false end

			if _immuneCheck(unit) then return false end

			if physical and UnitBuffID(unit,1022) then return false end

			if int then
				if channelInterruptable == true then
					channelInterruptable = false
				end
				if castInterruptable == true then
					castInterruptable = false
				end
			end

			--latency &amp; travel time delay
			local frame_buffer = 1 / GetFramerate() -- 1 frame buffer
			local background_delay = (not IsForeground() and frame_buffer or 0)
			local interruptNetDelay = squid_avg_latency + frame_buffer + background_delay + _kickTravelTime(unit) + .115 + (SQUID.extra_net_delay or 0) -- latency + frame buffer + interrupt travel time + safety net

			-- print(interruptNetDelay,_castTimeLeft(unit))

			--pct delay
			local pct=99

			--overwrite based on jukes
			if jukeList[unit] then
				local jukes = jukeList[unit]["Jukes"]
				local max = jukeList[unit]["MaxJukes"]
				if not max then max = 3; end
				if jukes then
					if jukes < max then pct=99 else pct=0 end
				end
			end

			--mages shimmer, can't 99 them...
			if select(2,UnitClass(unit)) == "MAGE" and _isMeleeDps("player") then
				pct = 35;
			end

			--off targets can be kicked faster for melee
			if not unit_is_unit(unit,current_target) and _isMeleeDps("player") then
				pct = 30;
			end

			if lastShadowStep and GetTime()-lastShadowStep <= 2.5 then
				pct = 0;
			end

			if lastGapClose and GetTime() - lastGapClose <= 1.5 then
				pct = 0;
			end

			--override pct delay
			if forcedpct then
				pct = forcedpct
			end

			local pct_done = _castPctDone(unit)
			local time_left = _castTimeLeft(unit)
			local time_complete = _castTimeComplete(unit)

			--cast pct complete > pct and < net delay
			if ((cast and (pct_done >= pct or time_left <= interruptNetDelay) and (time_left < 1.5))
			--channels insta
			or channel and time_complete >= minDelayTime + (chan_delay == 1 and .55 or chan_delay == 2 and .35 or chan_delay == 3 and .1))
			--time complete > min delay
			and (time_complete >= minDelayTime or time_left <= interruptNetDelay) then
			-- --time left > net delay MINIMUM.
			-- and _castTimeLeft(unit) > interruptNetDelay/1.1 then

				--dont kick if your dk dark sim
				if UnitDebuffID(unit,77606) then return false; end

				--always kick in dungeons
				if not unit_is_player(unit) and select(2,UnitClass("player")) ~= "MAGE" and GetNumGroupMembers() <= 5 and not arena and (channelInterruptable == false or castInterruptable == false) then
					return true
				end

				--always kick as dh
				if select(2,UnitClass("player")) == "DEMONHUNTER" and (channelInterruptable == false or castInterruptable == false) then
					if GetNumGroupMembers() <= 10 then --good to kick everything in rbg, not raids
						return true;
					end
				end

				local friendlyMage = nil
				for i=1,#Friends do
					if select(2,UnitClass(Friends[i])) == "MAGE" then
						friendlyMage=Friends[i]
					end
				end

				--let mage get first kick on priests, unless they're our target / mage in cc
				--(i would do an los check but those are too expensive!)
				if friendlyMage and select(2,UnitClass("player")) ~= "MAGE" then
					if UnitCooldown(friendlyMage,2139) == 0 and not _CCcheck(friendlyMage) then
						if select(2,UnitClass(unit)) == "PRIEST" and not unit_is_unit(unit,current_target) then
							return false
						end
					end
				end

				--check for mage
				local mageExists;
				if arena then
					for i=1,GetNumArenaOpponents() do if unit_is_player("arena"..i) and select(2,UnitClass("arena"..i)) == "MAGE" then
						mageExists="arena"..i;
					end end
				end

				--lowest friend
				local lowestFriend=100;
				for i=1,#Friends do
					local friendhp = _HP(Friends[i]);
					if friendhp and friendhp < lowestFriend then
						lowestFriend=_HP(Friends[i]);
					end
				end

				--lowest enemy
				local lowestEnemy = 100;
				for i=1,#Enemies do if unit_is_player(Enemies[i]) and _HP(Enemies[i]) < lowestEnemy then
					lowestEnemy=_HP(Enemies[i]);
				end end

				--they have healer?
				local theirHealer
				for i=1,#Enemies do if _isHealer(Enemies[i]) then theirHealer=Enemies[i] end end

				--their healer in cc?
				local theirHealerCC
				local theirHealerCCremains = 0
				if theirHealer then
					local cc=_CCremains(theirHealer)
					if cc > 0 then
						theirHealerCC = true;
						theirHealerCCremains = cc;
					end
				end

				--healer in cc
				local healerInCC;
				if ourHealer and _CCcheck(ourHealer) then healerInCC=true; end

				lowestFriend = lowestFriend - (healerInCC and 30 or 0)

				local cast_target = UnitSpellTarget(unit)
				if not UnitIsVisible(cast_target) then cast_target = nil end

				local los_dest;
				if cast_target then
					if _LoS(unit,cast_target) then
						los_dest = true;
					end
				end

				--check cast function
				local function UnitCastingFrom(table)
					local interruptable = castInterruptable == false or channelInterruptable == false or int
					local spell = interruptable and cast
					if not spell then spell = interruptable and channel end

					--dont kick hex with friendly druid out of cc .. this logic causes weird problems with hex lasso being a thing now...
					-- if cast == "Hex" then
					-- 	if not _isHealer(unit) or lowestEnemy > 40 then
					-- 		if friendlyDruid then return false; end
					-- 	end
					-- end

					--dont kick cc if dest is immune ... so much cool shit i just can't do without functioning cast dest..
					-- if castDest then
					-- 	local cc = {
					-- 	"Polymorph",
					-- 	"Cyclone",
					-- 	"Fear",
					-- 	"Hex",
					-- 	"Repentance",
					-- 	"Dominate Mind",
					-- 	}
					-- 	if _immuneTrap(castDest,true) and tContains(cc,cast) then return false; end
					-- 	if cast ~= "Dominate Mind" and cast ~= "Fear" and cast ~= "Cyclone" and tContains(cc,cast) and _isBeast(castDest) then return false; end
					-- end

					--check cast
					if type(table) == "table" then
						for i=1,#table do
							local c = GetSpellInfo(table[i]);
							if c and spell == c then return true; end
						end
					end
					if type(table) == "string" then
						if spell == table then return true; end
					end
					if type(table) == "number" then
						if spell == GetSpellInfo(table) then return true; end
					end
				end

				if UnitCastingFrom(csCCPolymorphs) or UnitCastingFrom(csCCincapacitate) then

					return true;
				end

				--kick CC
				if UnitCastingFrom(csCCPolymorphs) or UnitCastingFrom(csCCincapacitate) or UnitCastingFrom(csCCdisorient) or UnitCastingFrom(csAlways) then
					--dont kick fear unless it's on your healer
					if (cast ~= GetSpellInfo(118699) or (unit_is_unit(castDest,ourHealer) and _disorientDR(ourHealer) >= .5 and lowestFriend < _disorientDR(ourHealer) * 80) or lowestEnemy < 45 + (theirHealerCCremains > 2 and theirHealerCCremains * 10 or 0) - ((100-lowestFriend)*.5)) then
						return true;
					end
				end

				--kick only if channeled
				if UnitCastingFrom(csOnlyChannel) and UnitChannelInfo(unit) then
					return true;
				end

				--cs heals if enemy < %hp
				if lowestEnemy < 92 then
					if _isHealer(unit) or theirHealerCC or not theirHealer then
						if UnitCastingFrom(csHeals) then
							if cast ~= GetSpellInfo(33076) or lowestEnemy < 40 then
								if not mageExists or lowestEnemy < 45 or enemy_in_stun or IsLocked(unit) then
									if lowestEnemy < 55 and _isHealer(unit) then return "important" end
									return true;
								end
							end
						end
					end
				end

				--cs mass dispel (if friend immune or enemy trapped)
				if cast == "Mass Dispel" and (castInterruptable == false or int) then

					local friendImmune
					for i=1,#Friends do
						if UnitBuffID(Friends[i],642) or UnitBuffID(Friends[i],45438) then
							friendImmune=true;
						end
					end

					local enemyCC
					for i=1,#Enemies do
						if _inDispellableCC(Enemies[i]) then
							enemyCC=true;
						end
					end

					if friendImmune or enemyCC then
						return true;
					end

				end

				--scorch or fireball (with combustion up)
				if (cast == "Fireball" or cast == "Scorch") and UnitBuffID(unit,190319) then
					if lowestFriend < 30 then return "important" end
					return true;
				end

				--frost mage damage (mage or teammate extremely low)
				if UnitCastingFrom(csMageDamage) and (_HP(unit) < 35 or lowestFriend < 20) then
					return true;
				end

				--any arcane cast when healer in cc
				if UnitCastingFrom(csArcaneDamage) and (lowestFriend < 40 + (healerInCC and 60 or 0)) then
					return true;
				end

				if select(2,UnitClass(unit)) == "WARLOCK" then
					if UnitBuffID(unit,113858) then --only kick bolts when dark soul is up, have to trust healer dispel on cc casts.
						if cast == "Chaos Bolt" then
							if time_complete >= minDelayTime * 4 or time_left <= interruptNetDelay then
								return true
							end
						else
							return false;
						end
					else --normal lock kicks
						--kick fear if we have pressure
						local fearkickhp = 50
						fearkickhp = fearkickhp + (theirHealerCC and 35 or 0)
						if cast == "Fear" and _HP(unit) < fearkickhp then
							if time_complete >= minDelayTime * 2.5 or time_left <= interruptNetDelay then
								return true
							end
						end
						--idk kick ua locks out of the game i guess?
						if cast == "Unstable Affliction" and lowestFriend < 80 then
							return true;
						end
						--dont kick bolts unless we really have to while their healer is cc'd
						if cast == "Chaos Bolt" and lowestFriend < 65 and (not theirHealerCC or lowestFriend < 35) then
							if time_complete >= minDelayTime * 2.5 or time_left <= interruptNetDelay then
								return true
							end
						end
					end
				else
					--kick from big dmg (lowest teammate < 60)
					if UnitCastingFrom(castedDMG) and lowestFriend < 60 then
						if lowestFriend < 45 then return "important" end
						return true;
					end
				end

				--holy paladin spells (low hp)
				if (cast == "Holy Light" or cast == "Flash of Light") and (castInterruptable == false or int) and _HP(unit) < 65 then
					return true;
				end

				--kick vt (if you're targeting)
				if cast == "Vampiric Touch" and (unit_is_unit(unit,current_target) or lowestEnemy < 35 or _isHealer("player")) then
					return true;
				end

				--antilock
				-- if UnitCastingFrom(csWarlock) then
				-- 	return true;
				-- end

			end
		end
	end

	function PhysicalInterrupt(unit,int,pct,physical,custombuffer)
		return Interrupt(unit,int,pct,true,custombuffer);
	end

	function _unitIsFacingUnit(firstUnit,secondUnit,angle)
		if not angle then angle = 180; end
		if firstUnit and secondUnit then
			return UnitIsFacing(firstUnit,secondUnit,angle)
		end
		return false
	end

	function _amIfacing(unit)
		if not UnitExists(unit) then return false end
		return _unitIsFacingUnit("player",unit);
	end
	am_i_facing = _amIfacing

	function am_i_facing_angle(unit,angle)
		if not unit then return false end
		if not angle then angle = 180; end
		return UnitIsFacing("player",unit,angle)
		-- local secondUnit=unit
		-- unit="player"
		-- if not secondUnit then return false end
		-- if UnitIsVisible(unit) and UnitIsVisible(secondUnit) then
		-- 	local X,Y,Z = ObjectPosition(unit);
		-- 	local unitX,unitY,unitZ = ObjectPosition(secondUnit);
		-- 	local Rotation = ObjectFacing(unit);
		-- 	local dist = _realDistance(unit,secondUnit)
		-- 	local uhh = (((X-unitX)*math.cos(-Rotation))-((Y-unitY)*math.sin(-Rotation)))
		-- 	uhh = uhh + dist
		-- 	return uhh < angle or dist < 1.5;
		-- end
		-- if not unit then
		-- 	if not angle then angle = .75; end
		-- 	local secondUnit=unit
		-- 	unit="player"
		-- 	if not secondUnit then return false end
		-- 	if UnitIsVisible(unit) and UnitIsVisible(secondUnit) then
		-- 		local X,Y,Z = ObjectPosition(unit);
		-- 		local unitX,unitY,unitZ = ObjectPosition(secondUnit);
		-- 		local Rotation = ObjectFacing(unit);
		-- 		local dist = _realDistance(unit,secondUnit)
		-- 		local uhh = (((X-unitX)*math.cos(-Rotation))-((Y-unitY)*math.sin(-Rotation)))
		-- 		uhh = uhh + dist
		-- 		return uhh < angle or dist < 1.5;
		-- 	end
		-- return false end
	end

	function facing_bcc(dist,angle)
		if not angle then angle = .75 end
		if not dist then dist = 15 end
		local bcc = {}
		for i=1,#Enemies do if _breakableCC(Enemies[i]) and _distance(Enemies[i]) < dist then
			table.insert(bcc,Enemies[i])
		end end
		for i=1,#bcc do
			if am_i_facing_angle(bcc[i],angle) then
				return true
			end
		end
	end

	local pCC = {
	-- PVP DISPELs --
	--------------------
	--Death Knight
	-- Druid
	--99, -- Disorienting Roar (talent)
	2637,	-- Hibernate
	-- Hunter
	3355, -- Freezing Trap
	-- Mage
	28272,		-- Pig
	118,		-- Sheep
	277792,		-- Bee
	161354,		-- Monkey
	277787,		-- Direhorn
	161355,		-- Penguin
	161353,		-- Polar Bear
	120140,		-- Porcupine
	61305,		-- Cat
	61721,		-- Rabbit
	61780,		-- Turkey
	28271,		-- Turtle
	82691,		-- Ring of Frost
	-- Monk
	-- Paladin
	853, -- Hammer of Justice
	105421, -- Blinding Light
	20066, -- Repentance
	-- Priest
	9484, -- Shackle Undead
	-- 87204, -- Sin and Punishment
	64044, -- Psychic Horror (Stun)
	-- 605,	-- MC
	-- 200196,	-- Holy Word: Chastise (FIX ME, MIGHT NOT BE DISPELLABLE)
	205369,	-- Mind Bomb (Pre Stun)
	226943,	-- Mind Bomb (Post Stun)
	-- Rogue
	-- Shaman
	118905, -- Static Charge
	51514,  -- Hex
	-- Hunter
	-- Paladin
	-- 10326, -- Turn Evil
	-- Priest
	8122, -- Psychic Scream
	-- Rogue
	-- Warlock
	5782, -- Fear -- new SpellID in MoP, Blood Fear uses same ID
	118699,	-- Fear (BFA spellid)
	5484, -- Howl of Terror
	6789, -- Mortal Coil
	6358, -- Seduction (Succubus)
	115268, -- Mesmerize (Shivarra) -- FIXME: verify this is the correct category
	-- 111397, -- Blood horror
	30283, -- shadowfury
	-- Warrior
	-- Demon Hunter
	206649, -- Eye of Leotheras
	179057,	-- Chaos Nova
	217832,	-- Imprison
	}

	local cc = {
	--Demon Hunter
	179057,	-- Chaos Nova
	--Mage
	102051, -- Frostjaw (talent)
	--Priest
	15487, --Silence
	 -- Hunter
	-- Paladin
	10326, -- Turn Evil
	-- PVP DISPELs --
	--------------------
	-- Druid
	-- 99, -- Disorienting Roar (talent)
	-- Hunter
	187650, -- Freezing Trap
	19386, -- Wyvern Sting
	-- Mage
	118, -- Polymorph
	28272, -- Polymorph (pig)
	28271, -- Polymorph (turtle)
	61305, -- Polymorph (black cat)
	61025, -- Polymorph (serpent) -- FIXME: gone ?
	61721, -- Polymorph (rabbit)
	61780, -- Polymorph (turkey)
	82691, -- Ring of Frost
	44572, -- Deep Freeze
	157997, --New ice nova
	31661, --Dragon's roar
	-- Monk
	198909,	-- Song of Chi Ji
	-- Paladin
	853, -- Hammer of Justice
	105593, -- Fist of Justice (talent)
	105421, -- Blinding Light
	20066, -- Repentance
	-- Priest
	9484, -- Shackle Undead
	87204, -- Sin and Punishment
	64044, -- Psychic Horror (Horrify effect)
	--605,	--MC
	-- Rogue
	-- Shaman
	118905, -- Static Charge
	--51514,  -- Hex
	-- Hunter
	117526, --binding shit i mean shot
	-- Paladin
	10326, -- Turn Evil
	-- Priest
	8122, -- Psychic Scream
	-- Rogue
	-- Warlock
	118699, -- Fear -- new SpellID in MoP, Blood Fear uses same ID
	5484, -- Howl of Terror
	6789, --Mortal Coil-
	6358, -- Seduction (Succubus)
	115268, -- Mesmerize (Shivarra) -- FIXME: verify this is the correct category
	111397, -- Blood Horror
	-- Warrior
	--DK
	47476
	}
	local rootDispels = {
		--96294,		--Chains Of Ice
		--91807,		--ShamblingRush
		339,		-- Entangling Roots
		--45334,		-- Immobilized (Wild Charge - Bear)
		102359,		-- Mass Entanglement
		-- ** FIND NEW ENTRAPMENT **
		136634,		-- Narrow Escape
		122,		-- Frost Nova
		111340,		-- Ice Ward
		--116706,		-- Disable
		--87194,		-- Glyph of Mind Blast
		--114404,		-- Void Tendril's Grasp
		64695,		-- Earthgrab (Earthgrab Totem)
		63685,		-- Freeze (Frozen Power)
		--107566,		-- Staggering Shout
		--39965,		-- Frost Grenade
		--55536,		-- Frostweave Net
		--13099		-- Net-o-Matic
		-- 233395,		-- Remorseless Root
	}
	local ccProt = {
		34914, 		--VampiricTouch
		30108, 		--UA
	}
	local mdBuffs = {
	642,	-- Divine Shield
	45438, 	--Ice Block
	1022	--bop
	}

	function _shouldCleanse(unit)

		-- dont dispel vt or ua when we are literally fucking dead
		if _buffFromTable(unit,ccProt) and lowestFriend < 35 then
			return false
		end

		local schools = {
		"Magic",
		"Poison",
		"Disease",
		}
		local lessDelay = minDelayTime / 1.5;
		local time = GetTime()
		for i=1,#pCC do
			local debuff,_,_,five,six,seven = UnitDebuffID(unit,pCC[i]);
			if debuff and seven-time < six-lessDelay then
				if tContains(schools,five) then
					return pCC[i];
				end
			end
		end
		--voodoo doll
		if UnitDebuffID(unit,271465) then
			return 271465
		end
		--maledict
		if UnitDebuffID(unit,305252) then
			return 305252
		end
		--claw
		if UnitDebuffID(unit,313148) then
			return 313148
		end
		--Dispelling Roots--
		if (_isMeleeDps(unit) or _isHealer(unit)) then
			for i=1,#rootDispels do
				if UnitDebuffID(unit,rootDispels[i]) then
					return rootDispels[i];
				end
			end
		end
	end

	function should_purify(unit)
		if not unit then return end
		local time = GetTime()
		local lessDelay = minDelayTime / 2;
		local schools = {
		"Magic",
		"Disease",
		}
		--Dispelling CC--
		for i=1,#pCC do
			local debuff,_,_,five,six,seven = UnitDebuffID(unit,pCC[i]);
			if debuff and seven-time < six-lessDelay then
				if tContains(schools,five) then
					return pCC[i];
				end
			end
		end
		--voodoo doll
		if UnitDebuffID(unit,271465) then
			return 271465
		end
		--maledict
		if UnitDebuffID(unit,305252) then
			return 305252
		end
		--claw
		if UnitDebuffID(unit,313148) then
			return 313148
		end
		--Dispelling Roots--
		if (_isMeleeDps(unit) or _isHealer(unit)) then
			for i=1,#rootDispels do
				if UnitDebuffID(unit,rootDispels[i]) then
					return rootDispels[i];
				end
			end
		end
	end

	function should_cleanse(unit)
		if not unit then return end
		local time = GetTime()
		local lessDelay = minDelayTime / 2;
		local schools = {
		"Magic",
		"Disease",
		}
		--Dispelling CC--
		for i=1,#pCC do
			local debuff,_,_,five,six,seven = UnitDebuffID(unit,pCC[i]);
			if debuff and seven-time < six-lessDelay then
				if tContains(schools,five) then
					return pCC[i];
				end
			end
		end
		--voodoo doll
		if UnitDebuffID(unit,271465) then
			return 271465
		end
		--maledict
		if UnitDebuffID(unit,305252) then
			return 305252
		end
		--Dispelling Roots--
		if (_isMeleeDps(unit) or _isHealer(unit)) then
			for i=1,#rootDispels do
				if UnitDebuffID(unit,rootDispels[i]) then
					return rootDispels[i];
				end
			end
		end
	end

	function should_md(unit)
		local md_cast_time = _castTime(32375)
		if unit_can_attack("player",unit) and UnitDebuffID(unit,33786) then return false end
		for i=1,#mdBuffs do
			if _buffRemains(unit,mdBuffs[i]) > md_cast_time + 1.5 and (mdBuffs ~= 1022 or _purgeCount(unit) >= 5) then
				return true
			end
		end
	end

	function _shouldPurify(unit)
		local schools = {
		"Magic",
		"Poison",
		"Disease",
		}
		local lessDelay = minDelayTime / 4.2;
		local time = GetTime()
		for i=1,#pCC do
			local debuff,_,_,five,six,seven = UnitDebuffID(unit,pCC[i]);
			if debuff and seven-time < six-lessDelay then
				if tContains(schools,five) then
					return pCC[i]
				end
			end
		end
		--voodoo doll
		if UnitDebuffID(unit,271465) then
			return 271465
		end
		--maledict
		if UnitDebuffID(unit,305252) then
			return 305252
		end
		--Dispelling Roots--
		if (_isMeleeDps(unit) or _isHealer(unit)) then
			for i=1,#rootDispels do
				if UnitDebuffID(unit,rootDispels[i]) then
					return rootDispels[i]
				end
			end
		end
	end

	function cleanse_poisons(unit)
		for i=1,30 do
			local debuff,_,_,debufftype = UnitDebuff(unit,i)
			if not debuff then break end
			if debufftype == "Poison" then
				return debuff
			end
		end
	end

	local rootList = {
		--96294,		--Chains Of Ice
		-- 91807,		--ShamblingRush
		339,		-- Entangling Roots
		212638,		-- Tracker's Net
		45334,		-- Immobilized (Wild Charge - Bear)
		102359,		-- Mass Entanglement
		-- ** FIND NEW ENTRAPMENT **
		136634,		-- Narrow Escape
		122,		-- Frost Nova
		111340,		-- Ice Ward
		116706,		-- Disable
		--87194,		-- Glyph of Mind Blast
		--114404,		-- Void Tendril's Grasp
		64695,		-- Earthgrab (Earthgrab Totem)
		63685,		-- Freeze (Frozen Power)
		--107566,		-- Staggering Shout
		--39965,		-- Frost Grenade
		--55536,		-- Frostweave Net
		--13099		-- Net-o-Matic
		-- 233395,		-- Remorseless Root
	}

	local roots =
	{
		--96294,		--Chains Of Ice
		--91807,		--ShamblingRush
		339,		-- Entangling Roots
		45334,		-- Immobilized (Wild Charge - Bear)
		102359,		-- Mass Entanglement
		136634,		-- Narrow Escape
		122,		-- Frost Nova
		33395,		-- Mage Pet Freeze
		111340,		-- Ice Ward
		--87194,		-- Glyph of Mind Blast
		114404,		-- Void Tendril's Grasp
		64695,		-- Earthgrab (Earthgrab Totem)
		63685,		-- Freeze (Frozen Power)
		107566,		-- Staggering Shout
		199786,		-- Glacial Spike
		200108,		-- Ranger's Net
		190927,		-- Harpoon
		--39965,		-- Frost Grenade
		--55536,		-- Frostweave Net
		--13099		-- Net-o-Matic
		233395,		-- Remorseless Root
		212638,		-- Tracker's Net
		117526, -- Binding Shot (talent)
	}

	local rootz =
	{
		--96294,		--Chains Of Ice
		--91807,		--ShamblingRush
		--339,		-- Entangling Roots
		45334,		-- Immobilized (Wild Charge - Bear)
		--102359,		-- Mass Entanglement
		--136634,		-- Narrow Escape
		--122,		-- Frost Nova
		--33395,		-- Mage Pet Freeze
		--111340,		-- Ice Ward
		--87194,		-- Glyph of Mind Blast
		--114404,		-- Void Tendril's Grasp
		--64695,		-- Earthgrab (Earthgrab Totem)
		63685,		-- Freeze (Frozen Power)
		--107566,		-- Staggering Shout
		--39965,		-- Frost Grenade
		--55536,		-- Frostweave Net
		--13099		-- Net-o-Matic
	}

	function _rootCheck(unit)
		local hasdebuff,debuff = _debuffFromTable(unit,roots);
		if hasdebuff then return true; end
	end

	function _rootRemains(unit)
		if not ObjectIsVisible(unit) then return 0; end
		local debuffs = _debuffFromTable(unit,roots,true);
		table.sort(debuffs,function(x,y) return x > y end);
		return debuffs[1] or 0;
	end

	function _shouldFreedom(unit)
		local lessDelay = minDelayTime / 4.2;
		local isdps = _isMeleeDps(unit)
		local ishealer = _isHealer(unit)
		--Dispelling Roots--
		if isdps and not _CCcheck(unit) then
			for i=1,#rootList do
				if UnitDebuffID(unit,rootList[i]) and _debuffRemains(unit,rootList[i]) > 1.8 then
					return rootList[i];
				end
			end
			if _isSlowed(unit) then
				if (isdps and lowestEnemy < 30) or UnitBuffID(unit,221883) then
					return true;
				end
			end
		end
	end

	function SquidSac(unit)

		local t=unit or current_target

		if not UnitExists(t) then return false; end

		if UnitDebuffID(t,33786) then return false; end

		SQ_CastSpellByName("Blessing of Sacrifice",t);

	end

	local stealthIDs = {
		5215, --Prowl
		1784, --Stealth
		115191, --NEW Rogue Stealth
		114018, --Mass Stealth
		110960, --Mage Greater Invis
		115193, --vanish (old)
		119032, --Spectral Guise
		66, --Mage going invis
		198158, --Mass Invis
		188501,	--Spectral Sight (usually good to attack / sap)
		32612,	--new mage invis
		11327,	--vanish (new)

	}
	function _stealthCheck(unit)

		-- local buff = _buffFromTable(unit,stealthIDs);
		-- if buff then return buff; end

		local buffs = _buffFromTable(unit,stealthIDs,true,true)
		if buffs then
			table.sort(buffs,function(x,y) return x.r == -1 or x.r > y.r end)
		end

		if #buffs > 0 then
			return buffs[1].id ~= 0 and buffs[1].id or nil;
		end

	end

	local bigCD = {
	--Death Knight
	51271, --PillarOfFrost
	--Druid
	106951, --Berserk
	102560, --Boomkin Incarnation
	102543, --Feral Incarnation
	112071, --Celestial Alignment
	194223,	--Celestial Alignment
	173562,	--Celestial Alignment
	339943, -- Balance of All Things (bunch of crit)
	--Hunter
	193526, --Rapid Fire
	186289, --Aspect of the Eagle
	19574,	--Bestial Wrath
	193530,	--Aspect of the Wild
	--Mage
	12472, --IcyVeins
	12042, --Arcane Power
	190319,	--Combustion
	--Paladin
	31884, --Wings
	231895,	--Crusade
	--Priest
	10060, --Power Infusion
	194249,	--Void Form
	--Rouge
	51713, --Shadow Dance
	51690, --Killing Spree
	13750, --AR
	121471, --Shadow Blades
	--Shaman
	114050, --EleAscendance
	114051, --EnhAscendance
	16166, --ElementalMastery
	2825, --Bloodlust
	32182, --Heroism
	--Warlock
	196098,	--Soul Harvest
	-- 216708, --Soul consume thing (This is up like 100% of the time, so no.)
	--Warrior
	1719, --Battle Cry
	107574, --Avatar
	248622,	--In for the kill
	--Demon Hunter
	162264, --Metamorphosis
	206491,	--Nemesis
	247938,	--Chaos Blades
	--Windwalker
	152173,	--Serenity
	137639,	-- Storm, Earth, and Fire
	}

	function _CDcheck(unit)
		if not unit_is_player(unit) or _isHealer(unit) then return false end
		if enemy_chain_harvest and GetTime() - enemy_chain_harvest < 5 then
			if unit_is_unit(chain_harvest_pointer, unit) then
				return true
			end
		end
		local buffs = _buffFromTable(unit,bigCD)
		if buffs then return true; end
		-- if _buffStacks(unit,231895) >= 6 then return true; end
		if #BigCDTable > 0 then
			for i=1,#BigCDTable do
				local t = BigCDTable[i]
				local source=t.unit
				local dest=t.dest
				local cd=t.spell
				if UnitIsVisible(dest) and unit_is_unit(unit,source) then
					return UnitDebuffID(dest,cd)
				end
			end
		end
	end

	function _unitTargetMaxHP(unit)
		getUnit = UnitTarget(unit)
		unitHP = UnitHealth(getUnit)
		return unitHP
	end

	function _unitTargetHP(unit)
		getUnit = UnitTarget(unit)
		unitHP = UnitHealth(getUnit)
		return unitHP
	end

	function _targetLastTarget()
		if current_target then
			return;
		else
			RunMacroText("/targetlasttarget")
		end
	end
	target_last_target = _targetLastTarget

	azerite_power_cache = {}
	function AzeritePowerTaken(powerid)
		if azerite_power_cache[powerid] then return azerite_power_cache[powerid] end
		local isSelected
		for _, itemLocation in AzeriteUtil.EnumerateEquipedAzeriteEmpoweredItems() do
			isSelected = C_AzeriteEmpoweredItem.IsPowerSelected(itemLocation, powerid)
			azerite_power_cache[powerid] = isSelected
			if isSelected then return true end
		end
		return false
	end

	azerite_power_rank_cache = {}
	function GetNumAzeritePowerTaken(powerid)
		if azerite_power_rank_cache[powerid] then return azerite_power_rank_cache[powerid] end
		local count = 0
		for _, itemLocation in AzeriteUtil.EnumerateEquipedAzeriteEmpoweredItems() do
			count = count + (C_AzeriteEmpoweredItem.IsPowerSelected(itemLocation, powerid) and 1 or 0)
		end
		azerite_power_rank_cache[powerid] = count
		return count
	end

	function FrendlyCooldownsUp()
		local count = 0
		for i=1,#Friends do
			if _CDcheck(Friends[i]) then
				count = count + 1
			end
		end
		return count
	end

	function squid_meteor(unit)
		if _spellCooldown(153561) > 1.25 then return false end
		local x,y,z = best_meteor_point(unit)
		if x and y and z then
			if player_casting_crittable_damage and meteor_cd == 0 and (not comubstion or player_cast_time_left > .5) then SpellStopCasting() end
			SQ_CastSpellByID(153561)
			if IsAoEPending() then
				ClickPosition(x,y,z)
				_targetLastTarget()
				Squid_Alert("Meteor",nil,nil,nil,153561)
			end
			return true
		end
	end

	function EnemiesAttacking(friend,role)
		local count=0
		local melee=0
		local range=0
		local cds=0
		for i=1,#Enemies do
			local e = Enemies[i]
			if (not arena or unit_is_player(e)) and _CCremains(e) < .25 and not _isHealer(e) then
				local r = arena and _isRangedDps(e) or UnitCastingInfo(e)
				local m = arena and _isMeleeDps(e) or not r

				local inrange
				if unit_is_unit(friend,"player") then
					if m then inrange = _distance(e) < 6 end
					if r then inrange = _distance(e) < 40 and _LoS(e) end
				else
					if m then inrange = _distance(friend,e) < 6 end
					if r then inrange = _distance(friend,e) < 40 and _LoS(friend,e) end
				end
				if inrange then
					if not role or (role == 1 and m) or (role == 2 and r) then
						local cd_up = _CDcheck(e)
						local enemytarget=UnitTarget(e)
						if unit_is_unit(friend,enemytarget) then
							count = count + 1
							melee = melee + (m and 1 or 0)
							range = range + (r and 1 or 0)
							cds = cds + (cd_up and 1 or 0)
						end
					end
				end
			end
		end
		return count,melee,range,cds
	end

	function UnitEnemiesAttacking(unit,role)
		local count=0
		local melee=0
		local range=0
		local cds=0
		-- if not unit then error("No unit specified (UnitEnemiesAttacking") return 0,0,0,0 end
		if unit_can_attack("player",unit) then
			for i=1,#Friends do if not unit_is_unit(Friends[i],"player") then
				local e = Friends[i]
				if (not arena or unit_is_player(e)) and not _isHealer(e) then
					local friend_target = UnitTarget(e)
					if unit_is_unit(unit,friend_target) then

						local m = _isMeleeDps(e)
						local r = _isRangedDps(e)

						local inrange = true
						-- if m then inrange = _distance(unit,e) < 6.5 end
						-- if r then inrange = _distance(unit,e) < 40 end

						if inrange and (_CCremains(e) < .5 or ccdoesntmatter) then
							if not role or (role == 1 and m) or (role == 2 and r) then
								local cd_up = _CDcheck(e)
								count = count + 1
								melee = melee + (m and 1 or 0)
								range = range + (r and 1 or 0)
								cds = cds + (cd_up and 1 or 0)
							end
						end
					end
				end
			end end
		elseif UnitIsFriend("player",unit) then
			return EnemiesAttacking(unit,role)
		end
		return count,melee,range,cds
	end

	function _isMoving(unit)
		return unit and GetUnitSpeed(unit) > 0 or false
	end

	function GetSpellRange(spellID)
		return select(6,GetSpellInfo(spellID)) or 0
	end

	function _spellInRange(spellid,unit,otherUnit)
		if not otherUnit then otherUnit = "player"; end
		if UnitIsVisible(unit) and (type(spellid) == "number" or IsUsableSpell(spellid)) then
			local spellRange = select(6,GetSpellInfo(spellid));
			--balance affinity fix
			spellRange = spellRange + (IsPlayerSpell(197488) and (spellRange == 0 and 8 or 4) or 0)
			--death sentence fix
			spellRange = spellRange + (spellid == 163201 and IsPlayerSpell(198500) and 10 or 0)

			--shadowstrike in stealth                                                              -- tooltip says 25y but it's more like 22.5
			if spellid == 185438 then
				spellRange = spellRange + ((UnitBuffID("player",1784) or UnitBuffID("player",115191)) and 22.5 or 0)
			end

			--kill command
			if spellid == 34026 then return true end
			-- print(spellRange, _distance(unit))
			if spellRange > 0 and _distance(unit,otherUnit) <= spellRange then
				return true;
			end
			if spellRange == 0 and _meleeRange(unit,otherUnit) then
				return true;
			end
		end
		return false;
	end

	trackedPlayers = {}
	drReset = 19

	drSpells = {

		--[[ DISORIENTS ]]--
		-- Covenant?
		[331866] = "disorient", -- Door of Shadows
		-- Druid
		[33786] = "disorient",  -- Cyclone
		--Paladin
		[105421] = "disorient", -- Blinding Light
		[10326] = "disorient", -- Turn Evil
		--Priest
		[8122] = "disorient", -- Psychic Scream
		-- [205369] = "disorient", -- Mind Bomb Pre-Explosion
		[226943]  = "disorient", -- Mind Bomb (New ID?)
		[605] = "disorient", -- Mind Control
		--Rogue
		[2094] = "disorient", -- Blind
		--Warlock
		[5782] = "disorient", --fear
		[118699] = "disorient", --fear fear
		[5484] = "disorient", -- Howl of Terror
		[6358] = "disorient", -- Seduction (Succubus)
		[115268] = "disorient", -- Mesmerize (Shivarra)
		--Warrior
		[5246] = "disorient", -- Intimidating Shout
		--Mage
		[31661] = "disorient", -- Dragon's Breath
		--Monk
		[198909] = "disorient",	-- Song of Chi Ji
		--Death Knight
		[207167] = "disorient", -- Blinding Sleet
		--[[ END DISORIENTS ]]--

		--[[ INCAPACITATE ]]--
		--Racial
		[107079] = "incapacitate", -- Quaking Palm
		--Druid
		[99] = "incapacitate", --Incapacitating Roar
		[2637] = "incapacitate", -- Hibernate
		--Hunter
		[3355] = "incapacitate", -- Freezing Trap
		[187650] = "incapacitate", -- Freezing Trap (Old?)
		[213691] = "incapacitate", -- Scatter Shot
		--Mage
		[118] = "incapacitate", -- Polymorph Sheep
		[28272] = "incapacitate", -- Polymorph (Pig)
		[277792] = "incapacitate", -- Polymorph (Bee)
		[161354] = "incapacitate", -- Polymorph (Monkey)
		[277787] = "incapacitate", -- Polymorph (Direhorn)
		[161355] = "incapacitate", -- Polymorph (Penguin)
		[161353] = "incapacitate", -- Polymorph (Polar Bear)
		[120140] = "incapacitate", -- Polymorph (Porcupine)
		[61305] = "incapacitate", -- Polymorph (Cat)
		[61025] = "incapacitate", -- Polymorph (Snake) (removed?)
		[61721] = "incapacitate", -- Polymorph (Rabbit)
		[61780] = "incapacitate", -- Polymorph (Turkey)
		[28271] = "incapacitate", -- Polymorph (Turtle)
		[161372] = "incapacitate", -- Polymorph (Peacock)
		[82691] = "incapacitate", -- Ring of Frost
		--Monk
		[123394] = "incapacitate", -- Glyph of Breath of Fire
		[115078] = "incapacitate", -- Paralysis
		--Paladin
		[20066] = "incapacitate", -- Repentance
		--Priest
		[200196] = "incapacitate", --Holy Word: Chastise
		--Rogue
		[1776] = "incapacitate", -- Gouge
		[6770] = "incapacitate", -- Sap
		--Shaman
		[51514] = "incapacitate", -- Hex
		[211015] = "incapacitate", -- Hex (Cockroach)
		[210873] = "incapacitate", -- Hex (Compy)
		[211010] = "incapacitate",	-- Hex (Snake)
		[211004] = "incapacitate",	-- Hex (Spider)
		[277784] = "incapacitate",	-- Hex (Wicker Mongrel)
		[277778] = "incapacitate",	-- Hex (Zandalari Tendonripper)
		[309328] = "incapacitate",	-- Hex (Living Honey)
		[269352] = "incapacitate",	-- Hex (Skeletal Raptor)
		--Warlock
		[710] = "incapacitate",   -- Banish ?
		[6789] = "incapacitate",	-- Mortal Coil
		--Demon Hunter
		[217832] = "incapacitate",  -- Imprison
		[221527] = "incapacitate",  -- Imprison (detainment)
		--[[ END INCAPACITATE]]--

		--[[ SILENCES ]]--
		-- Death Knight
		[47476] = "silence", -- Strangulate (removed?)
		-- Druid
		-- [81261] = "silence", -- Solar Beam, Doesn't DR
		-- Paladin
		[31935] = "silence", -- Avenger's Shield
		-- Priest
		[15487] = "silence", -- Silence
		-- Rogue
		[1330] = "silence", -- Garrote Silence
		-- Hunter
		[202933]  = "silence", -- Spider Sting
		--[[END SILENCES]]--

		--[[ STUNS ]]--
		-- Warrior
		[132168] = "stun", -- Shockwave
		[132169] = "stun", -- Storm Bolt
		-- Death Knight
		[108194] = "stun", -- Asphyxiate
		[221562] = "stun", -- Asphyxiate (Blood)
		[91800] = "stun", -- Gnaw (Ghoul)
		[91797] = "stun", -- Monstrous Blow (Dark Transformation Ghoul)
		[210141]  = "stun", -- Zombie Explosion
		-- Druid
		[203123] = "stun", -- Maim
		[5211] = "stun", -- Mighty Bash
		[163505] = "stun", -- Rake (Stun from Prowl)
		-- Hunter
		[24394] = "stun", -- Intimidation
		-- Monk
		[119392] = "stun", -- Charging Ox Wave (talent)
		[119381] = "stun", -- Leg Sweep
		[120086] = "stun", -- Fists of Fury (Windwalker)
		-- Paladin
		[853] = "stun", -- Hammer of Justice
		[119072] = "stun", -- Holy Wrath (Protection)
		-- Rogue
		[1833] = "stun", -- Cheap Shot
		[408] = "stun", -- Kidney Shot
		-- [199804] = "stun", -- Between the eyes ( no longer a stun )
		-- Shaman
		[118905] = "stun", -- Static Charge (Capacitor Totem)
		[118345] = "stun", -- Pulverize
		-- Warlock
		[30283] = "stun", -- Shadowfury
		[89766] = "stun", -- Axe Toss (Felguard)
		-- Demon Hunter
		[179057] = "stun", -- Chaos Nova
		[191427] = "stun", -- Metamorphosis (Might not be a thing any more.)
		[211881] = "stun", -- Fel Eruption
		--Priest
		[200200] = "stun", -- Censure Chastise
		[64044] = "stun", -- Psychic Horror (Stun effect)
		-- Tauren
		[20549] = "stun", -- War Stomp
		--[[ END STUNS ]]--

		--Roots-
		[339] = "root",    -- Entangling Roots
		[102359] = "root",   -- Mass Entanglement
		[136634] = "root",   -- Narrow Escape
		[122] = "root",    -- Frost Nova
		[33395] = "root",    -- Mage Pet Freeze
		[111340] = "root",   -- Ice Ward
		[114404] = "root",   -- Void Tendril's Grasp
		[64695] = "root",    -- Earthgrab (Earthgrab Totem)
		[63685] = "root",    -- Freeze (Frozen Power)
		[107566] = "root",   -- Staggering Shout
		[200108] = "root",   -- Ranger's Net (talent)
		[116706] = "root",   -- Disable (Monk)
		[235963] = "root",   -- Melee Roots (Earthen Grasp)
		[117526] = "root", -- Binding Shot (talent)

	}

	listDisorients = {
		-- Covenant
		331866, -- Door of Shadows
		-- Druid
		33786,  -- Cyclone
		--Paladin
		105421, -- Blinding Light
		10326, -- Turn Evil
		--Priest
		8122, -- Psychic Scream
		205369, -- Mind Bomb
		605, -- Mind Control
		--Rogue
		2094, -- Blind
		--Warlock
		5782, --fear
		118699, --fear fear
		5484, -- Howl of Terror
		6358, -- Seduction (Succubus)
		115268, -- Mesmerize (Shivarra)
		--Warrior
		5246, -- Intimidating Shout
		--Mage
		31661, -- Dragon's Breath
		--Monk
		198909,	-- Song of Chi Ji
		--Death Knight
		207167, -- Blinding Sleet
	}

	listIncapacitates = {
	--Racial
		107079, -- Quaking Palm
		--Druid
		99, --Incapacitating Roar
		2637, -- Hibernate
		--Hunter
		3355, -- Freezing Trap
		187650, -- Freezing Trap (Old?)
		213691, -- Scatter Shot
		--Mage
		118, -- Polymorph Sheep
		28272, -- Polymorph (Pig)
		277792, -- Polymorph (Bee)
		161354, -- Polymorph (Monkey)
		277787, -- Polymorph (Direhorn)
		161355, -- Polymorph (Penguin)
		161353, -- Polymorph (Polar Bear)
		120140, -- Polymorph (Porcupine)
		61305, -- Polymorph (Cat)
		61025, -- Polymorph (Snake) (removed?)
		61721, -- Polymorph (Rabbit)
		61780, -- Polymorph (Turkey)
		28271, -- Polymorph (Turtle)
		161372, -- Polymorph (Peacock)
		82691, -- Ring of Frost
		--Monk
		123394, -- Glyph of Breath of Fire
		115078, -- Paralysis
		--Paladin
		20066, -- Repentance
		--Priest
		200196, --Holy Word: Chastise
		--Rogue
		1776, -- Gouge
		6770, -- Sap
		--Shaman
		51514, -- Hex
		211015, -- Hex (Cockroach)
		210873, -- Hex (Compy)
		211010,	-- Hex (Snake)
		211004,	-- Hex (Spider)
		277784,	-- Hex (Wicker Mongrel)
		277778,	-- Hex (Zandalari Tendonripper)
		309328,	-- Hex (Living Honey)
		269352,	-- Hex (Skeletal Raptor)
		--Warlock
		710,   -- Banish ?
		6789,	-- Mortal Coil
		--Demon Hunter
		217832,  -- Imprison
		221527,  -- Imprison (detainment)
	}

	listSilences = {
		-- Druid
	  81261, -- Solar Beam
		-- Paladin
	  31935, -- Avenger's Shield
		-- Priest
	  15487, -- Silence
		-- Rogue
	  1330, -- Garrote
	}

	listStuns = {
	  --[[ STUNS ]]--
	  -- Death Knight
	  108194, -- Asphyxiate (talent)
	  91800, -- Gnaw (Ghoul)
	  91797, -- Monstrous Blow (Dark Transformation Ghoul)
	  115001, -- Remorseless Winter (talent)
		-- Druid
	  22570, -- Maim
	  203123, -- Maim
	  5211, -- Mighty Bash (talent)
	  163505, -- Rake Stun
		-- Hunter
	  24394, -- Intimidation
		-- Mage
	  44572, -- Deep Freeze
		-- Monk
	  119392, -- Charging Ox Wave (talent)
	  119381, -- Leg Sweep (talent)
	  120086, -- Fists of Fury (Windwalker)
		-- Paladin
	  853, -- Hammer of Justice
	  119072, -- Holy Wrath (Protection)
	  105593, -- Fist of Justice (talent)
	  -- Priest
	  200200,	--Censure Chastise
	  64044, -- Psychic Horror (Stun Effect)
		-- Rogue
	  1833, -- Cheap Shot
	  408, -- Kidney Shot
	  199804, -- Between the eyes
		-- Shaman
	  118905, -- Static Charge (Capacitor Totem)
	  118345, -- Pulverize
	  -- Warlock
	  30283, -- Shadowfury
	  89766, -- Axe Toss (Felguard)
	  22703, -- Infernal Stun
		-- Warrior
	  132168, -- Shockwave
	  107570, -- Storm Bolt
	  132169, -- Storm Bolt (New SpellID)
		-- Demon Hunter
	  179057, -- Chaos Nova
	  191427, -- Metamorphosis (Might not be a thing any more.)
	  211881, -- Fel Eruption
		-- Tauren
	  20549, -- War Stomp
	}

	listRoots = {

	  339,    -- Entangling Roots
	  102359,   -- Mass Entanglement
	  136634,   -- Narrow Escape
	  122,    -- Frost Nova
	  33395,    -- Mage Pet Freeze
	  111340,   -- Ice Ward
	  114404,   -- Void Tendril's Grasp
	  64695,    -- Earthgrab (Earthgrab Totem)
	  63685,    -- Freeze (Frozen Power)
	  107566,   -- Staggering Shout
	  200108,   -- Ranger's Net (talent)
	  116706,   -- Disable (Monk)
	  235963,   -- Melee Roots (Earthen Grasp)
	   117526, -- Binding Shot (talent)
	}

	-- DR Category names
	drCategoryNames = {
	  "stun",
	  "disorient",
	  "incapacitate",
	  "silence",
	  "root",
	}

	function _getDrSpellCategory(spellID)
	  return spellID and drSpells[spellID] or nil;
	end

	function _nextDr(diminished)
	  if diminished > 0.25 then return diminished / 2; end
	  return 0;
	end


	function debuffGained(spellID,destName,destPointer)
		if not destPointer then return; end

		local drCat = _getDrSpellCategory(spellID)

		if not trackedPlayers[destPointer] then
			trackedPlayers[destPointer] = {}
			trackedPlayers[destPointer][drCat] = { reset = 0, diminished = 1.0 }
			return
		end

		local tracked = trackedPlayers[destPointer][drCat]

		if tracked and tracked.reset <= GetTime() then
			tracked.diminished = 1.0
			tracked.refresh = nil
		end

	end

	function debuffFaded(spellID,destName,destPointer)
		if not destPointer then return; end

		local drCat = _getDrSpellCategory(spellID)

		if not trackedPlayers[destPointer] then
			trackedPlayers[destPointer] = {}
		end

		if not trackedPlayers[destPointer][drCat] then
			trackedPlayers[destPointer][drCat] = { reset = 0, diminished = 1.0 }
		end

		local time = GetTime()
		local tracked = trackedPlayers[destPointer][drCat]

		tracked.reset = time + drReset
		tracked.diminished = _nextDr(tracked.diminished)
		tracked.refresh = nil

	end

	--FIXME6 - ask youness abt inting sheep -- add 2 comblog
	function debuffRefresh(spellID,destName,destPointer)

		if not destPointer then return; end

		local drCat = _getDrSpellCategory(spellID)

		if not trackedPlayers[destPointer] then
			trackedPlayers[destPointer] = {}
			trackedPlayers[destPointer][drCat] = { reset = 0, diminished = 1 }
		end

		local tracked = trackedPlayers[destPointer][drCat]

		if tracked then
			tracked.diminished = _nextDr(tracked.diminished)
			tracked.refresh = true
		end
	end

	function _pulseResetDR()
	  local time = GetTime()
	  for i=1,#Enemies do
		if trackedPlayers[Enemies[i]] then
		  for v=1,#drCategoryNames do
			if trackedPlayers[Enemies[i]][drCategoryNames[v]] then
			  local tracked = trackedPlayers[Enemies[i]][drCategoryNames[v]];
			  if tracked.reset < time and tracked.diminished ~= 1 and not tracked.refresh then
				  tracked.diminished = 1;
				  tracked.reset = 0;
			  end
			end
		  end
		end
	  end
	  for i=1,#Friends do
		if trackedPlayers[Friends[i]] then
		  for v=1,#drCategoryNames do
			if trackedPlayers[Friends[i]][drCategoryNames[v]] then
			  local tracked = trackedPlayers[Friends[i]][drCategoryNames[v]];
			  if tracked.reset < time and tracked.diminished ~= 1 and not tracked.refresh then
				  tracked.diminished = 1;
				  tracked.reset = 0;
			  end
			end
		  end
		end
	  end
	end

	-- function _clearSpellList()
	--   for i=1,#spellList do
	--     if not spellList[i] == false then
	--       if UnitIsVisible(spellList[i].unit) then
	--         if math.abs(spellList[i].time-GetTime()) > GetSpellBaseCooldown(spellList[i].spell)/1000 then
	--           tremove(spellList,i);
	--         end
	--       end
	--     end
	--   end
	-- end

	function _disorientDR(pointer)
	  if not UnitIsVisible(pointer) then return 0; end
	  local dr=1;
	  if trackedPlayers[pointer] and trackedPlayers[pointer]["disorient"] and trackedPlayers[pointer]["disorient"]["diminished"] then
		dr = trackedPlayers[pointer]["disorient"]["diminished"];
	  end
	  for i=1,#listDisorients do
		if UnitDebuffID(pointer,listDisorients[i]) then
		  return dr/2;
		end
	  end
	  return dr;
	end

	function _incapacitateDR(pointer)
	  if not UnitIsVisible(pointer) then return 0; end
	  local dr=1;
	  if trackedPlayers[pointer] and trackedPlayers[pointer]["incapacitate"] and trackedPlayers[pointer]["incapacitate"]["diminished"] then
		dr = trackedPlayers[pointer]["incapacitate"]["diminished"];
	  end
	  for i=1,#listIncapacitates do
		if UnitDebuffID(pointer,listIncapacitates[i]) then
		  return dr/2;
		end
	  end
	  return dr;
	end

	function _silenceDR(pointer)
	  if not UnitIsVisible(pointer) then return 0; end
	  local dr=1;
	  if trackedPlayers[pointer] and trackedPlayers[pointer]["silence"] and trackedPlayers[pointer]["silence"]["diminished"] then
		dr = trackedPlayers[pointer]["silence"]["diminished"];
	  end
	  for i=1,#listSilences do
		if UnitDebuffID(pointer,listSilences[i]) then
		  return dr/2;
		end
	  end
	  return dr;
	end

	local dots =
	{
	--Death Knight--
	55095, 		-- Frost Fever
	55078, 		-- Blood Plague
	115989,		-- Unholy Blight
	155159,		-- Necrotic Plague
	191587,		-- Virulent Plague
	--Druid--
	33745,		-- Lacerate
	8921,		-- Moonfire
	1079,		-- Rip
	1822,		-- Rake
	93402,		-- Sunfire
	106830,		-- Thrash
	77758,		-- Thrash
	--Hunter--
	13813,		-- Explosive Trap
	118253,		-- Serpent Sting
	3674,		-- Black Arrow
	53301,		-- Explosive Arrow
	--Mage--
	113092,		-- Frost Bomb
	114923,		-- Nether Tempest
	44457,		-- Living Bomb
	2136,		-- Fireblast
	2120,		-- Flamestrike
	11366,		-- Pyroblast
	12846,		-- Ignite
	155158,		-- Meteor Burn
	--Monk--
	128531,		-- Blackout Kick
	123725,		-- Breath of Fire
	--Paladin--
	114917,		-- Execution Sentence
	31801,		-- Censure
	114916,		-- Execution Sentence
	--Priest--
	34914,		-- Vampiric Touch
	2944,		-- Devouring Plague
	14914,		-- Holy Fire
	589,		-- Shadow Word: Pain
	15407,		-- Mind Flay
	204213,		-- Purge the Wicked
	--Rogue--
	122233,		-- Crimson Tempest
	2823,		-- Deadly Poison
	16511,		-- Hemorrhage
	2818,		-- Deadly Poison
	703,		-- Garrote
	1943,		-- Rupture
	--Shaman--
	8050,		-- Flame Shock
	--Warlock--
	27243,		-- Seed of Corruption
	980,		-- Agony
	348,		-- Immolate
	30108,		-- UA
	131736,		-- UA
	172,		-- Corruption
	131740,		-- Corruption
	131737,		-- Agony
	75017,		-- Doom
	64157,		-- Doom
	70144,		-- Doom
	69969,		-- Doom
	63106,		-- Siphon life
	205179,		-- Phantom Singularity
	--Warrior--
	115768,		-- Deep Wounds
	113344,		-- BloodBath
	}
	function _hasDot(unit)
		local hasdebuff,debuff = _debuffFromTable(unit,dots);
		if hasdebuff then return true; end
		--meteor dropping
		if lastMeteor and GetTime()-lastMeteor < 3.5 then
			if lastMeteorSource and UnitIsVisible(lastMeteorSource) then
				if unit_can_attack(lastMeteorSource,unit) then
					return true;
				end
			end
		end
	end

	function DoNotBCC(unit)
		--immune
		if _immunePhysical(unit) then
			return true;
		end
		--cc'd
		if _CCremains(unit) > .2 then
			return true;
		end
		--meteor dropping
		if lastMeteor and GetTime()-lastMeteor < 3.5 then
			if lastMeteorSource and UnitIsVisible(lastMeteorSource) then
				if UnitIsFriend("player",lastMeteorSource) then
					return true;
				end
			end
		end
		--premonition used
		if premonitionUsed and GetTime()-premonitionUsed < 1.5 then
			if premonitionPointer and UnitIsVisible(premonitionPointer) and unit_can_attack("player",premonitionPointer) then
				return true;
			end
		end
		--sac out
		for i=1,#Enemies do
			if UnitBuffID(Enemies[i],6940) or UnitDebuffID(Enemies[i],6940) then
				return true;
			end
		end
	end

	function Squid_SingleTarget()

	end

	function DoNotSheep(unit)
		-- --premonition
		-- if premonitionUsed then
		-- 	local time_since_prem = time - premonitionUsed
		-- 	local time_til_prem_proc = 1.5-time_since_prem
		-- 	if player_cast_time_left < time_til_prem_proc then
		-- 		if premonitionPointer and UnitIsVisible(premonitionPointer) and unit_is_unit(player_cast_target,premonitionPointer) then
		-- 			Squid_Alert_Big("Stopcasting","(Premonition)",4,3,305498)
		-- 			SpellStopCasting()
		-- 		end
		-- 	end
		-- end

		--blessing of sac
		local sac_up
		local sac_source

		--small sac
		for i=1,#Enemies do
			local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],6940)
			if buff then
				sac_up = true
				sac_source = source
			end
		end

		--big sac
		for i=1,#Enemies do
			local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],199448)
			if buff then
				sac_up = true
				sac_source = source
			end
		end

		--casting on the healer
		if sac_up and unit_is_unit(unit,sac_source) then
			return true
		end

		--meteor
		if UnitDebuffID(unit,155158) then
			if PlayerCanBeKicked() then
				--still want to cast + cancel to bait kicks while they sit in meteor
			else
				return true
			end
		end

		--orb
		if _spellCooldown(198149) > 42.5 then
			if UnitDebuffID(unit,289308) then
				return true
			end
			for i=1,#AreaTriggers do
				local id = ObjectID(AreaTriggers[i])
				if id == 12740 and GetDistanceBetweenObjects(AreaTriggers[i],unit) < 6 then
					return true
				end
			end
		end

		--already in other cc
		-- if UnitIsVisible(player_cast_target) then

		-- 	if _CCremains(player_cast_target) > 6 then

		-- 		return true

		-- 	end

		-- end

		--war banner
		if UnitBuffID(unit,236321) then
			return true
		end
	end

	function _rakeStunned(unit)

		local rakes = 0

		local cache = unit_debuff_cache[unit]

		if not cache then
			unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
			cache = unit_debuff_cache[unit]
			for i=1,#cache do
				local name = cache[i][1]
				if name == "Rake" then
					rakes = rakes + 1
				end
			end
		else
			local cache = unit_debuff_cache[unit]
			for i=1,#cache do
				local name = cache[i][1]
				if name == "Rake" then
					rakes = rakes + 1
				end
			end
		end

		if rakes >= 2 then return true end

	end

	function _rakeStunRemains(unit)

		local rakes = 0

		local cache = unit_debuff_cache[unit]
		if not cache then
			unit_debuff_cache[unit] = {get_unit_debuffs(unit)}
			cache = unit_debuff_cache[unit]
			for i=1,#cache do
				local name = cache[i][1]
				if name == "Rake" then
					rakes = rakes + 1
				end
			end
		else
			local cache = unit_debuff_cache[unit]
			for i=1,#cache do
				local name = cache[i][1]
				if name == "Rake" then
					rakes = rakes + 1
				end
			end
		end

		if rakes >= 2 then
			local time = GetTime()
			if cache then
				for i=1,#cache do
					local name,id,end_time = cache[i][1],cache[i][10],cache[i][6]
					if id == 163505 and time - end_time < 4 then
						return end_time - time
					end
				end
			end
		end

		return 0

	end

	--stunremains
	local stuns ={
	-----------------------
	--[[ CONTROL STUNS ]]--
	-----------------------
	-- Death Knight
	108194, -- Asphyxiate (talent)
	91800, -- Gnaw (Ghoul)
	91797, -- Monstrous Blow (Dark Transformation Ghoul)
	-- Druid
	22570, -- Maim
	203123,	-- maim
	5211, -- Mighty Bash (talent)
	113801, -- Bash (treants in feral spec) (Bugged by blizzard - it instantly applies all 3 levels of DR right now, making any target instantly immune to ctrlstuns)
	-- Hunter
	24394, -- Intimidation
	50519, -- Sonic Blast (Bat)
	-- Mage
	44572, -- Deep Freeze
	157997, -- New ice nova
	-- Monk
	119392, -- Charging Ox Wave (talent)
	119381, -- Leg Sweep (talent)
	120086, -- Fists of Fury (Windwalker)
	-- Paladin
	853, -- Hammer of Justice
	119072, -- Holy Wrath (Protection)
	105593, -- Fist of Justice (talent)
	-- Rogue
	1833, -- Cheap Shot
	408, -- Kidney Shot
	199804, -- Between the eyes
	-- Shaman
	118905, -- Static Charge (Capacitor Totem)
	-- Warlock
	30283, -- Shadowfury
	89766, -- Axe Toss (Felguard)
	22703, -- Infernal Awakening (Infernal)
	-- Warrior
	132168, -- Shockwave
	132169,	-- Storm Bolt
	-- Demon Hunter
	179057, -- Chaos Nova
	191427, -- Metamorphosis
	211881, -- Fel Eruption
	-- Priest
	200200,	--Censure Chastise
	-- Tauren
	20549 -- War Stomp
	}

	function _stunRemains(unit)
		if not unit then return 0; end
		local cconunit = {};
		local debuffs = _debuffFromTable(unit,stuns,true);
		local r = _rakeStunRemains(unit)
		if r>0 then
			table.insert(debuffs,r);
		end
		table.sort(debuffs,function(x,y) return x > y end);
		return debuffs[1] or 0;
	end


	function _stunDR(pointer)
	  if not pointer then return 0; end
	  local dr=1;
	  if trackedPlayers[pointer] and trackedPlayers[pointer]["stun"] and trackedPlayers[pointer]["stun"]["diminished"] then
		dr = trackedPlayers[pointer]["stun"]["diminished"]
	  end
	  for i=1,#listStuns do
		if UnitDebuffID(pointer,listStuns[i]) and (listStuns[i] ~= 163505 or _rakeStunned(pointer)) then
		  return dr/2;
		end
	  end
	  return dr;
	end

	function _rootDR(pointer)
	  if not pointer then return 0; end
	  local dr=1;
	  if trackedPlayers[pointer] and trackedPlayers[pointer]["root"] and trackedPlayers[pointer]["root"]["diminished"] then
		dr = trackedPlayers[pointer]["root"]["diminished"];
	  end
	  for i=1,#listRoots do
		if UnitDebuffID(pointer,listRoots[i]) and (listRoots[i] ~= 116706 or select(11,UnitDebuffID(pointer,116706)) ~= 116095) then
		  return dr/2;
		end
	  end
	  return dr;
	end

	function _incapacitateCheck(unit)
		local debuffs = _debuffFromTable(unit,listIncapacitates,true,true)
		if debuffs then
			table.sort(debuffs,function(x,y) return x.r > y.r end)
		end
		if #debuffs > 0 then
			return debuffs[1].id ~= 0 and debuffs[1].id or nil;
		end
	end

	function incapacitate_remains(unit)
		local debuffs = _debuffFromTable(unit,listIncapacitates,true,true)
		table.sort(debuffs,function(x,y) return x.r > y.r end)
		return debuffs[1].r, debuffs[1].id
	end

	function _disorientCheck(unit)
		local debuffs = _debuffFromTable(unit,listDisorients,true,true)
		if debuffs then
			table.sort(debuffs,function(x,y) return x.r > y.r end)
		end
		if #debuffs > 0 then
			return debuffs[1].id ~= 0 and debuffs[1].id or nil;
		end
	end

	function _stunCheck(unit)
		local debuffs = _debuffFromTable(unit,listStuns,true,true)
		if debuffs then
			table.sort(debuffs,function(x,y) return x.r > y.r end)
		end
		if #debuffs > 0 then
			return debuffs[1].id ~= 0 and debuffs[1].id or nil;
		end
	end

	function _silenceCheck(unit)
		local debuffs = _debuffFromTable(unit,listSilences,true,true)
		if debuffs then
			table.sort(debuffs,function(x,y) return x.r > y.r end)
		end
		if #debuffs > 0 then
			return debuffs[1].id ~= 0 and debuffs[1].id or nil;
		end
	end

	function _drRemains(pointer,drType)
		if not pointer then return 0; end
		local remaining = 0;
		if trackedPlayers[pointer] and trackedPlayers[pointer][drType] and trackedPlayers[pointer][drType].reset then
			if trackedPlayers[pointer][drType].reset >= GetTime() then
				remaining = trackedPlayers[pointer][drType].reset - GetTime();
			end
		end
		if remaining == 0 or remaining > 12 then
			if drType == "incapacitate" and _incapacitateCheck(pointer) then
				remaining = drReset
			end
			if drType == "disorient" and _disorientCheck(pointer) then
				remaining = drReset
			end
			if drType == "stun" and _stunCheck(pointer) then
				remaining = drReset
			end
			if drType == "silence" and _silenceCheck(pointer) then
				remaining = drReset
			end
		end
		return remaining;
	end

	function GetCurrentSnapshot(spell)

		local power = 1

		--tiger's fury
		power = power + (UnitBuffID("player",5217) and .15 or 0)
		--bloodtalons
		power = power + (UnitBuffID("player",145152) and .25 or 0)
		--prowl
		power = power + ((spell == 1822 and (was_stealth or UnitBuffID("player",102543)) and .6) or 0)
		--subterfuge / stealth (with shrouded suffocation)
		power = power + ((AzeritePowerTaken(408) and (was_stealth or UnitBuffID("player",115192))) and 1 or 0)

		return power

	end

	unit_creature_id_cache = {}

	function UnitCreatureID (UnitID)

		--caches creature ids
		if unit_creature_id_cache[UnitID] then return unit_creature_id_cache[UnitID] end

		local Parts = {};
		if not UnitGUID(UnitID) then return nil; end
		for Part in string.gmatch(UnitGUID(UnitID), "([^-]+)") do
			table.insert(Parts, Part);
		end
		if Parts[1] == "Creature" then
			local id = tonumber(Parts[6]);
			unit_creature_id_cache[UnitID] = id
			return id
		elseif Parts[1] == "Vehicle" then
			local id = tonumber(Parts[6]);
			unit_creature_id_cache[UnitID] = id
			return id
		elseif Parts[1] == "Pet" then
			local id = tonumber(Parts[6]);
			unit_creature_id_cache[UnitID] = id
			return id
		else
			return nil;
		end
	end

	function UnitHasDefensive(unit)
		--mage
		--warrior
		--rogue
		--druid
		--monk
		--pally
		--priest
		--shaman
		--warlock
		--hunter
		--dh
	end

	is_dummy_cache = {}

	local dummies = {
	-- Misc/Unknown
		[79987]  = "Training Dummy", 	          -- Location Unknown
		[92169]  = "Raider's Training Dummy",     -- Tanking (Eastern Plaguelands)
		[96442]  = "Training Dummy", 			  -- Damage (Location Unknown)
		[109595] = "Training Dummy",              -- Location Unknown
		[113963] = "Raider's Training Dummy", 	  -- Damage (Location Unknown)
		[131985] = "Dungeoneer's Training Dummy", -- Damage (Zuldazar)
		[131990] = "Raider's Training Dummy",     -- Tanking (Zuldazar)
		[132976] = "Training Dummy", 			  -- Morale Booster (Zuldazar)
	-- Level 1
		[17578]  = "Hellfire Training Dummy",     -- Lvl 1 (The Shattered Halls)
		[60197]  = "Training Dummy",              -- Lvl 1 (Scarlet Monastery)
		[64446]  = "Training Dummy",              -- Lvl 1 (Scarlet Monastery)
		[144077] = "Training Dummy",              -- Lvl 1 (Dazar'alor) - Morale Booster
	-- Level 3
		[44171]  = "Training Dummy",              -- Lvl 3 (New Tinkertown, Dun Morogh)
		[44389]  = "Training Dummy",              -- Lvl 3 (Coldridge Valley)
		[44848]  = "Training Dummy", 			  -- Lvl 3 (Camp Narache, Mulgore)
		[44548]  = "Training Dummy",              -- Lvl 3 (Elwynn Forest)
		[44614]  = "Training Dummy",              -- Lvl 3 (Teldrassil, Shadowglen)
		[44703]  = "Training Dummy", 			  -- Lvl 3 (Ammen Vale)
		[44794]  = "Training Dummy", 			  -- Lvl 3 (Dethknell, Tirisfal Glades)
		[44820]  = "Training Dummy",              -- Lvl 3 (Valley of Trials, Durotar)
		[44937]  = "Training Dummy",              -- Lvl 3 (Eversong Woods, Sunstrider Isle)
		[48304]  = "Training Dummy",              -- Lvl 3 (Kezan)
	-- Level 55
		[32541]  = "Initiate's Training Dummy",   -- Lvl 55 (Plaguelands: The Scarlet Enclave)
		[32545]  = "Initiate's Training Dummy",   -- Lvl 55 (Eastern Plaguelands)
	-- Level 60
		[32666]  = "Training Dummy",              -- Lvl 60 (Siege of Orgrimmar, Darnassus, Ironforge, ...)
	-- Level 65
		[32542]  = "Disciple's Training Dummy",   -- Lvl 65 (Eastern Plaguelands)
	-- Level 70
		[32667]  = "Training Dummy",              -- Lvl 70 (Orgrimmar, Darnassus, Silvermoon City, ...)
	-- Level 75
		[32543]  = "Veteran's Training Dummy",    -- Lvl 75 (Eastern Plaguelands)
	-- Level 80
		[31144]  = "Training Dummy",              -- Lvl 80 (Orgrimmar, Darnassus, Ironforge, ...)
		[32546]  = "Ebon Knight's Training Dummy",-- Lvl 80 (Eastern Plaguelands)
	-- Level 85
		[46647]  = "Training Dummy",              -- Lvl 85 (Orgrimmar, Stormwind City)
	-- Level 90
		[67127]  = "Training Dummy",              -- Lvl 90 (Vale of Eternal Blossoms)
	-- Level 95
		[79414]  = "Training Dummy",              -- Lvl 95 (Broken Shore, Talador)
	-- Level 100
		[87317]  = "Training Dummy",              -- Lvl 100 (Lunarfall, Frostwall) - Damage
		[87321]  = "Training Dummy",              -- Lvl 100 (Stormshield) - Healing
		[87760]  = "Training Dummy",              -- Lvl 100 (Frostwall) - Damage
		[88289]  = "Training Dummy",              -- Lvl 100 (Frostwall) - Healing
		[88316]  = "Training Dummy",              -- Lvl 100 (Lunarfall) - Healing
		[88835]  = "Training Dummy",              -- Lvl 100 (Warspear) - Healing
		[88906]  = "Combat Dummy",                -- Lvl 100 (Nagrand)
		[88967]  = "Training Dummy",              -- Lvl 100 (Lunarfall, Frostwall)
		[89078]  = "Training Dummy",              -- Lvl 100 (Frostwall, Lunarfall)
	-- Levl 100 - 110
		[92164]  = "Training Dummy", 			  -- Lvl 100 - 110 (Dalaran) - Damage
		[92165]  = "Dungeoneer's Training Dummy", -- Lvl 100 - 110 (Eastern Plaguelands) - Damage
		[92167]  = "Training Dummy",              -- Lvl 100 - 110 (The Maelstrom, Eastern Plaguelands, The Wandering Isle)
		[92168]  = "Dungeoneer's Training Dummy", -- Lvl 100 - 110 (The Wandering Isles, Easter Plaguelands)
		[100440] = "Training Bag", 				  -- Lvl 100 - 110 (The Wandering Isles)
		[100441] = "Dungeoneer's Training Bag",   -- Lvl 100 - 110 (The Wandering Isles)
		[102045] = "Rebellious Wrathguard",       -- Lvl 100 - 110 (Dreadscar Rift) - Dungeoneer
		[102048] = "Rebellious Felguard",         -- Lvl 100 - 110 (Dreadscar Rift)
		[102052] = "Rebellious Imp", 			  -- Lvl 100 - 110 (Dreadscar Rift) - AoE
		[103402] = "Lesser Bulwark Construct",    -- Lvl 100 - 110 (Hall of the Guardian)
		[103404] = "Bulwark Construct",           -- Lvl 100 - 110 (Hall of the Guardian) - Dungeoneer
		[107483] = "Lesser Sparring Partner",     -- Lvl 100 - 110 (Skyhold)
		[107555] = "Bound Void Wraith",           -- Lvl 100 - 110 (Netherlight Temple)
		[107557] = "Training Dummy",              -- Lvl 100 - 110 (Netherlight Temple) - Healing
		[108420] = "Training Dummy",              -- Lvl 100 - 110 (Stormwind City, Durotar)
		[111824] = "Training Dummy", 			  -- Lvl 100 - 110 (Azsuna)
		[113674] = "Imprisoned Centurion",        -- Lvl 100 - 110 (Mardum, the Shattered Abyss) - Dungeoneer
		[113676] = "Imprisoned Weaver", 	      -- Lvl 100 - 110 (Mardum, the Shattered Abyss)
		[113687] = "Imprisoned Imp",              -- Lvl 100 - 110 (Mardum, the Shattered Abyss) - Swarm
		[113858] = "Training Dummy",              -- Lvl 100 - 110 (Trueshot Lodge) - Damage
		[113859] = "Dungeoneer's Training Dummy", -- Lvl 100 - 110 (Trueshot Lodge) - Damage
		[113862] = "Training Dummy",              -- Lvl 100 - 110 (Trueshot Lodge) - Damage
		[113863] = "Dungeoneer's Training Dummy", -- Lvl 100 - 110 (Trueshot Lodge) - Damage
		[113871] = "Bombardier's Training Dummy", -- Lvl 100 - 110 (Trueshot Lodge) - Damage
		[113966] = "Dungeoneer's Training Dummy", -- Lvl 100 - 110 - Damage
		[113967] = "Training Dummy",              -- Lvl 100 - 110 (The Dreamgrove) - Healing
		[114832] = "PvP Training Dummy",          -- Lvl 100 - 110 (Stormwind City)
		[114840] = "PvP Training Dummy",          -- Lvl 100 - 110 (Orgrimmar)
	-- Level 102
		[87318]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Lunarfall) - Damage
		[87322]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Stormshield) - Tank
		[87761]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Frostwall) - Damage
		[88288]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Frostwall) - Tank
		[88314]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Lunarfall) - Tank
		[88836]  = "Dungeoneer's Training Dummy", -- Lvl 102 (Warspear) - Tank
		[93828]  = "Training Dummy",              -- Lvl 102 (Hellfire Citadel)
		[97668]  = "Boxer's Trianing Dummy",      -- Lvl 102 (Highmountain)
		[98581]  = "Prepfoot Training Dummy",     -- Lvl 102 (Highmountain)
	-- Level 110 - 120
		[126781] = "Training Dummy", 			  -- Lvl 110 - 120 (Boralus) - Damage
		[131989] = "Training Dummy", 			  -- Lvl 110 - 120 (Boralus) - Damage
		[131994] = "Training Dummy", 			  -- Lvl 110 - 120 (Boralus) - Healing
		[144082] = "Training Dummy",              -- Lvl 110 - 120 (Dazar'alor) - PVP Damage
		[144085] = "Training Dummy", 			  -- Lvl 110 - 120 (Dazar'alor) - Damage
		[144081] = "Training Dummy",              -- Lvl 110 - 120 (Dazar'alor) - Damage
		[153285] = "Training Dummy", 			  -- Lvl 110 - 120 (Ogrimmar) - Damage
		[153292] = "Training Dummy", 			  -- Lvl 110 - 120 (Stormwind) - Damage
	-- Level 111 - 120
		[131997] = "Training Dummy", 			  -- Lvl 111 - 120 (Boralus, Zuldazar) - PVP Damage
		[131998] = "Training Dummy",              -- Lvl 111 - 120 (Boralus, Zuldazar) - PVP Healing
	-- Level 112 - 120
		[144074] = "Training Dummy", 			  -- Lvl 112 - 120 (Dazar'alor) - PVP Healing
	-- Level 112 - 122
		[131992] = "Dungeoneer's Training Dummy",  -- Lvl 112 - 122 (Boralus) - Tanking
	-- Level 113 - 120
		[132036] = "Training Dummy", 			  -- Lvl 113 - 120 (Boralus) - Healing
	-- Level 113 - 122
		[144078] = "Dungeoneer's Training Dummy", -- Lvl 113 - 122 (Dazar'alor) - Tanking
	-- Level 114 - 120
		[144075] = "Training Dummy", 			  -- Lvl 114 - 120 (Dazar'alor) - Healing
	-- Level ??
		[24792]  = "Advanced Training Dummy",     -- Lvl ?? Boss (Location Unknown)
		[30527]  = "Training Dummy", 		      -- Lvl ?? Boss (Location Unknown)
		[31146]  = "Raider's Training Dummy",     -- Lvl ?? (Orgrimmar, Stormwind City, Ironforge, ...)
		[87320]  = "Raider's Training Dummy",     -- Lvl ?? (Lunarfall, Stormshield) - Damage
		[87329]  = "Raider's Training Dummy",     -- Lvl ?? (Stormshield) - Tank
		[87762]  = "Raider's Training Dummy",     -- Lvl ?? (Frostwall, Warspear) - Damage
		[88837]  = "Raider's Training Dummy",     -- Lvl ?? (Warspear) - Tank
		[92166]  = "Raider's Training Dummy",     -- Lvl ?? (The Maelstrom, Dalaran, Eastern Plaguelands, ...) - Damage
		[101956] = "Rebellious Fel Lord",         -- lvl ?? (Dreadscar Rift) - Raider
		[103397] = "Greater Bulwark Construct",   -- Lvl ?? (Hall of the Guardian) - Raider
		[107202] = "Reanimated Monstrosity", 	  -- Lvl ?? (Broken Shore) - Raider
		[107484] = "Greater Sparring Partner",    -- Lvl ?? (Skyhold)
		[107556] = "Bound Void Walker",           -- Lvl ?? (Netherlight Temple) - Raider
		[113636] = "Imprisoned Forgefiend",       -- Lvl ?? (Mardum, the Shattered Abyss) - Raider
		[113860] = "Raider's Training Dummy",     -- Lvl ?? (Trueshot Lodge) - Damage
		[113864] = "Raider's Training Dummy",     -- Lvl ?? (Trueshot Lodge) - Damage
		[70245]  = "Training Dummy",              -- Lvl ?? (Throne of Thunder)
		[113964] = "Raider's Training Dummy",     -- Lvl ?? (The Dreamgrove) - Tanking
		[131983] = "Raider's Training Dummy",     -- Lvl ?? (Boralus) - Damage
		[144086] = "Raider's Training Dummy",     -- Lvl ?? (Dazal'alor) - Damage
		[164589] = "Flower Thing", 				  -- Flower thing after guy die
		[174569] = "Training Dummy",
		[174570] = "Swarm Training Dummy",
		[174571] = "Cleave Training Dummy",
		[174568] = "Dungeoneer's Training Dummy",
		[174567] = "Raider's Training Dummy",
		[174566] = "Dungeoneer's Tanking Dummy",
		[174565] = "Raider's Tanking Dummy",
		[175450] = "Raider's Training Dummy",

	}

	function _isDummy(unit)

		if not unit then return false end

		local cache = is_dummy_cache[unit]
		if cache ~= nil then return cache end

		local id = ObjectID(unit)

		if dummies[id] then
			is_dummy_cache[unit] = true
			return true
		else
			is_dummy_cache[unit] = false
			return false
		end

	end

	local combat_whitelist = {
		[98081] = "Bellowing Idol", -- Neltharian's Lair
		[100818] = "Bellowing Idol",
		[133492] = "Corruption Corpuscle",
		[135016] = "Plague Amalgam",
		[131009] = "Spirit of Gold", --Atal
		[125828] = "Soulspawn", --Atal
		[127315] = "Reanimation Totem", -- Atal
		[134691] = "Static Charged Dervish", --Temple
		[147218] = "Spirit of Gold", --Opulence
		[148436] = "Barrier", --Jadefire Masters
		[148415] = "Barrier", --Jadefire Masters
		[147377] = "Barrier", --Jadefire Masters
		[147376] = "Barrier", --Jadefire Masters
		[147374] = "Barrier", --Jadefire Masters
		[147375] = "Barrier", --Jadefire Masters
		[146756] = "Energized Storm", --Jadefire Masters
		[146107] = "Living Bomb", -- Jadefire Masters
		[148522] = "Ice Block", --Jaina
		[148907] = "Prismatic Image", --Jaina
		[148716] = "Risen Soul", --M+ Reaping
		[148893] = "Tormented Soul", --M+ Reaping
		[148894] = "Lost Soul", --M+ Reaping
		[120651] = "Explosive", -- Explosive
		[137051] = "Ancient Mindbender", -- Shrine of Storms - Lord Stormsong
		[136330] = "Soul Thorns", -- Soul Thorns Waycrest Manor
		[133361] = "Wasting Servant", -- Waycrest Manor
		[134388] = "A Knot of Snakes", -- A Knot of Snakes ToS
		[153064] = "Overzealous Hulk", -- Overzealous Hulk
		[154240] = "Azshara's Devoted", -- Azshara's Devoted
		[155354] = "Azshara's Indomitable", -- Azshara's Indomitable
		[153194] = "Briny Bubble", -- Lady Ashvane Fight
		[150773] = "Shimmerskin Pufferfish", -- Shimmerskin Pufferfish
		[154174] = "Horrific Summoner", -- Za'qul
		[154175] = "Horrific Summoner", -- Za'qul
		[151581] = "Horrific Vision", -- Za'qul
		[151900] = "Horrific Summoner", -- Za'qul
		[155278] = "Shimmerskin Pufferfish", --EP Trash
		[158327] = "Crackling Shard", --Ny'alotha - Wrathion
		[158781] = "Shredded Psyche", -- Ny'alotha - Skitra
		[158343] = "Organ of Corruption", -- Ny'alotha - Il'gynoth
		[157612] = "Eye of Drest'agath", -- Ny'alotha - Drest'agath
		[157613] = "Maw of Drest'agath", -- Ny'alotha - Drest'agath
		[157461] = "Mycelial Cyst", -- Ny'alotha - Carapace
		[157475] = "Synthesis Growth", -- Ny'alotha - Carapace
		[158376] = "Psychus", -- Ny'alotha - N'zoth
		[158122] = "Mind's Eye", -- Ny'alotha - N'zoth
		[159578] = "Exposed Synapse", -- Ny'alotha - N'zoth
		[162331] = "Corrupted Neuron", -- Ny'alotha - N'zoth
		[158367] = "Basher Tentacle", -- Ny'alotha - N'zoth
		[158375] = "Corrupter Tentacle", -- Ny'alotha - N'zoth
		[157486] = "Horrific Hemorrhage", -- Ny'alotha - N'zoth
		[160249] = "Spike Tentacle", -- Ny'alotha - N'zoth
		[162933] = "Thought Harvester", -- Ny'alotha - N'zoth
		[161408] = "Malicious Growth", -- M+ S4 Affix
		[166608] = "Mueh'Zala", -- Mueh'Zala (De'Other Side)
		[168326] = "Shattered Visage", -- Shattered Visage (De'Other Side)
	}

	local no_touch_units = {
		-- Jade Temple
		{unitID = 56448, buff = 106062}, -- Wise Mari with Bubble
		--Shadopan Monastery
		{unitID = 56747, buff = 110945}, -- Gu Cloudstrike with Charging Soul
		-- Iron Docks
		{unitID = 87451, buff = 164504, spell = 164426}, --Fleshrender Nok'gar, do not attack during defensive stance buff, Todo: Should stop when he cast 164504
		{unitID = 1, buff = 163689}, -- Never attack Sanguine Sphere
		{unitID = 105906, buff = 209915}, -- Don't attack The Eye of Il'gynoth when it has Stuff of Nightmares buff
		{unitID = 95887, buff = 194323}, -- Don't attack Glazer when he casts Focusing
		{unitID = 95888, buff = 205004}, -- Don't attack Cordana Felsong when she casts Vengeance
		{unitID = 95888, buff = 197422}, -- Don't attack Cordana Felsong when she casts Creeping Doom
		{unitID = 112956, buff = 225840}, -- Don't attack Shimmering Manaspine
		{unitID = 104154, buff = 206516}, -- Don't attack Gul'dan when he is in The Eye of Aman'Thul cage
		-- Nighthold: Mythic Spellblade - Fel Soul
		{unitID = 115905},
		-- Tomb of Sargeras
		{unitID = 116689, buff = 233441}, -- Don't attack Atrigan while Bonesaw
		{unitID = 116691, buff = 235230}, -- Don't attack Belac while Fel Squall
		{unitID = 117264, buff = -241008}, -- Don't attack Maiden of Valor unless Buff is Present *** negative buff value denotes not present ***
		-- BfA
		-- Uldir
		{unitID = 137119, buff = 271965}, -- Don't attack Taloc while Powered Down
		{unitID = 131227, buff = 260189}, -- Motherlode last boss flight
		{unitID = 136383, buff = 274230}, -- Mythrax immunity
		-- Battle of Dazar'alor
		{unitID = 144683, buff = 284436}, -- Champion of the Light (A), Ra'wani Kanae, Seal of Reckoning
		{unitID = 144680, buff = 284436}, -- Champion of the Light (H), Frida Ironbellows, Seal of Reckoning
		{unitID = 144942, buff = 289644}, -- Spark Bot,High Tinker Mekkatorque, Mythic
		{unitID = 145644, buff = 284377}, -- Bwonsamdi with Unliving buff
		-- Freehold
		{unitID = 129448}, -- Shark Boss Shark
		{unitID = 129359}, -- Shark Boss Shark
		-- The Motherlode!
		{unitID = 129232, buff = 260189}, -- Mogul Razdunk with Configuration: Drill buff
		-- Underrot
		{unitID = 137458}, -- Rotting Spore
		-- Siege of Boralus
		{unitID = 128652}, -- Viq'Goth
		-- Atal'Dazar
		{unitID = 129399 , buff =250192}, -- Vol'kaal with Bad Voodoo buff
		-- Temple of Sethraliss
		{unitID = 133379, buff = 263246}, -- Adderis with Lightning Shield
		{unitID = 133944, buff = 263246}, -- Aspix with Lightning Shield
		-- Mechagon
		{unitID = 152703}, -- Walkie Shockie X1
		{buff = 296571}, -- Power Shield 99 % Dmg reduc
		-- Eternal Palace
		{unitID = 152364, buff = 295916}, -- Radiance of Azshara
		{unitID = 155434, buff = 302415}, -- Emissary of Tides Teleporting Home
		{unitID = 155432, buff = 302415}, -- Enchanted Emissary Teleporting Home
		{unitID = 155433, buff = 302415}, -- Void Touched Emissary Teleporting Home
		-- Mythic Za'qul
		{unitID = 150859, buff = 301117}, -- Dark Shield
		-- Eternal Palace
		{unitID = 155126, buff = 300620}, -- Crystalline Shield
		-- Ny'Alotha
		{unitID = 158041, buff = 310126}, -- N'Zoth 99% Shit
		-- Horrific Visions
		{unitID = 158315}, -- Eye of Chaos
		-- Waycrest Manor
		{buff = 261265},   -- Witch Sisters Ironbark Shield 99% Dmg Reduc
		{buff = 261264},   -- Witch Sisters 99 % dmg red
		{buff = 261266},   -- Witch Sisters 99 % dmg red
		--Thing from Beyond
		{unitID = 161895},
	}

	local combat_whitelist_buffs = {
		292982,	-- https://www.wowhead.com/spell=292982/disciple-of-nzoth (SotS Mind Control)
		292981,	-- SotS Mind Control Secondary ID
	}

	function valid_attackable(unit)

		if not unit then return false end

		local solo_mode = SQUID.solo_mode_enabled

		--combat whitelist buffs
		if _debuffFromTable(unit,combat_whitelist_buffs) or _buffFromTable(unit,combat_whitelist_buffs) then return true end

		--object id
		local id = ObjectID(unit)

		--combat whitelist object ids
		if combat_whitelist[id] then return true end

		--no touch units
		local no_touch
		for i=1,#no_touch_units do
			local notouch = no_touch_units[i]
			if notouch.unitID == id or notouch.unitID == nil then
				local buff = notouch.buff
				if buff == nil then
					no_touch = true
				else
					if UnitBuffID(unit,buff) then
						no_touch = true
					end
				end
			end
		end

		if no_touch then return false end

		--check combat / dummy
		if UnitAffectingCombat(unit) or ( _isDummy(unit) and UnitAffectingCombat("player") ) or ( solo_mode and unit_is_unit(unit,current_target) and (squid_ttd(unit) < 25 or Squid_Alert_Big("Please manually engage combat")) ) then

			return true

		end

	end

	function IsLocked(unit,remaining)
		if not remaining then
			for i=1,#kickTable do if unit_is_unit(kickTable[i].unit,unit) and not kickTable[i].juked then return true; end end
			return false;
		else
			for i=1,#kickTable do if unit_is_unit(kickTable[i].unit,unit) and not kickTable[i].juked then return kickTable[i].time - GetTime(); end end
			return 0;
		end
	end

	function UnitIsLocked(unit)
		local remaining = 0
		local locked
		local school
		for i=1,#kickTable do
			if unit_is_unit(kickTable[i].unit,unit) and not kickTable[i].juked then
				remaining = kickTable[i].time - GetTime();
				locked = true
				school = kickTable[i].school
			end
		end
		return locked,remaining,school
	end

	-- function UnitLockoutRegistered(unit)
	-- 	local time=GetTime()
	-- 	if #kickTable == 0 then
	-- 		return false;
	-- 	else
	-- 		for i=1,#kickTable do
	-- 			if kickTable[i].unit == unit and (kickTable[i].time == time +
	-- end

	function SpellRecentlyUsed(spell,window)
		local time=GetTime()
		for i=1,#PlayerSpellCasts do
			if time - PlayerSpellCasts[i].time <= window then
				if PlayerSpellCasts[i].name == spell or PlayerSpellCasts[i].id == spell then
					return true
				end
			end
		end
	end

	function recently_trinketed(unit, window)
		local time=GetTime()
		for i=1,#TrinketTracker do
			if time - TrinketTracker[i].time <= window then
				if unit_is_unit(unit,TrinketTracker[i].pointer) then
					return true
				end
			end
		end
	end

	function do_not_sap(unit)

		if unit_has_dot(unit) then return true end

		-- blessing of sac
		local sac_up
		local sac_source
		-- small sac
		for i=1,#Enemies do
			local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],6940)
			if buff then
				sac_up = 6940
				sac_source = source
			end
		end
		-- big sac
		for i=1,#Enemies do
			local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],199448)
			if buff then
				sac_up = 199448
				sac_source = source
			end
		end
		-- casting on the sac source
		if sac_up and unit_is_unit(unit,sac_source) then
			return sac_up
		end

		local aoe_debuffs = {
			155158, -- meteor burn
			289308,	-- orb
		}
		local aoe_debuff
		for i=1,#aoe_debuffs do
			if UnitDebuffID(unit,aoe_debuffs[i]) then
				aoe_debuff = aoe_debuffs[i]
				break
			end
		end

		-- aoe debuffs
		if aoe_debuff then
			return aoe_debuff
		end

		--war banner
		if UnitBuffID(unit,236321) then
			return 236321
		end

	end

	function do_not_blind(unit)

		-- blessing of sac
		local sac_up
		local sac_source
		-- small sac
		for i=1,#Enemies do
			local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],6940)
			if buff then
				sac_up = 6940
				sac_source = source
			end
		end
		-- big sac
		for i=1,#Enemies do
			local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],199448)
			if buff then
				sac_up = 199448
				sac_source = source
			end
		end
		-- casting on the sac source
		if sac_up and unit_is_unit(unit,sac_source) then
			return sac_up
		end

		local aoe_debuffs = {
			155158, -- meteor burn
			289308,	-- orb
		}
		local aoe_debuff
		for i=1,#aoe_debuffs do
			if UnitDebuffID(unit,aoe_debuffs[i]) then
				aoe_debuff = aoe_debuffs[i]
				break
			end
		end

		--war banner
		if UnitBuffID(unit,236321) then
			return 236321
		end

	end

	function Prev_GCD(count)
		if not count then count = 1 end
		local gcd_casts = { }
		for i=1,#PlayerSpellCasts do
			local cast = PlayerSpellCasts[i]
			if cast then
				local id = cast.id
				if IsSpellOnGCD(id) then
					table.insert(gcd_casts,id)
				end
			end
		end
		return gcd_casts[count]
	end

	function GetItemCD(itemID)
		if IsEquippedItem(itemID) then
			local start, duration = GetItemCooldown(itemID)
			if start and duration then
				if start == 0 and duration == 0 then return 0 end
				return duration - ( GetTime() - start )
			end
		end
		return math.huge
	end

	sq_cooldowns = {

		defensives = {

		},

		disruptive = {

		},

		cc = {

		},

		-- Death Knight
		[47528] = { default = true, duration = 15, class = "DEATHKNIGHT" }, -- Mind Freeze
		[48265] = { duration = 45, class = "DEATHKNIGHT" }, -- Death's Advance
		[48707] = { duration = 60, class = "DEATHKNIGHT" }, -- Anti-Magic Shell
		[49576] = { duration = 25, class = "DEATHKNIGHT", charges = 2 }, -- Death Grip
		[51052] = { duration = 120, class = "DEATHKNIGHT" }, -- Anti-Magic Zone
		[61999] = { duration = 600, class = "DEATHKNIGHT" }, -- Raise Ally
		[77606] = { duration = 20, class = "DEATHKNIGHT" }, -- Dark Simulacrum
		[212552] = { duration = 60, class = "DEATHKNIGHT" }, -- Wraith Walk

			-- Blood
			[43265] = { duration = 30, class = "DEATHKNIGHT", specID = { 250, 252 } }, -- Death and Decay
			[47476] = { duration = 60, class = "DEATHKNIGHT", specID = { 250 } }, -- Strangulate
			[49028] = { duration = 120, class = "DEATHKNIGHT", specID = { 250 } }, -- Dancing Rune Weapon
			[55233] = { duration = 90, class = "DEATHKNIGHT", specID = { 250 } }, -- Vampiric Blood
			[108199] = { duration = 120, class = "DEATHKNIGHT", specID = { 250 } }, -- Gorefiend's Grasp
			[194679] = { duration = 25, class = "DEATHKNIGHT", specID = { 250 }, charges = 2 }, -- Rune Tap
			[194844] = { duration = 60, class = "DEATHKNIGHT", specID = { 250 } }, -- Bonestorm
			[203173] = { duration = 15, class = "DEATHKNIGHT", specID = { 250 } }, -- Death Chain
			[205223] = { duration = 45, class = "DEATHKNIGHT", specID = { 250 } }, -- Consumption
			[206931] = { duration = 30, class = "DEATHKNIGHT", specID = { 250 } }, -- Blooddrinker
			[206977] = { duration = 120, class = "DEATHKNIGHT", specID = { 250 } }, -- Blood Mirror
			[219809] = { duration = 60, class = "DEATHKNIGHT", specID = { 250 } }, -- Tombstone
			[221562] = { duration = 45, class = "DEATHKNIGHT", specID = { 250, 252 } }, -- Asphyxiate (Blood)
				[108194] = { parent = 221562 }, -- Asphyxiate (Unholy)
			[221699] = { duration = 60, class = "DEATHKNIGHT", specID = { 250 }, charges = 2 }, -- Blood Tap

			-- Frost
			[47568] = { duration = 120, class = "DEATHKNIGHT", specID = { 251 }, charges = 2 }, -- Empower Rune Weapon
				[207127] = { parent = 47568 }, -- Hungering Rune Weapon
			[48792] = { duration = 180, class = "DEATHKNIGHT", specID = { 251, 252 } }, -- Icebound Fortitude
			[51271] = { duration = 45, class = "DEATHKNIGHT", specID = { 251 } }, -- Pillar of Frost
			[152279] = { duration = 120, class = "DEATHKNIGHT", specID = { 251} }, -- Breath of Sindragosa
			[196770] = { duration = 20, class = "DEATHKNIGHT", specID = { 251 } }, -- Remorseless Winter
			[204143] = { duration = 45, class = "DEATHKNIGHT", specID = { 251 } }, -- Killing Machine
			[204160] = { duration = 45, class = "DEATHKNIGHT", specID = { 251 } }, -- Chill Streak
			[207167] = { duration = 60, class = "DEATHKNIGHT", specID = { 251} }, -- Blinding Sleet
			[207256] = { duration = 90, class = "DEATHKNIGHT", specID = { 251} }, -- Obliteration
			[279302] = { duration = 180, class = "DEATHKNIGHT", specID = { 251} }, -- Frostwyrm's Fury

			-- Unholy
			[42650] = { duration = 480, class = "DEATHKNIGHT", specID = { 252 } }, -- Army of the Dead
			[63560] = { duration = 60, class = "DEATHKNIGHT", specID = { 252 } }, -- Dark Transformation
			[43265] = { duration = 30, class = "DEATHKNIGHT", specID = { 252 } }, -- Death and Decay
				[152280] = { parent = 43265 }, -- Defile
			[47481] = { duration = 90, class = "DEATHKNIGHT", specID = { 252 } }, -- Gnaw (Ghoul)
			[47482] = { duration = 30, class = "DEATHKNIGHT", specID = { 252 } }, -- Leap (Ghoul)
			[49206] = { duration = 180, class = "DEATHKNIGHT", specID = { 252 } }, -- Summon Gargoyle
				[207349] = { parent = 49206 }, -- Dark Arbiter
			[91802] = { duration = 30, class = "DEATHKNIGHT", specID = { 252 } }, -- Shambling Rush (Ghoul)
			[207289] = { duration = 120, class = "DEATHKNIGHT", specID = { 252 } }, -- Unholy Frenzy
			[207319] = { duration = 60, class = "DEATHKNIGHT", specID = { 252 } }, -- Corpse Shield
			[220143] = { duration = 90, class = "DEATHKNIGHT", specID = { 252 } }, -- Apocalypse

		-- Demon Hunter
		[179057] = { duration = 60, class = "DEMONHUNTER" }, -- Chaos Nova
		[183752] = { default = true, duration = 15, class = "DEMONHUNTER" }, -- Disrupt
		[188499] = { duration = 9, class = "DEMONHUNTER" }, -- Blade Dance
		[188501] = { duration = 30, class = "DEMONHUNTER" }, -- Spectral Sight
		[191427] = { duration = 105, class = "DEMONHUNTER" }, -- Metamorphosis
			[187827] = { parent = 191427, duration = 180 }, -- Metamorphosis (Vengeance)
			[162264] = { parent = 191427 }, -- Metamorphosis
		[196718] = { duration = 180, class = "DEMONHUNTER" }, -- Darkness
		[198013] = { duration = 30, class = "DEMONHUNTER" }, -- Eye Beam
		[198793] = { duration = 25, class = "DEMONHUNTER" }, -- Vengeful Retreat
		[203704] = { duration = 60, class = "DEMONHUNTER" }, -- Mana Break
		[205604] = { duration = 60, class = "DEMONHUNTER" }, -- Reverse Magic
		[206649] = { duration = 45, class = "DEMONHUNTER" }, -- Eye of Leotheras
		[206803] = { duration = 60, class = "DEMONHUNTER" }, -- Rain from Above
		[212800] = { duration = 60, class = "DEMONHUNTER" }, -- Blur
			[196555] = { parent = 212800, duration = 90 }, -- Netherwalk
		[214743] = { duration = 60, class = "DEMONHUNTER" }, -- Soul Carver
			[207407] = { parent = 214743 }, -- Soul Carver (Vengeance)
		[221527] = { duration = 45, class = "DEMONHUNTER" }, -- Imprison

			-- Havoc
			[201467] = { duration = 60, class = "DEMONHUNTER", specID = { 577 } }, -- Fury of the Illidari
			[206491] = { duration = 120, class = "DEMONHUNTER", specID = { 577 } }, -- Nemesis
			--[211048] = { duration = 120, class = "DEMONHUNTER", specID = { 577 } }, -- Chaos Blades
			[211881] = { duration = 30, class = "DEMONHUNTER", specID = { 577, 581 } }, -- Fel Eruption

			-- Vengeance
			[202137] = { duration = 60, class = "DEMONHUNTER", specID = { 581 } }, -- Sigil of Silence
			[202138] = { duration = 120, class = "DEMONHUNTER", specID = { 581 } }, -- Sigil of Chains
			[204021] = { duration = 60, class = "DEMONHUNTER", specID = { 581 } }, -- Fiery Brand
			[204596] = { duration = 30, class = "DEMONHUNTER", specID = { 581 } }, -- Sigil of Flame
			[205629] = { duration = 30,  class = "DEMONHUNTER", specID = { 581 } }, -- Demonic Trample
			[205630] = { duration = 90, class = "DEMONHUNTER", specID = { 581 } }, -- Illidan's Grasp
			[207684] = { duration = 90, class = "DEMONHUNTER", specID = { 581 } }, -- Sigil of Misery
			[207810] = { duration = 120, class = "DEMONHUNTER", specID = { 581 } }, -- Nether Bond
			--[218256] = { duration = 20, class = "DEMONHUNTER", specID = { 581 } }, -- Empower Wards
			[263648] = { duration = 20, class = "DEMONHUNTER", specID = { 581 } }, -- Soul Barrier

		-- Priest
		[586] = { duration = 30, class = "PRIEST" }, -- Fade
			[213602] = { parent = 586 }, -- Greater Fade
		[32375] = { duration = 45, class = "PRIEST" }, -- Mass Dispel

			-- Discipline
			[8122] = { duration = 30, class = "PRIEST", specID = { 256, 257, 258 } }, -- Psychic Scream
			[10060] = { duration = 120, class = "PRIEST", specID = { 256, 258 } }, -- Power Infusion
			[33206] = { duration = 180, class = "PRIEST", specID = { 256 } }, -- Pain Suppression
			[34433] = { duration = 180, class = "PRIEST", specID = { 256, 258 } }, -- Shadowfiend
				[123040] = { parent = 34433, duration = 60 }, -- Mindbender (Discipline)
				[200174] = { parent = 34433, duration = 60 }, -- Mindbender (Shadow)
			[47536] = { duration = 90, class = "PRIEST", specID = { 256 } }, -- Rapture
			[62618] = { duration = 180, class = "PRIEST", specID = { 256 } }, -- Power Word: Barrier
			[73325] = { duration = 90, class = "PRIEST", specID = { 256, 257, 258 } }, -- Leap of Faith
			[197862] = { duration = 60, class = "PRIEST", specID = { 256 } }, -- Archangel
			[197871] = { duration = 60, class = "PRIEST", specID = { 256 } }, -- Dark Archangel
			[204263] = { duration = 45, class = "PRIEST", specID = { 256, 257 } }, -- Shining Force
			[305498] = { duration = 12, class = "PRIEST", specID = { 256} }, -- Premonition

			-- Holy
			[19236] = { duration = 90, class = "PRIEST", specID = { 256, 257 } }, -- Desperate Prayer
			[47788] = { duration = 180, class = "PRIEST", specID = { 257 } }, -- Guardian Spirit
			[64843] = { duration = 180, class = "PRIEST", specID = { 257 } }, -- Divine Hymn
			[64901] = { duration = 300, class = "PRIEST", specID = { 257 } }, -- Symbol of Hope
			[196762] = { duration = 30, class = "PRIEST", specID = { 257 } }, -- Inner Focus
			[197268] = { duration = 60, class = "PRIEST", specID = { 257 } }, -- Ray of Hope
			[200183] = { duration = 120, class = "PRIEST", specID = { 257 } }, -- Apotheosis
			[213610] = { duration = 30, class = "PRIEST", specID = { 257 } }, -- Holy Ward
			[215769] = { duration = 300, class = "PRIEST", specID = { 257 } }, -- Spirit of Redemption

			-- Shadow
			[15286] = { duration = 120, class = "PRIEST", specID = { 258 } }, -- Vampiric Embrace
			[15487] = { duration = 45, class = "PRIEST", specID = { 258 } }, -- Silence
			[32379] = { duration = 9, class = "PRIEST", specID = { 258 }, charges = 2 }, -- Shadow Word: Death
			[47585] = { duration = 120, class = "PRIEST", specID = { 258 } }, -- Dispersion
			[64044] = { duration = 45, class = "PRIEST", specID = { 258 } }, -- Psychic Horror
			[108968] = { duration = 300, class = "PRIEST", specID = { 258 } }, -- Void Shift
			[193223] = { duration = 240, class = "PRIEST", specID = { 258 } }, -- Surrender to Madness
			[205065] = { duration = 45, class = "PRIEST", specID = { 258 } }, -- Void Torrent
			[205369] = { duration = 30, class = "PRIEST", specID = { 258 } }, -- Mind Bomb
			[211522] = { duration = 45, class = "PRIEST", specID = { 258 } }, -- Psyfiend

		-- Paladin
		[633] = { duration = 600, class = "PALADIN" }, -- Lay on Hands
		[642] = { duration = 300, class = "PALADIN" }, -- Divine Shield
		[853] = { duration = 60, class = "PALADIN" }, -- Hammer of Justice
		[1022] = { duration = 300, class = "PALADIN", charges = 2 }, -- Blessing of Protection
			[204018] = { parent = 1022, duration = 180 }, -- Blessing of Spellwarding
		[1044] = { duration = 25, class = "PALADIN", charges = 2 }, -- Blessing of Freedom
		[20066] = { duration = 15, class = "PALADIN" }, -- Repentance
		[31884] = { duration = 120, class = "PALADIN" }, -- Avenging Wrath
			[31842] = { parent = 31884 }, -- Avenging Wrath (Holy)
			[216331] = { parent = 31884 }, -- Avenging Crusader
			[224668] = { parent = 31884 }, -- Crusade
			[231895] = { parent = 31884 }, -- Crusade
		[115750] = { duration = 90, class = "PALADIN" }, -- Blinding Light

			-- Holy
			[498] = { duration = 60, class = "PALADIN", specID = { 65, 66 } }, -- Divine Protection
			[6940] = { duration = 120, class = "PALADIN", specID = { 65, 66 }, charges = 2 }, -- Blessing of Sacrifice
			[31821] = { duration = 180, class = "PALADIN", specID = { 65 } }, -- Aura Mastery
			[105809] = { duration = 90, class = "PALADIN", specID = { 65 } }, -- Holy Avenger
			[114158] = { duration = 60, class = "PALADIN", specID = { 65 } }, -- Light's Hammer
			[200652] = { duration = 90, class = "PALADIN", specID = { 65 } }, -- Tyr's Deliverance
			[210294] = { duration = 25, class = "PALADIN", specID = { 65 } }, -- Divine Favor
			[214202] = { duration = 30, class = "PALADIN", specID = { 65 }, charges = 2 }, -- Rule of Law

			-- Protection
			[31850] = { duration = 120, class = "PALADIN", specID = { 66 } }, -- Ardent Defender
			[31935] = { default = true, duration = 15, class = "PALADIN", specID = { 66 } }, -- Avenger's Shield
			[86659] = { duration = 300, class = "PALADIN", specID = { 66 } }, -- Guardian of Ancient Kings
				[228049] = { parent = 86659 }, -- Guardian of the Forgotten Queen
			[96231] = { default = true, duration = 15, class = "PALADIN", specID = { 66, 70 } }, -- Rebuke
			[152262] = { duration = 30, class = "PALADIN", specID = { 66 } }, -- Seraphim
			[190784] = { duration = 45, class = "PALADIN", specID = { 66 } }, -- Divine Steed
			[209202] = { duration = 60, class = "PALADIN", specID = { 66 } }, -- Eye of Tyr
			[215652] = { duration = 25, class = "PALADIN", specID = { 66 } }, -- Shield of Virtue

			-- Retribution
			[184662] = { duration = 120, class = "PALADIN", specID = { 70 } }, -- Shield of Vengeance
			[204939] = { duration = 60, class = "PALADIN", specID = { 70 } }, -- Hammer of Reckoning
			[205191] = { duration = 60, class = "PALADIN", specID = { 70 } }, -- Eye for an Eye
			[205273] = { duration = 45, class = "PALADIN", specID = { 70 } }, -- Wake of Ashes
			[210220] = { duration = 180, class = "PALADIN", specID = { 70 } }, -- Holy Wrath
			[210256] = { duration = 45, class = "PALADIN", specID = { 70 } }, -- Blessing of Sanctuary

		-- Druid
		[1850] = { duration = 120, class = "DRUID" }, -- Dash
			[252216] = { parent = 1850, duration = 45 }, -- Tiger Dash
		[5211] = { duration = 50, class = "DRUID" }, -- Mighty Bash
		[20484] = { duration = 600, class = "DRUID" }, -- Rebirth
		[102280] = { duration = 30, class = "DRUID" }, -- Displacer Beast
		[102359] = { duration = 30, class = "DRUID" }, -- Mass Entanglement
		[102401] = { duration = 15, class = "DRUID" }, -- Wild Charge
		[132469] = { duration = 30, class = "DRUID" }, -- Typhoon

			-- Balance
			[22812] = { duration = { default = 60, [104] = 35 }, class = "DRUID", specID = { 102, 104, 105 } }, -- Barkskin
			[29166] = { duration = 180, class = "DRUID", specID = { 102, 105 } }, -- Innervate
			[78675] = { default = true, duration = 60, class = "DRUID", specID = { 102 } }, -- Solar Beam
			[102560] = { duration = 180, class = "DRUID", specID = { 102 } }, -- Incarnation: Chosen of Elune
			[108238] = { duration = 120, class = "DRUID", specID = { 102, 103, 105 } }, -- Renewal
			[194223] = { duration = 180, class = "DRUID", specID = { 102 } }, -- Celestial Alignment
			[202425] = { duration = 45, class = "DRUID", specID = { 102 } }, -- Warrior of Elune
			[202770] = { duration = 60, class = "DRUID", specID = { 102 } }, -- Fury of Elune
			[205636] = { duration = 60, class = "DRUID", specID = { 102 } }, -- Force of Nature
			[209749] = { duration = 30, class = "DRUID", specID = { 102 } }, -- Faerie Swarm

			-- Feral
			[5217] = { duration = 30, class = "DRUID", specID = { 103 } }, -- Tiger's Fury
			[22570] = { duration = 20, class = "DRUID", specID = { 103 } }, -- Maim
			[61336] = { duration = { default = 180, [104] = 120 }, class = "DRUID", specID = { 103, 104 }, charges = 2 }, -- Survival Instincts
			[102543] = { duration = 180, class = "DRUID", specID = { 103 } }, -- Incarnation: King of the Jungle
			[106839] = { default = true, duration = 15, class = "DRUID", specID = { 103, 104 } }, -- Skull Bash
			[106898] = { duration = 120, class = "DRUID", specID = { 103, 104 } }, -- Stampeding Roar
			[106951] = { duration = 180, class = "DRUID", specID = { 103 } }, -- Berserk
			[202060] = { duration = 45, class = "DRUID", specID = { 103 } }, -- Elune's Guidance
			[203242] = { duration = 60, class = "DRUID", specID = { 103 } }, -- Rip and Tear
			[210722] = { duration = 75, class = "DRUID", specID = { 103 } }, -- Ashamane's Frenzy

			-- Guardian
			[99] = { duration = 30, class = "DRUID", specID = { 104 } }, -- Incapacitating Roar
			[22842] = { duration = 36, class = "DRUID", specID = { 104 } }, -- Frenzied Regeneration
			[102558] = { duration = 180, class = "DRUID", specID = { 104 } }, -- Incarnation: Guardian of Ursoc
			[200851] = { duration = 90, class = "DRUID", specID = { 104 } }, -- Rage of the Sleeper
			[202246] = { duration = 15, class = "DRUID", specID = { 104 } }, -- Overrun
			[204066] = { duration = 90, class = "DRUID", specID = { 104 } }, -- Lunar Beam

			-- Restoration
			[740] = { duration = 180, class = "DRUID", specID = { 105} }, -- Tranquility
			[18562] = { duration = 25, class = "DRUID", specID = { 105}, charges = 2 }, -- Swiftmend
			[33891] = { duration = 180, class = "DRUID", specID = { 105} }, -- Incarnation: Tree of Life
			[102342] = { duration = 60, class = "DRUID", specID = { 105} }, -- Ironbark
			[102351] = { duration = 30, class = "DRUID", specID = { 105} }, -- Cenarion Ward
			[102793] = { duration = 60, class = "DRUID", specID = { 105} }, -- Ursol's Vortex
			[197721] = { duration = 90, class = "DRUID", specID = { 105} }, -- Flourish
			[201664] = { duration = 60, class = "DRUID", specID = { 105} }, -- Demoralizing Roar
			[203651] = { duration = 45, class = "DRUID", specID = { 105} }, -- Overgrowth
			[236696] = { duration = 45, class = "DRUID", specID = { 102, 103, 105} }, -- Thorns
			[208253] = { duration = 90, class = "DRUID", specID = { 105} }, -- Essence of G'Hanir

		-- Warrior
		[100] = { duration = 20, class = "WARRIOR" }, -- Charge
			[198758] = { parent = 100, charges = 2 }, -- Intercept
		[1719] = { duration = 90, class = "WARRIOR" }, -- Recklessness
		[6544] = { duration = 30, class = "WARRIOR", charges = 2 }, -- Heroic Leap
		[6552] = { default = true, duration = 15, class = "WARRIOR" }, -- Pummel
		[18499] = { duration = 60, class = "WARRIOR" }, -- Berserker Rage
		[23920] = { duration = 25, class = "WARRIOR" }, -- Spell Reflection
			[213915] = { parent = 23920, duration = 30 }, -- Mass Spell Reflection
			[216890] = { parent = 23920 }, -- Spell Reflection (Arms, Fury)
		[46968] = { duration = 40, class = "WARRIOR" }, -- Shockwave
		[107570] = { duration = 30, class = "WARRIOR" }, -- Storm Bolt
		[107574] = { duration = 90, class = "WARRIOR" }, -- Avatar
		[236077] = { duration = 45, class = "WARRIOR" }, -- Disarm
			[236236] = { parent = 236077 }, -- Disarm (Protection)

			-- Arms
			[5246] = { duration = 90, class = "WARRIOR", specID = { 71, 72 } }, -- Intimidating Shout
			[97462] = { duration = 180, class = "WARRIOR", specID = { 71, 72, 73 } }, -- Rallying Cry
			[118038] = { duration = 180, class = "WARRIOR", specID = { 71 } }, -- Die by the Sword
			[167105] = { duration = 45, class = "WARRIOR", specID = { 71 } }, -- Colossus Smash
				[262161] = { parent = 167105 }, -- Warbreaker
			[197690] = { duration = 10, class = "WARRIOR", specID = { 71 } }, -- Defensive Stance
			[198817] = { duration = 45, class = "WARRIOR", specID = { 71 } }, -- Sharpen Blade
			[227847] = { duration = 60, class = "WARRIOR", specID = { 71, 72 } }, -- Bladestorm (Arms)
				[46924] = { parent = 227847 }, -- Bladestorm (Fury)
				[152277] = { parent = 227847 }, -- Ravager
			[236273] = { duration = 60 , class = "WARRIOR", specID = { 71 } }, -- Duel

			-- Fury
			[184364] = { duration = 120, class = "WARRIOR", specID = { 72 } }, -- Enraged Regeneration
			[205545] = { duration = 45, class = "WARRIOR", specID = { 72 } }, -- Odyn's Fury

			-- Protection
			[871] = { duration = 240, class = "WARRIOR", specID = { 73 } }, -- Shield Wall
			[1160] = { duration = 45, class = "WARRIOR", specID = { 73 } }, -- Demoralizing Shout
			[12975] = { duration = 180, class = "WARRIOR", specID = { 73 } }, -- Last Stand
			[118000] = { duration = 35, class = "WARRIOR", specID = { 73 } }, -- Dragon Roar
			[198304] = { duration = 20, class = "WARRIOR", specID = { 73 }, charges = 2 }, -- Intercept
			[206572] = { duration = 20, class = "WARRIOR", specID = { 73 } }, -- Dragon Charge
			[213871] = { duration = 15, class = "WARRIOR", specID = { 73 } }, -- Bodyguard
			[228920] = { duration = 60, class = "WARRIOR", specID = { 73 } }, -- Ravager

		-- Warlock
		[1122] = { duration = 180, class = "WARLOCK" }, -- Summon Infernal
		[6358] = { duration = 30, class = "WARLOCK" }, -- Seduction
			[115268] = { parent = 6358 }, -- Mesmerize
		[6360] = { duration = 25, class = "WARLOCK" }, -- Whiplash
			[115770] = { parent = 6360 }, -- Fellash
		[6789] = { duration = 45, class = "WARLOCK" }, -- Mortal Coil
		--[18540] = { duration = 180, class = "WARLOCK" }, -- Summon Doomguard
		[20707] = { duration = 600, class = "WARLOCK" }, -- Soulstone
		[30283] = { duration = 60, class = "WARLOCK" }, -- Shadowfury
		[104773] = { duration = 180, class = "WARLOCK" }, -- Unending Resolve
		[108416] = { duration = 60, class = "WARLOCK" }, -- Dark Pact
		[108501] = { duration = 90, class = "WARLOCK" }, -- Grimoire of Service
		[111896] = { duration = 90, class = "WARLOCK" }, -- Grimoire: Succubus
		[119910] = { default = true, duration = 24, class = "WARLOCK" }, -- Spell Lock (Command Demon)
			[19647] = { parent = 119910 }, -- Spell Lock (Felhunter)
			[119911] = { parent = 119910 }, -- Optical Blast (Command Demon)
			[115781] = { parent = 119910 }, -- Optical Blast (Observer)
			[132409] = { parent = 119910 }, -- Spell Lock (Grimoire of Sacrifice)
			[171138] = { parent = 119910 }, -- Shadow Lock (Doomguard)
			[171139] = { parent = 119910 }, -- Shadow Lock (Grimoire of Sacrifice)
			[171140] = { parent = 119910 }, -- Shadow Lock (Command Demon)
		[171152] = { duration = 60, class = "WARLOCK" }, -- Meteor Strike
		[196098] = { duration = 120, class = "WARLOCK" }, -- Soul Harvest
		[199890] = { duration = 15, class = "WARLOCK" }, -- Curse of Tongues
		[199892] = { duration = 20, class = "WARLOCK" }, -- Curse of Weakness
		[199954] = { duration = 45, class = "WARLOCK" }, -- Curse of Fragility
		[212295] = { duration = 45, class = "WARLOCK" }, -- Nether Ward
		[221703] = { duration = 30, class = "WARLOCK" }, -- Casting Circle

			-- Affliction
			[5484] = { duration = 40, class = "WARLOCK", specID = { 265 } }, -- Howl of Terror
			[48181] = { duration = 15, class = "WARLOCK", specID = { 265 } }, -- Haunt
			[86121] = { duration = 20, class = "WARLOCK", specID = { 265 } }, -- Soul Swap
			[113860] = { duration = 120, class = "WARLOCK", specID = { 265 } }, -- Dark Soul: Misery
			[205179] = { duration = 45, class = "WARLOCK", specID = { 265 } }, -- Phantom Singularity

			-- Demonology
			[89751] = { duration = 45, class = "WARLOCK", specID = { 266 } }, -- Felstorm
				[115831] = { parent = 89751 }, -- Wrathstorm
			[89766] = { duration = 30, class = "WARLOCK", specID = { 266 } }, -- Axe Toss
			[201996] = { duration = 90, class = "WARLOCK", specID = { 266 } }, -- Call Observer
			[205180] = { duration = 24, class = "WARLOCK", specID = { 266 } }, -- Summon Darkglare
			[205181] = { duration = 14, class = "WARLOCK", specID = { 266 }, charges = 2 }, -- Shadowflame
			[211714] = { duration = 45, class = "WARLOCK", specID = { 266 } }, -- Thal'kiel's Consumption
			[212459] = { duration = 90, class = "WARLOCK", specID = { 266 } }, -- Call Fel Lord
			[212619] = { duration = 24, class = "WARLOCK", specID = { 266 } }, -- Call Felhunter
			[212623] = { duration = 15, class = "WARLOCK", specID = { 266 } }, -- Singe Magic

			--  Destruction
			[17962] = { duration = 12, class = "WARLOCK", specID = { 267 }, charges = 2 }, -- Conflagrate
			[80240] = { duration = 30, class = "WARLOCK", specID = { 267 } }, -- Havoc
			[113858] = { duration = 120, class = "WARLOCK", specID = { 267 } }, -- Dark Soul: Instability
			[152108] = { duration = 45, class = "WARLOCK", specID = { 267 } }, -- Cataclysm
			[196447] = { duration = 15, class = "WARLOCK", specID = { 267 } }, -- Channel Demonfire
			[196586] = { duration = 45, class = "WARLOCK", specID = { 267 }, charges = 3 }, -- Dimensional Rift
			[212284] = { duration = 45, class = "WARLOCK", specID = { 267 } }, -- Firestone

		-- Shaman
		[2825] = { duration = 60, class = "SHAMAN" }, -- Bloodlust
			[32182] = { parent = 2825 }, -- Heroism
		[20608] = { duration = 1800, class = "SHAMAN" }, -- Reincarnation
		[51485] = { duration = 30, class = "SHAMAN" }, -- Earthgrab Totem
		[51514] = { duration = { default = 30, [264] = 10 }, class = "SHAMAN" }, -- Hex
			[196932] = { parent = 51514 }, -- Voodoo Totem
			[210873] = { parent = 51514 }, -- Hex (Compy)
			[211004] = { parent = 51514 }, -- Hex (Spider)
			[211010] = { parent = 51514 }, -- Hex (Snake)
			[211015] = { parent = 51514 }, -- Hex (Cockroach)
		[57994] = { default = true, duration = 12, class = "SHAMAN" }, -- Wind Shear
		[108271] = { duration = 90, class = "SHAMAN" }, -- Astral Shift
			[210918] = { parent = 108271, duration = 45 }, -- Ethereal Form
		[114049] = { duration = 180, class = "SHAMAN" }, -- Ascendance
			[114050] = { parent = 114050 }, -- Ascendance (Elemental)
			[114051] = { parent = 114050 }, -- Ascendance (Enhancement)
			[114052] = { parent = 114050 }, -- Ascendance (Restoration)
		[192058] = { duration = 60, class = "SHAMAN" }, -- Capacitor
		[192077] = { duration = 120, class = "SHAMAN" }, -- Wind Rush Totem
		[204330] = { duration = 45, class = "SHAMAN" }, -- Skyfury Totem
		[204331] = { duration = 45, class = "SHAMAN" }, -- Counterstrike Totem
		[204332] = { duration = 30, class = "SHAMAN" }, -- Windfury Totem

			-- Elemental
			[16166] = { duration = 120, class = "SHAMAN", specID = { 262 } }, -- Elemental Mastery
			[51490] = { duration = 45, class = "SHAMAN", specID = { 262 } }, -- Thunderstorm
			[108281] = { duration = 120, class = "SHAMAN", specID = { 262, 264 } }, -- Ancestral Guidance
			[192063] = { duration = 15, class = "SHAMAN", specID = { 262, 264 } }, -- Gust of Wind
			[192222] = { duration = 60, class = "SHAMAN", specID = { 262 } }, -- Liquid Magma Totem
			[198067] = { duration = 150, class = "SHAMAN", specID = { 262 } }, -- Fire Elemental
				[192249] = { parent = 198067 }, -- Storm Elemental
			[198103] = { duration = 120, class = "SHAMAN", specID = { 262 } }, -- Earth Elemental
			[204437] = { duration = 30, class = "SHAMAN", specID = { 262 } }, -- Lightning Lasso
			[191634] = { duration = 60, class = "SHAMAN", specID = { 262 } }, -- Stormkeeper

			-- Enhancement
			[58875] = { duration = 60, class = "SHAMAN", specID = { 263 } }, -- Spirit Walk
			[196884] = { duration = 30, class = "SHAMAN", specID = { 263 } }, -- Feral Lunge
			[197214] = { duration = 40, class = "SHAMAN", specID = { 263 } }, -- Sundering
			[201898] = { duration = 45, class = "SHAMAN", specID = { 263 } }, -- Windsong
			[204366] = { duration = 45, class = "SHAMAN", specID = { 263 } }, -- Thundercharge
			[204945] = { duration = 60, class = "SHAMAN", specID = { 263 } }, -- Doom Winds

			-- Restoration
			[5394] = { duration = 30, class = "SHAMAN", specID = { 264 }, charges = 30 }, -- Healing Stream Totem
			[79206] = { duration = 60, class = "SHAMAN", specID = { 264 } }, -- Spiritwalker's Grace
			[98008] = { duration = 180, class = "SHAMAN", specID = { 264 } }, -- Spirit Link Totem
				[204293] = { parent = 98008, duration = 60 }, -- Spirit Link
			[108280] = { duration = 180, class = "SHAMAN", specID = { 264 } }, -- Healing Tide Totem
			[157153] = { duration = 30, class = "SHAMAN", specID = { 264 } }, -- Cloudburst Totem
			[198838] = { duration = 60, class = "SHAMAN", specID = { 264 } }, -- Earthen Wall Totem
			[204336] = { duration = 30, class = "SHAMAN", specID = { 264 } }, -- Grounding Totem
			[207399] = { duration = 300, class = "SHAMAN", specID = { 264 } }, -- Ancestral Protection Totem
			[207778] = { duration = 45, class = "SHAMAN", specID = { 264 } }, -- Gift of the Queen

		-- Hunter
		[136] = { duration = 10, class = "HUNTER" }, -- Mend Pet
		[1543] = { duration = 20, class = "HUNTER" }, -- Flare
		[5384] = { duration = 30, class = "HUNTER" }, -- Feign Death
		[53480] = { duration = 60, class = "HUNTER" }, -- Roar of Sacrifice
		[109304] = { duration = 120, class = "HUNTER" }, -- Exhilaration (Beast Mastery, Survival)
		[131894] = { duration = 60, class = "HUNTER" }, -- A Murder of Crows (Beast Mastery, Marksmanship)
			[206505] = { parent = 131894 }, -- A Murder of Crows (Survival)
		[186257] = { duration = { default = 180, [253] = 120, [255] = 144 }, class = "HUNTER" }, -- Aspect of the Cheetah
		[186265] = { duration = { default = 180, [255] = 144 }, class = "HUNTER" }, -- Aspect of the Turtle
		[187650] = { duration = { default = 30, [255] = 20 }, class = "HUNTER" }, -- Freezing Trap
		[202914] = { duration = 60, class = "HUNTER" }, -- Spider Sting
		[209997] = { duration = 30, class = "HUNTER" }, -- Play Dead

			-- Beast Mastery
			[781] = { duration = 20, class = "HUNTER", specID = { 253, 254 } }, -- Disengage
			[19386] = { duration = 45, class = "HUNTER", specID = { 253, 254 } }, -- Wyvern Sting
			[19574] = { duration = 75, class = "HUNTER", specID = { 253 } }, -- Bestial Wrath
			[19577] = { duration = 60, class = "HUNTER", specID = { 253 } }, -- Intimidation
			[109248] = { duration = 45, class = "HUNTER", specID = { 253, 254 } }, -- Binding Shot
			[147362] = { default = true, duration = 24, class = "HUNTER", specID = { 253, 254 } }, -- Counter Shot
			[193530] = { duration = 120, class = "HUNTER", specID = { 253 } }, -- Aspect of the Wild
			[194386] = { duration = 90, class = "HUNTER", specID = { 253, 254 } }, -- Volley
			[201430] = { duration = 180, class = "HUNTER", specID = { 253 } }, -- Stampede
			[207068] = { duration = 60, class = "HUNTER", specID = { 253 } }, -- Titan's Thunder
			[208652] = { duration = 30, class = "HUNTER", specID = { 253 } }, -- Dire Beast: Hawk

			-- Marksmanship
			[34477] = { duration = 30, class = "HUNTER", specID = { 254 } }, -- Misdirection
			[186387] = { duration = 20, class = "HUNTER", specID = { 254 } }, -- Bursting Shot
			[199483] = { duration = 60, class = "HUNTER", specID = { 254, 255 } }, -- Camouflage
			[204147] = { duration = 20, class = "HUNTER", specID = { 254 } }, -- Windburst
			[206817] = { duration = 30, class = "HUNTER", specID = { 254 } }, -- Sentinel
			[209789] = { duration = 30, class = "HUNTER", specID = { 254 } }, -- Freezing Arrow
			[213691] = { duration = 20, class = "HUNTER", specID = { 254 } }, -- Scatter Shot

			-- Survival
			[53271] = { duration = 45, class = "HUNTER", specID = { 255 } }, -- Master's Call
			[186289] = { duration = 96, class = "HUNTER", specID = { 255 } }, -- Aspect of the Eagle
			[187698] = { duration = 20, class = "HUNTER", specID = { 255 } }, -- Tar Trap
			[187707] = { default = true, duration = 15, class = "HUNTER", specID = { 255 } }, -- Muzzle
			[190925] = { duration = 20, class = "HUNTER", specID = { 255 } }, -- Harpoon
			[191241] = { duration = 30, class = "HUNTER", specID = { 255 } }, -- Sticky Bomb
			[191433] = { duration = 20, class = "HUNTER", specID = { 255 } }, -- Explosive Trap
			[194407] = { duration = 90, class = "HUNTER", specID = { 255 } }, -- Spitting Cobra
			[201078] = { duration = 90, class = "HUNTER", specID = { 255 } }, -- Snake Hunter
			[203415] = { duration = 45, class = "HUNTER", specID = { 255 } }, -- Fury of the Eagle
			[205691] = { duration = 120, class = "HUNTER", specID = { 255 } }, -- Dire Beast: Basilisk
			[212640] = { duration = 25, class = "HUNTER", specID = { 255 } }, -- Mending Bandage
			[266779] = { duration = 20, class = "HUNTER", specID = { 255 } }, -- Coordinated Assault

		-- Mage
		[66] = { duration = 300, class = "MAGE" }, -- Invisibility
		[1953] = { duration = 15, class = "MAGE"}, -- Blink
			[212653] = { parent = 1953, duration = 20, charges = 2 }, -- Shimmer
		[2139] = { default = true, duration = 24, class = "MAGE" }, -- Counterspell
		[11426] = { duration = 25, class = "MAGE" }, -- Ice Barrier
		[45438] = { duration = 240, class = "MAGE" }, -- Ice Block
		[108839] = { duration = 20, class = "MAGE", charges = 3 }, -- Ice Floes
		[113724] = { duration = 45, class = "MAGE" }, -- Ring of Frost
		[116011] = { duration = 40, class = "MAGE", charges = 2 }, -- Rune of Power
		[198111] = { duration = 45, class = "MAGE" }, -- Temporal Shield

			-- Arcane
			[12042] = { duration = 90, class = "MAGE", specID = { 62 } }, -- Arcane Power
			[12051] = { duration = 90, class = "MAGE", specID = { 62 } }, -- Evocation
			[153626] = { duration = 20, class = "MAGE", specID = { 62 } }, -- Arcane Orb
			[157980] = { duration = 25, class = "MAGE", specID = { 62 } }, -- Supernova
			[195676] = { duration = 24, class = "MAGE", specID = { 62 } }, -- Displacement
			[198158] = { duration = 60, class = "MAGE", specID = { 62 } }, -- Mass Invisibility
			[205025] = { duration = 60, class = "MAGE", specID = { 62 } }, -- Presence of Mind
			[224968] = { duration = 60, class = "MAGE", specID = { 62 } }, -- Mark of Aluneth
			[110959] = { duration = 75, class = "MAGE", specID = { 62 } }, -- Greater Invisibility

			-- Fire
			[31661] = { duration = 18, class = "MAGE", specID = { 63 } }, -- Dragon's Breath
			[108853] = { duration = 8.4, class = "MAGE", specID = { 63 }, charges = 3 }, -- Fire Blast
			[153561] = { duration = 45, class = "MAGE", specID = { 63 } }, -- Meteor
			[157981] = { duration = 25, class = "MAGE", specID = { 63 } }, -- Blast Wave
			[190319] = { duration = 120, class = "MAGE", specID = { 63 } }, -- Combustion

			-- Frost
			[122] = { duration = 30, class = "MAGE", specID = { 64 }, charges = 2 }, -- Frost Nova
			[12472] = { duration = 180, class = "MAGE", specID = { 64 } }, -- Icy Veins
				[198144] = { parent = 12472, duration = 45 }, -- Ice Form
			[31687] = { duration = 60, class = "MAGE", specID = { 64 } }, -- Summon Water Elemental
			[84714] = { duration = 60, class = "MAGE", specID = { 64 } }, -- Frozen Orb
			[153595] = { duration = 30, class = "MAGE", specID = { 64 } }, -- Comet Storm
			[157997] = { duration = 25, class = "MAGE", specID = { 64 } }, -- Ice Nova
			[205021] = { duration = 75, class = "MAGE", specID = { 64 } }, -- Ray of Frost
			[214634] = { duration = 45, class = "MAGE", specID = { 64 } }, -- Ebonbolt

		-- Rogue
		[1725] = { duration = 30, class = "ROGUE" }, -- Distract
		[1766] = { default = true, duration = 15, class = "ROGUE" }, -- Kick
		[1856] = { duration = { default = 120, [261] = 30 }, class = "ROGUE" }, -- Vanish
		[2983] = { duration = { default = 60, [259] = 51 }, class = "ROGUE" }, -- Sprint
		[31224] = { duration = { default = 90, [259] = 81 }, class = "ROGUE" }, -- Cloak of Shadows
		[57934] = { duration = 30, class = "ROGUE" }, -- Tricks of the Trade
		[137619] = { duration = 40, class = "ROGUE" }, -- Marked for Death
		[152150] = { duration = 20, class = "ROGUE" }, -- Death from Above

			-- Assassination
			[408] = { duration = 20, class = "ROGUE", specID = { 259, 261 } }, -- Kidney Shot
			[703] = { duration = 6, class = "ROGUE", specID = { 259 } }, -- Garrote
			[5277] = { duration = 120, class = "ROGUE", specID = { 259, 261 } }, -- Evasion
			[36554] = { duration = 30, class = "ROGUE", specID = { 259, 261 } }, -- Shadowstep
			[79140] = { duration = 120, class = "ROGUE", specID = { 259 } }, -- Vendetta
			[192759] = { duration = 45, class = "ROGUE", specID = { 259 } }, -- Kingsbane
			[200806] = { duration = 45, class = "ROGUE", specID = { 259 } }, -- Exsanguinate
			[206328] = { duration = 25, class = "ROGUE", specID = { 259 } }, -- Shiv

			-- Outlaw
			[1776] = { duration = 15, class = "ROGUE", specID = { 260 } }, -- Gouge
			[2094] = { duration = 120, class = "ROGUE", specID = { 260, 261 } }, -- Blind
				[199743] = { parent = 2094, duration = 20 }, -- Parley
			[13750] = { duration = 150, class = "ROGUE", specID = { 260 } }, -- Adrenaline Rush
			[51690] = { duration = 120, class = "ROGUE", specID = { 260 } }, -- Killing Spree
			--[185767] = { duration = 60, class = "ROGUE", specID = { 260 } }, -- Cannonball Barrage
			[195457] = { duration = 30, class = "ROGUE", specID = { 260 } }, -- Grappling Hook
			[198529] = { duration = 120, class = "ROGUE", specID = { 260 } }, -- Plunder Armor
			[199754] = { duration = 120, class = "ROGUE", specID = { 260 } }, -- Riposte
			[199804] = { duration = 30, class = "ROGUE", specID = { 260 } }, -- Between the Eyes
			[202665] = { duration = 90, class = "ROGUE", specID = { 260 } }, -- Curse of the Dreadblades
			[207777] = { duration = 45, class = "ROGUE", specID = { 260 } }, -- Dismantle

			-- Subtlety
			[121471] = { duration = 180, class = "ROGUE", specID = { 261 } }, -- Shadow Blades
			[185313] = { duration = 60, class = "ROGUE", specID = { 261 }, charges = 3 }, -- Shadow Dance
			[207736] = { duration = 120, class = "ROGUE", specID = { 261 } }, -- Shadowy Duel
			[209782] = { duration = 60, class = "ROGUE", specID = { 261 } }, -- Goremaw's Bite
			[212182] = { duration = 180, class = "ROGUE", specID = { 261 } }, -- Smoke Bomb
			[213981] = { duration = 45, class = "ROGUE", specID = { 261 } }, -- Cold Blood

		-- Monk
		[109132] = { duration = 15, class = "MONK", charges = 3 }, -- Roll
			[115008] = { parent = 109132 }, -- Chi Torpedo
		[115078] = { duration = 45, class = "MONK" }, -- Paralysis
		[116841] = { duration = 30, class = "MONK" }, -- Tiger's Lust
		[116844] = { duration = 45, class = "MONK" }, -- Ring of Peace
		[119381] = { duration = 60, class = "MONK" }, -- Leg Sweep
		[119996] = { duration = 45, class = "MONK" }, -- Transcendence: Transfer
		[122278] = { duration = 120, class = "MONK" }, -- Dampen Harm
		[122783] = { duration = 120, class = "MONK" }, -- Diffuse Magic
		[123986] = { duration = 30, class = "MONK" }, -- Chi Burst
		--[137648] = { duration = 120, class = "MONK" }, -- Nimble Brew

			-- Brewmaster
			[115203] = { duration = 105, class = "MONK", specID = { 268 } }, -- Fortifying Brew
			[115399] = { duration = 90, class = "MONK", specID = { 268 } }, -- Black Ox Brew
			[116705] = { default = true, duration = 15, class = "MONK", specID = { 268, 269 } }, -- Spear Hand Strike
			[132578] = { duration = 180, class = "MONK", specID = { 268 } }, -- Invoke Niuzao, the Black Ox
			[202162] = { duration = 45, class = "MONK", specID = { 268 } }, -- Guard
			[202272] = { duration = 45, class = "MONK", specID = { 268 } }, -- Incendiary Brew
			[202370] = { duration = 60, class = "MONK", specID = { 268 } }, -- Mighty Ox Kick

			-- Windwalker
			[101545] = { duration = 25, class = "MONK", specID = { 269 }, charges = 2 }, -- Flying Serpent Kick
			[113656] = { duration = 24, class = "MONK", specID = { 269 } }, -- Fists of Fury
			[115080] = { duration = 120, class = "MONK", specID = { 269 } }, -- Touch of Death
				[152173] = { parent = 137639 }, -- Serenity
			[115176] = { duration = 150, class = "MONK", specID = { 269 } }, -- Zen Meditation
				[201325] = { parent = 115176, 180 }, -- Zen Meditation (Windwalker)
			[115288] = { duration = 60, class = "MONK", specID = { 269 } }, -- Energizing Elixir
			[122470] = { duration = 90, class = "MONK", specID = { 269 } }, -- Touch of Karma
			[123904] = { duration = 120, class = "MONK", specID = { 269 } }, -- Invoke Xuen, the White Tiger
			[137639] = { duration = 90, class = "MONK", specID = { 269 }, charges = 2 }, -- Storm, Earth, and Fire
			[152175] = { duration = 24, class = "MONK", specID = { 269 } }, -- Whirling Dragon Punch
			[201318] = { duration = 90, class = "MONK", specID = { 269 } }, -- Fortifying Elixir

			-- Mistweaver
			[115310] = { duration = 180, class = "MONK", specID = { 270 } }, -- Revival
			[116680] = { duration = 30, class = "MONK", specID = { 270 } }, -- Thunder Focus Tea
			[116849] = { duration = 120, class = "MONK", specID = { 270 } }, -- Life Cocoon
			[197908] = { duration = 90, class = "MONK", specID = { 270 } }, -- Mana Tea
			--[197945] = { duration = 20, class = "MONK", specID = { 270 }, charges = 2 }, -- Mistwalk
			[198898] = { duration = 30, class = "MONK", specID = { 270 } }, -- Song of Chi-Ji

	}

	--Check cooldown remaining on unit's ability
	function UnitCooldown(unit,spell)
		if type(spell) == "number" then
			if SpellTracker[spell] and unit_is_unit(unit, SpellTracker[spell].pointer) then
				return max(0, SpellTracker[spell].expires - GetTime())
			end
		end
		if type(spell) == "string" then
			for k,v in pairs(SpellTracker) do
				if v.name == spell and unit_is_unit(unit,v.pointer) then
					return max(0, v.expires - GetTime())
				end
			end
		end
		return 0;
	end

	function _rakePower(unit)
		for i=1,#dotTracker do
			if unit_is_unit(dotTracker[i].rakepointer,unit) and dotTracker[i].rakePower then
				return dotTracker[i].rakePower;
			end
		end
		return 0;
	end

	function _ripPower(unit)
		for i=1,#dotTracker do
			if unit_is_unit(dotTracker[i].rippointer,unit) and dotTracker[i].ripPower then
				return dotTracker[i].ripPower;
			end
		end
		return UnitDebuffID(unit,1079,"player") and 1 or 0;
	end

	function _garrotePower(unit)
		for i=1,#dotTracker do
			if unit_is_unit(dotTracker[i].garrotepointer,unit) and dotTracker[i].garrotePower then
				return dotTracker[i].garrotePower;
			end
		end
		return 0;
	end

	local bCC = {
	-- DEATH KNIGHT
	-- DRUID
	99,   -- Disorienting Roar
	236025,	--Enraged Maim
	-- HUNTER
	3355,  -- Freezing Trap
	187650,	--Freezing Trap
	19386,  -- Wyvern Sting
	-- MAGE
	28272,		-- Pig
	118,		-- Sheep
	277792,		-- Bee
	161354,		-- Monkey
	277787,		-- Direhorn
	161355,		-- Penguin
	161353,		-- Polar Bear
	120140,		-- Porcupine
	61305,		-- Cat
	61721,		-- Rabbit
	61780,		-- Turkey
	28271,		-- Turtle
	-- 113724,		-- Ring of Frost
	-- 136511,		-- Ring of Frost
	-- 140384,		-- Ring of Frost
	82691,		-- Ring of Frost (I think this is actually it)
	31661,		-- Dragon's Breath
	-- MONK
	115078,  -- Paralysis
	-- PALADIN
	105421,  -- Blinding Light
	20066,  -- Repentance
	-- PRIEST
	9484,  -- Shackle Undead
	-- ROGUE
	2094,  -- Blind
	1776,  -- Gouge
	6770,  -- Sap
	-- SHAMAN
	51514,  -- Hex
	211015,	--hex cockroach
	210873,	--hex compy
	211010,	--hex snake
	211004,	--hex spider
	277784,	--hex wicker mongrel
	277778,	--hex zandalari tendonripper
	309328,	--hex living honey
	269352,	--hex skeletal raptor
	-- WARLOCK
	115268,  -- Mesmerize
	6358,  -- Seduction
	-- RACIALS
	107079,  -- Quaking Palm
	238559,	--Bursting Shot
	--DEMON HUNTER
	217832,	-- Imprison
	}

	breakable_cc_cache = {}

	function _breakableCC(unit,breakfears)
		if breakable_cc_cache[unit] ~= nil then return breakable_cc_cache[unit] end
		local cctable = {unpack(bCC)}
		if breakfears then
			for i=1,#cctable do if cctable[i] == 118699 then
				table.remove(cctable,i)
			end end
		end
		local hasdebuff,debuff = _debuffFromTable(unit,cctable);
		if hasdebuff then
			breakable_cc_cache[unit] = true
			return true;
		else
			breakable_cc_cache[unit] = false
		end
	end

	function bcc_remains(unit)
		local bcc = {}
		local debuffs = _debuffFromTable(unit,bCC,true)
		table.sort(debuffs,function(x,y) return x > y end)
		local ccr = debuffs[1]
		if ccr == math.huge then ccr = 0 end
		if not ccr then ccr = 0 end
		return ccr
	end

	function _bccAM(dist)
		for i=1,#Enemies do
			if _distance(Enemies[i]) <= dist then
				if _breakableCC(Enemies[i]) then
					return true;
				end
			end
		end
	end

	function breakable_cc_around(unit,dist)
		for i=1,#Enemies do
			if _distance(unit,Enemies[i]) <= dist then
				if bcc_remains(Enemies[i]) > squid_avg_latency + .25 then
					return true;
				end
			end
		end
	end

	function bcc_facing(unit,range,angle)
		for i=1,#Enemies do
			if _breakableCC(Enemies[i]) then
				if _distance(Enemies[i]) <= range
				and UnitIsFacing("player", unit, angle) then
					return true
				end
			end
		end
	end

	local disarms = {
	236077,	--Disarm
	207777,	--Dismantle
	233759, --Grapple weapon
	209749, --Faerie Swarm
	}

	function disarm_check(unit)
		local debuffs = _debuffFromTable(unit,disarms)
		if debuffs then return true end
	end

	function explosive_trap_knock(unit)

		if not UnitIsVisible(unit) then return end

		if IsPlayerSpell(236776) and _spellCooldown(236776) <= .5 and not _rootCheck(unit) then

			local my_trap

			for i=1,#AreaTriggers do if ObjectID(AreaTriggers[i]) == 9170 then
				my_trap = AreaTriggers[i]
			end end

			if my_trap then

				local ux,uy,uz = ObjectPosition(unit)
				local px,py,pz = GetPlayerPosition()
				local x,y,z = ObjectPosition(my_trap)

				local direction = math.atan2(uy-y, ux-x)

				if aoe_cast(236776,ux + 1.5 * math.cos(direction), uy + 1.5 * math.sin(direction), uz) then return end

			else

				--explosive trap away from team

				local mapid = GetMapId()

				local dist = 18 -- knock distance?

				local px,py,pz = GetPlayerPosition()
				local ux,uy,uz = ObjectPosition(unit)

				local points = {}

				local meshloaded = IsMeshLoaded(mapid)

				local step = (math.pi*2) / 20
				for i=0,math.pi*2,step do
					local x,y,z = ux + dist * math.cos(i), uy + dist * math.sin(i), uz
					if x and y and z and not TraceLine(ux, uy, uz+1.5, x, y, z+.5, collisionflags) then
						local gx,gy,gz = GroundZ(x,y,z)
						local zdif = z - gz
						-- if zdif > 1 then -- Maybe don't check z dif so if player just wants to knock away (out of earthen or bomb?) they can
							local ex,ey,ez = GroundZ(ux - 1.5 * math.cos(i), uy - 1.5 * math.sin(i), uz)
							if not TraceLine(px,py,pz+1.7,ex,ey,ez+1.7,losflags) then
								local pdist
								local hit,bcc,avg = Enemies_Around_Point(x,y,z,60,unit)
								table.insert(points,{x=ex,y=ey,z=ez,zdif=(zdif * 3.5)+avg,avg=avg})
							end
						-- end
					end
				end

				table.sort(points,function(x,y) return x.zdif > y.zdif or (x.zdif == y.zdif and x.avg > y.avg) end)

				if #points > 0 then
					SquidPause()
					local tx,ty,tz = points[1].x,points[1].y,points[1].z
					if aoe_cast(236776,tx,ty,tz) then return end
				end

			end

		end

	end

	function PlayerZDiff()
		local x,y,z = GetPlayerPosition()
		local _,_,gz = GroundZ(x,y,z)
		return z - gz
	end

	local function AnyKeyPressed()
		if GetKeyState(0x01)
		or GetKeyState(0x02)
		or GetKeyState(0x04)
		or GetKeyState(0x05)
		or GetKeyState(0x06)
		or GetKeyState(0x09)
		or GetKeyState(0x10)
		or GetKeyState(0x11)
		or GetKeyState(0x12)
		or GetKeyState(0x31)
		or GetKeyState(0x32)
		or GetKeyState(0x33)
		or GetKeyState(0x34)
		or GetKeyState(0x35)
		or GetKeyState(0x36)
		or GetKeyState(0x37)
		or GetKeyState(0x38)
		or GetKeyState(0x39)
		or GetKeyState(0x41)
		or GetKeyState(0x42)
		or GetKeyState(0x43)
		or GetKeyState(0x44)
		or GetKeyState(0x45)
		or GetKeyState(0x46)
		or GetKeyState(0x47)
		or GetKeyState(0x48)
		or GetKeyState(0x49)
		or GetKeyState(0x51)
		or GetKeyState(0x52)
		or GetKeyState(0x53)
		or GetKeyState(0x54)
		or GetKeyState(0x56)
		or GetKeyState(0x57)
		or GetKeyState(0x58)
		or GetKeyState(0x5A)
		or GetKeyState(0x60)
		or GetKeyState(0x61)
		or GetKeyState(0x62)
		or GetKeyState(0x63)
		or GetKeyState(0x64)
		or GetKeyState(0x65)
		or GetKeyState(0x66)
		or GetKeyState(0x67)
		or GetKeyState(0x68)
		or GetKeyState(0x69) then
			return true
		end
	end

	function should_feign()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
		local frame_buffer = 3 / GetFramerate()
		local latency = squid_avg_latency + squid_avg_home_latency
		local falling_val = (IsFalling() and PlayerZDiff() * .5 or 0)
		local buffer = frame_buffer + latency + .1 + falling_val
		local spec = GetSpecialization()
		local my_kick = (spec == 3 and 187707 or 147362)
		local kick_cd = _spellCooldown(my_kick)
		local kick_base_cd = GetSpellBaseCooldown(my_kick)/1000
		local feign_cd = _spellCooldown(5384)
		local gcd_remains = GetGCD()
		if feign_cd <= gcd_remains and kick_cd < kick_base_cd - .3 then
			--feignable debuffs
			if IsPlayerSpell(202746) then
				--touch of death
				local tod_remains = _debuffRemains("player",115080)
				if tod_remains > 0 then
					if tod_remains < gcd+gcd_remains+buffer then
						if tod_remains < 1.5 then
							return 115080
						end
						return "wait"
					end
				end
				--obsidian claw
				--maledict
			end
			--enemy casts
			for i=1,#Enemies do
				local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i])
				if cast then
					local target = UnitSpellTarget(Enemies[i])
					if unit_is_unit("player",target) then
						local timeleft = _castTimeLeft(Enemies[i])
						--incapacitates
						if tContains(csCCincapacitate,cast) and (_incapacitateDR("player") >= lowestEnemy / 100 or _drRemains("player","incapacitate") < timeleft) then
							if timeleft <= gcd+gcd_remains+buffer and _LoS(Enemies[i]) then
								if timeleft <= buffer then
									return cast
								end
								return "wait"
							end
						end
						--big dmg
						if tContains(castedDMG,cast) then
							if timeleft <= gcd+gcd_remains+buffer and _LoS(Enemies[i]) then
								if timeleft <= buffer then
									return cast
								end
								return "wait"
							end
						end
						--disorients
						if tContains(csCCdisorient,cast) and (_disorientDR("player") >= lowestEnemy / 100 or _drRemains("player","disorient") < timeleft) then
							if timeleft <= gcd+gcd_remains+buffer and _LoS(Enemies[i]) then
								if timeleft <= buffer then
									return cast
								end
								return "wait"
							end
						end
					end
				end
			end
		end
	end

	function should_ward()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		local fps = (1/GetFramerate())*4 --ms per frame * 4 (4 fps buffer)
		local latency = (select(4,GetNetStats())/1000)+.13
		local buffer = fps+latency
		for i=1,#Enemies do
			local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i]) --spellID of the cast
			if cast then
				local target = UnitSpellTarget(Enemies[i])
				if unit_is_unit("player",target) then
					local timeleft = _castTimeLeft(Enemies[i])
					--incapacitates
					if tContains(csCCincapacitate,cast) and (_incapacitateDR("player") == 1 or _drRemains(unit,"incapacitate") < timeleft or lowestEnemy < 65) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (_spellCooldown(19647) > timeleft) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
					--big dmg
					if tContains(castedDMG,cast) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (not _meleeRange('player', Enemies[i]) or _spellCooldown(6552) > timeleft) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
					--disorients
					if tContains(csCCdisorient,cast) and (_disorientDR("player") == 1 or _disorientDR(unit) == 1) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (not _meleeRange('player', Enemies[i]) or _spellCooldown(6552) > timeleft) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
				end
			end
		end
	end

	function should_reflect()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		local fps = (1/GetFramerate())*4 --ms per frame * 4 (4 fps buffer)
		local latency = (select(4,GetNetStats())/1000)+.13
		local buffer = fps+latency
		for i=1,#Enemies do
			local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i]) --spellID of the cast
			if cast then
				local target = UnitSpellTarget(Enemies[i])
				if unit_is_unit("player",target) then
					local timeleft = _castTimeLeft(Enemies[i])
					--incapacitates
					if tContains(csCCincapacitate,cast) and (_incapacitateDR("player") == 1 or _drRemains(unit,"incapacitate") < timeleft or lowestEnemy < 65) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (not _meleeRange('player', Enemies[i]) or _spellCooldown(6552) > timeleft) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
					--big dmg
					if tContains(castedDMG,cast) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (not _meleeRange('player', Enemies[i]) or _spellCooldown(6552) > timeleft) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
					--disorients
					if tContains(csCCdisorient,cast) and (_disorientDR("player") == 1 or _disorientDR(unit) == 1) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) and (not _meleeRange('player', Enemies[i]) or _spellCooldown(6552) > timeleft) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
				end
			end
		end
	end

	function should_intervene()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		local fps = (1/GetFramerate())*4 --ms per frame * 4 (4 fps buffer)
		local latency = (select(4,GetNetStats())/1000)+.13
		local buffer = fps+latency
		for i = 1, #Enemies do
			local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i]) --spellID of the cast
			if cast then
				local target = UnitSpellTarget(Enemies[i])
				if unit_is_unit(ourHealer, target) then
					local timeleft = _castTimeLeft(Enemies[i])
					--check for OverWatch 329035 before intervening spells
					if IsPlayerSpell(329035) then
						--incapacitates
						if tContains(csCCincapacitate,cast) and (_incapacitateDR("player") == 1 or _drRemains(unit,"incapacitate") < timeleft or lowestEnemy < 65) then
							if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
								if timeleft <= buffer then
									return cast
								end
								return "wait"
							end
						end
						--big dmg
						if tContains(castedDMG,cast) then
							if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
								if timeleft <= buffer then
									return cast
								end
								return "wait"
							end
						end
						--disorients
						if tContains(csCCdisorient,cast) and (_disorientDR("player") == 1 or _disorientDR(unit) == 1) then
							if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
								if timeleft <= buffer then
									return cast
								end
								return "wait"
							end
						end
					end
				end
			end
		end
		--reflect trap on healer
		if not UnitDebuffID(unit,187650) and _incapacitateDR(unit) == 1 then
			if lastTrapPointer and UnitIsVisible(lastTrapPointer) and unit_can_attack("player",lastTrapPointer) then
				if lastTrap and GetTime()-lastTrap < 1.5 then
					return 3355
				end
			end
		end
	end

	function should_ground()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		local fps = (1/GetFramerate())*4 --ms per frame * 4 (4 fps buffer)
		local latency = (select(4,GetNetStats())/1000)+.13
		local buffer = fps+latency
		for i=1,#Enemies do
			local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i])
			if cast then
				local target = UnitSpellTarget(Enemies[i])
				if unit_is_unit("player",target) or UnitIsFriend("player",target) then
					local timeleft = _castTimeLeft(Enemies[i])
					--incapacitates
					if tContains(csCCincapacitate,cast) and (_incapacitateDR("player") == 1 or _drRemains(unit,"incapacitate") < timeleft or lowestEnemy < 65) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
					--big dmg
					if tContains(castedDMG,cast) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
					--disorients
					if tContains(csCCdisorient,cast) and (_disorientDR("player") == 1 or _disorientDR(unit) == 1) then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
				end
			end
		end
	end

	function should_banner(unit)
		if not UnitIsVisible(unit) or _distance(unit) > 28 then return false end
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		local fps = (1/GetFramerate())*18 --ms per frame * 18 (18 fps buffer)
		local latency = (select(4,GetNetStats())/1000)+.13
		local buffer = fps+latency
		for i=1,#Enemies do
			local cast = unit_casting_info(Enemies[i])
			if cast then
				local target = UnitSpellTarget(Enemies[i])
				if unit_is_unit(unit,target) then
					local timeleft = _castTimeLeft(Enemies[i])
					--incapacitates
					if tContains(csCCincapacitate,cast) and _incapacitateDR(unit) == 1 then
						if timeleft <= gcd+GetGCD()+buffer then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
				end
			end
		end
		--traps
		--if intervene is on cooldown
		if _spellCooldown(3411) > .5 and not UnitDebuffID(unit,187650) and _incapacitateDR(unit) == 1 then
			if lastTrapPointer and UnitIsVisible(lastTrapPointer) and unit_can_attack("player",lastTrapPointer) then
				if lastTrap and GetTime()-lastTrap < 1.5 then
					return 3355
				end
			end
		end
	end

	function should_ground(unit)
		if not UnitIsVisible(unit) or _distance(unit) > 28 then return false end
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		local fps = ((1000/GetFramerate())/1000)*18 --ms per frame * 18 (18 fps buffer)
		local latency = (select(4,GetNetStats())/1000)+.1
		local buffer = fps+latency
		for i=1,#Enemies do
			local cast = unit_casting_info(Enemies[i])
			if cast then
				local target = UnitSpellTarget(Enemies[i])
				if unit_is_unit(unit,target) then
					local timeleft = _castTimeLeft(Enemies[i])
					--incapacitates
					if tContains(csCCincapacitate,cast) and (_incapacitateDR(unit) == 1 or _drRemains(unit,"incapacitate") < timeleft) then
						if timeleft <= gcd+GetGCD()+buffer then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end

				end
			end
		end
		--traps
		if not UnitDebuffID(unit,187650) and _incapacitateDR(unit) == 1 then
			if lastTrapPointer and UnitIsVisible(lastTrapPointer) and unit_can_attack("player",lastTrapPointer) then
				if lastTrap and GetTime()-lastTrap < 1.7 then
					return 3355
				end
			end
		end
	end

	function should_death()
		local time = GetTime()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		local fps = (1/GetFramerate())*4 --ms per frame * 4 (4 fps buffer)
		local latency = (select(4,GetNetStats())/1000)
		local buffer = fps+latency+.05
		local incapdr = _incapacitateDR("player")
		local incapdr_remains = _drRemains("player","incapacitate")
		for i=1,#Enemies do
			local _,_,_,_,_,_,_,_,cast = unit_casting_info(Enemies[i])
			if cast then
				local target = UnitSpellTarget(Enemies[i])
				if unit_is_unit("player",target) then
					local timeleft = _castTimeLeft(Enemies[i])
					--incapacitates
					if tContains(csCCincapacitate,cast) and incapdr_remains <= timeleft then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
					--disorients
					if tContains(csCCdisorient,cast) and cast ~= 33786 and cast ~= 205367 and _disorientDR("player") == 1 then
						if timeleft <= gcd+GetGCD()+buffer and _LoS(Enemies[i]) then
							if timeleft <= buffer then
								return cast
							end
							return "wait"
						end
					end
				end
			end
		end
		--traps
		if not UnitDebuffID(unit,187650) and _incapacitateDR(unit) == 1 then
			if lastTrapPointer and UnitIsVisible(lastTrapPointer) and unit_can_attack("player",lastTrapPointer) then
				if lastTrap and GetTime()-lastTrap < 1.7 then
					return 3355
				end
			end
		end
	end

	function EnemiesAroundMe(dist)
		local count=0
		for i=1,#Enemies do
			if _distance(Enemies[i]) <= dist then
				count=count+1;
			end
		end
		return count
	end

	function AllEnemiesAroundMe(dist)
		local count=0
		for i=1,#Pets do if UnitCreatureType(Pets[i]) ~= "Totem" then
			if _realDistance(Pets[i]) <= dist then
				count=count+1;
			end
		end end
		return count
	end

	function Enemies_Around_Point(x,y,z,dist,unit)
		local avgdist=0
		local totalcount=0
		local totaldist=0.00001 -- sometimes will end up dividing by zero if this started at zero
		local count=0
		local bcc=0
		for i=1,#Enemies do
			if not unit or not unit_is_unit(Enemies[i],unit) then
				local ex,ey,ez = ObjectPosition(Enemies[i])
				local distance_from_pos = GetDistanceBetweenPositions(x,y,z,ex,ey,ez)
				if distance_from_pos <= dist then
					count=count+1;
					if _breakableCC(Enemies[i]) then
						bcc=bcc+1
						--prio bcc units in avg dist
						if distance_from_pos < dist*1.75 then
							totaldist = totaldist + distance_from_pos
						end
					end
				end
				--units within 2x the given dist
				if distance_from_pos < dist*1.75 then

					totalcount=totalcount+1

					totaldist=totaldist+distance_from_pos

				end
			end
		end
		avgdist = totaldist/totalcount
		return count,bcc,avgdist
	end

	function Enemies_Around_Unit(unit,dist,realdist)

		if not UnitIsVisible(unit) then return 0,0,0 end

		local count = 0
		local bcc = 0
		local avg = 0

		for i=1,#Enemies do
			if not unit_is_unit(Enemies[i],unit) then
				if realdist and _realDistance(unit,Enemies[i]) <= dist or not realdist and _distance(unit,Enemies[i]) <= dist then--and _LoS(unit,Enemies[i]) then
					if _breakableCC(Enemies[i]) then
						bcc = bcc + 1
					end
					count = count+1;
				end
			end
		end

		return count,bcc,avg

	end

	function GroundZ(X,Y,Z)
		local x,y,z = TraceLine(X,Y,Z+4,X,Y,-10000,collisionflags)--GetGroundZ(X,Y,0x100111)
		if not z then z = Z end
		return x,y,math.min(z,Z)
	end

	function point_between_points(points)

		local valid_points = {}

		for i=1,#points do
			local point = points[i]
			local x,y = point[1],point[2]
			table.insert(valid_points,{x=x,y=y})
		end

		local total_x = 0
		local total_y = 0
		for i=1,#valid_points do
			total_x = total_x + valid_points[i].x
			total_y = total_y + valid_points[i].y
		end

		local x = total_x / #valid_points
		local y = total_y / #valid_points

		return TraceLine(x,y,-10000,x,y,10000,collisionflags)

	end

	function point_between_units(units)
		local points = {}
		for i=1,#units do
			local x,y,z = ObjectPosition(units[i])
			table.insert(points,{x,y,z})
		end
		return point_between_points(points)
	end

	--param unit, unit to check
	--param elapsed, time of moving to predict position after
	--returns x,y,z, the grounded position of the unit after the given time
	function PredictUnitPosition(unit,elapsed)

		if not unit then return false end

		if not elapsed then elapsed = 1 end

		local x,y,z

		if unit_is_unit(unit,"player") then
			x,y,z = GetPlayerPosition()
		else
			x,y,z = ObjectPosition(unit)
		end

		if x and y and z then

			local direction = GetMovingDirection(unit)

			local distance = GetUnitSpeed(unit) * elapsed

			local px=x + distance * math.cos(direction);
			local py=y + distance * math.sin(direction);
			local pz=z;

			local tx,ty,tz = TraceLine(x,y,z+2,px,py,pz+2,collisionflags)

			if not tx then

				return GroundZ(px,py,pz)

			else

				return GroundZ(tx,ty,tz)

			end

		end

	end

	function _anglesBetweenObjects(unit1,unit2)
		return GetAnglesBetweenObjects (unit1,unit2)
	end

	function _findCorner(fx,fy,fz,diameter,flags,dist)

		if not fz then
			fx,fy,fz = ObjectPosition(fx);
			diameter = fy;
		end
		local sx,sy,sz = GetPlayerPosition()
		local radius = diameter/2 or 0
		local diameter = diameter or 0
		if not dist then dist=10000 end

		if not TraceLine(sx,sy,sz+2,fx,fy,fz+2,0x10) then
			return fx,fy,fz
		end

		if TraceLine(sx,sy,sz,fx,fy,fz,0x10) then

			for i=0,radius,2 do

				if not TraceLine(sx,sy,sz+2,fx+i,fy,fz+2,0x10) and not TraceLine(fx+i,fy,fz+4,fx,fy,fz+4,0x10) then
					return fx+i,fy,fz
				end

				if not TraceLine(sx,sy,sz+2,fx,fy+i,fz+2,0x10) and not TraceLine(fx,fy+i,fz+4,fx,fy,fz+4,0x10) then
					return fx,fy+i,fz
				end

				if not TraceLine(sx,sy,sz+2,fx-i,fy,fz+2,0x10) and not TraceLine(fx-i,fy,fz+4,fx,fy,fz+4,0x10) then
					return fx-i,fy,fz
				end

				if not TraceLine(sx,sy,sz+2,fx,fy-i,fz+2,0x10) and not TraceLine(fx,fy-i,fz+4,fx,fy,fz+4,0x10) then
					return fx,fy-i,fz
				end

				if not TraceLine(sx,sy,sz+2,fx-i,fy-i,fz+2,0x10) and not TraceLine(fx,fy-i,fz+4,fx,fy,fz+4,0x10) then
					return fx-i,fy-i,fz
				end

				if not TraceLine(sx,sy,sz+2,fx+i,fy+i,fz+2,0x10) and not TraceLine(fx,fy-i,fz+4,fx,fy,fz+4,0x10) then
					return fx+i,fy+i,fz
				end

			end
		end
		return fx,fy,fz
	end

	function position_after_blink(direction)
		local px,py,pz = GetPlayerPosition()
		--ideal blink position (no obstacles)
		local bx,by,bz = GroundZ(px + 20 * math.cos(direction), py + 20 * math.sin(direction), pz)
		local x,y,z = px,py,pz

		if bx and by and bz then
			for i=1,20,.5 do
				local nx,ny,nz = GetPositionBetweenPositions(px,py,pz,bx,by,bz,i)
				nx,ny,nz = GroundZ(nx,ny,nz)
				local zdif = nz - z
				if zdif > .5 or zdif < -.5 then
					local lx,ly,lz = x,y,z--GetPositionBetweenPositions(x,y,z,px,py,pz,min(2,i))
					return lx,ly,lz
				else
					x,y,z = nx,ny,nz
				end
			end
		end

		-- local stuff = {bx,by,bz,x,y,z}
		-- local str = ""
		-- for i=1,#stuff do
		-- 	if stuff[i] then
		-- 		str = str .. stuff[i] .. " "
		-- 	else
		-- 		str = str .. i .. " "
		-- 	end
		-- end
		-- squid_print("Unable to determine GroundZ position in blink pos: "..direction.." "..str)
		-- x,y,z = bx,by,bz

		return x,y,z
	end

	--using position_after_blink (resource heavy higher accuracy)
	-- function blink_los_point(unit,maxdist,x,y,z)

	-- 	if not unit then return end

	-- 	if not x or not y or not z then
	-- 		x, y, z = ObjectPosition(unit)
	-- 	end

	-- 	local px, py, pz = GetPlayerPosition()

	-- 	maxdist = maxdist or 100

	-- 	-- local player_interruptable = PlayerCanBeKicked()

	-- 	--update - check player los to blink pos and z dif before tracline from blink pos to unit
	-- 	--thoughts - prio blink pos change: furthest from all units with interrupts > lowest z dif
	-- 	local points = {}
	-- 	for i=0,math.pi*2,.1256 do
	-- 		local bx, by, bz = position_after_blink(i)--GroundZ ( px + 20 * math.cos(i), py + 20 * math.sin(i), pz )
	-- 		if bx and by and bz and not TraceLine( px, py, pz + 1.3, bx, by, bz + 1.3, 0x100111 ) then
	-- 			if not TraceLine( bx, by, bz + 1.6, x, y, z + 1.6, 0x100111 ) then
	-- 				local dist = GetDistanceBetweenPositions(x,y,z,bx,by,bz) - UnitCombatReach("player") - UnitCombatReach(unit)
	-- 				-- print(dist)
	-- 				if dist < maxdist then
	-- 					table.insert(points,{x=bx,y=by,z=bz,dist=dist})
	-- 				end
	-- 			end
	-- 		end
	-- 	end

	-- 	table.sort(points,function(x,y) return x.dist < y.dist end)

	-- 	if #points > 0 then

	-- 		if #points == 1 then
	-- 			return points[1].x,points[1].y,points[1].z
	-- 		else
	-- 			local index = math.ceil(#points/4)
	-- 			local a,b,c = points[index].x,points[index].y,points[index].z
	-- 			return a,b,c,points[index].dist
	-- 		end
	-- 	end

	-- 	-- if #points > 0 then
	-- 	-- 	if #points == 1 then
	-- 	-- 		local a,b,c = GroundZ(points[1].x,points[1].y,points[1].z)
	-- 	-- 		return a,b,c,points[1].dist
	-- 	-- 	else
	-- 	-- 		local index = math.ceil(#points/3)
	-- 	-- 		local a,b,c = GroundZ(points[index].x,points[index].y,points[index].z)
	-- 	-- 		return a,b,c,points[index].dist
	-- 	-- 	end
	-- 	-- end

	-- end

	-- using zdif at end of assumed blink pos and choosing the safest out of possible points (previous version)
	function blink_los_point(unit,maxdist,x,y,z)

		if not unit then return end

		if not x and not y and not z then
			x, y, z = ObjectPosition(unit)
		end

		local px, py, pz = GetPlayerPosition()

		maxdist = maxdist or 100

		--update - check player los to blink pos and z dif before tracline from blink pos to unit
		--thoughts - prio blink pos change: furthest from all units with interrupts > lowest z dif
		local all_checks = {}
		local points = {}
		for i=0,math.pi*2,.1256 do
			local bx, by, bz = GroundZ ( px + 20 * math.cos(i), py + 20 * math.sin(i), pz )
			if bx and by and bz and not TraceLine( px, py, pz + 1.2, bx, by, bz + 1.2, collisionflags ) then
				all_checks[i] = true
				local zdif = pz - bz
				--max z dif of 1 yd
				if zdif < 1.25 and zdif > -1.25 then
					--make negative zdif positive for proper sorting (don't want climbing angle too high or too low)
					if zdif < 0 then zdif = -zdif end
					if not TraceLine( bx, by, bz + 1.5, x, y, z + 1.5, losflags ) then
						local dist_to_unit = GetDistanceBetweenPositions(x,y,z,bx,by,bz) - UnitCombatReach("player") - UnitCombatReach(unit)
						if dist_to_unit < maxdist then
							table.insert(points,{x=bx,y=by,z=bz,dist=dist_to_unit,zdif=math.floor(zdif)})
						end
					end
				end
			else
				all_checks[i] = false
			end
		end

		table.sort(points,function(x,y) return x.zdif < y.zdif or ( x.zdif == y.zdif and x.dist < y.dist ) end)

		if #points > 0 then
			if #points == 1 then
				return points[1].x,points[1].y,points[1].z
			else
				local index = math.ceil(#points/4)
				local a,b,c = points[index].x,points[index].y,points[index].z
				return a,b,c,points[index].dist
			end
		end

		-- if #points > 0 then
		-- 	if #points == 1 then
		-- 		local a,b,c = GroundZ(points[1].x,points[1].y,points[1].z)
		-- 		return a,b,c,points[1].dist
		-- 	else
		-- 		local index = math.ceil(#points/3)
		-- 		local a,b,c = GroundZ(points[index].x,points[index].y,points[index].z)
		-- 		return a,b,c,points[index].dist
		-- 	end
		-- end

	end

	function africa_blink()

		local px, py, pz = GetPlayerPosition()

		local points = {}
		for i=0,math.pi*2,.1256 do
			local bx, by, bz = GroundZ ( px + 20 * math.cos(i), py + 20 * math.sin(i), pz )
			if bx and by and bz and not TraceLine( px, py, pz + 1.2, bx, by, bz + 1.2, collisionflags ) then
				local zdif = pz - bz
				--max z dif of 1 yd
				if zdif < 1.25 and zdif > -1.25 then
					--make negative zdif positive for proper sorting (don't want climbing angle too high or too low)
					if zdif < 0 then zdif = -zdif end
					local _,_,avg_dist = Enemies_Around_Point(bx,by,bz,50)
					if avg_dist then
						table.insert(points,{x=bx,y=by,z=bz,dist=avg_dist,zdif=math.floor(zdif)})
					end
				end
			end
		end

		table.sort(points,function(x,y) return x.dist > y.dist end)

		if #points > 0 then
			if #points == 1 then
				return points[1].x,points[1].y,points[1].z
			else
				local index = math.ceil(#points/8)
				local a,b,c = points[index].x,points[index].y,points[index].z
				return a,b,c,points[index].dist
			end
		end

	end

	function best_meteor_point(unit,keypress,override)

		if not unit then return end

		-- local ux,uy,uz = ObjectPosition(unit)
		local ux,uy,uz = PredictUnitPosition(unit,.45)
		if not ux then
			ux,uy,uz = ObjectPosition(unit)
		end

		local px,py,pz = GetPlayerPosition()

		local points = {}

		local base_speed = select(2,GetUnitSpeed(unit))
		local current_speed = GetUnitSpeed(unit)
		local moving = current_speed > 0 or _isMoving(unit)

		local cc = _CCremains(unit)

		local meteor_impact_diameter = 8.75

		--maximum distance from unit that meteor will be placed
		local true_max_dist = 7
		true_max_dist = true_max_dist + (cc > 0 and not moving and round(min(1.5, cc)*.33, 1) or 0) -- true max dist can be complete edge if they will be cc'd in place for the entire 1.5 sec

		local dist = true_max_dist

		if cc > 1.5 and not moving then
			-- everything is good
		elseif cc > 1.5 then
			dist = dist - (current_speed / 2)
		elseif moving then
			dist = dist - (current_speed / 1.2) - 1 + (keypress and .5 or 0)
		else
			dist = dist - (base_speed / (2.5 + Enemies_Around_Point(x,y,z,meteor_impact_diameter*1.5))) + min(1.5,_rootRemains(unit)) + (keypress and .5 or 0) + (unit_casting_info(unit) and 1 or 0) + (_isDummy(unit) and 2 or 0)
		end

		if override then dist = override end

		-- if keypress then dist = dist * 1.15 end
		if dist < 0 then dist = 0 end
		if dist > true_max_dist then dist = true_max_dist end

		local flamecannon_stacks = _buffStacks("player",203285)
		local flamecannon_value = (flamecannon_stacks * 3)

		local meteor_range = 39.5 + flamecannon_value

		local circ = ( override and (math.pi*2) / 4 or (math.pi*2) / 16 )
		for d=.3,dist,((dist-.3)/9) do
			for i=0,math.pi*2,circ do
				local x,y,z = GroundZ (ux + d * math.cos(i), uy + d * math.sin(i), uz+2)
				if x and y and z and not TraceLine(x, y, z+1.7, px, py, pz+1.7, losflags) and not TraceLine(x, y, z+1.1, ux, uy, uz+1.1, losflags) and GetDistanceBetweenPositions(x,y,z,px,py,pz) < meteor_range then
					local hit,bcc,avg = Enemies_Around_Point(x,y,z,meteor_impact_diameter,unit)
					if bcc == 0 then
						local zdif = z - uz
						zdif = math.abs(zdif)
						if d+zdif <= true_max_dist then
							table.insert(points,{x=x,y=y,z=z,hit=hit,avg=avg})
						end
					end
				end
			end
		end

		table.sort(points,function(x,y) return x.hit < y.hit or (x.hit == y.hit and x.avg > y.avg) end)

		if #points > 0 then
			local x,y,z = points[1].x,points[1].y,points[1].z
			if points[1].hit > 0 and not override then
				return best_meteor_point(unit,keypress,0)
			end
			return x,y,z,points[1].hit,points[1].avg
		elseif keypress then
			Squid_Alert_Big("No viable meteor point",nil,nil,nil,153561)
		end

	end

	-- function best_meteor_point(unit,keypress)
	-- 	if not unit then return end
	-- 	local ux,uy,uz
	-- 	if keypress then
	-- 		ux,uy,uz = PredictUnitPosition(unit,.3)
	-- 	else
	-- 		ux,uy,uz = ObjectPosition(unit)
	-- 	end

	-- 	local px,py,pz = GetPlayerPosition()

	-- 	local cc = _CCremains(unit)

	-- 	local speed = select(4,GetUnitSpeed(unit))
	-- 	local actualspeed = GetUnitSpeed(unit)

	-- 	local points = {}

	-- 	local meteor_impact_diameter = 8.75

	-- 	--max dist from target to place meteor
	-- 	local dist = 7.5

	-- 	local is_slowed, slow_percent = unit_is_slowed(unit)

	-- 	local minmaxdist = (slow_percent >= 60 and 6
	-- 					or slow_percent >= 40 and 5
	-- 					or slow_percent >= 30 and 4.5
	-- 					or slow_percent >= 20 and 4
	-- 					or GetUnitSpeed(unit) > 12 and (2 - (_isMoving(unit) and 2 or 0))
	-- 					or GetUnitSpeed(unit) > 9 and (2.6 - (_isMoving(unit) and 2 or 0))
	-- 					or not _isMoving(unit) and (5.25 + ((unit_casting_info(unit) or _rootCheck(unit)) and 2 or 0))
	-- 					or 3)

	-- 	-- reduce max dist based on target cc remaining
	-- 	if cc < 1 then
	-- 		if cc > 0 then
	-- 			local reduc = (7-(cc*8))
	-- 			if reduc > 0 then
	-- 				dist = dist - reduc
	-- 			end
	-- 			if _isMoving(unit) and dist > 0 then
	-- 				dist = dist - (actualspeed/2)
	-- 			end
	-- 			if dist < 0 then dist = .3 end
	-- 		else
	-- 			if _isMoving(unit) then
	-- 				dist = minmaxdist
	-- 			else
	-- 				if not unit_casting_info(unit) and not _rootCheck(unit) and not _isDummy(unit) then
	-- 					dist = minmaxdist - .3
	-- 				else
	-- 					dist = minmaxdist + .6
	-- 				end
	-- 			end
	-- 		end
	-- 	end

	-- 	if keypress and dist < minmaxdist then dist = minmaxdist end -- minimum max dist when pressed manually
	-- 	if dist < 0 then dist = 0 end

	-- 	if _isMoving(unit) then
	-- 		if dist > 7 then dist = 7 end
	-- 	else
	-- 		if dist > 7.5 then dist = 7.5 end
	-- 	end

	-- 	local flamecannon_stacks = _buffStacks("player",203285)

	-- 	local flamecannon_value = (flamecannon_stacks * 3)

	-- 	local meteor_range = 39.5 + flamecannon_value

	-- 	local circ = (math.pi*2) / 14

	-- 	if cc <= 0 then
	-- 		if GetUnitSpeed(unit) >= 8 then
	-- 			local ux,uy,uz = PredictUnitPosition(unit,.75)
	-- 			for d=.3,dist,((dist-.3)/10) do
	-- 				for i=0,math.pi*2,circ do
	-- 					local x,y,z = GroundZ (ux + d * math.cos(i), uy + d * math.sin(i), uz+2)
	-- 					if x and y and z and not TraceLine(x, y, z+1.7, px, py, pz+1.7, losflags) and not TraceLine(x, y, z+1.5, ux, uy, uz+1.5, losflags) and GetDistanceBetweenPositions(x,y,z,px,py,pz) < meteor_range then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
	-- 						local mx = x
	-- 						local my = y
	-- 						local mz = z
	-- 						-- local dist = GetDistanceBetweenPositions(px,py,pz,mx,my,mz)
	-- 						local hit,bcc,avg = Enemies_Around_Point(mx,my,mz,meteor_impact_diameter,unit)
	-- 						if bcc == 0 and (d >= 6.5 or hit == 0 or keypress) then
	-- 							local zdif = mz - uz
	-- 							zdif = math.abs(zdif)
	-- 							if d+zdif <= 7.5 then
	-- 								table.insert(points,{xx=mx,yy=my,zz=mz,hit=hit,avg=avg})
	-- 							end
	-- 						end
	-- 					end
	-- 				end
	-- 			end
	-- 		else
	-- 			for d=.3,dist,((dist-.3)/10) do
	-- 				for i=0,math.pi*2,circ do
	-- 					local x,y,z = GroundZ (ux + d * math.cos(i), uy + d * math.sin(i), uz+2)
	-- 					if x and y and z and not TraceLine(x, y, z+1.7, px, py, pz+1.7, losflags) and not TraceLine(x, y, z+1.5, ux, uy, uz+1.5, losflags) and GetDistanceBetweenPositions(x,y,z,px,py,pz) < meteor_range then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
	-- 						local mx = x
	-- 						local my = y
	-- 						local mz = z
	-- 						-- local dist = GetDistanceBetweenPositions(px,py,pz,mx,my,mz)
	-- 						local hit,bcc,avg = Enemies_Around_Point(mx,my,mz,meteor_impact_diameter,unit)
	-- 						print(dist)
	-- 						if bcc == 0 and (d >= 6.5 or hit == 0 or keypress) then
	-- 							local zdif = mz - uz
	-- 							zdif = math.abs(zdif)
	-- 							if d+zdif <= 7.5 then
	-- 								table.insert(points,{xx=mx,yy=my,zz=mz,hit=hit,avg=avg})
	-- 							end
	-- 						end
	-- 					end
	-- 				end
	-- 			end
	-- 		end
	-- 	else
	-- 		for d=dist,.3,-((dist-.3)/10) do
	-- 			for i=0,math.pi*2,circ do
	-- 				local x,y,z = GroundZ (ux + d * math.cos(i), uy + d * math.sin(i), uz+2)
	-- 				if x and y and z and not TraceLine(x, y, z+1.7, px, py, pz+1.7, losflags) and not TraceLine(x, y, z+1.5, ux, uy, uz+1.5, losflags) and GetDistanceBetweenPositions(x,y,z,px,py,pz) < meteor_range then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
	-- 					local mx = x
	-- 					local my = y
	-- 					local mz = z
	-- 					-- local dist = GetDistanceBetweenPositions(px,py,pz,mx,my,mz)
	-- 					local hit,bcc,avg = Enemies_Around_Point(mx,my,mz,meteor_impact_diameter,unit)
	-- 					if bcc == 0 and (d >= 6.5 or hit == 0 or keypress) then
	-- 						local zdif = mz - uz
	-- 						zdif = math.abs(zdif)
	-- 						if d+zdif <= 7.5 then
	-- 							table.insert(points,{xx=mx,yy=my,zz=mz,hit=hit,avg=avg})
	-- 						end
	-- 					end
	-- 				end
	-- 			end
	-- 		end
	-- 	end

	-- 	table.sort(points,function(x,y) return x.hit < y.hit or (x.hit == y.hit and x.avg > y.avg) end)

	-- 	if #points > 0 then
	-- 		local a,b,c = points[1].xx,points[1].yy,points[1].zz
	-- 		print (points[1].hit)
	-- 		return a,b,c,points[1].hit
	-- 	elseif keypress then
	-- 		Squid_Alert_Big("No viable meteor point",nil,nil,nil,153561)
	-- 	end

	-- end

	function Queue_Trap(unit)
		if unit == "focus" then
			focus_trap_queued = GetTime()
		elseif unit == "healer" then
			healer_trap_queued = GetTime()
		end
	end

	function rop_unit_to_unit(unit,unit2)
		if not unit or not unit2 then return end
		local x,y,z = ObjectPosition(unit)
		local x2,y2,z2 = ObjectPosition(unit2)

		-- x,y,z = GroundZ(x,y,z)

		local points = {}

		local direction
		for i=0,math.pi*2,.4 do
			local x,y,z = GroundZ (x + 2 * math.cos(i), y + 2 * math.sin(i), z)
			if not TraceLine(x, y, z+2, x2, y2, z2+2, losflags) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
				direction = i
				local mx = x --+ 7.25 * math.cos(direction)
				local my = y --+ 7.25 * math.sin(direction)
				local mz = z
				local dist = GetDistanceBetweenPositions(x2,y2,z2,mx,my,mz)
				table.insert(points,{x=mx,y=my,z=mz,dist=dist})
			end
		end

		table.sort(points,function(x,y) return x.dist > y.dist end)

		if #points > 0 then
			local a,b,c = points[1].x,points[1].y,points[1].z
			return a,b,c,points[1].dist
		end

	end

	local CameraOrSelectOrMoveStart_OG
	CreateFrame("Frame"):SetScript("OnUpdate",function()
		if not IsHackEnabled then return end
		if not CameraOrSelectOrMoveStart_OG then CameraOrSelectOrMoveStart_OG = CameraOrSelectOrMoveStart end
	end)

	function ring_of_frost(unit, player_forced)
		if not IsPlayerSpell(113724) or not UnitExists(unit) then return end
		local ring_cd = _spellCooldown(113724)
		local buffer = (select(4,GetNetStats())/1000)+(2/GetFramerate())+.05
		local ring_range = 30 + (_buffStacks("player",203285) * 3)
		if ring_cd <= buffer and ( not UnitCastingInfo("player") or _castTimeLeft("player") <= buffer*1.5 ) then
			local x,y,z = ObjectPosition(unit)
			local px,py,pz = GetPlayerPosition()

			-- to the right or left side of them
			local moving_direction = GetMovingDirection(unit)
			moving_direction = mod(moving_direction + math.pi, math.pi * 1.5)
			local moving_direction_right = mod(moving_direction + math.pi, math.pi * .5)

			local step = (math.pi*2) / 12

			local direction

			if _isMoving(unit) then
				local directions = {}
				for i=0,math.pi*2,step do
					if GetDistanceBetweenPositions(x-5*math.cos(i),y-5*math.sin(i),z,px,py,pz) < ring_range and not TraceLine(x-5*math.cos(i),y-5*math.sin(i),z+1,px,py,pz+1,losflags) then
						table.insert(directions,i)
					end
				end
				local function sort_directions(dir1, dir2)
					return abs(moving_direction-dir1) < abs(moving_direction-dir2)
				end
				table.sort(directions, sort_directions)
				direction = directions[1]
			else
				for i=0,math.pi*2,step do
					if GetDistanceBetweenPositions(x-5*math.cos(i),y-5*math.sin(i),z,px,py,pz) < ring_range and not TraceLine(x-5*math.cos(i),y-5*math.sin(i),z+1,px,py,pz+1,losflags) then
						direction = i
						break
					end
				end
			end

			if direction then

				if not _isMoving("player") then

					local t = current_target

					x = x - 5 * math.cos(direction)
					y = y - 5 * math.sin(direction)

					local dir = _getMovingDirection(unit)
					local dist = ( not _CCcheck(unit) and GetUnitSpeed(unit) * (squid_avg_latency + (_castTime(113724)/4) + .25) or ( UnitDebuffID(unit,118699) or UnitDebuffID(unit,8122) ) and GetUnitSpeed(unit) * ( _castTime(113724) + squid_avg_latency + squid_avg_home_latency + (1/GetFramerate()) ) or GetUnitSpeed(unit)/5.6 )
					x = x + dist * math.cos(dir)
					y = y + dist * math.sin(dir)

					if not SQUID.streaming_mode or player_can_see_coords(x,y,z) then

						local target_existed = UnitExists("target")

						CameraOrSelectOrMoveStop()

						CameraOrSelectOrMoveStart = function() end

						SQ_CastSpellByID(113724)

						ClickPosition(x, y, z)

						Squid_Alert_Big("Ring of Frost",UnitClass(unit),nil,nil,113724)

						if target_existed then _targetLastTarget() end

						C_Timer.After(.1,function() CameraOrSelectOrMoveStart = CameraOrSelectOrMoveStart_OG; if target_existed then _targetLastTarget() end end)
					end
				end

				if IsAoEPending() then
					CancelPendingSpell();
				end

				return true

			else
				CancelPendingSpell()
			end
		end
	end

	function door_of_shadows(unit)

		local x,y,z = PredictUnitPosition(unit,.4)
		local px,py,pz = GetPlayerPosition()

		if not _isMoving("player") and _spellCooldown(300728) == 0 then
			if GetDistanceBetweenPositions(px,py,pz,x,y,z) < 35 then
				if not SQUID.streaming_mode or player_can_see_coords(x,y,z) then

					local target_existed = UnitExists("target")

					CameraOrSelectOrMoveStop()
					CameraOrSelectOrMoveStart = function() end

					SQ_CastSpellByID(300728)
					ClickPosition(x, y, z)
					Squid_Alert_Big("Door of Shadows",UnitClass(unit),nil,nil,300728)

					if target_existed then _targetLastTarget() end
					C_Timer.After(.1,function() CameraOrSelectOrMoveStart = CameraOrSelectOrMoveStart_OG; if target_existed then _targetLastTarget() end end)

					door_of_shadows_pos = {unit,x,y,z,GetTime()}

					if IsAoEPending() then
						CancelPendingSpell();
					end

				end
			end
		end

	end

	function blink_db_point(unit)

		if not UnitIsVisible(unit) then return false end
		local x,y,z = ObjectPosition(unit)
		local px,py,pz = GetPlayerPosition()

		-- local step = (math.pi*2) / 8
		-- for n=3,8 do
		-- 	for i=0,math.pi*2,step do
		-- 		if not TraceLine(x - n * math.cos(i), y - n * math.sin(i), z+2, px, py, pz+2, 0x100111) then

		local maxdist = 8

		local points = {}

		local step = (math.pi*2) / 12
		local direction
		for i=0,math.pi*2,step do
			local bx, by, bz = GroundZ ( px + 20 * math.cos(i), py + 20 * math.sin(i), pz )
			if bx and by and bz and not TraceLine(px, py, pz+1.2, bx, by, bz+1.2, collisionflags) then
				local zdif = pz - bz
				if zdif < 1.5 and zdif > -1.5 then
					if zdif < 0 then zdif = -zdif end
					if not TraceLine( bx, by, bz + 1.7, x, y, z + 1.7, losflags ) then
						local dist = GetDistanceBetweenPositions(x,y,z,bx,by,bz)
						if dist < maxdist then
							table.insert(points,{x=bx,y=by,z=bz,dist=dist,zdif=math.floor(zdif)})
						end
					end
				end
			end
		end

		table.sort(points,function(x,y) return x.zdif < y.zdif or ( x.zdif == y.zdif and x.dist < y.dist ) end)

		if #points > 0 then
			if #points == 1 then
				local a,b,c = points[1].x,points[1].y,points[1].z
				return a,b,c,points[1].dist
			else
				-- local a,b,c = GroundZ(points[1].x,points[1].y,points[1].z)
				-- return a,b,c,points[1].dist
				local index = math.ceil(#points/4)
				local a,b,c = points[index].x,points[index].y,points[index].z
				return a,b,c,points[index].dist
			end
		end

	end

	function blink_to_db(unit)

		local time = GetTime()

		if not Squid_DB then return false end

		if _spellCooldown(31661) > GetGCD()+.1 then return false end

		if not UnitIsVisible(unit) then return false end

		local px,py,pz = GetPlayerPosition()

		local x,y,z = blink_db_point(unit)

		if _realDistance(unit) > 10.5 then
			if x and y and z and _spellCooldown(212653) == 0 and (not player_blink or time - player_blink > .65) then
				local dir = GetAnglesBetweenPositions(px,py,pz,x,y,z)
				FaceDirection(dir,true)
				if Player_Facing(dir) then
					SQ_CastSpellByID(1953)
					player_blink = time
					return true
				end
			end
		end

	end

	function blink_db(unit)

		local time = GetTime()

		if not Squid_DB then return false end

		if _spellCooldown(31661) > .1 then return false end

		if not UnitIsVisible(unit) then return false end

		local px,py,pz = GetPlayerPosition()

		local x,y,z = blink_db_point(unit)

		if _distance(unit) > 12.5 then
			if x and y and z and _spellCooldown(212653) == 0 and (not player_blink or time - player_blink > squid_avg_latency + .5) and not _isMoving("player") then
				local dir = GetAnglesBetweenPositions(px,py,pz,x,y,z)
				FaceDirection(dir,true)
				local c = ObjectFacing("player")
				if Player_Facing(dir) then
					SQ_CastSpellByID(1953)
					player_blink = time
					return true
				end
			end
		else
			x,y,z = PredictUnitPosition(unit,.08)
			if GetDistanceBetweenPositions(x,y,z,px,py,pz) < 9.25 and not TraceLine(x,y,z+1.6,px,py,pz+1.6,losflags) then
				if unit_casting_info("player") ~= "Greater Pyroblast" then
					SpellStopCasting()
				end
				return Squid_DB(unit)
			end
		end

	end

	function RopPosition(x,y,z)
		if _Cast(116844) then
			ClickPosition(x,y,z)
			Squid_Alert_Big("Ring of Peace","(Double Stun)",1,nil,116844)
		end
		CancelPendingSpell()
	end

	function MaxDistLoS(unit,distance)

		local px,py,pz=GetPlayerPosition();

		if not distance then return; end
		if not ObjectIsVisible(unit) then return; end

		local ux,uy,uz=ObjectPosition(unit);

		local distanceToUnit = _distance(unit);

		local coords = {};

		for i=1,math.pi*2,.05 do
			local x = px + distance * math.cos(i);
			local y = py + distance * math.sin(i);
			local newx,newy,newz=x,y,pz
			local z = newz or pz
			local dist = _distanceToCoord(x,y,z,ux,uy,uz);
			local zdiff = z-pz
			local los = not TraceLine(x,y,z+2,ux,uy,uz+2,0x10) and 1 or 0;
			local lospoint = not TraceLine(x,y,z+2,px,py,pz+2,0x10) and 1 or 0;
			-- print("Grounded: "..z)
			-- print("Current: "..pz)
			if los == 1 and lospoint == 1 and zdiff < 7 and zdiff > -7 then
				table.insert(coords,{x=x,y=y,z=z,dist=dist,los=los})
			end
		end
		table.sort(coords,function(x,y) return x.los > y.los or (x.los == y.los and x.dist > y.dist) end);

		--mid
		local num=#coords
		-- print(num)
		if #coords > 0 then
			--further we are away, the wider the angle.
			local mod = distanceToUnit/distance
			if mod > 1 then mod=1; end
			if mod < .01 then mod=.01; end
			num=math.ceil(#coords*mod);
		end

		if coords[1] and coords[num].los == 1 then
			return coords[num].x,coords[num].y,coords[num].z;
		end

	end

	-- Turn the player towards a point
	function _faceLocation(X,Y,Z)
		local PlayerX, PlayerY, PlayerZ = GetPlayerPosition();

		-- if rad(atan2(Y - PlayerY, X - PlayerX)) < 0 then
		local dir = GetAnglesBetweenPositions(PlayerX,PlayerY,PlayerZ,X,Y,Z)
		FaceDirection(dir,true)
			-- FaceDirection(rad(atan2(Y - PlayerY, X - PlayerX) + 360),true);
		-- end
		return;
	end

	function _faceAwayFrom(X,Y)
		local PlayerX, PlayerY = GetPlayerPosition();
		if rad(atan2(Y - PlayerY, X - PlayerX)) < 0 then
			FaceDirection(rad(atan2(Y - PlayerY, X - PlayerX) + 360));
		else
			FaceDirection(rad(atan2(Y - PlayerY, X - PlayerX)));
		end
		FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true)
		return;
	end

	function _faceAwayFromUnit(unit)
		if not ObjectIsVisible(unit) then return false; end
		_faceAwayFrom(ObjectPosition(unit));
	end

	function _faceUnit(unit)
		FaceDirection(_anglesBetweenObjects("player",unit),true)
	end

	local beastbuff			=
	{
	5487,		-- Bear
	768,		-- Cat
	783,		-- Travel
	33891, 		-- Tree
	24858,		-- Moonkin
	197625,		-- Balance Affinity Moonkin
	-- 171746,		-- Claws of Shirvallah Cat
	}
	function _isBeast(unit)
		for i=1,#beastbuff do
			if UnitBuffID(unit,beastbuff[i]) then
				return true;
			end
		end
	end

	--retreat forward (for macro)
	function RetreatForward()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		if _spellCooldown(198793) <= gcd then

			if unit_casting_info("player") then
				SpellStopCasting();
				RunMacroText("/stopcasting")
				return
			end

			if _spellCooldown(198793) == 0 then

				if not IsFlying() and not IsSwimming() then
				if not IsFalling() then JumpOrAscendStart(); end
				JumpOrAscendStart();
				end
				TurnOrActionStart();
				FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true)
				_Cast(198793);
				Squid_Alert("Retreat Forward",nil,nil,nil,198793)
				C_Timer.After(0.4 + (select(4,GetNetStats())/1000), function()
					TurnOrActionStart()
					FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true)
				end)
				PauseGCD = GetTime()
				C_Timer.After(.8, function()
				if IsMouselooking() and not IsMouseButtonDown(2) then
					MouselookStop()
				end end)
				return;
			end

		end
	end

	function RetreatToUnit(unit,los,close)
		if not UnitIsVisible(unit) then return false; end
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		local facing = ObjectFacing("player");
		if _spellCooldown(198793) == 0 and not UnitBuffID("player",209426) then
			--closest possible point
			if close then
				local x,y,z = _findCorner(unit,15);
				if x and y and z then
					return RetreatToCoords(x,y,z);
				end
				return;
			end
			--directly towards
			if not los then
				if not IsFlying() and not IsSwimming() and not IsFalling() then
					JumpOrAscendStart();
				end
				TurnOrActionStart();
				_faceAwayFromUnit(unit);
				_Cast(198793);
				C_Timer.After(0.4 + ((select(4,GetNetStats())/1000)+.025),
				function()
					TurnOrActionStart();
					FaceDirection(facing,true);
					end)
				C_Timer.After(1,
				function()
					if IsMouselooking() and not IsMouseButtonDown(2) then
						MouselookStop();
					end
				end)
				return true;
			else
				--into their LoS
				local x,y,z=MaxDistLoS(unit,15);
				if x and y and z then
					return RetreatToCoords(x,y,z);
				end
			end
		end
	end

	function RetreatToCoords(x,y,z)
		if _spellCooldown(198793) == 0 then
			local facing=ObjectFacing("player");
			if not IsFlying() and not IsSwimming() and not IsFalling() then
				JumpOrAscendStart();
			end
			TurnOrActionStart();
			_faceAwayFrom(x,y);
			_Cast(198793);
			C_Timer.After(0.4 + ((select(4,GetNetStats())/1000)+.025),
			function()
				TurnOrActionStart();
				FaceDirection(facing,true);
				end)
			C_Timer.After(1,
			function()
				if IsMouselooking() and not IsMouseButtonDown(2) then
					MouselookStop();
				end
			end)
			return true;
		end
	end

	--Disengage to a target
	function _disengageToUnit(unit,los,close)
		if not UnitIsVisible(unit) then return false end
		local facing = ObjectFacing("player")
		if _spellCooldown(781) == 0 then
			--closest possible point
			if close then
				local x,y,z = _findCorner(unit,15);
				if x and y and z then
					return _disengageToCoords(x,y,z)
				end
				return;
			end
			--directly towards
			if not los then
				if not IsFlying() and not IsSwimming() and not IsFalling() then
					JumpOrAscendStart()
				end
				TurnOrActionStart()
				_faceAwayFromUnit(unit)
				_Cast(781);
				C_Timer.After(0.4 + ((select(4,GetNetStats())/1000)+.025),
				function()
					TurnOrActionStart()
					FaceDirection(facing,true)
					end)
				C_Timer.After(1,
				function()
					if IsMouselooking() and not IsMouseButtonDown(2) then
						MouselookStop()
					end
				end)
				return true;
			else
				--into their LoS
				local x,y,z=MaxDistLoS(unit,15);
				if x and y and z then
					return _disengageToCoords(x,y,z)
				end
			end
		end
	end

	disengage_to_unit = _disengageToUnit

	function DisengageForward()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		if _spellCooldown(781) <= gcd then

			if unit_casting_info("player") then
				SpellStopCasting();
				RunMacroText("/stopcasting")
				return
			end

			if _spellCooldown(781) == 0 then

				if not IsFlying() and not IsSwimming() then
					if not IsFalling() then JumpOrAscendStart(); end
					JumpOrAscendStart();
				end
				TurnOrActionStart();
				FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true)
				_Cast(781);
				C_Timer.After(0.4 + (select(4,GetNetStats())/1000), function()
				TurnOrActionStart()
				FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true) end)
				C_Timer.After(1, function()
				if IsMouselooking() and not IsMouseButtonDown(2) then
					MouselookStop()
				end end)
				return;
			end

		end
	end

	function _disengageToCoords(x,y,z)
		if _spellCooldown(781) == 0 then
			local facing=ObjectFacing("player");
			if not IsFlying() and not IsSwimming() and not IsFalling() then
				JumpOrAscendStart();
			end
			TurnOrActionStart();
			_faceAwayFrom(x,y);
			_Cast(781);
			C_Timer.After(0.4 + ((select(4,GetNetStats())/1000)+.025),
			function()
				TurnOrActionStart();
				FaceDirection(facing,true);
				end)
			C_Timer.After(1,
			function()
				if IsMouselooking() and not IsMouseButtonDown(2) then
					MouselookStop();
				end
			end)
			return true;
		end
	end


	function basic_path_to_position(x,y,z)

		local px,py,pz = GetPlayerPosition()
		local dist = GetDistanceBetweenPositions(x,y,z,px,py,pz)

		local positions = {}
		for i=0,dist*2,1.5 do
			for n=0,math.pi*2,.78539816339745 do
				local nx,ny,nz = px + i * math.cos(n), py + i * math.sin(n), pz
				if not TraceLine(nx, ny, nz+2, px, py, pz+2, collisionflags) and not TraceLine(nx, ny, nz+2, x, y, z+2, collisionflags) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
					local dist = GetDistanceBetweenPositions(nx,ny,nz,x,y,z)
					table.insert(positions, {nx,ny,nz,dist=dist} )
				end
			end
		end

		table.sort(positions,function(x,y) return x.dist < y.dist end)

		if #positions > 0 then
			return positions[1][1],positions[1][2],positions[1][3]
		end

	end

	--arena map ids
	--Dalaran Sewers - 617
	--Robodrome - 2167
	function basic_path_to_unit(unit)
		if not UnitIsVisible(unit) then return false end
		local px,py,pz = ObjectPosition("player")
		local x,y,z = ObjectPosition(unit)
		x,y,z = GroundZ(x,y,z)
		px,py,pz = GroundZ(px,py,pz)

		local zdif = z - pz

		--hardcode coords to reach high ground
		local map_id = GetMapId()

		--dalaran sewers
		if map_id == 617 then
			local corner_ramps = {
				{1316.4604,815.6157,6.3605},
				{1316.4291,766.1436,6.3000},
				{1267.0081,766.3588,6.3912},
				{1267.4458,815.8305,6.4436}
			}
			if zdif > .95 then
				local cache = 9999
				local closest
				for i=1,#corner_ramps do
					local c = corner_ramps[i]
					local cx,cy,cz = c[1],c[2],c[3]
					local dist = GetDistanceBetweenPositions(px,py,pz,cx,cy,cz)
					if dist < cache then
						cache = dist
						closest = i
					end
				end
				if closest then
					return unpack( corner_ramps[closest] )
				end
			end
		elseif map_id == 1672 then
			local ramps = {
					--base of ramp                         top of ramp
				{ {2805.7695,5983.1801,-4.2972}, {2793.9577,5997.3959,4.8389} },
				{ {2768.8527,5955.9843,-3.6616}, {2757.9562,5970.0986,4.7787} },
				{ {2737.4426,5995.3120,-3.4376}, {2749.0620,5981.2573,4.2135} },
				{ {2770.2729,6026.2255,-3.773}, {2781.1542,6012.4321,4.7856} },
				{ {2803.1135,6051.0087,-3.7833}, {2815.1135,6035.5317,4.335} },
				{ {2836.7836,6011.1787,-3.8473}, {2824.0773,6026.0371,4.6} },
			}
			if zdif > 7.2 then
				local cache = 9999
				local closest
				for i=1,#ramps do
					local r = ramps[i]
					local bx,by,bz = r[1][1], r[1][2], r[1][3]
					local dist = GetDistanceBetweenPositions(px,py,pz,bx,by,bz)
					if dist < cache then
						cache = dist
						closest = i
					end
				end
				if closest then
					if cache > 1.5 then
						return basic_path_to_position ( unpack ( ramps[closest][1] ) )
					else
						return unpack ( ramps[closest][2] )
					end
				end
			else
				if zdif > 1 then
					local cache = 9999
					local closest
					for i=1,#ramps do
						local r = ramps[i]
						local bx,by,bz = r[2][1], r[2][2], r[2][3]
						local dist = GetDistanceBetweenPositions(px,py,pz,bx,by,bz)
						local los = not TraceLine(px,py,pz+2,bx,by,bz+2,collisionflags)
						if dist < cache and los then
							cache = dist
							closest = i
						end
					end
					if closest then
						return unpack ( ramps[closest][2] )
					end
				end
			end
		end

		if _LoS(unit) then
			return x,y,z
		else
			local x,y,z = ObjectPosition(unit)
			local px,py,pz = GetPlayerPosition()
			local dist = GetDistanceBetweenPositions(x,y,z,px,py,pz)
			-- i = dist, n = direction
			local positions = {}
			for i=0,dist,2 do
				for n=0,math.pi*2,.78539816339745 do
					local nx,ny,nz = px + i * math.cos(n), py + i * math.sin(n), pz
					if not TraceLine(nx, ny, nz+2, px, py, pz+2, collisionflags) and not TraceLine(nx, ny, nz+2, x, y, z+2, collisionflags) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
						local dist = GetDistanceBetweenPositions(nx,ny,nz,x,y,z)
						table.insert(positions, {nx,ny,nz,dist=dist} )
					end
				end
			end
			table.sort(positions,function(x,y) return x.dist < y.dist end)
			if #positions > 0 then
				return positions[1][1],positions[1][2],positions[1][3]
			end
		end
	end

	--mastery 10yd
	--75 20yd
	--25 30yd
	--0 40yd

	--(40 - _distance("target"))* 28 / 100
	spell_effect_cache = {}

	function GetSpellEffect(spellID)
		if not spellID then return end
		if spell_effect_cache[spellID] then return spell_effect_cache[spellID] end
		local desc = GetSpellDescription(spellID);
		local blocks = {};
		for n in desc:gmatch("%S+") do
			table.insert(blocks,n);
		end
		local good = {}
		for i=1,#blocks do
			local s = string.gsub(blocks[i],",","");
			table.insert(good,s);
		end
		local reallygood={};
		for i=1,#good do if tonumber(good[i]) then table.insert(reallygood,tonumber(good[i])); end end
		table.sort(reallygood, function(x,y) return x > y end)
		spell_effect_cache[spellID] = reallygood[1]
		return reallygood[1]
	end

	local CostTip = CreateFrame('GameTooltip')
	local CostText = CostTip:CreateFontString()
	CostTip:AddFontStrings(CostTip:CreateFontString(), CostTip:CreateFontString())
	CostTip:AddFontStrings(CostText, CostTip:CreateFontString())
	function PowerCostFromTooltip(spellID) -- returns the value of the second line of the tooltip
		if not spellID then return end
		CostTip:SetOwner(WorldFrame, 'ANCHOR_NONE')
		CostTip:SetSpellByID(spellID)
		return CostText:GetText()
	end

	--Get the cost (number)
	function GetSpellCost(spellID)
		local costText = PowerCostFromTooltip(spellID) -- get the line out of the tooltip
		local costString = {};
		for w in costText:gmatch("%S+") do if tonumber(w) then table.insert(costString,w) end end
		local cost=costString[1];
		if cost == nil then cost = -1 end
		return tonumber(cost);
	end

	function squid_cast(castinfo,unit)
		local name = castinfo.name
		local id = castinfo.id
		local cd = castinfo.cd
		local facing = castinfo.facing
		local immunetype = castinfo.immunetype

		local latency = (select(4,GetNetStats())/1000)
		local update = (1/GetFramerate())*2
		local spellwindow = .1

		local gcdbuffer = latency+update+spellwindow

		--dont cast spells on cd
		if cd > gcdbuffer then return false end

		--dont cast while casting, unless it's a spell that can do that
		local castable_while_casting = {
		"Fire Blast",
		"Enveloping Mist",
		"Vivify",
		"Surging Mist",
		}

		local cast = unit_casting_info("player")
		local channel = UnitChannelInfo("player")

		if (cast or channel) and not tContains(castable_while_casting,name) then return false end

		--check facing if required
		if unit and facing == true and not am_i_facing(unit) then return false end

		--check immunities
		if immunetype and unit then
			if immunetype == "magic" and _immuneMagic(unit) then return false end
			if immunetype == "physical" and _immunePhysical(unit) then return false end
		end

		--casts with designated unit
		if unit then
			if _spellInRange(id,unit) and _LoS(unit) then
				--force facing the unit
				if facing == "force" then
					if IsUsableSpell(name) then
						local facing = ObjectFacing("player");
						FaceDirection(_anglesBetweenObjects("player",unit))
						SQ_CastSpellByName(name,unit)
						FaceDirection(facing)
					end
				else
					SQ_CastSpellByName(name,unit)
				end
				return true
			end
			SQ_CastSpellByName(name,"");
			if IsPlayerSpell(id) then return true; end
		end
	end

	local only_by_id = {
		[118] = true,		-- Sheep
		[28272] = true,		-- Pig
		[277792] = true,		-- Bee
		[161354] = true,		-- Monkey
		[277787] = true,		-- Direhorn
		[161355] = true,		-- Penguin
		[161353] = true,		-- Polar Bear
		[120140] = true,		-- Porcupine
		[61305] = true,		-- Cat
		[61721] = true,		-- Rabbit
		[61780] = true,		-- Turkey
		[28271] = true,		-- Turtle
	}

	next_cast_attempt = {}
	function _Cast(spell,unit,requiresfacing,forcefacing,ignorecc,forcequeue)

		local spell_string = tostring(spell)
		local unit_string = tostring(unit)
		local rf_string = tostring(requiresfacing)
		local ff_string = tostring(forcefacing)
		local icc_string = tostring(ignorecc)

		local arg_string = spell_string..unit_string..rf_string..ff_string..icc_string

		local latency = select(4,GetNetStats())/1000
		local update = 1/GetFramerate()
		local time = GetTime()

		if next_cast_attempt[arg_string] and time < next_cast_attempt[arg_string] and IsSpellOnGCD(spell) then
			return true
		end

		if dumpstuff then
			local cd,unit,spellid,req,facing,ignorecc = _spellCooldown(spell),unit or "No Unit",(spell or "No Spell"),(requiresfacing and "Yes" or "No"),(forcefacing and "Yes" or "No"),(ignorecc and "No" or "Yes")
			if spellid and (spell_logged ~= spellid) then
				spell_logged = spellid
				WriteFile("SquidDump.txt", "SpellID = "..spellid..", Target = "..unit..", ReqFacing = "..req.. ", ForceFacing = " ..facing.. ", IgnoreControl = " ..ignorecc .."\n", true)
			end
		end

		if unit and (UnitIsDeadOrGhost(unit) or UnitIsDead(unit)) then return false end

		local spellName = GetSpellInfo(spell)
		if not spellName then return end

		local buffer = latency+update+.25

		-- no stupid rune of powers
		if spell == 116011 then
			--devour magic (Nya - Maut)
			if UnitDebuffID("player",307806) then return false end
		end

		if spell == 223829 and not IsPlayerSpell(spell) then
			spell=55090;
		end

		if _spellCooldown(spell) > buffer then return false; end

		if AlwaysFacing and unit then forcefacing=true end

		--do not begin casts with quaking debuff
		local quaking_remains = _debuffRemains("player",240447)
		if quaking_remains > 0 and _castTime(spell) > 0 and _castTime(spell) > quaking_remains - 0.5 then return false end

		if UnitBuffID("player",227847) then
			if spellid ~= 97462 then return false; end
		end

		if not player_has_control() and not ignorecc then return false end

		local castableWhileCasting = {
			"Fire Blast",
			"Enveloping Mist",
			"Vivify",
			"Surging Mist",
			"Touch of Karma",
			"Combustion",
		}

		local queueSpells = {
			"Pyroblast",
			"Breath of the Dying",
			-- "Frost Nova",
		}

		if (UnitChannelInfo("player") or unit_casting_info("player") and (not tContains(queueSpells,spellName) and not forcequeue or _castTimeLeft("player") > buffer * 1.45)) and not tContains(castableWhileCasting,spellName) then
			return false;
		end

		if forcefacing then

		else
			if requiresfacing and not _amIfacing(unit) then return false; end
		end

		local casttime = _castTime(spell)

		if casttime > 0 then
			if current_cast_delay and time - current_cast_delay < .13 then
				return false
			end
		end

		local moving_spells = {
			2948,		--scorch
		}

		local min = 10
		local max = 60
		local delay = math.random(min,max) / 1000

		if unit then

			if IsPlayerSpell(spell) then
				if _castTime(spell) <= 0 or tContains(moving_spells,spell) or not _isMoving("player") or UnitBuffID("player",79206) or UnitBuffID("player",12042) or UnitBuffID("player",108839) then
					if _spellInRange(spell,unit) and _LoS(unit) then
						if forcefacing then
							local facing = ObjectFacing("player");
							FaceDirection(_anglesBetweenObjects("player",unit),true);
							if only_by_id[spell] then
								SQ_CastSpellByID(spell,unit)
							else
								SQ_CastSpellByName(spellName,unit)
							end
							FaceDirection(facing,true);
							next_cast_attempt[arg_string] = time + delay
							if spell == 257541 then
								pf_flying = time
							end
							if spell == 11366 then
								pyro_flying = time
							end
						else
							if only_by_id[spell] then
								SQ_CastSpellByID(spell,unit)
							else
								SQ_CastSpellByName(spellName,unit)
							end
							next_cast_attempt[arg_string] = time + delay
							if spell == 257541 then
								pf_flying = time
							end
							if spell == 11366 then
								pyro_flying = time
							end
						end
						return true;
					end
				end
			end
		else
			-- SQ_CastSpellByName(spellName,"");
			if only_by_id[spell] then
				SQ_CastSpellByID(spell,"")
			else
				SQ_CastSpellByName(spellName,"")
			end
			next_cast_attempt[arg_string] = time + delay
			if spell == 257541 then
				pf_flying = time
			end
			if spell == 11366 then
				pyro_flying = time
			end
			if IsPlayerSpell(spell) then return true; end
		end
	end

	function aoe_cast(spell,x,y,z)

		if not x or not y or not z then return false end

		--do not begin casts with quaking debuff
		local quaking_remains = _debuffRemains("player",240447)
		if quaking_remains > 0 and _castTime(spell) > 0 and _castTime(spell) > quaking_remains - 0.5 then return false end

		local waslooking = IsMouselooking()

		CameraOrSelectOrMoveStop()

		local CameraOrSelectOrMoveStart_OG

		if not CameraOrSelectOrMoveStart_Altered then
			CameraOrSelectOrMoveStart_OG = CameraOrSelectOrMoveStart
			CameraOrSelectOrMoveStart_Altered = true
			C_Timer.After(.05,function() CameraOrSelectOrMoveStart = CameraOrSelectOrMoveStart_OG CameraOrSelectOrMoveStart_Altered = nil if waslooking and GetKeyState(0x02) == true then MouselookStart() end end)
		end

		CameraOrSelectOrMoveStart = function() end

		if type(spell) == "number" then spell = GetSpellInfo(spell) end

		SQ_CastSpellByName(spell)

		ClickPosition(x, y, z)

		_targetLastTarget()

		if IsAoEPending() then
			CancelPendingSpell();
		end

	end

	function aoe_cast2(spell,x,y,z,nomoving,max_dist)

		local px,py,pz = GetPlayerPosition()

		if GetDistanceBetweenPositions(px,py,pz,x,y,z) > max_dist then return false end

		if TraceLine(px,py,pz+2,x,y,z+2,losflags) then return false end

		local waslooking = IsMouselooking()

		CameraOrSelectOrMoveStop()

		local CameraOrSelectOrMoveStart_OG

		if not CameraOrSelectOrMoveStart_Altered then
			CameraOrSelectOrMoveStart_OG = CameraOrSelectOrMoveStart
			CameraOrSelectOrMoveStart_Altered = true
			C_Timer.After(.05,function() CameraOrSelectOrMoveStart = CameraOrSelectOrMoveStart_OG CameraOrSelectOrMoveStart_Altered = nil _targetLastTarget() if waslooking and GetKeyState(0x02) == true then MouselookStart() end end)
		end

		CameraOrSelectOrMoveStart = function() end

		if type(spell) == "number" then spell = GetSpellInfo(spell) end

		SQ_CastSpellByName(spell)

		last_flamestrike_pos = {x = x, y = y, z = z}

		ClickPosition(x, y, z)

		_targetLastTarget()

		if IsAoEPending() then
			CancelPendingSpell();
		end

	end

	function _AeCast(spellid,unit,maxRange,diameter,nomoving,predictmovement)

		local latency = squid_avg_latency
		local update = 2/GetFramerate()

		local buffer = latency+update+.1

		if _spellCooldown(spellid) > buffer then return false end

		--do not begin casts with quaking debuff
		local quaking_remains = _debuffRemains("player",240447)
		if quaking_remains > 0 and _castTime(spellid) > 0 and _castTime(spellid) > quaking_remains - 0.5 then return false end

		local time = GetTime()

		local diameter = diameter or 0
		local radius = diameter / 2

		if type(spellid) == "number" then spellid = GetSpellInfo(spellid) end

		if nomoving and _isMoving("player") then return false end

		if IsUsableSpell(spellid) and UnitIsVisible(unit) then

			local px,py,pz = GetPlayerPosition()

			local X,Y,Z = ObjectPosition(unit)

			if not unit_casting_info("player") and not UnitChannelInfo("player") then

				local blacklisted_unit

				local name = UnitName(unit)

				local blacklist = {
				"Blackwater Behemoth",
				"Radiance of Azshara",
				"Raal the Gluttonous",
				"Slagmaw",
				"Drest'agath",
				"Horrific Hemorrhage",
				"Synthesis Growth",
				"Corrupted Neuron",
				"N'Zoth the Corruptor",
				"Omega Buster",
				"Demolishing Terror",
				"Gripping Terror",
				"Crackling Shard",
				}
				if tContains(blacklist,name) then blacklisted_unit = true end

				if blacklisted_unit then

					local points = {}

					local closest = 0

					local reach = not unit_is_player(unit) and max ( 1.5, UnitCombatReach(unit) ) or 0

					closest = max ( reach - 10, 0)

					for n=closest,reach do
						for i=0,math.pi*2 do
							local x,y,z = GroundZ ( X + ( radius + n ) * math.cos(i), Y + ( radius + n ) * math.sin(i), Z )
							if x and y and z then
								local dist = GetDistanceBetweenPositions(px,py,pz,x,y,z)
								if dist < maxRange then
									if not TraceLine(x, y, z+2, px, py, pz+2, losflags) then
										table.insert(points,{x=x,y=y,z=z,dist=dist})
									end
								end
							end
						end
					end

					table.sort(points,function(x,y) return x.dist < y.dist end)

					if #points > 0 then
						aoe_cast(spellid,points[1].x,points[1].y,points[1].z)
						return true
					end
				end

				if _realDistance(unit) <= maxRange then

					if _LoS(unit) then

						local x,y,z = GroundZ(X,Y,Z)

						aoe_cast(spellid,x,y,z)

						return true;

					elseif diameter > 0 then

						local px,py,pz = GetPlayerPosition()

						local nx,ny,nz


						for i=0,math.pi*2 do
							local x,y,z = X + radius * math.cos(i), Y + radius * math.sin(i), Z
							if not TraceLine(x, y, z+2, px, py, pz+2, losflags) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
								nx = x --+ 7.25 * math.cos(direction)
								ny = y --+ 7.25 * math.sin(direction)
								nz = z
								break
							end
						end

						if nx and ny and nz then

							aoe_cast(spellid,nx,ny,nz)

							return true;

						end

					end

				else

					local points = {}

					local reach = not unit_is_player(unit) and max ( UnitCombatReach(unit) - 1.5, 0 ) or 0

					for n=0,reach do
						for i=0,math.pi*2 do
							local x,y,z = GroundZ ( X + ( radius + n ) * math.cos(i), Y + ( radius + n ) * math.sin(i), Z )
							if x and y and z then
								local dist = GetDistanceBetweenPositions(px,py,pz,x,y,z)
								if dist < maxRange then
									if not TraceLine(x, y, z+2, px, py, pz+2, losflags) then
										table.insert(points,{x=x,y=y,z=z,dist=dist})
									end
								end
							end
						end
					end

					table.sort(points,function(x,y) return x.dist < y.dist end)

					if #points > 0 then
						aoe_cast(spellid,points[1].x,points[1].y,points[1].z)
						return true
					end

				end

			end

		end
	end

	function _AeCastPosition(spellid,X,Y,Z,maxRange)

		maxRange = maxRange or 40

		local aeCd = _spellCooldown(spellid)

		if aeCd > (select(4,GetNetStats())/1000)+.025 then return false; end

		if type(spellid) == "number" then spellid = GetSpellInfo(spellid) end

		if IsUsableSpell(spellid) then

			local px,py,pz = GetPlayerPosition()

			if not unit_casting_info("player") and not UnitChannelInfo("player") and GetDistanceBetweenPositions(X,Y,Z,px,py,pz) <= maxRange then

				if not TraceLine(px,py,pz+2,X,Y,Z+2,losflags) then

					SQ_CastSpellByName(spellid,"")
					if IsAoEPending() then
						local waslooking = IsMouselooking()
						X,Y,Z = GroundZ(X,Y,Z) -- ground z
						ClickPosition(X,Y,Z)
						_targetLastTarget()
						C_Timer.After(.05,CancelPendingSpell)
						CancelPendingSpell()
						if waslooking then MouselookStart() end
					end
					_targetLastTarget()
					CancelPendingSpell()
					return true;

				end

			end

		end
	end

	function _aeCastInMovingDirection(spellid,unit,distance,range,radius)

		if not spellid then return false; end

		range = range or 100

		local scriptUpdate = 4/GetFramerate()

		if _spellCooldown(spellid) > squid_avg_latency + scriptUpdate then return false; end

		if type(spellid) == "number" then
			spellid = GetSpellInfo(spellid)
		end

		local X, Y, Z = ObjectPosition(unit);
		local direction = _getMovingDirection(unit);

		if UnitIsVisible(unit) then
			local px,py,pz=GetPlayerPosition();
			local x = X + distance * math.cos(direction);
			local y = Y + distance * math.sin(direction);
			local z = Z;

			if not unit_casting_info("player") and not UnitChannelInfo("player") and not TraceLine(px,py,pz+2,x,y,z+2,losflags) and _distanceToCoord(x,y,z) <= range then

				x,y,z = GroundZ(x,y,z)

				if not TraceLine(px,py,pz+1.7,x,y,z+1.7,losflags) then
					aoe_cast(spellid,x,y,z)
				elseif radius then
					local found
					for i=0,math.pi*2,.5 do
						local nx,ny,nz = GroundZ(x + radius * math.cos(i), y + radius * math.sin(i), z)
						if nx and ny and nz
						and not TraceLine(x, y, z+1.7, nx, ny, nz+1.7, losflags)
						and not TraceLine(px, py, pz+1.7, nx, ny, nz+1.7, losflags) then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
							x,y,z = nx,ny,nz
							found = true
							break
						end
					end
					if found then
						aoe_cast(spellid,x,y,z)
					end
				end

				LastAttemptedSpellUnit = unit or "player";

				return true;

			end

		end

	end

	function valid_aoe(unit)
		local blacklist = {
			[120651] = true,	-- Explosives
			[161895] = true,    -- Thing From Beyond
			[158041] = true, 	-- N'Zoth
			[135903] = true,	-- Manifestation of the Deep (SoTS Last Boss)
		}
		local id = ObjectID(unit)
		if blacklist[id] then return false end
		return true
	end

	function get_enemies(thisUnit,radius,checkNoCombat,facing,aoe)

		local radius = tonumber(radius)
		local enemyTable = Enemies
		local enemiesTable = {}
		local e, distance

		if checkNoCombat == nil then checkNoCombat = false end
		if facing == nil then facing = false end

		for i=1,#enemyTable do
			e = enemyTable[i]
			distance = _distance(thisUnit,e)
			if distance < radius and (not facing or _amIfacing(e)) and valid_attackable(e) and (not aoe or valid_aoe(e)) then
				tinsert(enemiesTable,e)
			end
		end

		if #enemiesTable == 0 and UnitIsVisible(current_target) and _distance(current_target) < radius and UnitAffectingCombat(current_target) and (not facing or _amIfacing(current_target)) then
			tinsert(enemiesTable,current_target)
		end

		return enemiesTable
	end

	function get_future_position(unit, castTime)
		local distance = min ( 5, GetUnitSpeed(unit) ) * castTime
		if distance > 0 then
			local x,y,z = ObjectPosition(unit)
			local angle = _getMovingDirection(unit)--ObjectFacing(unit)
			--If Unit have a target, let's make sure they don't collide
			local unitTarget = UnitTarget(unit)
			local unitTargetDist = 0
			if unitTarget ~= nil then
				local tX, tY, tZ = ObjectPosition(unitTarget)
				--Lets get predicted position of unit target aswell
				if GetUnitSpeed(unitTarget) > 0 then
					local tDistance = ( GetUnitSpeed(unitTarget) * castTime ) / 1.7
					local tAngle = GetAnglesBetweenObjects(unit,unitTarget) -- _getMovingDirection(unitTarget)
					tX = tX + cos(tAngle) * tDistance
					tY = tY + sin(tAngle) * tDistance
					unitTargetDist = sqrt(((tX-x)^2) + ((tY-y)^2) + ((tZ-z)^2)) - ((UnitCombatReach(unit) or 0) + (UnitCombatReach(unitTarget) or 0))
					if unitTargetDist < distance then distance = unitTargetDist end
				else
					unitTargetDist = _distance(unitTarget, unit)
					if unitTargetDist < distance then distance = unitTargetDist end
				end
				-- calculate angle based on target position/future position
				angle = rad(atan2(tY - y, tX - x))
				if angle < 0 then
					angle = rad(360 + atan2(tY - y, tX - x))
				end
			end
			x = x + cos(angle) * distance
			y = y + sin(angle) * distance
			return x, y, z
		end
		return ObjectPosition(unit)
	end

	-- aoe_cast_best_position( 2120, 8, 2, 40, nil, _castTime(2120) )
	function aoe_cast_best_position(spellID, radius, minUnits, maxRange, minRange, castTime, nomoving, minttd)

		if radius == nil then radius = maxRange end
		if maxRange == nil then maxRange = radius end

		local latency = squid_avg_latency
		local update = 3/GetFramerate()

		local buffer = latency+update+.1025

		if _spellCooldown(spellID) > buffer then return false end

		--do not begin casts with quaking debuff
		local quaking_remains = _debuffRemains("player",240447)
		if quaking_remains > 0 and _castTime(spellID) > 0 and _castTime(spellID) > quaking_remains - 0.5 then return false end

		if nomoving and _isMoving("player") then return false end

		if unit_casting_info("player") and ( castTime > 0 or _castTimeLeft("player") > buffer*1.5 ) then return false end
		if UnitChannelInfo("player") then return false end

		-- return table with combination of every 2 units
		local function getAllCombinationsOfASet(arr, r)
			if(r > #arr) then
				return {}
			end
			if(r == 0) then
				return {}
			end
			if(r == 1) then
				local return_table = {}
				for i=1,#arr do
					table.insert(return_table, {arr[i]})
				end
				return return_table
			else
				local return_table = {}
				local arr_new = {}
				for i=2,#arr do
					table.insert(arr_new, arr[i])
				end
				for i, val in pairs(getAllCombinationsOfASet(arr_new, r-1)) do
					local curr_result = {}
					table.insert(curr_result, arr[1]);
					for j,curr_val in pairs(val) do
						table.insert(curr_result, curr_val)
					end
					table.insert(return_table, curr_result)
				end
				for i, val in pairs(getAllCombinationsOfASet(arr_new, r)) do
					table.insert(return_table, val)
				end
				return return_table
			end
		end

		--check if unit is inside of a circle
		local function unitInCircle(unit, cx, cy, radius, castTime)
			local uX, uY = 0, 0
			if castTime == nil or castTime == 0 then
			  uX, uY = ObjectPosition(unit)
			else
			  uX, uY = get_future_position(unit, castTime)
			end
			local rUnit = UnitBoundingRadius(unit)
			return math.abs((uX - cx) * (uX - cx) + (uY - cy) * (uY - cy)) <= (rUnit + radius) * (rUnit + radius);
		end

		--distance from center to unit
		local function unitDistanceCenter(unit, cx, cy, castTime)
			local uX, uY = 0, 0
			if castTime == nil or castTime == 0 then
				uX, uY = ObjectPosition(unit)
			else
				uX, uY = get_future_position(unit, castTime)
			end
			local rUnit = UnitBoundingRadius(unit)
			return sqrt(((uX-cx)^2) + ((uY-cy)^2))
		end

		if minRange == nil then minRange = 0 end
		local allUnitsInRange = {}
		allUnitsInRange = get_enemies("player",maxRange,false,nil,true)

		-- print(#allUnitsInRange)

		local testCircles = {}
		--for every combination of units make 2 circles, and put in testCircles
		if #allUnitsInRange >= 2 then
			local combs = getAllCombinationsOfASet(allUnitsInRange, 2)
			for i, val in pairs(combs) do
				local temp = {}
				for j, combination in pairs(val) do
					local tX, tY, tZ = 0,0,0
					if castTime == nil or castTime == 0 then
					  tX, tY, tZ = ObjectPosition(combination)
					else
					  tX, tY, tZ = get_future_position(combination, castTime)
					end
					if(j==#val) and temp.xi ~= nil then
						temp.xii = tX;
						temp.yii = tY;
						temp.zii = tZ;
						--distance
						temp.q = sqrt((temp.xii-temp.xi)^2 + (temp.yii-temp.yi)^2)
						--check to calculation. if result < 0 math.sqrt will give error
						local calc = ((radius^2)-((temp.q/2)^2))
						if calc <=0 then break end
						--x3
						temp.xiii = (temp.xi+temp.xii)/2
						--y3
						temp.yiii = (temp.yi+temp.yii)/2
						--first circle
						temp.xfc = temp.xiii + sqrt(calc)*((temp.yi-temp.yii)/temp.q)
						temp.yfc = temp.yiii + sqrt(calc)*((temp.xii-temp.xi)/temp.q)
						--second circle
						temp.xsc = temp.xiii - sqrt(calc)*((temp.yi-temp.yii)/temp.q)
						temp.ysc = temp.yiii - sqrt(calc)*((temp.xii-temp.xi)/temp.q)
						--
						temp.z = tZ
						tinsert(testCircles, temp)
					else
						temp.xi = tX;
						temp.yi = tY;
						temp.zi = tZ;
					end
				end
			end
		end

		local bestCircle = {}
		bestCircle.x = 0
		bestCircle.y = 0
		bestCircle.z = 0
		bestCircle.q = 0
		bestCircle.nro = 0
		--for every circle in testCircles, get units inside this circle, and return the circle with most units inside
		for i=1, #testCircles do
			local thisCircle = testCircles[i]
			local temp1 = 0
			local temp2 = 0
			local temp1Units = { }
			local temp2Units = { }
			for j=1, #allUnitsInRange do
				if unitInCircle(allUnitsInRange[j],thisCircle.xfc,thisCircle.yfc, radius, castTime) then
					temp1 = temp1 + 1
					tinsert(temp1Units,allUnitsInRange[j])
				end
				if unitInCircle(allUnitsInRange[j],thisCircle.xsc,thisCircle.ysc, radius, castTime) then
					temp2 = temp2 + 1
					tinsert(temp2Units,allUnitsInRange[j])
				end
			end
			if temp1 > temp2 and temp1 > bestCircle.nro then
				bestCircle.x = thisCircle.xfc
				bestCircle.y = thisCircle.yfc
				bestCircle.z = thisCircle.z
				bestCircle.nro = temp1
				bestCircle.units = {}
				for p = 1, #temp1Units do tinsert(bestCircle.units,temp1Units[p]) end
			elseif temp2 > temp1  and temp2 > bestCircle.nro then
				bestCircle.x = thisCircle.xsc
				bestCircle.y = thisCircle.ysc
				bestCircle.z = thisCircle.z
				bestCircle.nro = temp2
				bestCircle.units = {}
				for p = 1, #temp2Units do tinsert(bestCircle.units,temp2Units[p]) end
			elseif temp2 == temp1 and temp2 > bestCircle.nro then
				bestCircle.x = thisCircle.xsc
				bestCircle.y = thisCircle.ysc
				bestCircle.z = thisCircle.z
				bestCircle.nro = temp2
				bestCircle.units = {}
				for p = 1, #temp2Units do tinsert(bestCircle.units,temp2Units[p]) end
			end
		end
		-- print(#bestCircle.units)

		-- check if units of the best circle is equal of circle of unit, if it is, then cast on this unit
		-- for i=1,#allUnitsInRange do
		--     local thisUnit = allUnitsInRange[i]
		--     nmro = getUnits(thisUnit,allUnitsInRange, radius - 3)
		--     if nmro >= bestCircle.nro and nmro >= minUnits then
		--         if castGround(thisUnit,spellID,maxRange,minRange,radius,castTime) then return true else return false end
		--     end
		-- end

		--check with minUnits
		-- if minUnits == 1 and bestCircle.nro == 0 and GetUnitExists("target") then
		--     if _AeCast("target",spellID,maxRange,minRange,radius,castTime) then return true else return false end
		-- end
		if bestCircle.nro < minUnits then return false end

		if bestCircle.x ~= 0 and bestCircle.y ~= 0 and bestCircle.z ~= 0 then
			--Calculate x/y position with shortest dist to units
			local shortestDistance = 999
			local newBestCircleX, newBestCircleY = 0,0
			for x = bestCircle.x - radius, bestCircle.x + radius do
				for y = bestCircle.y - radius, bestCircle.y + radius do
					local totalDistance = 0
					for i = 1, #bestCircle.units do
						totalDistance = totalDistance + unitDistanceCenter(bestCircle.units[i], x, y, castTime)
					end
					if totalDistance < shortestDistance then
						shortestDistance = totalDistance
						newBestCircleX, newBestCircleY = x, y
					end
				end
			end
			bestCircle.x, bestCircle.y = (newBestCircleX + math.random() * 2), (newBestCircleY + math.random() * 2)
			-- print ( bestCircle.x, bestCircle.y )
			if aoe_cast2(spellID, bestCircle.x,bestCircle.y,bestCircle.z, nomoving, maxRange) then return true else return false end
		end
	end

	local PvPslows 	=
	{
		45524,          -- Chains of Ice
		50435,          -- Chilblains
		115000,         -- Remorseless Winter
		50259,          -- Dazed
		58180,          -- Infected Wounds
		61391,          -- Typhoon
		127797,         -- Ursol's Vortex
		5116,           -- Concussive Shot
		61394,          -- Frozen Wake (glyph of freezing trap)
		50433,          -- Ankle Crack
		54644,          -- Frost Breath
		120,            -- Cone of Cold
		116,            -- Frostbolt
		44614,          -- Frostfire Bolt
		113092,         -- Frost Bomb
		31589,          -- Slow
		116095,         -- Disable
		118585,         -- Leer of the Ox
		123586,         -- Flying Serpent Kick
		110300,         -- Burden of Guilt
		63529,          -- Dazed - Avenger's Shield
		20170,          -- Seal of Justice
		15407,          -- Mind Flay
		3409,           -- Crippling Poison
		26679,          -- Deadly Throw
		119696,         -- Debilitation
		3600,           -- Earthbind
		77478,          -- Earthquake
		8056,           -- Frost Shock
		51490,          -- Thunderstorm
		47960,          -- Shadowflame
		1715,           -- Hamstring
		12323,          -- Piercing Howl
		129923,         -- Sluggish
		81281,          -- Wild Mushroom
		--1604          -- Dazed
	}
	function _slowCheck(unit)
		local debuffs = _debuffFromTable(unit,PvPslows);
		if debuffs then
			return true;
		end
	end

	function _isSlowed(unit)
		local current_speed,_,_,swim_speed = GetUnitSpeed(unit)
		if swim_speed < 4 and current_speed < 7 then return true; end
		if _slowCheck(unit) then return true; end
	end

	function unit_is_slowed(unit)

		local unit_tag
		if unit_is_unit(unit,"target") then unit_tag = "target" end
		if unit_is_unit(unit,"focus") then unit_tag = "focus" end
		if unit_is_unit(unit,"arena1") then unit_tag = "arena1" end
		if unit_is_unit(unit,"arena2") then unit_tag = "arena2" end
		if unit_is_unit(unit,"arena3") then unit_tag = "arena3" end
		if not unit_tag then return false end

		local desc = squid_debuff_descriptions[unit_tag]

		local amount = 0
		local is_slowed = false

		for i=1,#desc do
			local str = desc[i]
			if strmatch(str, "slowed by") or strmatch(str, "Movement slowed") then
				is_slowed = true
				amount = string.match(str, "%d+")
				if amount and amount ~= 0 then
					amount = tonumber(amount)
				else
					amount = 0
				end
			end
		end

		return is_slowed, amount

	end

	function WorldPositionFromCursor()
		local x,y = GetMousePosition()
		return ScreenToWorld(x,y)
	end

	local immuneToSlowID =
	{
		54216, --Master's Call
		-- 19574, --Bestial Wrath
		45438, --IceBlock
		1044, --HandOfFreedom
		1022, --HandOfProt
		642,  --DivineShield
		47585, --Dispersion
		-- 114896, --Windwalk Totem
		227847, --Bladestorm
		114239, --Phantasm
		79438,	--Soulburn Port
		-- 115018,  --Desecrated ground
		216113,	--Way of the Crane
		2645,	--Ghost Wolf
		305395,	--cancerous undispellable freedom
	}

	function _slowImmuneCheck(unit)
		local buffs = _buffFromTable(unit,immuneToSlowID);
		if buffs then return true; end
	end

	local immuneToRoot =
	{
		54216, --Master's Call
		-- 19574, --Bestial Wrath
		45438, --IceBlock
		1044, --HandOfFreedom
		1022, --HandOfProt
		642,  --DivineShield
		47585, --Dispersion
		-- 114896, --Windwalk Totem
		227847, --Bladestorm
		-- 114239, --Phantasm
		-- 79438,	--Soulburn Port
		-- 115018,  --Desecrated ground
		216113,	--Way of the Crane
		305395,	--cancerous undispellable freedom
		-- 2645,	--Ghost Wolf
	}

	function _rootImmuneCheck(unit)
		local buffs = _buffFromTable(unit,immuneToRoot);
		if buffs then return true; end
	end

	function PvE_Spellsteal(unit)
		if UnitIsCharmed(unit) then return false end
		local blacklist = {
		269935,		--Bound by Shadows Shit from KR
		270920,		--Mind Control from KR https://www.wowhead.com/spell=270920/seduction
		278567,		-- soul fetish, not stealable
		333553,		-- Breaht of Coldheart (Torghast) Apparently some buff that gives 15% health and returns as stealable but isnt? Reported by @_cxmplex
		344739,		--Spectral buff will kill you
		}
		if _buffFromTable(unit,blacklist) then return false end
		if _purgeCount(unit) > 0 then return true end
	end

	function Basic_Spellsteal(unit)
		if IsPlayerSpell(198100) then return end
		local spec = GetSpecialization()
		local SSBuffs = {
		210294,		--Divine Favor
		1022, 		--BOP
		213610,		--Holy Ward
		774,		--Rejuv
		155777,		--Rejuv Germ
		-- 33763,		--Lifebloom
		286342,		--Safeguard
		198111,		--Temp
		124682,		--Enveloping
		305497,		--Thorns
		2645,		--Ghostwolf
		974,		--Riptide?
		61295,		--Earthshield?
		190319,		--Combust
		1022,		--Bop
		17,			--Pw:s
		48108,		--Hotstreak
		1459,		--Intellect
		21562,		--Fortitude
		216328,		--Light's Grace (dmg reduction)
		139,		--Renew
		235313,		--Blazing Barrier
		235450,		--Prismatic Barrier
		11426,		--Ice Barrier
		12472,		--Icy Veins
		12042,		--Arcane Power
		48108,		--Hot Streak
		}
		if unit_is_unit(unit,current_target) then
			local hasbuff,buffid = _buffFromTable(unit,SSBuffs)
			if hasbuff then return buffid end
		end
	end

	function Prio_Spellsteal(unit)
		if IsPlayerSpell(198100) then return end
		local spec = GetSpecialization()
		local SSBuffs = {
		210294,		-- Divine Favor
		1022, 		-- BOP
		213610,		-- Holy Ward
		10060,	    -- Power Infusion
		113858,		-- Dark Soul: Instability
		113860,		-- Dark Soul: Misery
		}
		for i=1,#SSBuffs do
			local buff = SSBuffs[i]
			if UnitBuffID(unit,buff) then
				return buff;
			end
		end
		local purge_count = _purgeCount(unit)
		--target only
		if unit_is_unit(unit,current_target) then
			if not UnitBuffID("player",190319) then
				--enveloping mist
				if purge_count <= 3 or spec == 1 and purge_count <= 3 then
					if _buffRemains(unit,124682) >= 3.75 then
						return 124682
					end
				end
				--temp long duration
				if purge_count <= 3 or spec == 1 and purge_count <= 3 then
					if _buffRemains(unit,198111) >= 2 then
						return 198111
					end
				end
			end
			--safeguard
			if purge_count <= 3 or spec == 1 and purge_count <= 3 then
				--286342
				local buff,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID(unit,286342)
				if buff and absorb > 13000 * (purge_count) then
					return 286342
				end
			end
			--nword
			if purge_count <= 2 or spec == 1 and purge_count <= 3 then
				if _buffRemains(unit,212295) > 1 then
					return 212295
				end
			end
		end
		--combust
		if purge_count <= 3 or spec == 1 then
			if _buffRemains(unit,190319) > 3 then
				return 190319
			end
		end
	end

	local hots = {
		774, --rejuv
		155777, --rejuv germ
		33763, --bloom
		305497, --thorns
		124682,	--enveloping mist
	}

	function Arcane_Spellsteal(unit)
		if IsPlayerSpell(198100) then return end
		local mana = (100 * UnitPower("player") / UnitPowerMax("player"));

		if unit_is_unit(unit,current_target) then
			if mana > lowestEnemy+20 or mana > 75 or load_mode_active then
				for i=1,#hots do
					local d = hots[i]
					if _buffRemains(unit,d) > 4 then
						return d
					end
				end
				local pws,_,_,_,_,_,_,_,_,_,_,_,_,_,_,pws_absorb = UnitBuffID(unit,17)
				if pws and pws_absorb >= 15000 then
					return 17
				end
			end
		end
	end

	function Arcane_Spellsteal_Two(unit)
		if IsPlayerSpell(198100) then return end
		local mana = (100 * UnitPower("player") / UnitPowerMax("player"));

		if unit_is_unit(unit,current_target) then
			if mana > lowestEnemy+10 or mana > 75 or load_mode_active then
				for i=1,#hots do
					local d = hots[i]
					if _buffRemains(unit,d) > 4 then
						return d
					end
				end
				local pws,_,_,_,_,_,_,_,_,_,_,_,_,_,_,pws_absorb = UnitBuffID(unit,17)
				if pws and pws_absorb >= 15000 then
					return 17
				end
			end
		end
	end

	function dispel_magic(unit)
		local SSBuffs = {
		210294,		--Divine Favor
		1022, 		--BOP
		305497,		--Thorns
		}
		if _purgeCount(unit) <= 3 and lowestFriend > 55 then
			for i=1,#SSBuffs do
				local debuff = SSBuffs[i]
				if UnitBuffID(unit,debuff) then
					return debuff;
				end
			end
		end
		--temp long duration
		if _purgeCount(unit) <= 3 and lowestFriend > 65 then
			if _buffRemains(unit,198111) >= 2 then
				return 198111
			end
		end
		--combust
		if (_purgeCount(unit) <= 3 and lowestFriend > 55) or lowestFriend > 75 then
			if _buffRemains(unit,190319) > 3 then
				return 190319
			end
		end
		--their healer cc and not in trouble
		if lowestFriend > 70 and (not theirHealer or _CCcheck(theirHealer)) then

		end
	end

	function table.clone(org)
	  return {unpack(org)}
	end

	function urlencode(str)
	   if (str) then
		  str = string.gsub (str, "\n", "\r\n")
		  str = string.gsub (str, "([^%w ])",
			 function (c) return string.format ("%%%02X", string.byte(c)) end)
		  str = string.gsub (str, " ", "+")
	   end
	   return str
	end

	-- this breaks skada lol
	-- function string.split(inputstr, sep)
	--     if sep == nil then
	--         sep = "%s"
	--     end
	--     local t={}
	--     for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
	--         table.insert(t, str)
	--     end
	--     return t
	-- end

	squid_combat_tracker = {}
	squid_klepto_tracker = {}

	--Squid Events
	function Squid_CombatLog(self,event,...)

		if event == "COMBAT_LOG_EVENT_UNFILTERED" then

			local _, subEvent, _, sourceGUID, sourceName, _, _, destGUID, destName, destFlags, destRaidFlags, spellID, spellName, _, auraType, extraSpellName, auraType2 = CombatLogGetCurrentEventInfo()

			local sourcePointer
			local destPointer

			if not IsHackEnabled then return; end

			for i=1,#Enemies do
				local guid = UnitGUID(Enemies[i])
				if destGUID == guid then
					destPointer = Enemies[i];
				end
				if sourceGUID == guid then
					sourcePointer = Enemies[i];
				end
			end

			for i=1,#Friends do
				local guid = UnitGUID(Friends[i])
				if destGUID == guid then
					destPointer = Friends[i];
				end
				if sourceGUID == guid then
					sourcePointer = Friends[i];
				end
			end

			if not sourcePointer and sourceGUID then
				sourcePointer = GetObjectWithGUID(sourceGUID)
			end

			if not destPointer and destGUID then
				destPointer = GetObjectWithGUID(destGUID)
			end

			local time = GetTime()

			--player casts
			if subEvent == "SPELL_CAST_SUCCESS" and sourcePointer then

				local stealth_ids = {
					[115191] = 115191,		-- Rogue Stealth
					[1856] = 11327,			-- Rogue Vanish
					[5215] = 5215, 			-- Druid Prowl
					-- 66    - going invis
					-- 32612 - actually invis
					[66] = 32612,			-- Mage Invis
				}
				if stealth_ids[spellID] and UnitCanAttack("player",sourcePointer) then
					Squid_Alert("Tracking " .. UnitClass(sourcePointer), spellName, nil, nil, spellID)
					local x,y,z = ObjectPosition(sourcePointer)
					local info = {
						speed = GetUnitSpeed(sourcePointer),
						direction = GetMovingDirection(sourcePointer),
						x = x,
						y = y,
						z = z,
						time = GetTime(),
						pointer = sourcePointer,
						id = stealth_ids[spellID],
						name = spellName,
					}
					table.insert(stealth_tracker,info)
				end

				--player is source
				if unit_is_unit(sourcePointer,"player") then

					-- print(destFlags, destRaidFlags, spellID, spellName, auraType, extraSpellName, auraType2)

					if spellID == 153595 and destPointer then
						comet_target = destPointer
					end

					if IsPlayerSpell(spellID) then
						if spellID ~= 169223 and spellID ~= 318378 then
							-- print(spellID)
							table.insert(PlayerSpellCasts,{name=spellName,id=spellID,time=time})
						end
					end

					if spellID == 127140 then
						if not UnitBuffID("player",110909) then
							squid_alter = {}
							squid_alter["start_hp"] = _HP("player")
							squid_alter["start_pos"] = {ObjectPosition("player")}
							Squid_Alert_Big("Alter Time",round(_HP("player"),2) .. "%", nil, nil, 108978)
						end
					end

					if spellID == 116011 then
						player_rop = time
					end

					if spellID == 133 then
						-- fireball_thrown = time
						-- fireball_target_dist = _distance(destPointer)
						fb_flying = time
						fb_really_flying = time
					end

					if spellID == 11366 then
						-- pyro_thrown = time
						-- pyro_target_dist = _distance(destPointer)
						pyro_flying = time
						pyro_really_flying = time
					end

					if spellID == 203286 then
						gpy_flying = time
						gpy_start_dist = _distance(destPointer)
						gpy_est_hit_time = time + ( gpy_start_dist / 8.9 )
					end

					if spellID == 257541 then
						-- pf_thrown = time
						-- pf_target_dist = _distance(destPointer)
						pf_flying = time
						pf_really_flying = time
					end

					if spellID == 36554 then
						lastShadowStep = time
						player_step = time
					end

					if spellID == 1943 then
						lastRupture = time
					end

					if spellID == 100 --charge
					or spellID == 6544 --heroic leap
					or spellID == 102401 --wild charge
					or spellID == 106839 --skull bash
					or spellID == 781	--Disengage
					or spellID == 195072--fel rush
					or spellID == 198793
					or spellID == 109132 --roll
					or spellID == 101545 --fsk
					or spellID == 119996 -- monk port
					then
						lastGapClose = time
					end
					if spellID == 187650 then
						trapthrown = time
					end
					if spellID == 210643 then
						totem_mastery_placed = time
					end
					if spellID == 1784
					or spellID == 5215 then
						if Squid_Last_Morph then
							C_Timer.After(.025,function()
								SquidMorph(Squid_Last_Morph[1],Squid_Last_Morph[2])
							end)
						end
					end
					if spellID == 109132 then
						player_roll=time
					end
					if spellID == 101545 then
						player_fsk = time
					end
					if spellID == 101643 or spellID == 119996 then
						portcoords = {}
						portcoords.x,portcoords.y,portcoords.z = GetPlayerPosition()
						portcoords.situated = true
					end
					if spellID == 212653 or spellID == 1953 then
						player_blink = time
						-- local x,y,z = GetPlayerPosition()
						-- last_blink_coords = {x,y,z}
					end
					if spellID == 203286 then
						player_gpy = time
					end
					if spellID == 33786 then
						player_clone = time
					end

				end -- end casts by player

				if spellID == 153561 then
					lastMeteor = time
					lastMeteorSource = sourcePointer
				end

				--enemy spellcasts
				if sourcePointer and unit_can_attack("player",sourcePointer) then
					-- if UnitClass(sourcePointer) == "Priest" then
					-- 	print(spellID, spellName)
					-- end
					--premonition
					if spellID == 32379 then
						premonitionUsed = time
						premonitionPointer = sourcePointer
						local player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
						local player_cast_target = UnitSpellTarget("player")
						if (player_casting_sheep or player_cast_id == 118) and unit_is_unit(player_cast_target,sourcePointer) then
							Squid_Alert_Big("Stopcasting","(Death)",4,3,32379)
							SpellStopCasting()
						end
					end
					--coil
					if spellID == 6789 then
						enemy_coil = time
						enemy_coil_pointer = sourcePointer
					end
					-- chain harvest
					if spellID == 320674 then
						enemy_chain_harvest = time
						chain_harvest_pointer = sourcePointer
					end

					-- Kleptomania Tracking
					if spellID == 30449 then
						if squid_klepto_tracker[sourcePointer] == nil then
							squid_klepto_tracker[sourcePointer] = {}
							squid_klepto_tracker[sourcePointer]["running_klepto"] = true
						end

						if squid_klepto_tracker[sourcePointer]["running_klepto"] == true then
							if squid_klepto_tracker[sourcePointer]["last_cast"] ~= nil and (time - squid_klepto_tracker[sourcePointer]["last_cast"] < 27) then
								squid_klepto_tracker[sourcePointer]["running_klepto"] = false
							end

							squid_klepto_tracker[sourcePointer]["last_cast"] = time
						end
					end

					-- Shifting Power Tracking for Kleptomania CD( The assumption is that they got a full 4s cast off, even if they did not. We'd rather assume that they have Klepto and be wrong than vice versa. )
					if spellID == 314791 then
						if squid_klepto_tracker[sourcePointer] and squid_klepto_tracker[sourcePointer]["running_klepto"] == true and squid_klepto_tracker[sourcePointer]["last_cast"] then
							squid_klepto_tracker[sourcePointer]["last_cast"] = (squid_klepto_tracker[sourcePointer]["last_cast"] - 10)
						end
					end
				end

				if spellID == 208683 or spellID == 195710 or spellID == 208683 or spellName == "Sinful Gladiator's Medallion" or spellName == "Sinful Aspirant's Medallion" then
					table.insert(TrinketTracker,{expires=time+120,pointer=sourcePointer,time=time})
					print(UnitName(sourcePointer) .. " used " .. spellName .. " (Trinket) - Added to trinket tracker!")
				end

				-- if spellName == "Feign Death" and unit_can_attack("player",sourcePointer) then
				-- 	if last_target and unit_is_unit(sourcePointer,last_target) and not current_target then
				-- 		Squid_Alert("Re-Target Hunter","(Feign Death)",1)
				-- 		TargetUnit(sourcePointer)
				-- 	end
				-- end

				if spellID == 781 --disengage
				or spellID == 109132 --roll
				or spellID == 101545 then --fsk
					gap_opener_used = time
					gap_opener_pointer = sourcePointer
				end

				if spellID == 152175 then
					last_wdp = time
				end

				-- step wild charge, hmmm i'm sure this can be bad sometimes but i can't think of when.
				if spellID == 49376 and sourcePointer and unit_can_attack("player",sourcePointer) and unit_is_unit(destPointer,"player") then
					last_wc = time
					last_wc_pointer = sourcePointer
					if select(2,UnitClass("player")) == "ROGUE" then
						if unit_is_unit(sourcePointer,current_target) and _Cast(36554,sourcePointer) then
							Squid_Alert("Shadowstep","(".. GetSpellInfo(spellID) ..")",1,3.5,36554)
						end
					end
				end

				if (spellID == 100 --charge
				or spellID == 6544 --heroic leap
				or spellID == 102401 --wild charge
				or spellID == 106839 --skull bash
				or spellID == 781	--Disengage
				or spellID == 195072 --fel rush
				or spellID == 198793 -- ???
				or spellID == 109132 --roll
				or spellID == 101545) --fsk
				and sourcePointer
				and unit_can_attack("player",sourcePointer) then
					enemy_gapclose = time
					enemy_gapclose_pointer = sourcePointer
				end

				if spellID == 36554 then
					if unit_is_unit("player",destPointer) then
						local player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
						if (player_cast_id == 203286 or player_cast_id == 133 or player_cast_id == 11366) then
							local player_target = UnitSpellTarget("player")
							if player_target and unit_is_unit(player_target,sourcePointer) then
								pause_auto_facing = time
								FaceDirection(mod(ObjectFacing("Player") + math.pi, math.pi * 2),true)
								Squid_Alert_Big("Face Rogue","Shadowstep",4,3,36554)
							end
						end
					end
				end

			end -- end spell casts with sourcepointer

			if subEvent == "SPELL_AURA_APPLIED" and auraType == "DEBUFF" and spellID == 187650 then
				traplanded = time
			end

			if subEvent == "SPELL_AURA_REMOVED" and auraType == "BUFF" then
				if spellID == 110909 and unit_is_unit("player",sourcePointer) and squid_alter then

					local hp_change = round ( squid_alter["start_hp"] - _HP("player"), 2)

					if hp_change == 0 then
						Squid_Alert("Alter Didn't Affect HP", nil, nil, nil, 108978)
					elseif hp_change > 25 then
						Squid_Alert_Big("Alter |cFFa9d271Healed",hp_change .. "%", nil, nil, 108978)
					elseif hp_change > 0 then
						Squid_Alert("Alter |cFFa9d271Healed",hp_change .. "%", nil, nil, 108978)
					elseif hp_change < 25 then
						Squid_Alert_Big("Alter |cffff6060Damaged",hp_change .. "%", nil, nil, 108978)
					else
						Squid_Alert("Alter |cffff6060Damaged",hp_change .. "%", nil, nil, 108978)
					end

					squid_alter = nil

				end

				if (spellID == 1784 or spellID == 5215) then
					if Squid_Last_Morph then
						C_Timer.After(.025,function()
							SquidMorph(Squid_Last_Morph[1],Squid_Last_Morph[2])
						end)
					end
				end
				if spellID == 210294 and select(2,UnitClass("player")) == "PALADIN" and not unit_is_unit(sourcePointer,"player") and unit_is_unit(destPointer,"player") then
					SpellStopCasting()
					Squid_Alert("Stopcasting","(Divine Favor Stolen)",2,nil,210294)
				end
			end

			--Track all abiliies used
			-- if arena then
				if subEvent == "SPELL_CAST_SUCCESS" and sourcePointer then
					local id = spellID
					local name = spellName
					local cd = GetSpellBaseCooldown(id)/1000
					if name == "Death Grip" then cd = 25 end

					if cd and cd > 0 then
						SpellTracker[id] = {expires=time+cd,pointer=sourcePointer,name=name};
					end

					--other things
					if id == 36554 and sourcePointer and unit_can_attack("player",sourcePointer) then
						enemy_shadowstep = time
						enemy_shadowstep_pointer = sourcePointer
						enemy_shadowstep_target = destPointer
					end
					if id == 187650 and sourcePointer and unit_can_attack("player",sourcePointer) then
						lastTrapPointer = sourcePointer
						lastTrap = time
					end

					--shitty combo point tracker?

				end
			-- end

			if subEvent == "SPELL_CAST_SUCCESS" then

				if sourcePointer then

					-- cds reduced by other spellcasts (+required talents) (ONLY ON DAMAGE TAKEN!!!)
					local cd_reduc = {
						[85673] = {parent = 853, talent = 234299, amount = 6}, -- word of glory reduces hoj cd by 6 sec
						[53600] = {parent = 853, talent = 234299, amount = 6}, -- shield of the righteous reduces hoj cd by 6 sec
						[85222] = {parent = 853, talent = 234299, amount = 6}, -- light of dawn reduces hoj cd by 6 sec
						[85256] = {parent = 853, talent = 234299, amount = 6}, -- templar's verdict reduces hoj cd by 6 sec
						[53385] = {parent = 853, talent = 234299, amount = 6}, -- divine storm reduces hoj cd by 6 sec
					}
					if cd_reduc[spellID] then
						local spell = cd_reduc[spellID]
						if not spell.talent or unit_has_talent(sourcePointer,spell.talent) then
							if SpellTracker[spell.parent] and unit_is_unit(sourcePointer,SpellTracker[spell.parent].pointer) then
								SpellTracker[spell.parent].expires = SpellTracker[spell.parent].expires - 5
							end
						end
					end

				end

				local name = spellName
				local id = spellID

				if sourcePointer and unit_can_attack("player",sourcePointer) then
					local dispels = {
						88423,	--Nature's Cure (Druid)
						4987,	--Cleanse (Paladin)
						527,	--Purify (Priest)
						77130,	--Purify Spirit (Shaman)
						115450,	--Detox (Monk)
					}
					if tContains(dispels,id) and _isHealer(sourcePointer) then
						last_dispel = time
						last_dispel_pointer = sourcePointer
					end
				end

				if unit_is_unit("player",destPointer) then
					if id == 203286 then
						gpy_on_player = time
					end
				end

				if id == 30449 then
					spellsteal_used = time
				end

				--bigdmg flying on player
				if unit_is_unit("player",destPointer) then

					--big dmg
					if name == "Wildfire Bomb" --regular wfb
					-- or name == "Pheromone Bomb" --pheromone bomb
					or name == "Volatile Bomb" --volatile bomb
					or name == "Shrapnel Bomb" --shrap bomb
					or name == "Chaos Bolt" --bolt
					or name == "Demonfire" --demonic tyrant shit
					or name == "Remote Guidance Device" then --completely fucking retarded trinket
						big_dmg_inc = id
						big_dmg_inc_time = time
						if (name == "Chaos Bolt" and UnitBuffID(sourcePointer,113858))
						or name == "Remote Guidance Device" then
							rly_big_dmg_inc = true
						end
					end

					--cc
					if name == "Storm Bolt"
					or name == "Mortal Coil" then
						cc_flying_towards_player = id
						cc_flying_towards_player_time = time
					end

				end

			end

			if subEvent == "SPELL_HEAL" then
				if UnitIsVisible(sourcePointer) and UnitCanAttack("player",sourcePointer) and unit_is_player(sourcePointer) then
					if UnitIsVisible(destPointer) and not unit_is_unit(sourcePointer,destPointer) and UnitAffectingCombat(destPointer) then
						squid_combat_tracker[sourcePointer] = GetTime() + .3
					end
				end
			end

			if subEvent == "SPELL_DAMAGE" or subEvent == "SWING_DAMAGE" or subEvent == "SPELL_MISSED" then

				if UnitIsVisible(sourcePointer) and UnitCanAttack("player",sourcePointer) and unit_is_player(sourcePointer) then
					squid_combat_tracker[sourcePointer] = GetTime() + .3
				end

				if UnitIsVisible(destPointer) and UnitCanAttack("player",destPointer) and unit_is_player(destPointer) then
					squid_combat_tracker[destPointer] = GetTime() + .3
				end

				if subEvent == "SPELL_DAMAGE" then
					-- cds reduced by other spellcasts (+required talents) (ONLY ON DAMAGE TAKEN!!!)
					local cd_reduc = {
						[133] = {parent = 190319, talent = 203283, amount = 5}, -- fireball reduces combust cd by 5 sec per cast
					}
					if cd_reduc[spellID] then
						local spell = cd_reduc[spellID]
						if not spell.talent or unit_has_talent(sourcePointer,spell.talent) then
							if SpellTracker[spell.parent] and unit_is_unit(sourcePointer,SpellTracker[spell.parent].pointer) then
								SpellTracker[spell.parent].expires = SpellTracker[spell.parent].expires - 5
							end
						end
					end
				end

				if unit_is_unit("player", sourcePointer) then
					player_combat_tracker = GetTime() + .9
				elseif unit_is_unit("player",destPointer) then
					player_combat_tracker = GetTime() + .9
				end

				--bigdmg flying on player
				if unit_is_unit("player",destPointer) then
					local name=spellName
					if name == "Wildfire Bomb" --regular wfb
					-- or name == "Pheromone Bomb" --pheromone bomb
					or name == "Volatile Bomb" --volatile bomb
					or name == "Shrapnel Bomb" --shrap bomb
					or name == "Chaos Bolt" --bolt
					or name == "Demonfire" --demonic tyrant shit
					or name == "Remote Guidance Device" then --completely fucking retarded trinket
						big_dmg_inc = nil
						big_dmg_inc_time = nil
						rly_big_dmg_inc = nil
					end
				end
				if spellID == 203286 and unit_is_unit("player",destPointer) then
					gpy_on_player = nil
				end
				if spellID == 133 and unit_is_unit("player",sourcePointer) then
					C_Timer.After(.075,function() fb_flying = nil fb_really_flying = nil end)
				end
				if spellID == 11366 and unit_is_unit("player",sourcePointer) then
					C_Timer.After(.075,function() pyro_flying = nil pyro_really_flying = nil end)
				end
				if spellID == 203286 and unit_is_unit("player",sourcePointer) then
					gpy_flying = nil
					gpy_est_hit_time = nil
				end
				if spellID == 257541 and unit_is_unit("player",sourcePointer) then
					C_Timer.After(.145,function() pf_flying = nil pf_really_flying = nil end)
				end
			end

			if subEvent == "SPELL_AURA_APPLIED" and auraType == "DEBUFF" and unit_is_unit("player",destPointer) then
				local name = spellName
				--cc
				if name == "Storm Bolt"
				or name == "Mortal Coil" then
					cc_flying_towards_player = nil
					cc_flying_towards_player_time = nil
				end
			end

			--DR tracking
			if subEvent == "SPELL_AURA_APPLIED" and auraType == "DEBUFF" and _getDrSpellCategory(spellID) then
				debuffGained(spellID,destName,destPointer)
			end

			if subEvent == "SPELL_AURA_REFRESH" and auraType == "DEBUFF" and _getDrSpellCategory(spellID) then
				debuffRefresh(spellID,destName,destPointer)
			end

			if subEvent == "SPELL_AURA_REMOVED" and auraType == "DEBUFF" then
				if _getDrSpellCategory(spellID) then
					debuffFaded(spellID,destName,destPointer)
				end
				if unit_is_unit(sourcePointer,"player")
				and (spellName == "Alliance Flag" or spellName == "Horde Flag" or spellName == "Horde Mine Cart" or spellName == "Alliance Mine Cart") then
					flag_drop_time = time
				end
			end

			--dotTracker refresh
			if subEvent == "SPELL_AURA_REFRESH" then

				--Rake--
				if unit_is_unit(sourcePointer,"player") and spellID == 155722 then
					if #dotTracker > 0 then
						for i=1,#dotTracker do
							if dotTracker[i].rakepointer == destPointer then
								dotTracker[i].rakePower = GetCurrentSnapshot(1822)
								return
							end
						end
					end
					--refreshed rake, but not in dot tracker
					table.insert(dotTracker,{rakepointer = destPointer, rakePower = GetCurrentSnapshot(1822), time=time})
				end


				--Rip--
				if unit_is_unit(sourcePointer,"player") and spellID == 1079 then
					if #dotTracker > 0 then
						for i=1,#dotTracker do
							if dotTracker[i].rippointer == destPointer then
								dotTracker[i].ripPower = GetCurrentSnapshot()
								return
							end
						end
					end
					--refreshed rip, but not in dot tracker
					table.insert(dotTracker,{rippointer = destPointer, ripPower = GetCurrentSnapshot(), time=time})
				end

				--Garrote--
				if unit_is_unit(sourcePointer,"player") and spellID == 703 then
					if #dotTracker > 0 then
						for i=1,#dotTracker do
							if dotTracker[i].garrotepointer == destPointer then
								dotTracker[i].garrotePower = GetCurrentSnapshot()
								return
							end
						end
					end
					--refreshed garrote, but not in dot tracker
					table.insert(dotTracker,{garrotepointer = destPointer, garrotePower = GetCurrentSnapshot(), time=time})
				end

			end

			if (subEvent == "SPELL_AURA_APPLIED" or subEvent == "SPELL_CAST_SUCCESS") and unit_is_unit("player",sourcePointer) then

				--Rake--
				if spellID == 155722 then
					for i=1,#dotTracker do
						if dotTracker[i].rakepointer == destPointer then
							return false;
						end
					end
					table.insert(dotTracker,{rakepointer = destPointer, rakePower = GetCurrentSnapshot(1822), time=time})
					return
				end

				--Rip--
				if spellID == 1079 then
					for i=1,#dotTracker do
						if dotTracker[i].rippointer == destPointer then
							return false;
						end
					end
					table.insert(dotTracker,{rippointer = destPointer, ripPower = GetCurrentSnapshot(), time=time})
					return
				end

				--Garrote--
				if spellID == 703 then
					for i=1,#dotTracker do
						if dotTracker[i].garrotepointer == destPointer then
							return false;
						end
					end
					table.insert(dotTracker,{garrotepointer = destPointer, garrotePower = GetCurrentSnapshot(), time=time})
					return
				end

			end

			--dotTracker cleanup
			for i=1,#dotTracker do

				--Rake
				if dotTracker[i] and dotTracker[i].rakepointer then
					if time - dotTracker[i].time > .1 and not UnitDebuffID(dotTracker[i].rakepointer,155722,"player") then
						tremove(dotTracker,i);
					end
				 end

				--Rip
				if dotTracker[i] and dotTracker[i].rippointer then
					if time - dotTracker[i].time > .1 and _debuffRemains(dotTracker[i].rippointer,1079,"player") == 0 then
						tremove(dotTracker,i);
					end
				end

				--Rip
				if dotTracker[i] and dotTracker[i].garrotepointer then
					if time - dotTracker[i].time > .1 and _debuffRemains(dotTracker[i].garrotepointer,703,"player") == 0 then
						tremove(dotTracker,i);
					end
				end

			end

			--dotTracker removal
			if subEvent == "SPELL_AURA_REMOVED" then

				--Rake--
				if spellID == 155722 then
					if #dotTracker > 0 then
						for i=1,#dotTracker do
							if dotTracker[i].rakepointer == destPointer then tremove(dotTracker,i) return true end
						end
					end
				end

				--Rip--
				if spellID == 1079 then
					if #dotTracker > 0 then
						for i=1,#dotTracker do
							if dotTracker[i].rippointer == destPointer then tremove(dotTracker,i) return true end
						end
					end
				end

				--Garrote--
				if spellID == 703 then
					if #dotTracker > 0 then
						for i=1,#dotTracker do
							if dotTracker[i].garrotepointer == destPointer then tremove(dotTracker,i) return true end
						end
					end
				end

				--slow out of block
				if spellID == 45438 then
					if select(2,UnitClass("player")) == "WARRIOR" then
						if _Cast(1715,destPointer,true) then
							Squid_Alert("Hamstring","Ice Block",3)
						end
					end
					if select(2,UnitClass("player")) == "MONK" then
						if _Cast(116095,destPointer,true) then
							Squid_Alert("Disable","Ice Block",3)
						end
					end
				end

			end

			local interrupts = {
			183752,--"Disrupt",
			6552,--"Pummel",
			96231,--"Rebuke",
			147362,--"Counter Shot",
			1766,--"Kick",
			47528,--"Mind Freeze",
			57994,--"Wind Shear",
			119911,--"Optical Blast",
			115781,--"Optical Blast",
			19647,--"Spell Lock",
			132409,--"Spell Lock",
			251523,--"Spell Lock",
			119910,--"Spell Lock",
			171138,--"Shadow Lock",
			2139,--"Counterspell",
			116705,--"Spear Hand Strike",
			106839,--"Skull Bash",
			93985,--"Skull Bash"
			78675,--"Solar Beam",
			187707,--"Muzzle",
			91802,--"Shambling Rush"
			}
			if subEvent == "SPELL_INTERRUPT" then
				if tContains(interrupts,spellID) then
					for i=1,#Enemies do
						local e=Enemies[i]
						if unit_is_unit(e,destPointer) then
							local cast=extraSpellName
							local school=CombatLog_String_SchoolString(auraType2)
							if cast then
								table.insert(kickTable, {unit=e, time=time+LockoutDuration(spellName), kick=spellName, kickID=spellID, cast=cast, school=school})
							end
						end
					end
				end
				-- print(CombatLog_String_SchoolString(auraType2))
				-- print(subEvent, sourceGUID, sourceName, destGUID, destName, destFlags, destRaidFlags, spellID, spellName, auraType, extraSpellName, auraType2)
			end
			if subEvent == "SPELL_CAST_SUCCESS" then
				if tContains(interrupts,spellName) then
					for i=1,#Enemies do
						local e=Enemies[i]
						if unit_is_unit(e,destPointer) then
							local cast = unit_casting_info(e)
							local channel = UnitChannelInfo(e)
							if not cast and not channel then
								table.insert(kickTable, {unit=e, time=time+1.2, kick=spellName, kickIcon=GetSpellTexture(spellID), juked=true})
							elseif channel == "Penance" then
								table.insert(kickTable, {unit=e, time=time+LockoutDuration(spellName), kick=spellName, kickID=spellID, cast=channel})
							-- elseif extraSpellName then
							-- 	table.insert(kickTable, {unit=e, time=time+LockoutDuration(spellName), kick=spellName, kickIcon=GetSpellTexture(spellID), cast=extraSpellName})
							end
						end
					end
				end
			end

			local rootEvents = {
			6544, --Heroic Leap
			100, --Charge
			781, --Disengage
			101545, --Flying Serpent Kick
			109132, --Monk Roll
			-- 108212, --Burst of Speed
			108843, --Blazing Speed (Cauterize)
			115008, -- Chi Torpedo
			195457, -- Grappling Hook
			190925, -- Harpoon
			195072, -- Fel Rush
			198793, -- Vengeful Retreat
			102401, -- Wild Charge
			102417, -- Wild Charge
			49376,  -- Wild Charge
			190784, -- Divine Steed
			192063, -- Gust of Wind
			768, -- Cat Form
			212552, -- Wraith Walk
			}
			if subEvent == "SPELL_CAST_SUCCESS" and UnitIsVisible(sourcePointer) then
				if tContains(rootEvents,spellID) and unit_can_attack("player",sourcePointer) then
					if (spellID ~= 768 or _isMeleeDps(sourcePointer)) and (spellID ~= 190784 or _buffRemains(sourcePointer,190784) <= 3) then
						if spellID == 100 or spellID == 102401 then
							time=time-.3;
						end
						shouldRootUnit,shouldRootTime,shouldRootReason = sourcePointer,time,GetSpellInfo(spellID);
					end
				end
			end

			local debuffcd = {
			79140,	--Vendetta
			131894,	--Murder of Crows
			308498,	--Resonating Arrow
			-- 305483,	--Lightning Lasso
			}

			if subEvent == "SPELL_CAST_SUCCESS" and UnitIsVisible(sourcePointer) then
				if tContains(debuffcd,spellID) then
					table.insert(BigCDTable,{unit=sourcePointer,dest=destPointer,time=time,spell=spellID})
				end
			end

			--Track Kick Cooldowns--
			if subEvent == "SPELL_CAST_SUCCESS" and sourcePointer then
				--Pummel
				if spellName == "Pummel" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.8}); end
				--Rebuke
				if spellName == "Rebuke" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.8}); end
				--Counter Shot
				if spellName == "Counter Shot" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+23.8}); end
				--Kick
				if spellName == "Kick" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.8}); end
				--Mind Freeze
				if spellName == "Mind Freeze" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.8}); end
				--Wind Shear
				if spellName == "Wind Shear" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+11.8}); end
				--Disrupt
				if spellName == "Disrupt" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.8}); end
				--Optical Blast
				if spellName == "Optical Blast" then
					for i=1,#Enemies do if UnitIsPet(Pets[i]) and select(2,UnitClass(Pets[i])) == "WARLOCK" then
						table.insert(kickCooldowns,{pointer=Pets[i],expire=GetTime()+23.8});
					end end
				end
				--SpellLock
				if spellName == "Spell Lock" then
					if UnitBuffID(sourcePointer,108503) then
						table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+23.8});
					else
						for i=1,#Pets do if UnitIsPet(Pets[i]) and select(2,UnitClass(Pets[i])) == "WARLOCK" then
							table.insert(kickCooldowns,{pointer=Pets[i],expire=GetTime()+23.8});
						end end
					end
				end
				--Shadow Lock
				if spellName == "Shadow Lock" then
					for i=1,#Enemies do if UnitIsPet(Pets[i]) and select(2,UnitClass(Pets[i])) == "WARLOCK" then
						table.insert(kickCooldowns,{pointer=Pets[i],expire=GetTime()+23.8});
					end end
				end
				--Counterspell
				if spellName == "Counterspell" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+23.95}); end
				--Spear Hand Strike
				if spellName == "Spear Hand Strike" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.95}); end
				--Skull Bash
				if spellName == "Skull Bash" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+14.95}); end
				--Solar Beam
				if spellName == "Solar Beam" then table.insert(kickCooldowns,{pointer=sourcePointer,expire=GetTime()+59.95}); end
			end

		end--end of combat log

	end
	combo_point_tracker = {}
	BigCDTable = {}
	PlayerSpellCasts = {}
	SpellTracker = {}
	TrinketTracker = {}
	dotTracker = {}
	kickTable = {}
	kickCooldowns = {}
	SquidEvents = CreateFrame("Frame")
	SquidEvents:RegisterEvent("COMBAT_LOG_EVENT_UNFILTERED")
	SquidEvents:SetScript("OnEvent",Squid_CombatLog)

	local function update_target_pointer(self,event,test,nigga)
		if not IsHackEnabled then return false end
		if event == "PLAYER_FOCUS_CHANGED" then
			current_focus = ObjectPointer("focus")
		end
		if event == "PLAYER_TARGET_CHANGED" then
			current_target = ObjectPointer("target")
		end
	end

	local TPFrame = CreateFrame("Frame")
	TPFrame:RegisterEvent("PLAYER_TARGET_CHANGED")
	TPFrame:RegisterEvent("PLAYER_FOCUS_CHANGED")
	TPFrame:SetScript("OnEvent",update_target_pointer)

	function UnitCanKick(unit,otherUnit)

		local class = select(2,UnitClass(unit))

		if UnitIsPet(unit) then
			-- imp: 416 felhunter: 417 succ: 1863 felimp: 58959 observer: 58964
			if class ~= "WARLOCK" then return false end
			local object_id = ObjectID(unit)
			if object_id ~= 58964 and object_id ~= 417 then return false end
		end

		if not unit_is_player(unit) and not UnitIsPet(unit) then return false end

		if class == "WARLOCK" and not UnitIsPet(unit) and UnitName(unit) ~= "Felhunter" then return false end

		if _CCremains(unit) >= .15 then return false; end

		local role = GetUnitRole(unit)

		--classes that cannot interrupt while silenced
		if class == "MAGE" or class == "DEATHKNIGHT" or class == "SHAMAN" or (class == "DRUID" and role == "ranged") then
			if _silenceCheck(unit) then
				return false
			end
		end

		--classes that cannot interrupt while locked out
		local locked,remaining,school = UnitIsLocked(unit)
		if locked and remaining > .15 then
			if ( class == "MAGE" and school == "Arcane" )
			or ( class == "SHAMAN" and school == "Nature" ) then
				return false
			end
		end

		for i=1,#kickCooldowns do if unit_is_unit(kickCooldowns[i].pointer,unit) then return false end end

		if _LoS(unit,otherUnit) then

			local px,py,pz
			if unit_is_unit(otherUnit,"player") then
				px,py,pz = GetPlayerPosition()
			else
				px,py,pz = ObjectPosition(otherUnit)
			end

			local x,y,z = PredictUnitPosition(unit,.2)

			local dist = GetDistanceBetweenPositions(px,py,pz,x,y,z) - UnitCombatReach(unit) - UnitCombatReach(otherUnit)

			local has_bop = UnitBuffID(otherUnit,1022)

			if (class == "MAGE" or class == "WARLOCK" or class == "HUNTER" and _isRangedDps(unit)) and dist <= 40 then
				if class ~= "HUNTER" or not has_bop then
					return true
				end
			end

			if class == "SHAMAN" and dist <= 30 then
				return true
			end

			if class == "DRUID" then
				if role == "melee" and dist <= 13 and _isBeast(unit) and not has_bop then return true end
				-- if role == "ranged" and dist <= 45 then return true end
			end

			if (class == "WARRIOR" or (class == "MONK" and role == "melee") or (class == "PALADIN" and role == "melee") or class == "ROGUE") and dist <= 6 and not has_bop then
				return true
			end

			if class == "DEATHKNIGHT" and dist <= 15 then
				return true
			end

			if class == "DEMONHUNTER" and dist <= 11 then
				return true
			end

		end

		return false

	end

	function UnitCanBeKicked(unit)
		for i=1,#Pets do
			if unit_can_attack(Pets[i],unit) and UnitCanKick(Pets[i],unit) then
				return true
			end
		end
		for i=1,#Friends do
			if unit_can_attack(Friends[i],unit) and UnitCanKick(Friends[i],unit) then
				return true
			end
		end
		return false;
	end

	function PlayerCanBeKicked()
		return UnitCanBeKicked("player")
	end

	function SquidMessageHandler(self,event,prefix,text,author)

		local name,prefix = strsplit(" ", prefix)

		if string.lower(UnitName("player")) ~= name then return false end

		--move char
		if prefix == "SM" then
			x,y,z = strsplit(",",text)
			if x and y and z then
				x=tonumber(x)
				y=tonumber(y)
				z=tonumber(z)
				ExecutingPlayerMovementCommand = GetTime()
				Squid_Alert("Moving To Coords:","(" .. math.floor(x) .. ") , (" .. math.floor(y) .. ") , (" .. math.floor(z) .. ")")
				MoveTo(x,y,z,true)
			end
		end
		--run command
		if prefix == "SC" then
			RunScript(text)
			Squid_Alert("Remote Command:",text)
		end
		--interactmouseover
		if prefix == "SI" then

			local unitsnearby = {}

			for i=1,#Objects do
				local d = _realDistance(Objects[i])
				table.insert(unitsnearby,{unit=Objects[i],d=d})
			end
			table.sort(unitsnearby,function(x,y) return x.d < y.d end)

			local match
			for i=1,#unitsnearby do
				if UnitName(unitsnearby[i].unit) == text then
					match=unitsnearby[i].unit
					break
				end
			end

			if match then
				InteractUnit(match)
			else
				InteractUnit(text)
			end
			Squid_Alert("Interacting with object:",text)
		end
	end

	SquidMessage = CreateFrame("Frame")
	SquidMessage:RegisterEvent("CHAT_MSG_ADDON")
	SquidMessage:SetScript("OnEvent",SquidMessageHandler)
	C_ChatInfo.RegisterAddonMessagePrefix(string.lower(UnitName("player")) .. " SM")
	C_ChatInfo.RegisterAddonMessagePrefix(string.lower(UnitName("player")) .. " SC")
	C_ChatInfo.RegisterAddonMessagePrefix(string.lower(UnitName("player")) .. " SI")

	function SendMovementCommand(unit)
		unit = string.lower(unit)
		local x,y,z = WorldPositionFromCursor()
		if x and y and z then
			local success = C_ChatInfo.SendAddonMessage(unit .. " SM", x .. "," .. y .. "," .. z , "WHISPER" , unit)
		end
	end

	function SendInteractCommand(unit)
		local success
		local command

		unit = string.lower(unit)

		if GameTooltip:IsShown() and GameTooltipTextLeft1 then
			command = GameTooltipTextLeft1:GetText()
		end
		if command then
			success = C_ChatInfo.SendAddonMessage(unit .. " SI", command, "RAID" , unit)
		end
		if not success then
			command = UnitTarget("player")
			if command then
				success = C_ChatInfo.SendAddonMessage(unit .. " SI", command, "RAID" , unit)
			end
		end
	end

	function SendSquidCommand(unit,command)
		unit = string.lower(unit)
		return C_ChatInfo.SendAddonMessage(unit .. " SC", command, "PARTY")
	end

	local sq_whispers = CreateFrame("FRAME", "MsgFrame");
	sq_whispers:RegisterEvent("CHAT_MSG_WHISPER");
	local function handle_whispers(self, event, ...)
		local message = select(1,...)
		local author = select(2,...)
		local authorGUID = select(12,...)

		--fruit platter wongo bongo invite
		if SQUID.cap_bot and (message == "wongo bongo" or message == "fruit platters") then
			RunMacroText("/inv " .. author);
			print("Invited " .. author)
		end
	end
	sq_whispers:SetScript("OnEvent", handle_whispers);

	function SquidMorph(unit,displayid)
		if not displayid then displayid=unit; unit="player"; end
		UnitSetDisplayID (unit,displayid)
		UnitUpdateModel (unit)
		Squid_Last_Morph={unit,displayid}
		--49 LMAO
		--47931 SQUID ROFL
		--3037 dino with cleavers
	end

	function SquidPause()
		SquidPaused = GetTime();
	end

	function squid_queue_focus_maim()
		squid_maim_queued = GetTime();
		squid_maim_target = "focus"
		Squid_Alert("Focus Maim Queued",nil,nil,3.5,22570)
	end

	function squid_queue_target_maim()
		squid_maim_queued = GetTime();
		squid_maim_target = "target"
		Squid_Alert("Target Maim Queued",nil,nil,3.5,22570)
	end

	function squid_queue_healer_maim()
		for i=1,#Enemies do
			if _isHealer(Enemies[i]) then
				squid_maim_queued = GetTime();
				squid_maim_target = Enemies[i]
				Squid_Alert("Healer Maim Queued",nil,nil,3.5,22570)
				return true
			end
		end
		Squid_Alert("|cFFc31d39No Healers Found, Maim Not Queued",nil,nil,nil,22570)
	end

	function GetPortCoords()
		if portcoords then
			return portcoords.x,portcoords.y,portcoords.z
		end
	end

	player_can_see_cache = {}

	function player_can_see(unit)

		if player_can_see_cache[unit] then return player_can_see_cache[unit] end

		local x,y,z = ObjectPosition(unit)

		local see = WorldToScreen(x,y,z)

		if see then
			if see > 1300 then
				-- print("TOO FAR TO RIGHT "..math.random(1,10))
				see = nil
			elseif see < 30 then
				-- print("TOO FAR TO LEFT"..math.random(1,10))
				see = nil
			end
		end

		see = see and true or false

		player_can_see_cache[unit] = see

		return see

	end

	function player_can_see_coords(x,y,z)

		if not x or not y or not z then return end

		if player_can_see_cache[{x,y,z}] then return player_can_see_cache[{x,y,z}] end

		local see,zee = WorldToScreen(x,y,z)

		if see then
			if see > 1250 then
				-- print("TOO FAR TO RIGHT "..math.random(1,10))
				see = nil
			elseif see < 30 then
				-- print("TOO FAR TO LEFT"..math.random(1,10))
				see = nil
			end
		end

		if zee then
			if zee > 800 then
				-- print("TOO FAR UP "..math.random(1,10))
				zee = nil
			elseif zee < 90 then
				-- print("TOO FAR DOWN "..math.random(1,10))
				zee = nil
			end
		end

		see = see and true or false
		zee = zee and true or false

		player_can_see_cache[{x,y,z}] = (see and zee)

		return (see and zee)

	end

	-- needs to also blink into enemy smoke bomb when possible (instead of just not using a blink, check if we could blink into the smoke bomb?)
	function blink_to_unit(unit,maxdist,predict)
		if not maxdist then maxdist = 30 end
		local time = GetTime()
		if player_blink and time - player_blink < .35 then return false end

		--Displacement Position
		if UnitBuffID("player",212799) and _spellCooldown(212801) == 0 then
			if not _LoS(unit,nil,true) or _distance(unit) > maxdist then
				local displacement_position = {}
				for i=1,#AreaTriggers do if ObjectID(AreaTriggers[i]) == 11513 then
					local x,y,z = ObjectPosition(AreaTriggers[i])
					displacement_position = {x,y,z}
					break
				end end
				local dx,dy,dz = unpack(displacement_position)
				local x,y,z
				if dx and dy and dz then
					x,y,z = GroundZ(dx,dy,dz)
				end
				if x and y and z and dz-z < .05 then
					local ux,uy,uz = ObjectPosition(unit)
					if not TraceLine(ux,uy,uz+2,dx,dy,dz+2,losflags) then
						SQ_CastSpellByName("Displacement")
						player_blink = time
						return true
					end
				end
			end
		end
		if not UnitDebuffID(unit,212183) and not UnitBuffID(unit,212183) then
			if not _LoS(unit,nil,true) or _distance(unit) > maxdist then
				local x,y,z
				if predict then
					local px,py,pz = PredictUnitPosition(unit,(player_cast_time_left or .15))
					if px and py and pz then
						x,y,z = blink_los_point(unit,maxdist,px,py,pz)
					else
						x,y,z = blink_los_point(unit,maxdist)
						squid_print("Unable to predict movement blinking to unit")
					end
				else
					x,y,z = blink_los_point(unit,maxdist)
				end
				local px,py,pz = GetPlayerPosition()
				if x and y and z and _spellCooldown(212653) == 0 then
					local dir = GetAnglesBetweenPositions(px,py,pz,x,y,z)
					FaceDirectionFalse(dir,true)
					StopFalling()
					if Player_Facing( dir ) then
						SQ_CastSpellByID(1953)
						player_blink = time
						-- squid_print("Unable to force-blink, MiniBot doesn't support it =(")
						return true
					end
				end
			end
		end
	end

	function blink_to_pos(x,y,z)
		local px,py,pz = GetPlayerPosition()
		if x and y and z and _spellCooldown(212653) == 0 then
			local dir = GetAnglesBetweenPositions(px,py,pz,x,y,z)
			FaceDirection(dir,true)
			SQ_CastSpellByID(1953)
			player_blink = GetTime()
			return true
		end
	end

	function roll_to_unit(unit)
		local time=GetTime()
		if IsFalling() then return false end
		if _spellCooldown(109132) == 0 and _spellCooldown(101545) < 23.5 and (not last_wdp or time-last_wdp > 1.5) then
			local x,y,z = ObjectPosition(unit)
			StopMoving()
			SetMovementLocked(true)
			MoveTo(x,y,z,true)
			SQ_CastSpellByID(109132)
			Squid_Alert("Roll to "..UnitClass(unit),nil,nil,nil,109132)
			C_Timer.After(.1,function()
				SetMovementLocked(false)
			end)
		end
	end

	function fsk_to_unit(unit)
		local time=GetTime()
		if player_fsk and time-player_fsk < 1.5 then return end
		if _spellCooldown(101545) == 0 and (not last_wdp or time-last_wdp > 1.5) then
			StopMoving()
			local x,y,z=ObjectPosition(unit)
			local ml = IsMouselooking()

			if ml then
				C_Timer.After(.5,function()
					if player_fsk and time-player_fsk < 2 then MouselookStart() end
					_targetLastTarget()
				end)
				MouselookStop()
			end
			StrafeLeftStop()
			StrafeRightStop()
			MoveForwardStop()
			MoveTo(x,y,z,true)
			C_Timer.After(.5,function()
				RunMacroText("/console AutoInteract false")
				RunMacroText("/console AutoInteract 0")
			end)
			local flags = UnitMovementFlags("player")
			if flags == 1 then
				MoveTo(x,y,z,true)
				SQ_CastSpellByID(101545)
				forced_fsk=time
				return true
			end
		end
	end

	function squid_ttd(unit,playerdps)

		if not UnitIsVisible(unit) then return 999 end

		if _isDummy(unit) then return 999 end

		local time = GetTime()
		local player_hp = UnitHealthMax("player")
		local groupsize = GetNumGroupMembers()
		if groupsize == 0 then groupsize = 1 end

		--units that will not be dpsing
		local useless_count = 0
		for i=1,#Friends do if _isHealer(Friends[i]) or not UnitIsVisible(Friends[i]) then
			useless_count = useless_count + 1
		end end
		groupsize = groupsize - useless_count

		local unit_hp = UnitHealth(unit)

		local avgdps

		if UnitLevel("player") >= 50 then
			avgdps = player_hp / 9
		else
			avgdps = player_hp / 18
		end

		local totaldps = ( ( avgdps / 2 ) * groupsize ) + ( avgdps * UnitEnemiesAttacking(unit) )

		local ttd = unit_hp / totaldps

		return ttd

	end

	function squid_ttp(unit,percentage,playerdps)

		local time = GetTime()
		local player_hp = UnitHealthMax("player")
		local groupsize = GetNumGroupMembers()
		if groupsize == 0 then groupsize = 1 end

		--units that will not be dpsing
		local useless_count = 0
		for i=1,#Friends do if _isHealer(Friends[i]) or not UnitIsVisible(Friends[i]) then
			useless_count = useless_count + 1
		end end
		groupsize = groupsize - useless_count

		local unit_hp = UnitHealth(unit)
		local avgdps = player_hp / 8
		local totaldps = avgdps * groupsize
		local unit_hp_percentage = 100 * UnitHealth(unit) / UnitHealthMax(unit)
		local unit_hp_deficit = unit_hp_percentage - percentage

		if unit_hp_deficit > 0 then
			local pct_per_second = 100 * totaldps / UnitHealthMax(unit)
			local time_till_pct = unit_hp_deficit / pct_per_second
			return time_till_pct
		else
			return 0
		end

		-- if shitty_ttd[unit] then
		-- 	local time_combat_started = shitty_ttd[unit]
		-- 	local time_in_combat = time - time_combat_started
		-- 	local seconds_in_combat = time_in_combat
		-- 	local hp = _HP(unit)
		-- 	local hp_d = 100 - hp
		-- 	local hp_loss_per_second = hp_d / seconds_in_combat
		-- 	local time_til_zero = hp / hp_loss_per_second
		-- 	return time_til_zero
		-- end
	end

	-- function get_shell_offset()
	-- 	local shell = {}

	-- 	for i=1,#Squid_OM do if ObjectName(Squid_OM[i]) == "Shell" then
	-- 		local o = Squid_OM[i]
	-- 		for n=1,2600 do
	-- 			local descriptor = bit.rshift(ObjectDescriptor(o,n,"ushort"),6)
	-- 			if descriptor > 0 then
	-- 				table.insert(shell,{shell=o,offset=n,descriptor=descriptor,deficit=0})
	-- 			end
	-- 		end
	-- 	end end

	-- 	local offsets = {}
	-- 	for i=1,#shell do

	-- 	end

	-- end
	-- local deficit = 0 for i=1,#Squid_OM do local o = Squid_OM[i] if ObjectName(Squid_OM[i]) == "Shell" then

	local AutoLagTolerance = CreateFrame("Frame", "AutoLagTolerance")
	local GetNetStats = GetNetStats
	local min = math.min
	local SetCVar = SetCVar

	AutoLagTolerance.cache = GetCVar("SpellQueueWindow")
	AutoLagTolerance.timer = 0

	local function AutoLagTolerance_OnUpdate(self, elapsed)
		self.timer = self.timer + elapsed

		if self.timer < 1.0 then
			return
		end

		self.timer = 0

		local latency = min(400, select(4, GetNetStats()))

		local scriptUpdate = ((1/GetFramerate())*8)*1000

		latency = latency + scriptUpdate;

		if latency == 0 then
			return
		end

		if latency == self.cache then
			return
		end

		SetCVar("SpellQueueWindow", latency)

		self.cache = latency
	end

	AutoLagTolerance:SetScript("OnUpdate", AutoLagTolerance_OnUpdate)


	-- LubDraw by docbrown on fh-wow.com
	local LibDraw
	local sin, cos, atan, atan2, sqrt, rad = math.sin, math.cos, math.atan, math.atan2, math.sqrt, math.rad
	local tinsert, tremove = tinsert, tremove

	local function WorldToScreen (wX, wY, wZ)
		local sX, sY = _G.WorldToScreen(wX, wY, wZ);
		if sX and sY then
			return sX, -(WorldFrame:GetTop() - sY);
		else
			return sX, sY;
		end
	end

	-- if LibStub then
	--     -- LibStub version control
	--     LibDraw = LibStub:NewLibrary("LibDraw-1.0", 3)
	--     if not LibDraw then return end
	-- else
		-- Pretty much LibStub
		LibDraw = {
			version = 69.0
		}
		_G['LibDraw'] = LibDraw
	-- end

	LibDraw.line = LibDraw.line or { r = 0, g = 1, b = 0, a = 1, w = 1 }
	LibDraw.level = "BACKGROUND"
	LibDraw.callbacks = { }

	if not LibDraw.canvas then
		LibDraw.canvas = CreateFrame("Frame", WorldFrame)
		LibDraw.canvas:SetAllPoints(WorldFrame)
		LibDraw.lines = { }
		LibDraw.lines_used = { }
		LibDraw.textures = { }
		LibDraw.textures_used = { }
		LibDraw.fontstrings = { }
		LibDraw.fontstrings_used = { }
	end

	function LibDraw.SetColor(r, g, b, a)
		LibDraw.line.r = r * 0.00390625
		LibDraw.line.g = g * 0.00390625
		LibDraw.line.b = b * 0.00390625
		if a then
			LibDraw.line.a = a * 0.01
		else
			LibDraw.line.a = 1
		end
	end

	function LibDraw.SetColorRaw(r, g, b, a)
		LibDraw.line.r = r
		LibDraw.line.g = g
		LibDraw.line.b = b
		LibDraw.line.a = a
	end

	SQUID.line_scale = SQUID.line_scale or 1
	function LibDraw.SetWidth(w)
		LibDraw.line.w = w * SQUID.line_scale
	end

	function LibDraw.Line(sx, sy, sz, ex, ey, ez)
		if not WorldToScreen then return end

		local sx, sy = WorldToScreen(sx, sy, sz)
		local ex, ey = WorldToScreen(ex, ey, ez)

		LibDraw.Draw2DLine(sx, sy, ex, ey)
	end

	function LibDraw.rotateX(cx, cy, cz, px, py, pz, r)
		if r == nil then return px, py, pz end
		local s = sin(r)
		local c = cos(r)
		-- center of rotation
		px, py, pz = px - cx,  py - cy, pz - cz
		local x = px + cx
		local y = ((py * c - pz * s) + cy)
		local z = ((py * s + pz * c) + cz)
		return x, y, z
	end

	function LibDraw.rotateY(cx, cy, cz, px, py, pz, r)
		if r == nil then return px, py, pz end
		local s = sin(r)
		local c = cos(r)
		-- center of rotation
		px, py, pz = px - cx,  py - cy, pz - cz
		local x = ((pz * s + px * c) + cx)
		local y = py + cy
		local z = ((pz * c - px * s) + cz)
		return x, y, z
	end

	function LibDraw.rotateZ(cx, cy, cz, px, py, pz, r)
		if r == nil then return px, py, pz end
		local s = sin(r)
		local c = cos(r)
		-- center of rotation
		px, py, pz = px - cx,  py - cy, pz - cz
		local x = ((px * c - py * s) + cx)
		local y = ((px * s + py * c) + cy)
		local z = pz + cz
		return x, y, z
	end

	function LibDraw.Array(vectors, x, y, z, rotationX, rotationY, rotationZ)
		for _, vector in ipairs(vectors) do
			local sx, sy, sz = x+vector[1], y+vector[2], z+vector[3]
			local ex, ey, ez = x+vector[4], y+vector[5], z+vector[6]

			if rotationX then
				sx, sy, sz = LibDraw.rotateX(x, y, z, sx, sy, sz, rotationX)
				ex, ey, ez = LibDraw.rotateX(x, y, z, ex, ey, ez, rotationX)
			end
			if rotationY then
				sx, sy, sz = LibDraw.rotateY(x, y, z, sx, sy, sz, rotationY)
				ex, ey, ez = LibDraw.rotateY(x, y, z, ex, ey, ez, rotationY)
			end
			if rotationZ then
				sx, sy, sz = LibDraw.rotateZ(x, y, z, sx, sy, sz, rotationZ)
				ex, ey, ez = LibDraw.rotateZ(x, y, z, ex, ey, ez, rotationZ)
			end

			local sx, sy = WorldToScreen(sx, sy, sz)
			local ex, ey = WorldToScreen(ex, ey, ez)
			LibDraw.Draw2DLine(sx, sy, ex, ey)
		end
	end

	function LibDraw.Draw2DLine(sx, sy, ex, ey)

		if not WorldToScreen or not sx or not sy or not ex or not ey then return end

		local L = tremove(LibDraw.lines) or false
		if L == false then
			L = CreateFrame("Frame", LibDraw.canvas)
		L.line = L:CreateLine()
			L.line:SetDrawLayer(LibDraw.level)
		end
		tinsert(LibDraw.lines_used, L)

	  L:ClearAllPoints()

	  if sx > ex and sy > ey or  sx < ex and sy < ey  then
		L:SetPoint("TOPRIGHT", LibDraw.canvas, "TOPLEFT", sx, sy)
		L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", ex, ey)
		L.line:SetStartPoint('TOPRIGHT')
		L.line:SetEndPoint('BOTTOMLEFT')
	  elseif sx < ex and sy > ey then
		L:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
		L:SetPoint("BOTTOMRIGHT", LibDraw.canvas, "TOPLEFT", ex, ey)
		L.line:SetStartPoint('TOPLEFT')
		L.line:SetEndPoint('BOTTOMRIGHT')
	  elseif sx > ex and sy < ey then
		L:SetPoint("TOPRIGHT", LibDraw.canvas, "TOPLEFT", sx, sy)
		L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", ex, ey)
		L.line:SetStartPoint('TOPLEFT')
		L.line:SetEndPoint('BOTTOMRIGHT')
	  else
		-- wat, I don't like this, not one bit
		L:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
		L:SetPoint("BOTTOMLEFT", LibDraw.canvas, "TOPLEFT", sx, ey)
		L.line:SetStartPoint('TOPLEFT')
		L.line:SetEndPoint('BOTTOMLEFT')
	  end

	  L.line:SetThickness(LibDraw.line.w)
		L.line:SetColorTexture(LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a)

		L:Show()

	end

	local full_circle = rad(365)
	local small_circle_step = rad(3)

	function LibDraw.Circle(x, y, z, size)
		local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
		for v=0, full_circle, small_circle_step do
			nx, ny = WorldToScreen( (x+cos(v)*size), (y+sin(v)*size), z )
			LibDraw.Draw2DLine(lx, ly, nx, ny)
			lx, ly = nx, ny
		end
	end

	local flags = bit.bor(collisionflags)

	function LibDraw.GroundCircle(x, y, z, size)
		size = size / 2
		local lx, ly, nx, ny, fx, fy, fz = false, false, false, false, false, false, false
		for v=0, full_circle, small_circle_step*6 do
			fx, fy, fz = TraceLine(  (x+cos(v)*size), (y+sin(v)*size), z+4, (x+cos(v)*size), (y+sin(v)*size), z-100, flags )
			if fx == nil then
				fx, fy, fz = (x+cos(v)*size), (y+sin(v)*size), z
			end
			nx, ny = WorldToScreen( (fx+cos(v)*size), (fy+sin(v)*size), fz )
			LibDraw.Draw2DLine(lx, ly, nx, ny)
			lx, ly = nx, ny
		end
	end

	function LibDraw.Arc(x, y, z, size, arc, rotation)
		local lx, ly, nx, ny, fx, fy = false, false, false, false, false, false
		local half_arc = arc * 0.5
		local ss = (arc/half_arc)
		local as, ae = -half_arc, half_arc
		for v = as, ae, ss do
			nx, ny = WorldToScreen( (x+cos(rotation+rad(v))*size), (y+sin(rotation+rad(v))*size), z )
			if lx and ly then
				LibDraw.Draw2DLine(lx, ly, nx, ny)
			else
				fx, fy = nx, ny
			end
			lx, ly = nx, ny
		end
		local px, py = WorldToScreen(x, y, z)
		LibDraw.Draw2DLine(px, py, lx, ly)
		LibDraw.Draw2DLine(px, py, fx, fy)
	end

	function LibDraw.Texture(config, x, y, z, alphaA, texts)

		local texture, width, height = config.texture, config.width, config.height
		local left, right, top, bottom, scale =  config.left, config.right, config.top, config.bottom, config.scale
		local ULx,ULy,LLx,LLy,URx,URy,LRx,LRy = config.ULx, config.ULy, config.LLx, config.LLY, config.URx, config.URy, config.LRx, config.LRy
		local alpha = config.alpha or alphaA

		if not WorldToScreen or not texture or not width or not height or not x or not y or not z then return end
		if not left or not right or not top or not bottom then
			left = 0
			right = 1
			top = 0
			bottom = 1
		end
		if not scale then
			local cx, cy, cz = GetCameraPosition()
			scale = width / LibDraw.Distance(x, y, z, cx, cy, cz)
		end

		local sx, sy = WorldToScreen(x, y, z)
		if not sx or not sy then return end
		local w = width * scale
		local h = height * scale
		sx = sx - w*0.5
		sy = sy + h*0.5
		local ex, ey = sx + w, sy - h

		local T = tremove(LibDraw.textures) or false
		if T == false then
			T = LibDraw.canvas:CreateTexture(nil, "BACKGROUND")
			T:SetDrawLayer(LibDraw.level)
			T:SetTexture(LibDraw.texture)
		end
		tinsert(LibDraw.textures_used, T)
		T:ClearAllPoints()
		if ULx then
			T:SetTexCoord(ULx,ULy,LLx,LLy,URx,URy,LRx,LRy)
		else
			T:SetTexCoord(left, right, top, bottom)
		end
		T:SetTexture(texture)
		T:SetWidth(width)
		T:SetHeight(height)
		T:SetPoint("TOPLEFT", LibDraw.canvas, "TOPLEFT", sx, sy)
		T:SetPoint("BOTTOMRIGHT", LibDraw.canvas, "TOPLEFT", ex, ey)
		T:SetVertexColor(1, 1, 1, 1)
		if alpha then T:SetAlpha(alpha) else T:SetAlpha(1) end
		T:Show()

		if texts then
			for i=1,#texts do

				local text = texts[i].text
				local font = texts[i].font
				local offsetY = texts[i].offsetY or 0
				local offsetX = texts[i].offsetX or 0

				local F = tremove(LibDraw.fontstrings) or LibDraw.canvas:CreateFontString(nil, "BACKGROUND")

				F:SetFontObject(font)
				F:SetText(text)
				F:SetTextColor(LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a)

				if p then
					local width = F:GetStringWidth() - 4
					local offsetX = width*0.5
					local offsetY = F:GetStringHeight() + 3.5
					local pwidth = width*p*0.01
					FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX), sy-offsetY, 4, r, g, b, 0.25)
					FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX)-(width-pwidth), sy-offsetY, 4, r, g, b, 1)
				end

				F:SetPoint("TOPLEFT", UIParent, "TOPLEFT", sx-(F:GetStringWidth()*0.5)+offsetX, sy+offsetY)
				F:Show()

				tinsert(LibDraw.fontstrings_used, F)

			end
		end

	end

	function LibDraw.Text(text, font, x, y, z)

		local sx, sy = WorldToScreen(x, y, z)

		if sx and sy then

			local F = tremove(LibDraw.fontstrings) or LibDraw.canvas:CreateFontString(nil, "BACKGROUND")

			F:SetFontObject(font)
			F:SetText(text)
			F:SetTextColor(LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a)

			if p then
				local width = F:GetStringWidth() - 4
				local offsetX = width*0.5
				local offsetY = F:GetStringHeight() + 3.5
				local pwidth = width*p*0.01
				FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX), sy-offsetY, 4, r, g, b, 0.25)
				FHAugment.drawLine(sx-offsetX, sy-offsetY, (sx+offsetX)-(width-pwidth), sy-offsetY, 4, r, g, b, 1)
			end

			F:SetPoint("TOPLEFT", UIParent, "TOPLEFT", sx-(F:GetStringWidth()*0.5), sy)
			F:Show()

			tinsert(LibDraw.fontstrings_used, F)

		end

	end

	local rad90 = math.rad(-90)

	function LibDraw.Box(x, y, z, width, height, rotation, offset_x, offset_y)

		if not offset_x then offset_x = 0 end
		if not offset_y then offset_y = 0 end

		if rotation then rotation = rotation + rad90 end

		local half_width = width * 0.5
		local half_height = height * 0.5

		local p1x, p1y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y - half_width + offset_y, z, rotation)
		local p2x, p2y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y - half_width + offset_y, z, rotation)
		local p3x, p3y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y + half_width + offset_y, z, rotation)
		local p4x, p4y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y - half_width + offset_y, z, rotation)
		local p5x, p5y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y + half_width + offset_y, z, rotation)
		local p6x, p6y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y - half_width + offset_y, z, rotation)
		local p7x, p7y = LibDraw.rotateZ(x, y, z, x - half_width + offset_x, y + half_width + offset_y, z, rotation)
		local p8x, p8y = LibDraw.rotateZ(x, y, z, x + half_width + offset_x, y + half_width + offset_y, z, rotation)

		LibDraw.Line(p1x, p1y, z, p2x, p2y, z)
		LibDraw.Line(p3x, p3y, z, p4x, p4y, z)
		LibDraw.Line(p5x, p5y, z, p6x, p6y, z)
		LibDraw.Line(p7x, p7y, z, p8x, p8y, z)

	end

	local deg45 = math.rad(45)
	local arrowX = {
		{ 0  , 0, 0, 1.5,  0,    0   },
		{ 1.5, 0, 0, 1.2,  0.2, -0.2 },
		{ 1.5, 0, 0, 1.2, -0.2,  0.2 }
	}
	local arrowY = {
		{ 0, 0  , 0,  0  , 1.5,  0   },
		{ 0, 1.5, 0,  0.2, 1.2, -0.2 },
		{ 0, 1.5, 0, -0.2, 1.2,  0.2 }
	}
	local arrowZ = {
		{ 0, 0, 0  ,  0,    0,   1.5 },
		{ 0, 0, 1.5,  0.2, -0.2, 1.2 },
		{ 0, 0, 1.5, -0.2,  0.2, 1.2 }
	}

	function LibDraw.DrawHelper()
		local playerX, playerY, playerZ = ObjectPosition("player")
		local old_red, old_green, old_blue, old_alpha, old_width = LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a, LibDraw.line.w

		-- X
		LibDraw.SetColor(255, 0, 0, 100)
		LibDraw.SetWidth(1)
		LibDraw.Array(arrowX, playerX, playerY, playerZ, deg45, false, false)
		LibDraw.Text('X', "GameFontNormal", playerX + 1.75, playerY, playerZ)
		-- Y
		LibDraw.SetColor(0, 255, 0, 100)
		LibDraw.SetWidth(1)
		LibDraw.Array(arrowY, playerX, playerY, playerZ, false, -deg45, false)
		LibDraw.Text('Y', "GameFontNormal", playerX, playerY + 1.75, playerZ)
		-- Z
		LibDraw.SetColor(0, 0, 255, 100)
		LibDraw.SetWidth(1)
		LibDraw.Array(arrowZ, playerX, playerY, playerZ, false, false, false)
		LibDraw.Text('Z', "GameFontNormal", playerX, playerY, playerZ + 1.75)

		LibDraw.line.r, LibDraw.line.g, LibDraw.line.b, LibDraw.line.a, LibDraw.line.w = old_red, old_green, old_blue, old_alpha, old_width
	end

	function LibDraw.Distance(ax, ay, az, bx, by, bz)
		return math.sqrt(((bx-ax)*(bx-ax)) + ((by-ay)*(by-ay)) + ((bz-az)*(bz-az)))
	end

	function LibDraw.Camera()
		local fX, fY, fZ = ObjectPosition("player")
		local sX, sY, sZ = GetCameraPosition()
		return sX, sY, sZ, atan2(sY - fY, sX - fX), atan((sZ - fZ) / sqrt(((fX - sX) ^ 2) + ((fY - sY) ^ 2)))
	end

	function LibDraw.Sync(callback)
		tinsert(LibDraw.callbacks, callback)
	end

	function LibDraw.clearCanvas()
		-- LibDraw.stats = #LibDraw.textures_used
		for i = #LibDraw.textures_used, 1, -1 do
			LibDraw.textures_used[i]:Hide()
			tinsert(LibDraw.textures, tremove(LibDraw.textures_used))
		end
		for i = #LibDraw.fontstrings_used, 1, -1 do
			LibDraw.fontstrings_used[i]:Hide()
			tinsert(LibDraw.fontstrings, tremove(LibDraw.fontstrings_used))
		end
	  for i = #LibDraw.lines_used, 1, -1 do
			LibDraw.lines_used[i]:Hide()
			tinsert(LibDraw.lines, tremove(LibDraw.lines_used))
		end
	end

	local function OnUpdate()
		LibDraw.clearCanvas()
		for _, callback in ipairs(LibDraw.callbacks) do
			callback()
			if LibDraw.helper then
				LibDraw.DrawHelper()
			end
			LibDraw.helper = false
		end
	end

	function LibDraw.Enable(interval)
		local timer
		if not interval then
			timer = C_Timer.NewTicker(interval, OnUpdate)
		else
			timer = C_Timer.NewTicker(interval, OnUpdate)
		end
		return timer
	end

	function LibDraw.DeSync(index)
	  tremove(LibDraw.callbacks, index)
	end
	--LibDraw.canvas:SetScript("OnUpdate", OnUpdate)

	--START WAELITE

	local function Line(sx, sy, sz, ex, ey, ez)
		local function WorldToScreen (wX, wY, wZ)
			local sX, sY = _G.WorldToScreen(wX, wY, wZ);
			if sX and sY then
				return sX, -(WorldFrame:GetTop() - sY);
			else
				return sX, sY;
			end
		end
		local startx, starty = WorldToScreen(sx, sy, sz)
		local endx, endy = WorldToScreen(ex, ey, ez)
		if (endx == nil or endy == nil) and startx then
			local i = 1
			while ( endx == nil or endy == nil ) and i < 200 do
				endx, endy = WorldToScreen(GetPositionBetweenPositions(ex, ey, ez, sx, sy, sz, i))
				i = i + 1
			end
		end
		if (startx == nil or starty == nil) and endx then
			local i = 1
			while ( startx == nil or starty == nil ) and i < 200 do
				startx, starty = WorldToScreen(GetPositionBetweenPositions(sx, sy, sz, ex, ey, ez, i))
				i = i + 1
			end
		end
		if startx and starty and endx and endy then
			LibDraw.Draw2DLine(startx, starty, endx, endy)
		end
	end

	SLASH_trackQuests1 = "/trackquests"
	SlashCmdList["trackQuests"] = function(msg)
		if trackQuests == false then
			trackQuests = true
			print("Tracking Quest Objectives")
		else
			trackQuests = false
			print("Not Tracking Quest Objectives")
		end
	end

	SLASH_trackObjects1 = "/trackobjects"
	SlashCmdList["trackObjects"] = function(msg)
		if trackObjects == false then
			trackObjects = true
			print("Tracking Quest Objects")
		else
			trackObjects = false
			print("Not Tracking Quest Objects")
		end
	end

	SLASH_drawcleave1 = "/drawcleave"
	SlashCmdList["drawcleave"] = function(msg)
		if drawCleave == false then
			drawCleave = true
			print("Cleave Draw On")
		else
			drawCleave = false
			print("Cleave Draw Off")
		end
	end

	SLASH_dumpstuff1 = "/dumpstuff"
	SlashCmdList["dumpstuff"] = function(msg)
		if dumpstuff == false then
			dumpstuff = true
			print("dumpstuff On")
		else
			dumpstuff = false
			print("dumpstuff Off")
		end
	end

	local cleaveCasts = Squid_cleaveCasts

	--
	local function Debug_Print(strName, tData)
		if ViragDevTool_AddData then
			ViragDevTool_AddData(tData, strName)
		end
	end

	local areaTrigger = Squid_areaTrigger

	local function distance(unit1, unit2)
		local x1, y1, z1
		local unit1CR
		if unit1 == "player" then
			x1, y1, z1 = pX, pY, pZ
			unit1CR = playerCR
		else
			x1, y1, z1 = ObjectPosition(unit1)
			unit1CR = UnitCombatReach(unit1)
		end
		local x2, y2, z2 = ObjectPosition(unit2)
		if not x2 or not y2 or not z2 then om[unit2] = nil; return 0; end
		if not x1 or not y1 or not z1 then om[unit1] = nil; return 0; end
		return sqrt(((x2 - x1) ^ 2) + ((y2 - y1) ^ 2) + ((z2 - z1) ^ 2)) -
			((unit1CR or 0) + (UnitCombatReach(unit2) or 0)), z2 - z1
	end

	--Quest stuff
	-- local questPlateTooltip = CreateFrame('GameTooltip', 'QuestPlateTooltip', nil, 'GameTooltipTemplate')
	local myName = UnitName("player")
	local function isQuestUnit(unit)
		if trackQuests or SQUID.track_quests then
			local objectID = ObjectID(unit)
			local known = {
			[101518] = true,
			[156335] = true,
			}
			if known[objectID] then return true end
			local guid = ObjectGUID(unit)
			-- questPlateTooltip:SetOwner(WorldFrame, 'ANCHOR_NONE')
			-- questPlateTooltip:SetHyperlink('unit:' .. guid)
			-- for i = 3, questPlateTooltip:NumLines() do
			--     local str = _G['QuestPlateTooltipTextLeft' .. i]
			--     local text = str and str:GetText()
			--     if not text then
			--         return false
			--     end
			--     local playerName, progressText = strmatch(text, '^ ([^ ]-) ?%- (.+)$')
			--     if (playerName == "" or playerName == myName) and progressText ~= nil then
			--         local x, y = strmatch(progressText, '(%d+)/(%d+)')
			--         if x ~= nil and y ~= nil and y - x > 0 then
			--             local killQuest = false
			--             if (GetLocale() == "ruRU") then
			--                 killQuest = strfind(progressText, "ÑƒÐ±Ð¸Ñ‚Ð¾") ~= nil
			--             else
			--                 killQuest = strfind(progressText, "slain") ~= nil
			--             end
			--             if not UnitIsDeadOrGhost(unit) or (not killQuest and UnitCanBeLooted(unit)) then
			--                 return true
			--             end
			--         end
			--     end
			-- end
		end
		-- if IsQuestObject(unit) then return true end
		return false
	end

	local function isQuestObject(object) --Ty Ssateneth
		local objectID = ObjectID(object)
		-- if IsQuestObject(objectID) then return true end
		local known = {
		[290542] = true,
		[113768] = true,
		[113771] = true,
		[113769] = true,
		[113769] = true,
		[113770] = true,
		[325397] = true,
		[325996] = true,
		[341554] = true,
		[341606] = true,
		[341470] = true,
		[330543] = true,
		[330572] = true,
		}
		if known[objectID] then return true end
		-- local glow = ObjectDescriptor(object,GetOffset("CGObjectData__DynamicFlags"),"uint")
		if glow and (bit.band(glow,0x4)~=0 or bit.band(glow,0x20)~=0) then
			return true
		end
		return false
	end

	local function BasicLine(sx, sy, sz, ex, ey, ez)
		local function WorldToScreen (wX, wY, wZ)
			local sX, sY = _G.WorldToScreen(wX, wY, wZ);
			if sX and sY then
				return sX, -(WorldFrame:GetTop() - sY);
			else
				return sX, sY;
			end
		end
		local startx, starty = WorldToScreen(sx, sy, sz)
		local endx, endy = WorldToScreen(ex, ey, ez)
		if (endx == nil or endy == nil) and startx then
			local i = 1
			while endx == nil or endy == nil do
				local zdif = ez - sz
				if zdif > 0 then ez = ez - zdif end
				endx, endy = WorldToScreen(GetPositionBetweenPositions(ex, ey, ez, sx, sy, sz, i))
				i = i + 1
			end
		end
		if (startx == nil or starty == nil) and endx then
			local i = 1
			while startx == nil or starty == nil do
				local zdif = sz - ez
				if zdif > 0 then sz = sz - zdif end
				startx, starty = WorldToScreen(GetPositionBetweenPositions(sx, sy, sz, ex, ey, ez, i))
				i = i + 1
			end
		end
		LibDraw.Draw2DLine(startx, starty, endx, endy)
	end

	local function getRectUnit(width,length,unit,startingpoint,movingdir,extra,forcedangle)
		extra = extra or 0
		extra = extra * math.pi / 180
		startingpoint = startingpoint or 0
		width = width or 3
		length = length or 30
		local x, y, z = ObjectPosition(unit)
		local facing = not movingdir and ObjectFacing(unit) or _getMovingDirection(unit) or 0
		facing = facing + extra

		if forcedangle then
			facing = forcedangle
		end

		x = x + startingpoint * math.cos(facing)
		y = y + startingpoint * math.sin(facing)

		local halfWidth = width/2
		-- Near Left
		local nlX, nlY, nlZ = GetPositionFromPosition(x, y, z, halfWidth, facing + rad(90), 0)
		-- Near Right
		local nrX, nrY, nrZ = GetPositionFromPosition(x, y, z, halfWidth, facing + rad(270), 0)
		-- Far Left
		local flX, flY, flZ = GetPositionFromPosition(nlX, nlY, nlZ, length, facing, 0)
		-- Far Right
		local frX, frY, frZ = GetPositionFromPosition(nrX, nrY, nrZ, length, facing, 0)

		return nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ
	end

	local special_areatriggers = {

		--tests
		[12740] = true, -- test orb

		-- KINGS REST
		-- [17843] = true, -- KR Last Boss Tornadoes
		-- [17933] = true, -- KR Mob Tornadoes
		[17625] = true, -- KR Swirly Blade Boss

		-- MECHAGON WORKSHOP
		[19968] = true, -- Swirly Gears

		-- FREEHOLD
		-- [16776] = true, -- turtle shells
		[24078] = true, -- torg orb
		[165532] = true, -- plaguefall tentac
	}

	local player_class = select(2,UnitClass("player"))
	local function drawTriggers()
		if SQUID.streaming_mode then return end
		local px,py,pz = GetPlayerPosition()
		for _, v in pairs(areaTriggers) do
			if (trackQuests or SQUID.track_quests or trackObjects) and ( v.objectType == "GameObject" or v.objectType == "Unit" ) and isQuestObject(v.objectPointer) then

				local x,y,z = ObjectPosition(v.objectPointer)
				local s = v.size
				LibDraw.SetColor(255,0,0)
				LibDraw.SetWidth(4)
				local name = ObjectName(v.objectPointer)

				--trackquests waypoint
				-- if GetDistanceBetweenPositions(px,py,pz,x,y,z) > 4 then

					local dist = math.floor(GetDistanceBetweenPositions(px,py,pz,x,y,z))

					local wf_top = WorldFrame:GetTop()
					local scx,scy = GetCursorPosition()
					local sx,sy = WorldToScreen(x,y,z)

					local a = (100-(30-dist)) / 100
					if dist < 14 then
						a = a * (dist/14)
						if dist < 10 then
							a = a * (dist/32)
							if dist < 8 then
								a = a * (dist/32)
							end
						end
					end
					if a > 1 then a = 1 end
					if a < .3 then a = .3 end

					local dist_def = dist/4.5

					LibDraw.SetColorRaw(212/255,175/255,85/255,1)

					local mouse_in_range
					if sx and sy then
						if scx and scy then
							sy = sy + wf_top
							local d = sqrt( math.pow(scx - sx, 2) + math.pow(scy - sy, 2) )
							if d < max(80 - dist, 25) then
								if name and SQUID.mouseover_names then
									-- LibDraw.Text(name, "GameFontNormal", x, y, z+3)
									mouse_in_range=true
								end
								if d < max(80 - dist, 5) then
									-- local def = abs(5/(d-5))
									-- local fade = max(0,def)
									-- a = a - fade
									-- a = max(0.3,a)
								end
								-- InteractUnit(v.objectPointer)
							end
						end
					end

					local texture
					if UnitCanBeLooted(v.objectPointer)  then
						if mouse_in_range and dist < 5 then
							if GetKeyState(0x02) == true then
								InteractUnit(v.objectPointer)
								Squid_Alert("Helping you click the "..name, ":)")
							end
						end
						texture = {
							texture = 133784,
							width = 18+dist_def, height = 18+dist_def,
							alpha = a,
						}
					else
						texture = {

							texture = 3308452,
							width = 22 + (dist_def*.65), height = 41 + dist_def,
							alpha = a,

							left = 0.5,
							right = 1,
							top = 0,
							bottom = 1,

						}
					end


					local texts
					if mouse_in_range then
						texts = {
							[1] = {text=name, font="GameFontNormalSmall", offsetY=20, offsetX=7},
							[2] = {text=dist .. " yds", font="GameFontNormalSmall", offsetY=-23+(dist_def-12), offsetX=7}
						}
					end
					LibDraw.Texture(texture,x,y,z,nil,texts);

				-- end

				if SQUID.draw_line_to_objects and name ~= "Vault Door" then
					local dist = GetDistanceBetweenPositions(px,py,pz,x,y,z)
					local a = (100 - dist) / 100
					local g = a
					if a > .85 then a = .85 end
					if a < .3 then a = .3 end
					if g > 1 then g = 1 end
					if g < .75 then g = .75 end
					if SQUID.draw_line_to_objects and GetDistanceBetweenPositions(px,py,pz,x,y,z) <= SQUID.max_object_finder_dist then
						local w = 2.5 + (a * 3.5)
						LibDraw.SetWidth(w)
						local r = 1
						LibDraw.SetColorRaw(r, g, 0, a)
						BasicLine(px,py,pz,x,y,z)
					end
				end

			elseif v.objectType == "AreaTrigger" and v.distance <= 60 then

				local circle_draw

				local x,y,z = ObjectPosition(v.objectPointer)

				local s = v.size
				local dont_draw

				--if object.objectPointer == "player" or not TraceLine(pX, pY, pZ, x, y, z, 0x10) then
				LibDraw.SetWidth(4)
				if v.good == "owner" then

					local parents = {}
					if Squid_OM and v.parent then
						for i=1,#Squid_OM do
							if ObjectIsVisible(Squid_OM[i]) and ObjectID(Squid_OM[i]) == v.parent then
								table.insert(parents,Squid_OM[i])
							end
						end
					end

					local good_creator
					for i=1,#parents do
						local creator = ObjectCreator(parents[i])
						if creator then
							if UnitIsVisible(creator) and UnitIsFriend("player",creator) and not unit_can_attack("player",creator) then
								local ox,oy,oz = ObjectPosition(parents[i])
								if GetDistanceBetweenPositions(ox,oy,oz,x,y,z) < 1 then
									good_creator = true
								end
							end
						end
					end

					if good_creator then
						LibDraw.SetColor(100,255,0)
					else
						LibDraw.SetColor(255,255,80)
					end

				elseif type(v.good) == "function" then
					if v.good(v.objectPointer) then
						circle_draw = true
						LibDraw.SetColorRaw(.788, .96, .929, .3)
					else
						dont_draw = true
					end
				elseif v.good then
					LibDraw.SetColor(100,255,0)
				else
					LibDraw.SetColor(255,0,0)
				end

				local objectID = v.objectID
				local thisUnit = v.objectPointer

				if dumpstuff and not areaTrigger[objectID] then
					LibDraw.SetColor(255,255,255)
					LibDraw.Text(ObjectID(v.objectPointer), "GameFontNormal", x, y, z+5)
					--facing arrow
					local angle = ObjectFacing(v.objectPointer)
					if angle then
						LibDraw.SetColor(200,255,100)
						local arrow_size = 0.3
						local arrow_shape = {
						  {-arrow_size, -arrow_size, 0, 0, 0, 0},
						  {arrow_size, -arrow_size, 0, 0, 0, 0},
						}
						LibDraw.SetWidth(2)
						LibDraw.Array(arrow_shape, x + 3.5 * math.cos(angle), y + 3.5 * math.sin(angle), z, math.rad(180), math.rad(180), math.rad(90) + angle)
						angle = nil
					end
					--moving direction arrow
					local angle = _getMovingDirection(v.objectPointer)
					if angle then
						LibDraw.SetColor(80,255,100)
						local arrow_size = 0.5
						local arrow_shape = {
						  {-arrow_size, -arrow_size, 0, 0, 0, 0},
						  {arrow_size, -arrow_size, 0, 0, 0, 0},
						}
						LibDraw.SetWidth(2)
						LibDraw.Array(arrow_shape, x + 4.5 * math.cos(angle), y + 4.5 * math.sin(angle), z, math.rad(180), math.rad(180), math.rad(90) + angle)
					end
				end

				if circle_draw ~= false then
					if circle_draw then
						LibDraw.GroundCircle(x, y, z, s)
					elseif dont_draw then
						-- nope
					elseif areaTrigger[objectID] or dumpstuff then
						Line(x, y, z+s*1.75, x, y, z)
						Line(x-s, y, z, x+s, y, z)
						Line(x, y-s, z, x, y+s, z)
					end

				end

				LibDraw.SetColor(255,150,0)

				-- TESTS
				if dumpstuff and objectID == 12740 then --orb test
					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
						local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(8,12,thisUnit,2.5)
						Line(flX, flY, pZ, nlX, nlY, pZ)
						Line(frX, frY, pZ, nrX, nrY, pZ)
						Line(frX, frY, pZ, flX, flY, pZ)
						Line(nlX, nlY, pZ, nrX, nrY, pZ)
				-- KING'S REST
				elseif objectID == 17843 then -- KR last boss tornadoes
					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
						local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(3,4,thisUnit,1,nil,(ObjectFacing(thisUnit) * 180 / math.pi)-45)
						Line(flX, flY, pZ, nlX, nlY, pZ)
						Line(frX, frY, pZ, nrX, nrY, pZ)
						Line(frX, frY, pZ, flX, flY, pZ)
						Line(nlX, nlY, pZ, nrX, nrY, pZ)
				elseif objectID == 17933 then -- KR mob nados
					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
						local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(2.5,3.5,thisUnit,1)
						Line(flX, flY, pZ, nlX, nlY, pZ)
						Line(frX, frY, pZ, nrX, nrY, pZ)
						Line(frX, frY, pZ, flX, flY, pZ)
						Line(nlX, nlY, pZ, nrX, nrY, pZ)
				elseif objectID == 17625 then -- kr swirly blade axe
					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
						local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(9,14,thisUnit,-5)
						Line(flX, flY, pZ, nlX, nlY, pZ)
						Line(frX, frY, pZ, nrX, nrY, pZ)
						Line(frX, frY, pZ, flX, flY, pZ)
						Line(nlX, nlY, pZ, nrX, nrY, pZ)

				elseif objectID == 24078 and v.distance < 18 then -- torghast orb shit

					local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(1.8,6,thisUnit,-1)
					Line(flX, flY, pZ, nlX, nlY, pZ)
					Line(frX, frY, pZ, nrX, nrY, pZ)
					Line(frX, frY, pZ, flX, flY, pZ)
					Line(nlX, nlY, pZ, nrX, nrY, pZ)

				elseif objectID == 165532 then --plaguefall 40y range 25 deg cone tentacles on last boss

					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
					local x,y,z = ObjectPosition(thisUnit)
					local facing = ObjectFacing(thisUnit)
					-- if GetTime() - WAe.waUnitTimers[thisUnit] > 4 then
						LibDraw.Arc(x, y, z, 40, 25, facing)
					-- end

				end

			end
		end
		for k, v in pairs(om) do
			if v.pulseTime == nil or GetTime() >= v.pulseTime then
				local pointerDistance = distance("player", k)
				if pointerDistance > 50 then
					v.pulseTime = GetTime() + 0.25
				else
					v.pulseTime = GetTime() + 0.1
				end
				local thisType = v.objectType
				if thisType == "AreaTrigger" then
					-- local objectID = ObjectID(k)
					local insertObject = {}
					insertObject.objectID = v.objectID
					insertObject.objectPointer = k
					insertObject.distance = pointerDistance
					insertObject.objectType = thisType
					if areaTrigger[v.objectID] then
						insertObject.size = areaTrigger[v.objectID].size
						insertObject.good = areaTrigger[v.objectID].good
						insertObject.parent = areaTrigger[v.objectID].parent
					else
						insertObject.size = 2
						insertObject.good = false
					end
					areaTriggers[k] = insertObject
				elseif thisType == "Unit" or not inInstance and thisType == "Player" then
					wa_CheckUnit(k, pointerDistance)
				elseif not inInstance and thisType == "GameObject" and isQuestObject(k) then
					local insertObject = {}
					insertObject.objectPointer = k
					insertObject.distance = pointerDistance
					insertObject.objectType = thisType
					insertObject.size = 1.5
					areaTriggers[k] = insertObject
				end
			end
		end
		if dumpstuff and not IsMouselooking() then
			local cx,cy,cz = WorldPositionFromCursor()
			for k, v in pairs(om) do
				local thisUnit = k
				local objectID = v.objectID
				if not areaTrigger[objectID] then --and ( v.objectType == "GameObject" or v.objectType == "Unit" or )
					local x,y,z = ObjectPosition(thisUnit)
					if cx and cy and cz and x and y and z and ( GetDistanceBetweenPositions(cx,cy,cz,x,y,z) < 5 or unit_is_unit(thisUnit,"mouseover") ) then
						LibDraw.SetWidth(4)
						LibDraw.SetColor(0,255,100)
						LibDraw.Text(objectID, "GameFontNormal", x, y, z+4)
						LibDraw.SetColor(255,255,0)
						if v.objectType == "GameObject" then
							LibDraw.SetColor(255,0,255)
						elseif v.objectType == "Unit" then
							LibDraw.SetColor(100,255,0)
						elseif v.objectType == "AreaTrigger" then
							LibDraw.SetColor(255,255,255)
						end
						Line(x, y, z+2, x, y, z)
						Line(x-3, y, z, x+3, y, z)
						Line(x, y-3, z, x, y+3, z)
						if unit_can_attack("player",thisUnit) then
							local cast,_,_,_,_,_,_,_,castid = unit_casting_info(thisUnit)
							local channel,_,_,_,_,_,_,channelid = UnitChannelInfo(thisUnit)
							if cast or channel then
								if not cast_id_printed or GetTime() - cast_id_printed > .5 then
									if cast then print("Cast: " .. cast .. " ID: " .. castid) cast_id_printed = GetTime() end
									if channel then print("Channel: " .. channel .. " ID: " .. channelid) cast_id_printed = GetTime() end
								end
							end
						end
						--facing arrow
						local angle = ObjectFacing(v.objectPointer)
						if angle then
							LibDraw.SetColor(200,255,100)
							local arrow_size = 0.3
							local arrow_shape = {
							  {-arrow_size, -arrow_size, 0, 0, 0, 0},
							  {arrow_size, -arrow_size, 0, 0, 0, 0},
							}
							LibDraw.SetWidth(2)
							LibDraw.Array(arrow_shape, x + 3.5 * math.cos(angle), y + 3.5 * math.sin(angle), z, math.rad(180), math.rad(180), math.rad(90) + angle)
							angle = nil
						end
						--moving direction arrow
						local angle = _getMovingDirection(v.objectPointer)
						if angle then
							LibDraw.SetColor(80,255,100)
							local arrow_size = 0.5
							local arrow_shape = {
							  {-arrow_size, -arrow_size, 0, 0, 0, 0},
							  {arrow_size, -arrow_size, 0, 0, 0, 0},
							}
							LibDraw.SetWidth(2)
							LibDraw.Array(arrow_shape, x + 4.5 * math.cos(angle), y + 4.5 * math.sin(angle), z, math.rad(180), math.rad(180), math.rad(90) + angle)
						end
					end
				end
			end
		end
	end

	local defensives = {

		-- Flat Walls
		{id = 212800, dr = 35}, -- Blur (35% DMG REDUC)
		{id = 209426, dr = 100}, -- Darkness (Just calling it 100%)
		{id = 498, dr = 20}, -- Divine Protection (20% wall)
		{id = 31821, dr = 20}, -- Aura Mastery (20% wall)
		{id = 243435, dr = 20}, -- Fort Brew (20% wall)
		{id = 125174, dr = 100}, -- Karma (100% absorb that doesn't show up in absorbs)
		{id = 122278, dr = 50}, -- Diffuse Magic (20-50% wall based on damage of incoming attack, calling it 50 for the sake of botd)
		{id = 61336, dr = 50}, -- Survival Instincts (50% wall)
		{id = 22812, dr = 20}, -- Barkskin (20% wall)
		{id = 102342, dr = 20}, -- Ironbark (20% wall)
		{id = 201633, dr = 7}, -- Earthen Wall (~7% of botd dmg absorbed)
		{id = 108271, dr = 40}, -- Astral Shift (40% wall)
		{id = 104773, dr = 40}, -- Unending Resolve (40% wall)
		{id = 1966, dr = 30}, -- Feint (30% wall)
		{id = 33206, dr = 40}, -- Pain Supp (40% wall)
		{id = 81782, dr = 40}, -- Barrier (25-50% wall depending on talent)
		{id = 47585, dr = 75}, -- Dispersion (75% wall)
		{id = 213602, dr = 100}, -- Greater Fade (100% wall)
		{id = 197690, dr = 20}, -- Defensive Stance (20% wall)
		{id = 118038, dr = 30}, -- Parry (30% wall)
		{id = 48792, dr = 30}, -- IBF (30% wall)
		{id = 287081, dr = 30}, -- Lichborne (30% wall)
		{id = 186265, dr = 100}, -- Turtle (hunter det)
		{id = 45438, dr = 100}, -- Ice Block

		-- Magic Walls (AMS shows up in UnitGetTotalAbsorbs so not putting here)
		{id = 122783, dr = 60}, -- Diffuse Magic (60% mwall)
		{id = 31224, dr = 100}, -- Cloak of Shadows (100% magic immune)
		{id = 198065, dr = 50}, -- Prismatic Cloak Mage Blink Shit

	}

	local function isJainaSnow(unit)
		if ObjectID(unit) ~= 146409 then return false end
		local unitHP = 100*UnitHealth(unit)/UnitHealthMax(unit)
		if unitHP > 58 and unitHP < 61 then return true end
		return false
	end

	local function isJainaClone(unit)
		if ObjectID(unit) == 149535 then return true end
		return false
	end

	local function wa_CheckUnit(unit, unitDistance)

		if not dumpstuff and unit_is_player(unit) and not unit_can_attack("player", unit) then
			if waUnits[unit] ~= nil then
				waUnits[unit] = nil
				return false
			end
		end

		local function isCritter(Unit)
			local unitType = UnitCreatureType(Unit)
			local types = {
				["Critter"] = true,
				["Kleintier"] = true,
				["Bestiole"] = true,
				["ë™ë¬¼"] = true,
				["Alma"] = true,
				["Bicho"] = true,
				["Animale"] = true,
				["Ð¡ÑƒÑ‰ÐµÑÑ‚Ð²Ð¾"] = true,
				["å°åŠ¨ç‰©"] = true,
				["å°å‹•ç‰©"] = true,
				["Wild Pet"] = true,
				["UngezÃ¤hmtes Tier"] = true,
				["Mascotte sauvage"] = true,
				["ì•¼ìƒ ì• ì™„ë™ë¬¼"] = true,
				["Mascota salvaje"] = true,
				["MascÃ³ta Salvaje"] = true,
				["Mascote Selvagem"] = true,
				["Creatura Selvaggia"] = true,
				["é‡Žç”Ÿå® ç‰©"] = true,
				["é‡Žç”Ÿå¯µç‰©"] = true
			}
			if types[unitType] ~= nil then
				return true
			end
			return false
		end
		if unitDistance == nil then
			unitDistance = distance("player", unit)
		end
		if unitDistance > 50 and not isJainaSnow(unit) and not isJainaClone(unit) and not isQuestUnit(unit) then
			if waUnits[unit] ~= nil then
				waUnits[unit] = nil
			end
			if WAe.waUnitTimers[unit] ~= nil then
				WAe.waUnitTimers[unit] = nil
			end
			return false
		end
		if not isCritter(unit) then
			if waUnits[unit] == nil then
				waUnits[unit] = true
			end
			return true
		end
		return false
	end

	function UnitIsFacingExtra(unit,otherunit,angle,extra)
		if not extra or extra == 0 then return UnitIsFacing(unit,otherunit,angle) end
		local x,y = ObjectPosition(unit)
		local tX,tY = ObjectPosition(otherunit)
		local rotation = ObjectFacing(unit) + extra
		return ((x-tX)*math.cos(-rotation))-((y-tY)*math.sin(-rotation)) < ( angle * math.pi/180 )
	end

	local function checkCleave(unit, spellID)
		local function isInside(x,y,ax,ay,bx,by,dx,dy)
			local bax = bx - ax
			local bay = by - ay
			local dax = dx - ax
			local day = dy - ay
			if ((x - ax) * bax + (y - ay) * bay <= 0.0) then return false end
			if ((x - bx) * bax + (y - by) * bay >= 0.0) then return false end
			if ((x - ax) * dax + (y - ay) * day <= 0.0) then return false end
			if ((x - dx) * dax + (y - dy) * day >= 0.0) then return false end
			return true
		end
		--Cleave casts
		if spellID == nil then
			spellID = select(9,unit_casting_info(unit))
		end
		if spellID == nil then
			spellID = select(8,UnitChannelInfo(unit))
		end
		if spellID ~= nil and cleaveCasts[spellID] ~= nil then
			if cleaveCasts[spellID].type == "cone" then
				if UnitIsFacingExtra(unit, "player", (cleaveCasts[spellID].angle/2), cleaveCasts[spellID].direction) and distance("player", unit) <= cleaveCasts[spellID].range then
					return true
				end
			elseif cleaveCasts[spellID].type == "rect" then
				if cleaveCasts[spellID].targeted == true then
					return true
				end
				local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(cleaveCasts[spellID].width,cleaveCasts[spellID].range,unit,cleaveCasts[spellID].startingpoint)
				--local pX, pY, zY = ObjectPosition("player")
				if isInside(pX,pY,nlX,nlY,nrX,nrY,frX,frY) then
					return true
				end
			end
		end
		--Units/Objects
		local objectID = ObjectID(unit)
		--Volcanic
		if objectID == 105877 then
			if WAe.waUnitTimers[unit] == nil then
				WAe.waUnitTimers[unit] = GetTime()
			end
			if (GetTime() - WAe.waUnitTimers[unit]) <= 2 then
				if distance("player", unit) <= 2.5 then
					return true
				end
			end

		elseif objectID == 148881 then --Jaina ice spear thing
			if WAe.waUnitTimers[unit] == nil then
				WAe.waUnitTimers[unit] = GetTime()
			end
			if (GetTime() - WAe.waUnitTimers[unit]) <= 10 then
				local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(1.5,40,unit)
				if isInside(pX,pY,nlX,nlY,nrX,nrY,frX,frY) then
					return true
				end
			end
		end
		return false
	end

	-- test fix
	local squid_evade = true

	local function CleaveDraw()
		--local pX, pY, zY = ObjectPosition("player")
		local tX, tY, tZ, s
		for thisUnit in pairs(waUnits) do
			if wa_CheckUnit(thisUnit) then

				local channel
				local endtime, _, _, _, spellID = select(5,unit_casting_info(thisUnit))
				if spellID == nil then
					endtime, _, _,spellID = select(5,UnitChannelInfo(thisUnit))
					channel = spellID
				end

				if dumpstuff then
					local spell, channel, castobj, channobj = UnitCastID(thisUnit)
					castobj = castobj and ObjectName(castobj) or ""
					channobj = channobj and ObjectName(channobj) or ""
					-- local channelLogged
					if channel ~= 0 and (channelLogged ~= channel) and channel ~= nil then
						channelLogged = channel
						WriteFile("WAEliteDump.txt", "Name = "..ObjectName(thisUnit)..", CastID = ".. channel .. ", CastName = "..GetSpellInfo(channel)..", Target = "..channobj .. "\n", true)
					elseif spell ~= 0 and (spellloged ~= spell) and spell ~= nil then
						spellloged = spell
						WriteFile("WAEliteDump.txt", "Name = "..ObjectName(thisUnit)..", CastID = ".. spell .. ", CastName = "..GetSpellInfo(spell)..", Target = "..castobj .. "\n", true)
					end
				end

				if spellID ~= nil and cleaveCasts[spellID] ~= nil then
					--only draw player spells if you can attack the unit
					if not cleaveCasts[spellID].player or dumpstuff or unit_can_attack("player",thisUnit) then
						local check = checkCleave(thisUnit, spellID)
						if check then

							if channel then
								LibDraw.SetColorRaw(1, 0, 0, 1)
							else
								local r = 1 + ( 1.75 - _castTimeLeft(thisUnit) ) / 2.75
								local g = 1 - r
								local b = 0
								local a = .55 + ( min(.45,r / 2.2222222) )
								LibDraw.SetColorRaw(r, g, b, a)
								--squid evade
							end

						elseif not channel and _castTimeLeft(thisUnit) <= 2.75 then
							local r = ( 2.75 - _castTimeLeft(thisUnit) ) / 2.75
							local g = 1 - r
							local b = 0
							local a = .55 + ( min(.45,r / 2.2222222) )
							LibDraw.SetColorRaw(r, g, b, a)
						elseif channel then
							LibDraw.SetColorRaw(1, .25, 0, .8)
						else
							LibDraw.SetColorRaw(0, 1, 0, .55)
						end
						if cleaveCasts[spellID].type == "rect" then
							local rotation
							if cleaveCasts[spellID].targeted == true then
								local unit_target = UnitSpellTarget(thisUnit)
								if not unit_target then unit_target = UnitTarget(thisUnit) end
								if unit_target and UnitIsVisible(unit_target) then
									local pX, pY, pZ = ObjectPosition(unit_target)
									local tX,tY,tZ = ObjectPosition(thisUnit)
									rotation = GetAnglesBetweenPositions(tX,tY,tZ,pX,pY,pZ) + cleaveCasts[spellID].direction
								else
									rotation = ObjectFacing(thisUnit) + cleaveCasts[spellID].direction
								end
							end
							local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(cleaveCasts[spellID].width,cleaveCasts[spellID].range,thisUnit,cleaveCasts[spellID].startingpoint,nil,nil,rotation)
							Line(flX, flY, pZ, nlX, nlY, pZ)
							Line(frX, frY, pZ, nrX, nrY, pZ)
							Line(frX, frY, pZ, flX, flY, pZ)
							Line(nlX, nlY, pZ, nrX, nrY, pZ)
						elseif cleaveCasts[spellID].type == "cone" then
							tX, tY, tZ = ObjectPosition(thisUnit)

							local rotation
							if cleaveCasts[spellID].targeted == true then
								local unit_target = UnitSpellTarget(thisUnit)
								if not unit_target then unit_target = UnitTarget(thisUnit) end
								if unit_target and UnitIsVisible(unit_target) then
									local pX, pY, pZ = ObjectPosition(unit_target)
									rotation = GetAnglesBetweenPositions(tX,tY,tZ,pX,pY,pZ) + cleaveCasts[spellID].direction
								else
									rotation = ObjectFacing(thisUnit) + cleaveCasts[spellID].direction
								end
							else
								rotation = ObjectFacing(thisUnit) + cleaveCasts[spellID].direction
							end

							LibDraw.Arc(tX, tY, tZ, cleaveCasts[spellID].range, cleaveCasts[spellID].angle, rotation)
						end
					end
				end

				local objectID = ObjectID(thisUnit)
				if objectID == 105877 then -- Volcanic
					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
					if (GetTime() - WAe.waUnitTimers[thisUnit]) <= 2 then
						tX, tY, tZ = ObjectPosition(thisUnit)
						s = 1.5

						LibDraw.SetWidth(5)

						LibDraw.SetColorRaw(1, 0, 0, 1)

						Line(tX, tY, tZ+s*2, tX, tY, tZ)
						Line(tX-s, tY, tZ, tX+s, tY, tZ)
						Line(tX, tY-s, tZ, tX, tY+s, tZ)
					end
				elseif objectID == 129747 then -- FH Harlan's shits

					local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(2.5,20,thisUnit)
					Line(flX, flY, pZ, nlX, nlY, pZ)
					Line(frX, frY, pZ, nrX, nrY, pZ)
					Line(frX, frY, pZ, flX, flY, pZ)
					Line(nlX, nlY, pZ, nrX, nrY, pZ)

				elseif objectID == 165532 then --plaguefall 40y range 25 deg cone tentacles on last boss

					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
					local x,y,z = ObjectPosition(thisUnit)
					local facing = ObjectFacing(thisUnit)
					-- if GetTime() - WAe.waUnitTimers[thisUnit] > 4 then
						LibDraw.Arc(x, y, z, 40, 25, facing)
					-- end

				elseif objectID == 157314 or objectID == 168539 or objectID == 174803 then

					local x,y,z=ObjectPosition(thisUnit)
					local px,py,pz=GetPlayerPosition()
					if GetDistanceBetweenPositions(x,y,z,px,py,pz) < 30 then
						if GetDistanceBetweenPositions(x,y,z,px,py,pz) < 20 then
							LibDraw.Text("Axe Swing", "GameFontNormalSmall", x, y, z+4)
						end
						local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(2,20,thisUnit,-10)
						Line(flX, flY, pZ, nlX, nlY, pZ)
						Line(frX, frY, pZ, nrX, nrY, pZ)
						Line(frX, frY, pZ, flX, flY, pZ)
						Line(nlX, nlY, pZ, nrX, nrY, pZ)
					end

				elseif objectID == 126841 then -- FH Bird Charge
					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
					if GetUnitSpeed(thisUnit) < 3 or GetUnitSpeed(thisUnit) > 24 then
						local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(6,60,thisUnit)
						Line(flX, flY, pZ, nlX, nlY, pZ)
						Line(frX, frY, pZ, nrX, nrY, pZ)
						Line(frX, frY, pZ, flX, flY, pZ)
						Line(nlX, nlY, pZ, nrX, nrY, pZ)
					end
				elseif objectID == 129448 then -- FH Shark1
					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
						local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(3,5,thisUnit)
						Line(flX, flY, pZ, nlX, nlY, pZ)
						Line(frX, frY, pZ, nrX, nrY, pZ)
						Line(frX, frY, pZ, flX, flY, pZ)
						Line(nlX, nlY, pZ, nrX, nrY, pZ)
				elseif objectID == 129359 then -- FH Shark2
					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
						local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(3,5,thisUnit)
						Line(flX, flY, pZ, nlX, nlY, pZ)
						Line(frX, frY, pZ, nrX, nrY, pZ)
						Line(frX, frY, pZ, flX, flY, pZ)
						Line(nlX, nlY, pZ, nrX, nrY, pZ)
				elseif objectID == 161019 then -- n'yalotha hivemind rollies
					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
						local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(3.5,20,thisUnit)
						Line(flX, flY, pZ, nlX, nlY, pZ)
						Line(frX, frY, pZ, nrX, nrY, pZ)
						Line(frX, frY, pZ, flX, flY, pZ)
						Line(nlX, nlY, pZ, nrX, nrY, pZ)
				elseif objectID == 159173 then -- n'yalotha hivemind rollies alt id
					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
						local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(3.5,20,thisUnit)
						Line(flX, flY, pZ, nlX, nlY, pZ)
						Line(frX, frY, pZ, nrX, nrY, pZ)
						Line(frX, frY, pZ, flX, flY, pZ)
						Line(nlX, nlY, pZ, nrX, nrY, pZ)
				elseif isJainaSnow(thisUnit) then -- Find jaina
					tX, tY, tZ = ObjectPosition(thisUnit)
					s = 3
					LibDraw.SetColor(255,0,0)
					LibDraw.SetWidth(4)
					Line(tX, tY, tZ+s*1.75, tX, tY, tZ)
					Line(tX-s, tY, tZ, tX+s, tY, tZ)
					Line(tX, tY-s, tZ, tX, tY+s, tZ)
				elseif objectID == 149535 then -- Find jaina clone
					tX, tY, tZ = ObjectPosition(thisUnit)
					s = 2
					LibDraw.SetColor(0,128,0)
					LibDraw.SetWidth(4)
					Line(tX, tY, tZ+s*1.75, tX, tY, tZ)
					Line(tX-s, tY, tZ, tX+s, tY, tZ)
					Line(tX, tY-s, tZ, tX, tY+s, tZ)
				elseif objectID == 148881 then --Jaina ice spear thing
					if WAe.waUnitTimers[thisUnit] == nil then
						WAe.waUnitTimers[thisUnit] = GetTime()
					end
					if (GetTime() - WAe.waUnitTimers[thisUnit]) <= 10 then
						local nlX, nlY, nrX, nrY, frX, frY, flX, flY, flZ, nlZ, nrZ, frZ = getRectUnit(1.5,40,thisUnit)
						Line(flX, flY, pZ, nlX, nlY, pZ)
						Line(frX, frY, pZ, nrX, nrY, pZ)
						Line(frX, frY, pZ, flX, flY, pZ)
						Line(nlX, nlY, pZ, nrX, nrY, pZ)
					end
				elseif ( trackQuests or SQUID.track_quests ) and isQuestUnit(thisUnit) then
					tX, tY, tZ = ObjectPosition(thisUnit)
					local px,py,pz = GetPlayerPosition()
					local dist = GetDistanceBetweenPositions(px,py,pz,tX,tY,tZ)
					local dist_def = dist/10
					if UnitCanAttack("player",thisUnit) then
						if not UnitIsDeadOrGhost(thisUnit) then
							if dist > 5 then
								local texture = {
									texture = 236188,
									width = 22+dist_def, height = 22+dist_def,
									alpha = 1,
								}
								LibDraw.Texture(texture,tX,tY,tZ,nil,texts);
							end
						elseif UnitCanBeLooted(thisUnit) then
							local texture = {
								texture = 133784,
								width = 18+dist_def, height = 18+dist_def,
								alpha = 1,
							}
							LibDraw.Texture(texture,tX,tY,tZ,nil,texts);
						else
							local texture = {

								texture = 3308452,
								width = 22 + (dist_def*.65), height = 41 + dist_def,
								alpha = a,

								left = 0,
								right = 0.5,
								top = 0,
								bottom = 1,

							}
							LibDraw.Texture(texture,tX,tY,tZ,nil,texts);
						end
					else
						dist_def=dist_def*2
						texture = {

							texture = 3308452,
							width = 29 + (dist_def*.65), height = 53 + dist_def,
							alpha = a,

							left = 0.5,
							right = 1,
							top = 0,
							bottom = 1,

						}

						LibDraw.Texture(texture,tX,tY,tZ,nil,texts);
						-- s = 1.5
						-- LibDraw.SetColor(255,0,0)
						-- LibDraw.SetWidth(4)
						-- Line(tX, tY, tZ+s*1.5, tX, tY, tZ)
						-- Line(tX-s, tY, tZ, tX+s, tY, tZ)
						-- Line(tX, tY-s, tZ, tX, tY+s, tZ)
					end

					LibDraw.SetColor(0,255,0)
					local name = ObjectName(thisUnit)
					if SQUID.mouseover_names then
						local wf_top = WorldFrame:GetTop()
						local scx,scy = GetCursorPosition()
						local sx,sy = WorldToScreen(tX,tY,tZ)
						local dist = math.floor(_distance(thisUnit))
						if sx and sy then
							if scx and scy then
								sy = sy + wf_top
								local d = sqrt( math.pow(scx - sx, 2) + math.pow(scy - sy, 2) )
								if d < max(80 - dist, 25) then
									LibDraw.Text(name, "GameFontNormalSmall", tX, tY, tZ+2)
								end
							end
						end
					else
						local dist = math.floor(_distance(thisUnit))
						LibDraw.Text(name .. " - " .. dist, "GameFontNormalSmall", tX, tY, tZ+4)
					end

				elseif objectID == 135636 and not UnitIsDeadOrGhost(thisUnit) then --TD Intellect
					tX, tY, tZ = ObjectPosition(thisUnit)
					LibDraw.Text("Intellect", "GameFontNormal", tX, tY, tZ+2)
				elseif objectID == 135634 and not UnitIsDeadOrGhost(thisUnit) then --TD Wisdom
					tX, tY, tZ = ObjectPosition(thisUnit)
					LibDraw.Text("Wisdom", "GameFontNormal", tX, tY, tZ+2)
				elseif objectID == 135630 and not UnitIsDeadOrGhost(thisUnit) then --TD Stamina
					tX, tY, tZ = ObjectPosition(thisUnit)
					LibDraw.Text("Stamina", "GameFontNormal", tX, tY, tZ+2)
				elseif objectID == 135628 and not UnitIsDeadOrGhost(thisUnit) then --TD Attack
					tX, tY, tZ = ObjectPosition(thisUnit)
					LibDraw.Text("Attack", "GameFontNormal", tX, tY, tZ+2)
				end
			end
		end
	end

	function WAe:CheckCleave()
		for thisUnit in pairs(waUnits) do
			if wa_CheckUnit(thisUnit) then
				if checkCleave(thisUnit) then
					return true
				end
			end
		end
		return false
	end

	local function checkOM()
		for k, v in pairs(om) do
			if v.pulseTime == nil or GetTime() >= v.pulseTime then
				local pointerDistance = distance("player", k)
				if pointerDistance > 50 then
					v.pulseTime = GetTime() + 0.25
				else
					v.pulseTime = GetTime() + 0.1
				end
				local thisType = v.objectType
				if thisType == "AreaTrigger" then
					-- local objectID = ObjectID(k)
					local insertObject = {}
					insertObject.objectPointer = k
					insertObject.objectID = v.objectID
					insertObject.distance = pointerDistance
					insertObject.objectType = thisType
					if areaTrigger[v.objectID] then
						insertObject.size = areaTrigger[v.objectID].size
						insertObject.good = areaTrigger[v.objectID].good
						insertObject.parent = areaTrigger[v.objectID].parent
					else
						insertObject.size = 2
						insertObject.good = false
					end
					areaTriggers[k] = insertObject
				elseif thisType == "Unit" or not inInstance and thisType == "Player" then
					wa_CheckUnit(k, pointerDistance)
				elseif not inInstance and thisType == "GameObject" and isQuestObject(k) then
					local insertObject = {}
					insertObject.objectPointer = k
					insertObject.distance = pointerDistance
					insertObject.objectType = thisType
					insertObject.size = 1.5
					areaTriggers[k] = insertObject
				end
			end
		end
	end


	--OM
	local function wa_OM(updated,added,removed)
		pX, pY, pZ = GetPlayerPosition("player")
		playerCR = UnitCombatReach("player")
		local instance_type = select(2,IsInInstance())
		inInstance = instance_type ~= "none" and instance_type ~= "scenario"
		--Objects function
		local function objectCheck(thisObject)
			if om[thisObject] == nil then
				local internalObjectType = ObjectRawType(thisObject)
				if internalObjectType ~= 1 and internalObjectType ~= 9 and internalObjectType ~= 12 or dumpstuff then
					local guid = UnitGUID(thisObject)
					local objectType, _, _, _, _, objectID, _ = strsplit("-", guid)
					objectID = tonumber(objectID)
					-- if distance("player", thisObject) < 1 then print(objectType) end
					--Area triggers
					if objectType == "AreaTrigger" and (areaTrigger[objectID] ~= nil or dumpstuff or special_areatriggers[objectID]) or dumpstuff then
						local insertObject = {}
						insertObject.objectPointer = thisObject
						insertObject.objectID = objectID
						insertObject.objectType = objectType
						om[thisObject] = insertObject
						--print(insertObject.objectPointer)
					elseif (objectType == "Creature" or objectType == "Vehicle") then
						local insertObject = {}
						insertObject.objectPointer = thisObject
						insertObject.objectID = objectID
						insertObject.objectType = "Unit"
						om[thisObject] = insertObject
					elseif not inInstance and ( objectType == "GameObject" or objectType == "Unit" ) then
						local insertObject = {}
						insertObject.objectPointer = thisObject
						insertObject.objectID = objectID
						insertObject.objectType = objectType
						om[thisObject] = insertObject
					elseif objectType == "Player" then
						local insertObject = {}
						insertObject.objectPointer = thisObject
						insertObject.objectID = objectID
						insertObject.objectType = objectType
						om[thisObject] = insertObject
					end
				end
			end
		end
		-- local _, updated, added, removed = GetObjectCount(true)
		if #removed > 0 then
			for _, v in pairs(removed) do
				if om[v] ~= nil then
					om[v] = nil
				end
				if areaTriggers[v] ~= nil then
					areaTriggers[v] = nil
				end
				if waUnits[v] ~= nil then
					waUnits[v] = nil
				end
			end
		end
		if #added > 0 then
			for _, v in pairs(added) do
				objectCheck(v)
			end
		end
	end

	-- END WAELITE

	function SQ_CastSpellByName(spell, target)
		if IsHackEnabled then
			CastSpellByName(spell, target)
		elseif __LB__ then
			lb.UnitTagHandler(CastSpellByName, spell, target)
		end
	end

	function SQ_CastSpellByID(spell, target)
		if IsHackEnabled then
			CastSpellByID(spell, target)
		elseif __LB__ then
			lb.UnitTagHandler(CastSpellByID, spell, target)
		end
	end

	function GetActiveMover()
		return "player"
	end

	--OnUpdate Frame
	CreateFrame("Frame"):SetScript("OnUpdate",function()

		if not (wmbapi or __LB__) or stop_doing_shit then return end

		-- if UnitExists("target") then
		-- 	local x,y,z = ObjectPosition("player")
		-- 	local tx,ty,tz = ObjectPosition("target")
		-- 	Draw2DLine("player","target",15)
		-- 	Draw3DText(tx,ty,tz+2,"hello",25)
		-- end

		-- if nil==nil then return;end

		-- convert minibot api
		if not __LB__ and not minibot_api_converted then
			convert_mb_api()
			minibot_api_converted = true
		end

		--luabox api ( lb funcs lb api )
		if __LB__ and not lb_funcs_init then

			convert_lb_api()

			lb_funcs_init = true

		end

		is_in_instance,instance_type = IsInInstance()

		arena = instance_type == "arena"
		--testing
		-- arena = true
		-- Mage_Rotation_Override="PvP"
		dungeon = instance_type == "party"

		--wipe path out of instance
		if UnitIsDeadOrGhost("player") or instance_type == "none" then
			if _isMoving("player") and squid_path then Squid_StopNav() end
		end

		Squid_UpdateNav()

		local InteractUnit = InteractUnit
		local _LoS = _LoS
		local _isHealer = _isHealer
		-- local GetItemInfo = GetItemInfo
		-- local GetItemCount = GetItemCount
		-- local UnitIsFriend = UnitIsFriend
		-- local UnitInParty = UnitInParty
		local unit_is_unit = unit_is_unit
		local _HP = _HP
		local _CCremains = _CCremains
		local _breakableCC = _breakableCC
		local unit_is_unit = unit_is_unit
		local IsSpellOnGCD = IsSpellOnGCD
		local UnitEnemiesAttacking = UnitEnemiesAttacking
		local Interrupt = Interrupt
		local PhysicalInterrupt = PhysicalInterrupt
		local _Cast = _Cast
		local _distance = _distance
		local GetGCD = GetGCD
		local _castTimeLeft = _castTimeLeft
		local _isHealer = _isHealer
		local PVE_Interrupt = PVE_Interrupt
		local _immuneMagic = _immuneMagic
		local UnitBuffID = UnitBuffID
		local UnitDebuffID = UnitDebuffID
		local _meleeRange = _meleeRange

		unit_buff_cache = {}
		unit_debuff_cache = {}

		local time = GetTime()
		local latency = select(4,GetNetStats())/1000
		local home_latency = select(3,GetNetStats())/1000

		squid_player_class = select(2,UnitClass("player"))

		-- if gpy_est_hit_time then print( gpy_est_hit_time - time ) end

		local frame_buffer = 1/GetFramerate()

		-- Example using InitializeNavigation and CalculatePath:
		-- local initNavigation = false
		-- local ewtPath = nil
		-- local pathIndex = 1
		-- local stuckCount = 0
		-- local lastX, lastY, lastZ = 0, 0, 0
		-- local f = CreateFrame('frame')
		-- f:SetScript("OnUpdate", function (self, event, addon)
		--     if ewtPath ~= nil then
		--         local PlayerX, PlayerY, PlayerZ = ObjectPosition("Player");
		--         local destX = ewtPath[pathIndex][1]
		--         local destY = ewtPath[pathIndex][2]
		--         local destZ = ewtPath[pathIndex][3]
		--         if GetDistanceBetweenPositions(PlayerX, PlayerY, PlayerZ, destX, destY, destZ) < 1 then
		--             pathIndex = pathIndex + 1
		--             -- print('Moving to next coordinates')
		--             if pathIndex > #ewtPath then
		--                 pathIndex = 1
		--                 ewtPath = nil
		--             end
		--         else
		--             if lastX == PlayerX and lastY == PlayerY and lastZ == PlayerZ then
		--                 stuckCount = stuckCount + 1
		--                 if stuckCount > 100 then
		--                     -- print('Stuck jumping...')
		--                     JumpOrAscendStart()
		--                     stuckCount = 0
		--                 end
		--             end
		--             MoveTo(destX, destY, destZ)
		--             lastX = PlayerX
		--             lastY = PlayerY
		--             lastZ = PlayerZ
		--         end
		--     end
		-- end)

		-- run ewt callbacks
		if IsHackEnabled and ewt_callbacks then
			for i=1,#ewt_callbacks do
				ewt_callbacks[i]()
			end
			ewt_callbacks = nil
		end

		-- function GoTo(toX, toY, toZ)
		--     if initNavigation == false then
		--         print('Loading meshes... please wait.')
		--         InitializeNavigation(function(result, extra)
		--             if result == true then
		--                 print('Initialized meshes')
		--                 initNavigation = true
		--                 GoTo(toX, toY, toZ)
		--             else
		--                 print('Failed to initialize meshes.')
		--                 print(extra)
		--             end
		--         end)
		--     else
		--         pathIndex = 1
		--         ewtPath = nil
		--         local PlayerX, PlayerY, PlayerZ = ObjectPosition("Player");
		--         ewtPath, totalDist = CalculatePath(GetMapId(), PlayerX, PlayerY, PlayerZ, toX, toY, toZ, true, false, 1.5)
		--         print('Created path ' .. #ewtPath)
		--     end
		-- end

		-- load mesh for current map
		squid_nav_init = squid_nav_init or {}
		local map_id = GetMapId()
		local bla = IsMeshLoaded(map_id) -- does this need to be a string no
		-- print(bla)
		-- if squid_nav_init[map_id] == nil and not bla then
		-- 	if not mesh_load_attempt or time - mesh_load_attempt > 30 then
		-- 		squid_print("Loading Navigation Mesh For Map " .. map_id)-- .. " (" .. GetZoneText() .. ")")
		-- 		local maps = tostring(map_id)
		-- 		InitializeNavigation(
		-- 			function(x)
		-- 				if x == true then
		-- 					squid_print("Navigation Mesh Loaded For Map " .. map_id)-- .. " (" .. GetZoneText() .. ")" )
		-- 					squid_nav_init[map_id] = true
		-- 				else
		-- 					squid_print('Failed to load Navigation Meshes, please type "/squid mesh" for the link to download them.')
		-- 					squid_nav_init[map_id] = false
		-- 				end
		-- 			end,
		-- 			maps
		-- 		)
		-- 		mesh_load_attempt = time
		-- 	end
		-- end

		--track avg world latency
		squid_latency_tracker = squid_latency_tracker or {}

		if #squid_latency_tracker == 0 then
			if latency ~= 0 then
				table.insert(squid_latency_tracker,latency)
			end
		else
			local index = #squid_latency_tracker
			if latency ~= squid_latency_tracker[index] then
				table.insert(squid_latency_tracker,latency)
			end
		end

		local total_latency = 0
		for i=1,#squid_latency_tracker do
			total_latency = total_latency + squid_latency_tracker[i]
		end

		squid_avg_latency = total_latency / #squid_latency_tracker

		--use avg latency only if it is higher than current latency to account for fluctuation
		if not squid_avg_latency or squid_avg_latency == 0 or squid_avg_latency < latency then squid_avg_latency = latency end

		--track avg home latency
		squid_home_latency_tracker = squid_home_latency_tracker or {}

		if #squid_home_latency_tracker == 0 then
			if home_latency ~= 0 then
				table.insert(squid_home_latency_tracker,home_latency)
			end
		else
			local index = #squid_home_latency_tracker
			if home_latency ~= squid_home_latency_tracker[index] then
				table.insert(squid_home_latency_tracker,home_latency)
			end
		end

		local total_latency = 0
		for i=1,#squid_home_latency_tracker do
			total_latency = total_latency + squid_home_latency_tracker[i]
		end

		squid_avg_home_latency = total_latency / #squid_home_latency_tracker

		--use avg latency only if it is higher than current latency to account for fluctuation
		if not squid_avg_home_latency or squid_avg_home_latency == 0 or squid_avg_home_latency < home_latency then squid_avg_home_latency = home_latency end

		-- 10-20 ms per update for me
		-- squid_update_time = squid_update_time or time

		-- if time > squid_update_time then
		-- 	print(time - squid_update_time)
		-- 	squid_update_time = time
		-- end

		squid_conquest_earned = 0
		if ConquestFrame then
			local bar = ConquestFrame.ConquestBar
			if bar then
				local label = bar.Label
				if label then
					local txt = label:GetText()
					if txt then
						txt = string.gsub(txt,"Conquest","")
						txt = string.gsub(txt," / 500","")
						local amount = txt and tonumber(txt) or 0
						squid_conquest_earned = amount
					end
				end
			end
		end

		C_Timer.After(1.6,function()
			if not ChatFrame_Hooked and Hook_ChatFrame then
				Hook_ChatFrame()
			end
		end)

		if block_key then
			local spec = GetSpecialization()

			--snap
			-- if spec == 3 and _spellCooldown(45438) > GetGCD() + 2 then
			-- 	if _spellCooldown(235219) == 0 then
			-- 		SQ_CastSpellByID(235219)
			-- 		Squid_Alert("Cold Snap",nil,nil,nil,235219)
			-- 	end
			-- end

			--dont block in starting zone
			if UnitBuffID("player",32727) then Squid_Alert("Not Blocking","(Starting Room)",2,nil,45438) return end

			--block
			if _spellCooldown(45438) <= 2.15 then
				--hypo
				if UnitDebuffID("player",41425) and not UnitBuffID("player",45438) then
					Squid_Alert("Can't Block","(Hypothermia)",nil,nil,41425)
					return
				end
				SpellStopCasting()
				Squid_Alert_Big("Ice Block","(Manual)",nil,3,45438)
				SQ_CastSpellByID(45438)
				SQ_CastSpellByName("Ice Block")
				return

			--block not ready
			elseif not UnitBuffID("player",45438) then
				local str = "|cFFa665cdIce Block Not Ready Yet"
				Squid_Alert(str,nil,nil,nil,45438)
			end

		end

		--they have healer?
		theirHealer=nil
		for i=1,#Enemies do if _isHealer(Enemies[i]) then theirHealer=Enemies[i] end end

		for i=1,GetNumArenaOpponents() do
			local unit = "arena"..i
			if UnitIsVisible(unit) and _isHealer(unit) then
				theirHealer = ObjectPointer(unit)
			end
		end

		if not Squid_Dir then
			Squid_Dir = Squid_Directory()
		end

		--grab flags
		if SQUID.flag_pick and instance_type == "pvp" then
			if not flag_drop_time or time - flag_drop_time > 5 then
				if not flag_interact or time - flag_interact > .05 then
					local flags = {"Alliance Flag", "Horde Flag", "Alliance Mine cart", "Horde Mine Cart"}
					for i=1,#flags do InteractUnit(flags[i]) end
					flag_interact = time
				end
			end
		end

		--clear caches

		if not los_cache_cleared or time - los_cache_cleared > .1 then
			los_cache = {}
			los_cache_cleared = time
		end

		-- unit_is_unit_cache = {}

		if not object_id_cache_cleared or time - object_id_cache_cleared > .5 then
			object_id_cache = {}
			object_id_cache_cleared = time
		end

		cc_remains_cache = {}

		breakable_cc_cache = {}

		object_position_cache = {}

		if not unit_can_attack_cache_cleared or time - unit_can_attack_cache_cleared > .4 then
			unit_can_attack_cache = {}
			unit_can_attack_cache_cleared = time
		end

		-- if not unit_creature_type_cache_cleared or time - unit_creature_type_cache_cleared > 1.5 then
			unit_creature_type_cache = {}
		-- 	unit_creature_type_cache_cleared = time
		-- end

		unit_casting_info_cache = {}

		unit_channel_info_cache = {}

		if not unit_is_player_cache_cleared or time - unit_is_player_cache_cleared > .3 then
			unit_is_player_cache = {}
			unit_is_player_cache_cleared = time
		end

		unit_name_cache = {}

		unit_target_cache = {}

		if not spell_effect_cache or not spell_effect_cache_wiped or time - spell_effect_cache_wiped > .3 then
			spell_effect_cache = {}
			spell_effect_cache_wiped = time
		end

		-- if not unit_target_cache or not unit_target_cache_wiped or time - unit_target_cache_wiped > .3 then

		-- 	unit_target_cache_wiped = time
		-- end

		if not unit_combat_reach_cache or not unit_combat_reach_cache_wiped or time - unit_combat_reach_cache_wiped > 15 then
			unit_combat_reach_cache = {}
			unit_combat_reach_cache_wiped = time
		end

		if not unit_role_cache_cleared or time - unit_role_cache_cleared > .5 then
			unit_role_cache = {}
			unit_role_cache_cleared = time
		end

		if not unit_creature_id_cache_cleared or time - unit_creature_id_cache_cleared > 30 then
			unit_creature_id_cache = {}
			unit_creature_id_cache_cleared = time
		end

		if not is_dummy_cache_cleared or time - is_dummy_cache_cleared > 30 then
			is_dummy_cache = {}
			is_dummy_cache_cleared = time
		end

		if not azerite_power_rank_cache_cleared or time - azerite_power_rank_cache_cleared > 5 then
			azerite_power_rank_cache = {}
			azerite_power_rank_cache_cleared = time
		end

		if not azerite_power_cache_cleared or time - azerite_power_cache_cleared > 5 then
			azerite_power_cache = {}
			azerite_power_cache_cleared = time
		end

		if not player_can_see_cache_cleared or time - player_can_see_cache_cleared > .3 then
			player_can_see_cache = {}
			player_can_see_cache_cleared = time
		end

		hp_cache = {}

		if gpy_on_player and time - gpy_on_player > 3 or UnitBuffID("player",45438) then
			gpy_on_player = nil
		end

		if focus_trap_queued and time - focus_trap_queued > 6 then
			focus_trap_queued = nil
		end

		if healer_trap_queued and time - healer_trap_queued > 6 then
			healer_trap_queued = nil
		end

		local player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")

		if player_cast then
			current_cast_delay = time
			current_cast_delay_cast = player_cast_id
		end

		if not movement_lock_commands then
			movement_lock_commands = {}
		end

		for i=1,#movement_lock_commands do
			if movement_lock_commands[i] and movement_lock_commands[i] - time <= 0 then
				table.remove(movement_lock_commands,i)
			end
		end

		squid_missiles = {}
		local count = GetMissileCount()
		for i=1,count do
			local spellid, visualid, x, y, z, caster, sx, sy, sz, target, tx, ty, tz = GetMissileWithIndex(i)
			table.insert(squid_missiles,{spellid=spellid,visualid=visualid,pos={x,y,z},caster=caster,source={sx,sy,sz},dest={tx,ty,tz}})
		end
		-- eat_trap_test=true

		-- eat trap if close
		for i=1,#squid_missiles do
			local missile = squid_missiles[i]
			if missile.spellid == 187650 and UnitCanAttack("player",missile.caster) then
				local x,y,z = unpack(missile.dest)
				local cx,cy,cz = unpack(missile.pos)
				local px,py,pz = GetPlayerPosition()
				local angle = GetAnglesBetweenPositions(px,py,pz,x,y,z)

				-- local fx=x
				-- local fy=y
				local dist = GetDistanceBetweenPositions(fx,fy,z,px,py,pz)

				local fx = (dist > .5 and x + .5 * math.cos(angle) or x)
				local fy = (dist > .5 and y + .5 * math.sin(angle) or y)

				dist = GetDistanceBetweenPositions(fx,fy,z,px,py,pz)

				local ourHealer = ourHealer

				if eat_trap_test then
					-- if dist <= 5.5 then
		   --  			if not eat_trap or time - eat_trap > 1 then
		   --  				SetMovementLocked(false)
			  --   			MoveTo(fx,fy,z)
			  --   			Squid_Alert_Big("Eating Trap",nil,2,4,187650)
			  --   			StopMovingAndLock()
			  --   			table.insert(movement_lock_commands,time+1)
			  --   			eat_trap = time
			  --   		end
			  --   	end
					ourHealer="focus"
				end

				if UnitIsVisible(ourHealer) then
					local hx,hy,hz = ObjectPosition(ourHealer)
					local healer_dist = GetDistanceBetweenPositions(hx,hy,hz,fx,fy,z)
					local current_healer_dist = GetDistanceBetweenPositions(hx,hy,hz,cx,cy,cz)
					if healer_dist <= 4.25 then
						if dist <= 5.5 then
							if not eat_trap or time - eat_trap > 1 then
								SetMovementLocked(false)
								MoveTo(fx,fy,z)
								Squid_Alert_Big("Eating Trap",nil,2,4,187650)
								StopMovingAndLock()
								C_Timer.After(1,function() SetMovementLocked(false) end)
								eat_trap = time
							end
						end
						if select(2,UnitClass("player")) == "MAGE" then
							local bx,by,bz = position_after_blink(angle)
							local blink_trap_dist = GetDistanceBetweenPositions(bx,by,bz,fx,fy,z)
							if GetSpellCharges(212653) > 0 and blink_trap_dist <= 4 and current_healer_dist > 4 and (not player_blink or time - player_blink > 1) then
								if current_healer_dist > 8 or blink_trap_dist < 2 then
									FaceDirection(angle,true)
									if ObjectIsFacingPosition("player",x,y) then
										StopMovingAndLock()
										CastSpellByID(1953)
										player_blink = time
										Squid_Alert("Blink","(Eat Trap)",nil,nil,212653)
									end
								end
							end
						end
					elseif dist <= 5.5 and not eat_trap_test then
						local dx,dy,dz = GroundZ(fx - 5 * math.cos(angle), fy - 5 * math.sin(angle), z)
						if dx and dy and dz then
							MoveTo(dx,dy,dz)
							Squid_Alert_Big("Dodging Trap",nil,2,4,187650)
						end
					end
				elseif dist <= 5.5 and not eat_trap_test then
					local dx,dy,dz = GroundZ(fx - 5 * math.cos(angle), fy - 5 * math.sin(angle), z)
					if dx and dy and dz then
						MoveTo(dx,dy,dz)
						Squid_Alert_Big("Dodging Trap",nil,2,4,187650)
					end
				end
			end
		end

		if IsHackEnabled and not ewt_api_hooked then

			-- unit_name_cache = {}
			-- local og = UnitName
			-- function UnitName(unit)
			-- 	local cache = unit_name_cache[unit]
			-- 	if cache ~= nil then return cache end
			-- 	local name = og(unit)
			-- 	if unit then
			-- 		unit_name_cache[unit] = name
			-- 	end
			-- 	return name
			-- end

			-- unit_is_player_cache = {}
			-- local og = unit_is_player
			-- function unit_is_player(unit)
			-- 	local cache = unit_is_player_cache[unit]
			-- 	if cache ~= nil then return cache end
			-- 	local isplayer = og(unit)
			-- 	unit_is_player_cache[unit] = isplayer
			-- 	return isplayer
			-- end

			local og = ObjectName
			ObjectName=function(unit)
				local cache = unit_name_cache[unit]
				if cache ~= nil then return cache end
				local name = og(unit)
				unit_name_cache[unit] = name
				return name
			end

			local og = UnitCreatureType
			UnitCreatureType=function(unit)
				local cache = unit_creature_type_cache[unit]
				if cache ~= nil then return cache end
				local t = og(unit)
				unit_creature_type_cache[unit] = t
				return t
			end

			local og = ObjectPosition
			ObjectPosition = function(unit)
				local cache = object_position_cache[unit]
				if cache ~= nil then return unpack( object_position_cache[unit] ) end
				local pos = { og(unit) }
				if #pos > 0 then
					object_position_cache[unit] = pos
					return unpack( pos )
				else
					return nil
				end
			end

			local og = ObjectID
			ObjectID=function(unit)
				if not unit then return end
				local cache = object_id_cache[unit]
				if cache then
					return cache
				else
					local id = og(unit)
					object_id_cache[unit] = id
					return id
				end
			end

			local og = UnitTarget
			UnitTarget=function(unit)
				local cache = unit_target_cache[unit]
				if cache then
					return cache
				else
					local t = og(unit)
					unit_target_cache[unit] = t
					return t
				end
			end

			local og = UnitCombatReach
			UnitCombatReach=function(unit)
				if not unit then return end
				local cache = unit_combat_reach_cache[unit]
				if cache then
					return cache
				else
					local cr = og(unit)
					unit_combat_reach_cache[unit] = cr
					return cr
				end
			end

			local og = MoveTo
			MoveTo=function(x,y,z,directly)
				if x and y and z then
					local state = GetCVar("AutoInteract")
					if directly then
						SetCVar("AutoInteract",true)
						_faceLocation(x,y,z)
						og(x,y,z)
					else
						SetCVar("AutoInteract",true)
						og(x,y,z)
					end
					SetCVar("AutoInteract",state)
				end
			end

			local og = MoveTo
			JesusMoveTo=function(x,y,z,directly)
				if x and y and z then
					if not player_has_control() then return false end
					local state = GetCVar("AutoInteract")
					if directly then
						_faceLocation(x,y,z)
						og(x,y,z)
					else
						og(x,y,z)
					end
					SetCVar("AutoInteract",state)
				end
			end

			local og = TraceLine
			TraceLine=function(x,y,z,X,Y,Z,flags)
				if x and y and z and X and Y and Z and flags then
					return og(x,y,z,X,Y,Z,flags)
				else

				end
			end

			local og = FaceDirection
			FaceDirection=function(unit,update)
				if player_has_control() then
					og(unit,update)
				end
			end

			local og = GetDistanceBetweenPositions
			GetDistanceBetweenPositions=function(X1,Y1,Z1,X2,Y2,Z2)
				if X1 and Y1 and Z1 and X2 and Y2 and Z2 then return og(X1,Y1,Z1,X2,Y2,Z2) else return 0 end
			end

			function StopMoving()
				MoveForwardStop()
				MoveBackwardStop()
				StrafeLeftStop()
				StrafeRightStop()
				TurnLeftStop()
				TurnRightStop()
				AscendStop()
				CameraOrSelectOrMoveStop()
				local x,y,z = GetPlayerPosition()
				MoveTo(x,y,z)
				if squid_path then Squid_StopNav() end
			end

			function StopMovingAndLock()
				MoveForwardStop()
				MoveBackwardStop()
				StrafeLeftStop()
				StrafeRightStop()
				TurnLeftStop()
				TurnRightStop()
				AscendStop()
				CameraOrSelectOrMoveStop()
				local x,y,z = GetPlayerPosition()
				MoveTo(x,y,z)
				SetMovementLocked(true)
				if squid_path then Squid_StopNav() end
			end

			ewt_api_hooked=true
		end

		if IsHackEnabled and not movement_hooked then
			local MoveForwardStart_OG = MoveForwardStart
			local MoveBackwardStart_OG = MoveBackwardStart
			local StrafeLeftStart_OG = StrafeLeftStart
			local StrafeRightStart_OG = StrafeRightStart
			local JumpOrAscendStart_OG = JumpOrAscendStart
			local CameraOrSelectOrMoveStart_OG = CameraOrSelectOrMoveStart
			local MoveTo_OG = MoveTo
			-- can't make this, throws protected function error :(
			function SetMovementLocked(bool)
				if bool == true then
					MoveForwardStart=function() end
					MoveBackwardStart=function() end
					StrafeLeftStart=function() end
					StrafeRightStart=function() end
					JumpOrAscendStart=function() end
					CameraOrSelectOrMoveStart=function() end
					MoveTo=function() end
					squid_movement_locked=true
				else
					MoveForwardStart=MoveForwardStart_OG
					MoveBackwardStart=MoveBackwardStart_OG
					StrafeLeftStart=StrafeLeftStart_OG
					StrafeRightStart=StrafeRightStart_OG
					JumpOrAscendStart=JumpOrAscendStart_OG
					CameraOrSelectOrMoveStart=CameraOrSelectOrMoveStart_OG
					MoveTo=MoveTo_OG
					squid_movement_locked=false
				end
			end
			function IsMovementLocked()
				return squid_movement_locked
			end
			movement_hooked=true
		end

		if __LB__ then
			SetMovementLocked=function() end
		end

		player_position = {}
		player_position.x,player_position.y,player_position.z = ObjectPosition("player")

		_pulseResetDR()
		Squid_GUI_Update()

		if SQUID.cap_bot then
			if squid_conquest_earned == 500 then
				Squid_Alert_Big("You're capped!","Turn it in!",nil,nil,23335)
			elseif squid_conquest_earned >= 465 then
				Squid_Alert_Big("You're almost capped!","Get ready to turn it in!",nil,nil,23333)
			end
		end

		-- Squid_Alerts_Unlocked=true -- testing
		if Squid_Alerts_Unlocked then
			if not AlertFrames_Anchor:IsShown() then
				AlertFrames_Anchor:Show()
			end
			if not BigAlertFrames_Anchor:IsShown() then
				BigAlertFrames_Anchor:Show()
			end
			if not Squid_Alert_Test or time - Squid_Alert_Test > .5 then
				if not Squid_StopSpamming then
					local spell
					for i=1,100 do
						local r = math.random(1,99999)
						if GetSpellInfo(r) then
							spell=r
							break
						end
					end
					if not spell then spell = 118 end
					Squid_Alert("Testing",math.random(1,99999),nil,nil,spell)
					Squid_Alert_Big("Testing",math.random(1,99999),nil,nil,spell)
					Squid_Alert_Test=time
				end
			end
		else
			if AlertFrames_Anchor:IsShown() then
				AlertFrames_Anchor:Hide()
			end
			if BigAlertFrames_Anchor:IsShown() then
				BigAlertFrames_Anchor:Hide()
			end
		end

		if UnitBuffID("player",5215) or UnitBuffID("player",58984) or UnitBuffID("player",115191) or UnitBuffID("player",1784) then
			was_stealth=time
		end

		if was_stealth and time-was_stealth > .25 then
			was_stealth=nil
		end

		if Squid_Burst then
			if not squid_burst_enabled_msg or time - squid_burst_enabled_msg > .5 then
				Squid_Alert("Burst Mode Enabled",nil,nil,.5)
				squid_burst_enabled_msg=time
			end
		else
			squid_burst_enabled_msg = nil
		end

		if Squid_Burst and time - Squid_Burst > 2 then
			Squid_Burst = nil
		end

		if SQUID.anon then
			for i=1,40 do
				if _G["CompactRaidFrame"..i] then
					if _G["CompactRaidFrame"..i.."Name"] then
						local current = _G["CompactRaidFrame"..i.."Name"]:GetText()
						if current ~= nil and current ~= "The Squid" and current ~= "Friend of Squid" and current ~= "Squid?" then
							if unit_is_unit(current,"player") then
								_G["CompactRaidFrame"..i.."Name"]:SetText("The Squid")
							elseif UnitIsFriend("player",current) or UnitInParty(current) then
								_G["CompactRaidFrame"..i.."Name"]:SetText("Friend of Squid")
							else
								_G["CompactRaidFrame"..i.."Name"]:SetText("Squid?")
							end
						end
					end
				end
				if _G["PartyMemberFrame"..i] then
					if _G["PartyMemberFrame"..i.."Name"] then
						local current = _G["PartyMemberFrame"..i.."Name"]:GetText()
						if current ~= nil and current ~= "The Squid" and current ~= "Friend of Squid" and current ~= "Squid?" then
							if unit_is_unit(current,"player") then
								_G["PartyMemberFrame"..i.."Name"]:SetText("The Squid")
							elseif UnitIsFriend("player",current) or UnitInParty(current) then
								_G["PartyMemberFrame"..i.."Name"]:SetText("Friend of Squid")
							else
								_G["PartyMemberFrame"..i.."Name"]:SetText("Squid?")
							end
						end
					end
				end
			end
			-- if not anonymize_nameplates_hooked then
			-- 	hooksecurefunc("CompactUnitFrame_UpdateName",function(F)
			-- 		if F.unit:find("nameplate") and (UnitIsFriend("player", F.unit) or UnitInParty(F.unit)) then
			-- 			if F:IsShown() then
			-- 				F.name:SetText("Friend of Squid")
			-- 			end
			-- 		end
			-- 	end)
			-- 	anonymize_nameplates_hooked = true
			-- end
		end

		things_from_beyond = {}

		if not checked_player_afk or time - checked_player_afk > .15 then
			if AnyKeyPressed() then
				player_last_button_press = time
			end
			checked_player_afk = time
		end

		--is the player afk?
		if not player_last_button_press or time - player_last_button_press > 6 then
			player_afk = true
		else
			player_afk = false
		end

		-- player afk short
		if not player_last_button_press or time - player_last_button_press > .5 then
			player_afk_short = true
		else
			player_afk_short = false
		end

		if not IsForeground() then
			player_afk = true
		end

		-- check if any button is being pressed, and record the time of last button press

		--streaming mode persistence
		if LibDraw then
			if SQUID.streaming_mode then
				if not squid_streaming_mode_enabled then
					toggle_squid_streaming_mode()
				end
			else
				if squid_streaming_mode_enabled then
					toggle_squid_streaming_mode()
				end
			end
		end

		-- object manager

		--    local GetObjectWithIndex = GetObjectWithIndex
		--    local ObjectExists = ObjectExists
		-- local ObjectType = ObjectType
		-- local ObjectID = ObjectID
		-- local ObjectRawType = ObjectRawType
		-- local ObjectName = ObjectName
		-- local unit_is_player = unit_is_player
		-- local unit_can_attack = unit_can_attack
		-- local UnitAffectingCombat = UnitAffectingCombat
		-- local UnitIsDeadOrGhost = UnitIsDeadOrGhost
		-- local UnitIsDead = UnitIsDead
		-- local UnitIsFriend = UnitIsFriend
		-- local tremove = tremove
		-- if EWT then


			local total, updated, added, removed = GetObjectCount(true);

			--WAElite OM
			-- LibDraw.clearCanvas()
		 --    wa_OM(updated,added,removed)
		 --    checkOM()
		 --    if drawCleave then
		 --        CleaveDraw()
		 --    end
		 --    drawTriggers()

			local function isCritter(Unit)
				local unitType = UnitCreatureType(Unit)
				local types = {
					["Critter"] = true,
					["Kleintier"] = true,
					["Bestiole"] = true,
					["ë™ë¬¼"] = true,
					["Alma"] = true,
					["Bicho"] = true,
					["Animale"] = true,
					["Ð¡ÑƒÑ‰ÐµÑÑ‚Ð²Ð¾"] = true,
					["å°åŠ¨ç‰©"] = true,
					["å°å‹•ç‰©"] = true,
					["Wild Pet"] = true,
					["UngezÃ¤hmtes Tier"] = true,
					["Mascotte sauvage"] = true,
					["ì•¼ìƒ ì• ì™„ë™ë¬¼"] = true,
					["Mascota salvaje"] = true,
					["MascÃ³ta Salvaje"] = true,
					["Mascote Selvagem"] = true,
					["Creatura Selvaggia"] = true,
					["é‡Žç”Ÿå® ç‰©"] = true,
					["é‡Žç”Ÿå¯µç‰©"] = true
				}
				if types[unitType] ~= nil then
					return true
				end
				return false
			end

			if not Squid_OM then

				Squid_OM = {}
				Objects = {}
				Enemies = {}
				Friends = {}
				AreaTriggers = {}
				Pets = {}

				for i=1,total do

					local pointer = GetObjectWithIndex(i)

					local object_type = ObjectTypeName(pointer)

					if object_type == "Unit" or object_type == "Player" or object_type == "ActivePlayer" then
						if not isCritter(pointer) then
							table.insert(Squid_OM,pointer)
						end
						if id == 416 or id == 58959 then
							imp_exists = pointer
						end
					end
					if object_type == "Unit" or object_type == "Player" or object_type == "ActivePlayer" or object_type == "GameObject" then
						table.insert(Objects,pointer)
					end

					if object_type == "AreaTrigger" then
						table.insert(AreaTriggers,pointer)
					end

				end

				-- for i=1,GetObjectCount() do
				-- 	table.insert(Squid_ALL, GetObjectWithIndex(i))
				-- end

				-- for i=1,#Squid_ALL do

				-- 	local pointer = Squid_ALL[i]

				-- 	if ObjectTypeName(pointer) == "Unit" or ObjectTypeName(pointer) == "Player" or ObjectTypeName(pointer) == "ActivePlayer" then
				-- 		if not isCritter(pointer) then
			 --    			table.insert(Squid_OM,pointer)
			 --    		end
			 --    		if id == 416 or id == 58959 then
			 --    			imp_exists = pointer
			 --    		end
				-- 	end
				-- 	if ObjectTypeName(pointer) == "Unit" or  ObjectTypeName(pointer) == "Player" or  ObjectTypeName(pointer) == "ActivePlayer" or  ObjectTypeName(pointer) == "GameObject" then
				-- 		table.insert(Objects,pointer)
				-- 	end

				-- 	if ObjectTypeName(pointer) == "AreaTrigger" then
				-- 		table.insert(AreaTriggers,pointer)
				-- 	end

			 --    end

				for i=1,#Squid_OM do
					local pointer = Squid_OM[i]
					if unit_can_attack("player",pointer) and not UnitIsDeadOrGhost(pointer) then
						if arena then
							if unit_is_player(pointer) then
								table.insert(Enemies,pointer)
							end
							table.insert(Pets,pointer)
						else
							if UnitAffectingCombat(pointer) or unit_is_player(pointer) and (unit_is_unit(pointer,"target") or unit_is_unit(pointer,"focus") or unit_is_unit("player",UnitTarget(pointer)) or unit_is_unit("player",UnitSpellTarget(pointer))) or _isDummy(pointer) or UnitIsPet(pointer) or no_combat_debug then
								local objectid = ObjectID(pointer)
								local no_touch
								for i=1,#no_touch_units do
									local notouch = no_touch_units[i]
									if notouch.unitID == objectid then
										local buff = notouch.buff
										if buff == nil then
											no_touch = true
										else
											if UnitBuffID(pointer,buff) then
												no_touch = true
											end
										end
									end
								end
								if not no_touch then
									table.insert(Enemies,pointer)
									table.insert(Pets,pointer)
								end
							end
						end
						local name = ObjectName(pointer)
						if name == "Thing From Beyond" then
							table.insert(things_from_beyond,pointer)
						end
					end
					if unit_is_player(pointer) and UnitIsFriend("player",pointer) and not UnitIsDeadOrGhost(pointer) then
						if arena or friend_debug or UnitInParty(pointer) or unit_is_unit("player",pointer) then
							table.insert(Friends,pointer)
						end
					end
					if unit_is_unit("target",pointer) then
						current_target = pointer
					end
					if unit_is_unit("focus",pointer) then
						current_focus = pointer
					end
					if arena then
						if unit_is_unit("arena1",pointer) then
							current_arena1 = ObjectPointer("arena1")
						end
						if unit_is_unit("arena2",pointer) then
							current_arena2 = ObjectPointer("arena2")
						end
						if unit_is_unit("arena3",pointer) then
							current_arena3 = ObjectPointer("arena3")
						end
					end
				end

			elseif updated then

				Enemies = {}
				Friends = {}
				Pets = {}

				for i=1,#added do

					local pointer = added[i]

					local id = ObjectID(pointer)

					local object_type = ObjectTypeName(pointer)

					if object_type == "Unit" or object_type == "Player" or object_type == "ActivePlayer" then
						if not isCritter(pointer) then
							table.insert(Squid_OM,pointer)
						end
						if id == 416 or id == 58959 then
							imp_exists = pointer
						end
					end
					if object_type == "Unit" or object_type == "Player" or object_type == "ActivePlayer" or object_type == "GameObject" then
						table.insert(Objects,pointer)
					end

					if object_type == "AreaTrigger" then
						table.insert(AreaTriggers,pointer)
					end

				end

				for i=1,#removed do
					if removed[i]==imp_exists then
						imp_exists = nil
					end
					for n=1,#Squid_OM do if Squid_OM[n]==removed[i] then
						table.remove(Squid_OM,n)
					end end
					for n=1,#Objects do if Objects[n]==removed[i] then
						table.remove(Objects,n)
					end end
					for n=1,#AreaTriggers do if AreaTriggers[n]==removed[i] then
						table.remove(AreaTriggers,n)
					end end
				end

				for i=1,#Squid_OM do
					local pointer = Squid_OM[i]
					local player = unit_is_player(pointer)
					if unit_can_attack("player",pointer) and not UnitIsDeadOrGhost(pointer) then
						if arena then
							if player then
								table.insert(Enemies,pointer)
							end
							table.insert(Pets,pointer)
						else
							if UnitAffectingCombat(pointer) or unit_is_player(pointer) and (unit_is_unit(pointer,"target") or unit_is_unit(pointer,"focus") or unit_is_unit("player",UnitTarget(pointer)) or unit_is_unit("player",UnitSpellTarget(pointer))) or _isDummy(pointer) or UnitIsPet(pointer) or no_combat_debug then
								local objectid = ObjectID(pointer)
								local no_touch
								for i=1,#no_touch_units do
									local notouch = no_touch_units[i]
									if notouch.unitID == objectid then
										local buff = notouch.buff
										if buff == nil then
											no_touch = true
										else
											if UnitBuffID(pointer,buff) then
												no_touch = true
											end
										end
									end
								end
								if not no_touch then
									table.insert(Enemies,pointer)
									table.insert(Pets,pointer)
								end
							end
						end
						local name = ObjectName(pointer)
						if name == "Thing From Beyond" then
							table.insert(things_from_beyond,pointer)
						end
					end
					if player and UnitIsFriend("player",pointer) and not UnitIsDeadOrGhost(pointer) then
						if arena or friend_debug or UnitInParty(pointer) or unit_is_unit("player",pointer) then
							table.insert(Friends,pointer)
						end
					end
				end

				if arena then
					if UnitIsVisible("arena1") then
						current_arena1 = ObjectPointer("arena1")
					end
					if UnitIsVisible("arena2") then
						current_arena2 = ObjectPointer("arena2")
					end
					if UnitIsVisible("arena3") then
						current_arena3 = ObjectPointer("arena3")
					end
				end

				--move attackable units
				for i=1,#Friends do if unit_can_attack("player",Friends[i]) and not tContains(Enemies,Friends[i]) then
					table.insert(Enemies,Friends[i])
				end end

				--remove non existent objects?
				-- for i=1,#Enemies do if not ObjectExists(Enemies[i]) then tremove(Enemies,i) end end
				-- for i=1,#Friends do if not ObjectExists(Friends[i]) then tremove(Friends,i) end end
				-- for i=1,#Pets do if not ObjectExists(Pets[i]) then tremove(Pets,i) end end

				--remove inapproprate units
				if instance_type ~= "none" then
					for i=1,#Enemies do
						if Enemies[i] and UnitIsFriend("player",Enemies[i]) and not valid_attackable(Enemies[i]) then
							tremove(Enemies,i)
						end
					end
				end

			end

			if not UnitExists("arena1") then
				current_arena1=nil
			end
			if not UnitExists("arena2") then
				current_arena2=nil
			end
			if not UnitExists("arena3") then
				current_arena3=nil
			end

			-- if arena and #Enemies == 0 then
			-- 	if current_arena1 then
			-- 		table.insert(Enemies,current_arena1)
			-- 	end
			-- 	if current_arena2 then
			-- 		table.insert(Enemies,current_arena2)
			-- 	end
			-- 	if current_arena3 then
			-- 		table.insert(Enemies,current_arena3)
			-- 	end
			-- end

			player_pointer = ObjectPointer("player")

			-- if not distance_cache_wiped or time-distance_cache_wiped > .04 then
				distance_cache = {}
			-- 	distance_cache_wiped = time
			-- end

			if UnitIsVisible("target") and not current_target then current_target = ObjectPointer("target") end
			if UnitIsVisible("focus") and not current_focus then current_focus = ObjectPointer("focus") end

			if current_focus and UnitIsDeadOrGhost(current_focus) then current_focus = nil end
			if current_target and UnitIsDeadOrGhost(current_target) then current_target = nil end

			if current_target and not UnitIsVisible("target") then current_target = nil end
			if current_focus and not UnitIsVisible("focus") then current_focus = nil end

			--end of ewt obj manager
		-- elseif __LB__ then -- LB object manager

		-- 	player_pointer = ObjectPointer("player")

		-- 	-- if not distance_cache_wiped or time-distance_cache_wiped > .04 then
		-- 		distance_cache = {}
		-- 	-- 	distance_cache_wiped = time
		-- 	-- end

		-- 	if UnitIsVisible("target") and not current_target then current_target = ObjectPointer("target") end
		-- 	if UnitIsVisible("focus") and not current_focus then current_focus = ObjectPointer("focus") end

		-- 	if current_focus and UnitIsDeadOrGhost(current_focus) then current_focus = nil end
		-- 	if current_target and UnitIsDeadOrGhost(current_target) then current_target = nil end

		-- 	if current_target and not UnitIsVisible("target") then current_target = nil end
		-- 	if current_focus and not UnitIsVisible("focus") then current_focus = nil end

		-- end

		-- assign vars to special area triggers
		-- for i=1,#AreaTriggers do
		-- 	local id = ObjectID(AreaTriggers[i])
		-- 	if id == 12740 then
		-- 		mage_orb = AreaTriggers[i]
		-- 	end
		-- end

		if current_focus then
			if squid_trap_focus and time - squid_trap_focus < .35 then
				_aeCastInMovingDirection(187650,current_focus,perfectTravelDist(current_focus))
			end
		end

		-- --self reliance stealth detection
		-- self_reliance_stealth = AzeritePowerTaken(87) and not UnitBuffID("player",270661) and AllEnemiesAroundMe(18) == 0

		-- if self_reliance_stealth then
		-- 	Squid_Alert_Big("Stealth Detected","Self Reliance",2,nil,270661)
		-- end

		alter_effect = 0
		if squid_alter then
			alter_effect = round ( squid_alter["start_hp"] - _HP("player"), 2)
		end

		--lowest enemy
		lowestEnemy = 100;
		for i=1,#Enemies do if unit_is_player(Enemies[i]) and _HP(Enemies[i]) < lowestEnemy then
			lowestEnemy=_HP(Enemies[i]);
			lowestEnemyName=Enemies[i];
		end end

		--lowest friend
		lowestFriend=100;
		for i=1,#Friends do
			local friendhp = _HP(Friends[i]);
			if friendhp and friendhp <= lowestFriend then
				lowestFriend=_HP(Friends[i]);
				lowestFriendName=Friends[i];
			end
		end

		--CAP BOT (auto arena afk arena arena bot auto queue) auto que
		local cap_bot = SQUID.cap_bot
		local auto_q = SQUID.auto_queue
		local only_skirms = SQUID.only_skirms
		local only_bgs = SQUID.only_bgs

		local groupsize = GetNumGroupMembers()
		local bf_status = GetBattlefieldStatus(1)

		local queue_pop
		for i=1,3 do
			if GetBattlefieldStatus(i) == "confirm" then
				queue_pop = i
			end
		end

		function queue_up(arena_type)
			if bf_status == "none" then
				if only_skirms then
					JoinSkirmish(4,true)
					queue_up_time = time
				elseif arena_type == "Arena" and not only_skirms then
					JoinArena()
					queue_up_time = time
				elseif arena_type == "Bg" then
					JoinBattlefield(32)
				end
			end
		end

		--release in bg
		if cap_bot and instance_type == "pvp" and StaticPopup1 and StaticPopup1:IsShown() then
			if StaticPopup1.which == "DEATH" then
				if not waiting_to_accept or time - waiting_to_accept > 10 then
					waiting_to_accept = time
				elseif time - waiting_to_accept > minDelayTime * 8 then
					StaticPopup1Button1:Click()
					waiting_to_accept = nil
				end
			end
		end

		--never miss queue
		if queue_pop then
			if not queue_pop_start then
				queue_pop_start = time
			else
				if time - queue_pop_start > 25 then
					AcceptBattlefieldPort(queue_pop,1)
					join_battle_time = time
				end
			end
		else
			queue_pop_start = nil
		end
		if queue_pop_start and time - queue_pop_start > 30 then queue_pop_start = nil end

		function friend_in_instance()
			if groupsize > 0 then
				for i=1,groupsize do
					local icon = _G["CompactRaidFrame"..i.."CenterStatusIcon"]
					if icon and icon:IsShown() then
						local texture =  _G["CompactRaidFrame"..i.."CenterStatusIcon"].texture
						if texture and texture:GetTexture() ~= "Interface\\TargetingFrame\\UI-PhasingIcon" then
							return true
						end
					end
				end
			end
		end

		-- being sucked by Ursol's?
		if UnitDebuffID("player",127797) then
			last_ursol = time
		end

		if last_ursol and time - last_ursol < .5 and GetUnitSpeed("player") > 30 then
			last_suck = time
		end

		-- if last_suck and time - last_suck < 1 then
		-- 	Squid_Alert("You've Been Sucked!")
		-- end

		-- if PVPMatchResults and PVPMatchResults.buttonContainer and PVPMatchResults.buttonContainer.leaveButton then
		-- 	local function leftbattle() join_battle_time = time end
		-- 	PVPMatchResults.buttonContainer.leaveButton:HookScript("OnClick", leftbattle)
		-- end

		--auto queue
		if auto_q then
			--join battle faster
			if queue_pop and queue_pop_start and time - queue_pop_start > minDelayTime*15 then
				if bf_status == "confirm" or arena and not arena_loading_screen and PVPReadyDialog and PVPReadyDialog:IsShown() then
					AcceptBattlefieldPort(queue_pop,true)
					join_battle_time = time
				end
			end
			--accept ready checks
			if LFDRoleCheckPopup:IsShown() then
				if not role_check_start then
					role_check_start = time
				else
					if time - role_check_start > 2.6 and (not player_last_button_press or time - player_last_button_press < 25 or not SQUID.safe_afk_q or cap_bot) then
						LFDRoleCheckPopupAcceptButton:Click()
					end
				end
			else
				role_check_start = nil
			end
			--queue up
			if not arena_loading_screen and not arena and bf_status == "none" and not friend_in_instance() and (not player_last_button_press or time - player_last_button_press < 25 or not SQUID.safe_afk_q or cap_bot) then
				if not queue_up_time or time - queue_up_time > 14 then
					if groupsize == 0 then
						if only_bgs then
							queue_up("Bg")
						else
							queue_up("Skirmish")
						end
					else
						if only_bgs then
							queue_up("Bg")
						elseif only_skrims then
							queue_up("Skirmish")
						else
							queue_up("Arena")
						end
					end
				end
			end
			--leave arena
			-- (REQUE SKIRMS WITH WINNING GRPS!!)
			if PVPMatchResults and PVPMatchResults:IsShown() then
				if not game_over_time then
					game_over_time = time
				else
					if time - game_over_time > 2.1 + ( not SQUID.cap_bot and 15 or 0 ) then
						local results = PVPMatchResults.header
						results = results and results:GetText()
						--attempt req on victory
						if results == "VICTORY" and GetNumGroupMembers() > 1 and PVPMatchResults.buttonContainer.requeueButton and PVPMatchResults.buttonContainer.requeueButton:IsShown() and not get_squid_var("Leave Skirms") then
							if not reque_attempt_time or time - reque_attempt_time > 14 then
								print("Attempting to re-queue with this team because we won.")
								PVPMatchResults.buttonContainer.requeueButton:Click()
								reque_attempt_time = time
							end
						else
							--leave if loss or teammates leave
							local reason
							if not PVPMatchResults.buttonContainer.requeueButton or not PVPMatchResults.buttonContainer.requeueButton:IsShown() then
								reason = "we must."
							elseif GetNumGroupMembers() <= 1 then
								reason = "everyone left."
							else
								reason = "this team is undesirable."
							end
							if not leave_attempt_time or time - leave_attempt_time > 6 then
								print("Leaving the game because "..reason)
								PVPMatchResults.buttonContainer.leaveButton:Click()
								leave_attempt_time = time
								join_battle_time = time
							end
						end
					end
				end
			else
				game_over_time = nil
			end
		end

		arena_loading_screen = nil
		if join_battle_time and time - join_battle_time < 10 and not _isMoving("player") then
			arena_loading_screen=true
		end

		if game_over_time and time - game_over_time > 30 then game_over_time = nil end

		-- time in control?
		if not time_in_control or not player_has_control() then
			time_in_control = 0
			time_control_lost = time
		else
			time_in_control = time - time_control_lost
		end

		-- get healthstone
		if GetItemCount(5512) == 0 and UnitBuffID("player",32727) then
			if not soulwell_interact or time - soulwell_interact > 6 then
				InteractUnit("Soulwell");
				soulwell_interact = time
			end
		end

		healer_not_visible = false
		their_healer_hiding = false
		if arena then
			for i=1,GetNumArenaOpponents() do
				local specid = GetArenaOpponentSpec(i)
				if not specid then return nil end
				if select(5,GetSpecializationInfoByID(specid)) == "HEALER" and not UnitIsVisible("arena"..i) then
					healer_not_visible = true
					their_healer_hiding = true
				end
			end
		end

		--auto targeting
		if cap_bot and ( arena or instance_type == "pvp" ) then

			if not IsHackEnabled("AntiAFK") then
				if not afk_reset or time - afk_reset > 60 then
					wmbapi.ResetAfk()
					afk_reset = time
				end
				-- SetHackEnabled("AntiAFK",true)
			end

			local best_target
			local player_role = GetUnitRole("player")

			local cc_on_team
			for i=1,#Friends do
				local class = select(2,UnitClass(Friends[i]))
				if class == "MAGE" or class == "HUNTER" then
					cc_on_team=true
				end
			end

			local kill_healers = SQUID.kill_healers

			local possible_targets = {}
			if player_role ~= "healer" then
				--move to friend to get to enemy when we don't have mesh
				if instance_type == "pvp" and not arena and not squid_nav_init[map_id] then
					for i=1,#Friends do if not unit_is_unit("player",Friends[i]) then

						local prio = 0

						local actual_hp = UnitHealth(Friends[i])

						if _LoS(Friends[i]) then
							prio = prio + 750
							local dist_value = 0
							dist_value = math.max( 20 , _distance(Friends[i]) )
							dist_value = math.max( dist_value, 150 )
							prio = prio + dist_value
						end

						prio = prio + ( _isMoving(Friends[i]) and 1 or 0 )

						table.insert(possible_targets,{pointer=Friends[i],prio=prio,actual_hp=actual_hp});

					end end
				end
				local instance_type = instance_type
				--dps
				for i=1,#Enemies do if unit_is_player(Enemies[i]) and not _breakableCC(Enemies[i]) and not _immuneCheck(Enemies[i]) then

					local e = Enemies[i]
					local hp = _HP(e)
					local actual_hp = UnitHealth(e)

					local prio = 0

					if cc_on_team and _isHealer(e) then
						prio = prio - 1
					end

					local class = select(2,UnitClass(e))

					prio = prio + ( arena and UnitEnemiesAttacking(e) * 7 or UnitEnemiesAttacking(e) )
					prio = prio + (hp < 75 and 3 or 0)
					prio = prio + (hp < 50 and 4 or 0)
					prio = prio + (_LoS(e) and 3 or 0)

					prio = prio - (_isTank(e) and 3 or 0)
					prio = prio + (not _isHealer(e) and 1 or 0)
					prio = prio + (class ~= "DEATHKNIGHT" and 1 or 0)
					prio = prio + (kill_healers and _isHealer(e) and 10 or 0)
					prio = prio - (player_role == "melee" and _buffRemains(e,206804) > 1 and 100 or 0) -- rain from above

					--bg bot prio
					if instance_type == "pvp" and not arena then
						if not squid_nav_init[map_id] then
							prio = prio + (_LoS(e) and 1000 or 0)
							prio = prio + (_distance(e) < 40 and 9 or 0)
						else
							--target closest enemy
							prio = prio + (1000 - max(40,_distance(e)) )
						end
					end
					-- prio = prio - (class == "DEATHKNIGHT" and 10000000 or 0)
					-- prio = prio + (class == "DRUID" and 1 or 0)

					table.insert(possible_targets,{pointer=e,prio=prio,hp=hp,actual_hp=actual_hp})

				end end
			else
				--healing
				for i=1,#Friends do if not unit_is_unit("player",Friends[i]) then

					local prio = 0
					local hp = _HP(Friends[i])
					local actual_hp = UnitHealth(Friends[i])

					if hp < 50 then
						prio = prio + EnemiesAttacking(Friends[i])
					end

					if hp < 30 then
						prio = prio + 100
					end

					table.insert(possible_targets,{pointer=Friends[i],prio=prio,hp=hp,actual_hp=actual_hp});

				end end
			end

			table.sort(possible_targets,function(x,y) return x.prio > y.prio or (x.prio == y.prio and x.actual_hp < y.actual_hp) end)

			if #possible_targets > 0 then
				best_target = possible_targets[1].pointer
			end

			if not best_target then
				best_target = lowestEnemyName
			end

			if FLOWER_EXISTS then best_target = FLOWER_EXISTS end

			if best_target and UnitIsVisible(best_target) then
				TargetUnit(best_target)
			end

			--always face the target
			local target_in_range
			if player_role == "ranged" or player_role == "healer" then
				target_in_range = UnitIsVisible(current_target) and _LoS(current_target) and _distance(current_target) < 38
			elseif player_role == "melee" then
				target_in_range = UnitIsVisible(current_target) and _LoS(current_target) and _distance(current_target) < 6
			end
			if target_in_range and player_has_control() and not UnitIsDeadOrGhost("player") and not _isMoving("player") and UnitCanAttack("player",current_target) and not UnitBuffID("player",45438) and time_in_control > 1.5 then
				if not already_faced or time - already_faced > .5 then
					if not _amIfacing(current_target) then
						_faceUnit(current_target)
						already_faced = time
					end
				end
			end

		end

		--testing
		-- local map_id,sub_map_id,sub_map_id2 = GetMapId()
		-- maps_being_loaded = maps_being_loaded or false
		-- if not IsMeshLoaded(map_id) and not maps_being_loaded then
		-- 	InitializeNavigation(function(x) maps_being_loaded = true end, map_id.." "..sub_map_id.." "..sub_map_id2))
		-- end
		-- print(IsMeshLoaded(map_id))

		if arena_start_timer and arena_start_timer <= 5 then
			arena_just_starting = time
		end

		--torghast auto loot
		if GetMapId() == 2162 and not UnitAffectingCombat("player") and SQUID.auto_interact_objects then
			for i=1,#Squid_OM do
				local p = Squid_OM[i]
				if _distance(p) < 2.5 and UnitCanBeLooted(p) then
					if _isMoving("player") then
						--[[Squid_Alert("Stop Moving","LOOT!",2,nil,84766)--]]
						if _distance(p) < 2 and (not stopped_moving_for_loot or time - stopped_moving_for_loot > 2) then
							StopMoving()
							if not squid_auto_loot or time - squid_auto_loot > .25 then
								InteractUnit(p)
								Squid_Alert("Looting",ObjectName(p),nil,nil,84766)
								C_Timer.After(1,function() if LootFrameCloseButton:IsShown() then LootFrameCloseButton:Click() end end)
								squid_auto_loot = time
							end
							stopped_moving_for_loot = time
						end
					else
						if not squid_auto_loot or time - squid_auto_loot > .25 then
							InteractUnit(p)
							Squid_Alert("Looting",ObjectName(p),nil,nil,84766)
							C_Timer.After(1,function() if LootFrameCloseButton:IsShown() then LootFrameCloseButton:Click() end end)
							squid_auto_loot = time
						end
						C_Timer.After(1,function() if LootFrameCloseButton:IsShown() then LootFrameCloseButton:Click() end end)
					end
				end
			end
		end

		talent_info_updated = talent_info_updated or {}
		-- keep friends spec+talent info updated
		if LibInspect then
			for i=1,#Friends do if unit_is_player(Friends[i]) and UnitInParty(Friends[i]) then
				if not talent_info_updated[Friends[i]] or time - talent_info_updated[Friends[i]] > 5 then
					LibInspect:Rescan(Friends[i])
					talent_info_updated[Friends[i]] = time
				end
			end end
		end

		-- auto movement
		-- z dif hardcode paths for blades edgge and mugam
		local ready_for_combat
		local combat = UnitAffectingCombat("player")
		if cap_bot and ( arena or instance_type == "pvp" ) and not do_not_move then
			local map_id = GetMapId()
			local px,py,pz = GetPlayerPosition()
			--silvershard starting room                    -- this is ally starting zone
			if map_id == 727 and GetDistanceBetweenPositions(px,py,pz,851.57464,135.140,328.838) < 15 then
				--ally starting zone
				if GetDistanceBetweenPositions(px,py,pz,851.57464,135.140,328.838) < 15 and not UnitIsDeadOrGhost("player") then
					-- move out of starting room
					if not silvershard_move or time - silvershard_move > 12 then
						MoveTo(814.2376,158.4841,320.2999)
						silvershard_move = time
					end
				end
			else
				--without navmesh / arena just started ( mainly to get out of dalaran sewers pipe ) / BRH Arena (navmesh runs into gates)
				if not squid_nav_init[map_id] or (arena_just_starting and time - arena_just_starting < 5) or map_id == 1504 then
					local center_map = {
					robodrome = {-281.9567,-278.6942,70.4470},
					rol = {1293.8947,1678.3043,34.6745},
					}
					if not pause_auto_movement or time - pause_auto_movement > 20 then
						if (map_id == 2167 or map_id == 572) and ( IsMounted() or _stealthCheck("player") ) and not UnitBuffID("player",32727) and not _isMoving("player") and not UnitAffectingCombat("player") then
							if map_id == 2167 then
								local x,y,z = unpack ( center_map.robodrome )
								MoveTo(x,y,z)
								pause_auto_movement = time
							end
							if map_id == 572 then
								local x,y,z = unpack ( center_map.rol )
								MoveTo(x,y,z)
							end
						end
					end
					if UnitIsVisible(current_target) and (not pause_auto_movement or time - pause_auto_movement > 4.5) and not UnitIsDeadOrGhost("player") then
						local class = select(2,UnitClass("player"))
						local spec = GetSpecialization()
						local player_role = GetUnitRole("player")
						local attackable_target = current_target and unit_can_attack("player",current_target)
						local needs_to_mount = instance_type == "pvp" and not arena and not UnitAffectingCombat("player") and not IsIndoors() and not IsMounted() and (class ~= "ROGUE" and class ~= "DRUID" or not attackable_target) and (not attackable_target or _distance(current_target) > 42) and not _stealthCheck("player")
						if player_role == "ranged" then
							if not unit_casting_info("player") then
								local dist = _distance(current_target)
								local los = _LoS(current_target)
								local bg_val = 30
								if (dist > 35 - ( UnitIsFriend("player",current_target) and bg_val or 0 ) or not los) and not needs_to_mount then
									if not recent_movement or time - recent_movement > .75 or not _isMoving("player") then
										--move into range / los
										local x,y,z = basic_path_to_unit(current_target)
										MoveTo(x,y,z)
										recent_movement = time
									end
								elseif dist <= 35 - ( UnitIsFriend("player",current_target) and bg_val or 0 ) and los or needs_to_mount then
									ready_for_combat = unit_can_attack("player",current_target) and not needs_to_mount
									--stop moving when in range
									if _isMoving("player") then
										if unit_can_attack("player",current_target) or needs_to_mount then
											local px,py,pz = GetPlayerPosition()
											StopMoving()
											MoveTo(px,py,pz)
											-- if needs_to_mount then
											-- 	CallCompanion("MOUNT",math.random(1,15))
											-- end
										end
									end
									--dismount when in range
									if IsMounted() and unit_can_attack("player",current_target) then
										Dismount()
									end
								end
							end
						elseif player_role == "melee" then
							local dist = _distance(current_target)
							local los = _LoS(current_target)
							if (dist > 2 or not los) and not needs_to_mount then
								if not recent_movement or time - recent_movement > .1 or not _isMoving("player") then
									--move into range / los
									local x,y,z = basic_path_to_unit(current_target)
									MoveTo(x,y,z)
									recent_movement = time
								end
							elseif dist <= 2 and los then
								ready_for_combat = unit_can_attack("player",current_target) and not needs_to_mount
								--dismount when in range
								if IsMounted() and unit_can_attack("player",current_target)  then
									Dismount()
								end
							end
						elseif player_role == "healer" then
							if not unit_casting_info("player") then
								local dist = _distance(current_target)
								local los = _LoS(current_target)
								if ( dist > 35 or not los) and not needs_to_mount then
									if not recent_movement or time - recent_movement > 1 or not _isMoving("player") then
										--move into range / los
										local x,y,z = basic_path_to_unit(current_target)
										MoveTo(x,y,z)
										recent_movement = time
									end
								elseif dist <= 35 and los or needs_to_mount then
									--stop moving when in range
									if _isMoving("player") then
										local px,py,pz = GetPlayerPosition()
										StopMoving()
										MoveTo(px,py,pz)
										-- if needs_to_mount then
										-- 	CallCompanion("MOUNT",math.random(1,15))
										-- end
									end
									ready_for_combat = unit_can_attack("player",current_target) and not needs_to_mount
									--dismount when in range
									if IsMounted() and unit_can_attack("player",current_target) then
										Dismount()
									end
								end
							end
						end
					end
				--with navmesh
				else
					if UnitIsVisible(current_target) and not UnitIsDeadOrGhost("player") and instance_type ~= "none" then
						local their_healer
						for i=1,#Enemies do if _isHealer(Enemies[i]) then
							their_healer = Enemies[i]
						end end
						local t
						if their_healer and (_incapacitateDR(their_healer) == 1 or _drRemains(their_healer,"incapacitate") > 17.5 or _drRemains(their_healer,"incapacitate") < 5 or SQUID.mongo) and (not _LoS(their_healer) or _distance(their_healer) > 28) then
							t = their_healer
						else
							t = current_target
						end
						local class = select(2,UnitClass("player"))
						local spec = GetSpecialization()
						local dist = _distance(t)
						local los = _LoS(t)
						local player_role = GetUnitRole("player")
						local attackable_target = unit_can_attack("player",t)
						local role_min_mount_range = (player_role == "melee" and 11 or 42)
						local needs_to_mount = instance_type == "pvp" and not arena and not UnitAffectingCombat("player") and not IsIndoors() and not IsMounted() and (class ~= "ROGUE" and class ~= "DRUID" or not attackable_target) and (not attackable_target or dist > role_min_mount_range or not los)
						local needs_to_stealth
						if class == "ROGUE" or class == "DRUID" then
							needs_to_stealth = not combat and ( arena or instance_type == "pvp" and ready_for_combat )
						end
						if needs_to_stealh then needs_to_mount = nil end
						-- print(needs_to_mount)
						if player_role == "ranged" then
							if not unit_casting_info("player") then

								ready_for_combat = attackable_target and dist < 35 - (unit_is_unit(t,their_healer) and 6.5 or 0) and los and not needs_to_mount

								--stop moving when in range
								if _isMoving("player") then
									if ready_for_combat then
										Squid_StopNav()
									end
								end
								--dismount when in range
								if IsMounted() and ready_for_combat then
									Dismount()
								end

								--move to target
								if not needs_to_mount then
									if not recent_movement or time - recent_movement > .75 then
										if dist > 28 or not los then
											local x,y,z = ObjectPosition(t)
											Squid_Nav(x,y,z)
											recent_movement = time
										end
									end
								end

							end
						elseif player_role == "melee" then
							ready_for_combat = attackable_target and dist < 2 and los and not needs_to_mount
							--stop moving when in range
							if _isMoving("player") then
								if ready_for_combat then
									Squid_StopNav()
								end
							end
							--dismount when in range
							if IsMounted() and ready_for_combat then
								Dismount()
							end
							--move to target
							if not needs_to_mount then
								if not recent_movement or time - recent_movement > .5 then
									if dist >= 2 or not los then
										local x,y,z = ObjectPosition(current_target)
										Squid_Nav(x,y,z)
										recent_movement = time
									end
								end
							end
						elseif player_role == "healer" then
							if not unit_casting_info("player") then

								ready_for_combat = dist < 35 and los and not needs_to_mount
								--stop moving when in range
								if _isMoving("player") then
									if ready_for_combat then
										Squid_StopNav()
									end
								end
								--dismount when in range
								if IsMounted() and ready_for_combat then
									Dismount()
								end
								--move to target
								if not needs_to_mount then
									if not recent_movement or time - recent_movement > .5 then
										if dist > 33 or not los then
											local x,y,z = ObjectPosition(current_target)
											Squid_Nav(x,y,z)
											recent_movement = time
										end
									end
								end
							end
						end
					end
				end
			end
			--mount up when out of combat
			-- if needs_to_mount then
				if not UnitAffectingCombat("player") and not IsMounted() and not _stealthCheck("player") and not ready_for_combat then
					if not arena_loading_screen and (not UnitBuffID("player",32727) or arena_start_timer and arena_start_timer <= 15) then
						if not attempted_mount or time - attempted_mount > .5 then
							Squid_StopNav()
							CallCompanion("MOUNT",math.random(1,15))
							attempted_mount = time
						end
					end
				end
			-- end
		end

		--enable the bot with cap bot on..................
		if cap_bot and ( arena or instance_type == "pvp" ) and not SquidLobster then SquidToggle() end

		--alternate between tanking / winning
		-- if not tank_mmr_init then
		-- 	tank_mmr_init = time
		-- else
		-- 	if not UnitAffectingCombat("player") then
		-- 		if time - tank_mmr_init > 2400 or SQUID.tank_mmr and time - tank_mmr_init > 1200 then
		-- 			SQUID.tank_mmr = not SQUID.tank_mmr
		-- 			tank_mmr_init = time
		-- 		end
		-- 	end
		-- end

		--auto cooldowns
		if cap_bot and ( arena or instance_type == "pvp" ) then

			local class = select(2,UnitClass("player"))
			local spec = GetSpecialization()

			--trinket
			if UnitAffectingCombat("player") and _CCremains("player") >= 3.99 then
				-- if _spellCooldown(208683) == 0 or _spellCooldown(195710) == 0 then
				-- 	SQ_CastSpellByID(208683)
				-- 	SQ_CastSpellByID(195710)
				-- end
				if IsEquippedItem(184052) and GetItemCD(184052) == 0 then
					UseItemByName(tostring(GetItemInfo(184052)))
				end
				if IsPlayerSpell(59752) and _spellCooldown(59752) == 0 and _stunCheck("player") then
					SQ_CastSpellByName("Will to Survive")
				end
			end

			--human trinket
			if UnitAffectingCombat("player") and _stunRemains("player") >= 2.99 then
				SQ_CastSpellByID(59752)
			end

			-- Use bike
			if UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and not _immunePhysical(current_target) and _LoS(current_target) then
				if IsEquippedItem(169769) and GetItemCD(169769) <= 1 then
					if _HP(current_target) < 90 then
						UseItemByName(tostring(GetItemInfo(169769)));
					end
				end
			end

			-- Use absorb shit
			if IsEquippedItem(159618) and GetItemCD(159618) <= 1 then
				if _HP("player") < 40 then
					UseItemByName(tostring(GetItemInfo(159618)));
				end
			end

			-- Tankerino
			if SQUID.tank_mmr then
				if UnitAffectingCombat("player") then
					C_Timer.After(1,function()
						join_battle_time = time
						RunMacroText("/afk")
					end)
				end
			end

			-- HUNTER AUTOBOT CDS
			if class == "HUNTER" then
				if time_in_control > .3 then

					-- go targ
					if UnitIsVisible(current_target) and _distance(current_target) > 10 then
						_Cast(190925,current_target)
					end

					-- det
					if _HP("player") < 15 + (10 * EnemiesAttacking("player")) - (_spellCooldown(109304) < 2 and 15 or 0) then
						_Cast(186265)
					end

					-- cds
					if UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and not _immunePhysical(current_target) and _LoS(current_target) then
						if _HP(current_target) < 95 then
							_Cast(266779)
							if _distance(current_target) > 4.5 then
								_Cast(186289)
							end
						end
					end

					-- stun target
					if not IsMounted() or _distance(current_target) < 11 then
						if UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and not _immunePhysical(current_target) and _LoS(current_target) and not _immuneStuns(current_target) and not _CCcheck(current_target) and _stunDR(current_target) == 1 then
							_Cast(19577,current_target)
						end
					end

					-- get pet
					if map_id ~= 2167 or UnitAffectingCombat("player") then
						if not UnitIsVisible("pet") then
							if not pet_res_attempt or time - pet_res_attempt > 5 then
								pet_res_count = pet_res_count or 0
								pet_res_count = pet_res_count + 1
								CastSpellByName("Revive Pet")
								if pet_res_count > 5 then
									pet_res_attempt = time
								end
							else
								pet_res_count = 0
								CastSpellByName("Call Pet 3")
							end
						end
					end

				end
			end

			-- MAGE AUTOBOT CDS
			if class == "MAGE" then

				if time_in_control > .3 and not UnitIsDeadOrGhost("player") then

					local their_healer = theirHealer
					local their_healer_cc
					local their_healer_cc_remains = 0
					local their_healer_incapacitate_dr
					local their_healer_incapacitate_dr_remains = 0
					local their_healer_disorient_dr
					local their_healer_disorient_dr_remains = 0
					local their_healer_important_lockout
					if their_healer then
						if not UnitIsDeadOrGhost(their_healer) then
							their_healer_cc_remains = _CCremains(their_healer)
							their_healer_cc = their_healer_cc_remains > 0
							their_healer_incapacitate_dr = _incapacitateDR(their_healer)
							their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
							their_healer_disorient_dr = _disorientDR(their_healer)
							their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

							local class = select(2,UnitClass(their_healer))

							local locked,remaining,school = UnitIsLocked(their_healer)

							if locked and remaining > .25 then
								if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
								or ( class == "SHAMAN" and school == "Nature" )
								or ( class == "PALADIN" and school == "Holy" )
								or ( class == "MONK" and school == "Nature" )
								or ( class == "DRUID" and school == "Nature" )  then
									their_healer_important_lockout = true
								end
							end
						else -- no healer if he dead
							their_healer = nil
						end
					end

					local target_attackable = UnitIsVisible(current_target) and unit_can_attack("player",current_target) and _LoS(current_target) and _distance(current_target) < 35
					local sheeped_target
					local sheeped_target_duration = 0
					for i=1,#Enemies do
						local remains = _debuffRemains(Enemies[i],118,"player")
						-- if _debuffRemains(Enemies[i],82691,"player") > remains then remains = _debuffRemains(Enemies[i],82691,"player") end
						if remains > 0 then
							sheeped_target = Enemies[i]
							sheeped_target_duration = remains
						end
					end

					--fire
					if spec == 2 then
						local combustion = UnitBuffID("player",190319)
						--combust
						if not arena_loading_screen and target_attackable and _spellCooldown(190319) <= .2 and not _immuneMagic(current_target) then
							if (load_mode_active or meteor_in_flight) and (not unit_casting_info("player") or _castTimeLeft("player") < .25) and (not theirHealer or _CCcheck(theirHealer)) then
								SquidBurst()
							end
						end
						-- db
						if Squid_DB and not SQUID.i_am_xen then
							if lowestFriend < 80 or lowestEnemy < 30 then
								for i=1,#Enemies do if unit_is_player(Enemies[i]) and not _CCcheck(Enemies[i]) and (not unit_is_unit(current_target,Enemies[i]) or _HP(Enemies[i]) < 30 or lowestFriend < 50) and _disorientDR(Enemies[i]) >= .5 then
									Squid_DB(Enemies[i])
								end end
							end
						end
						--blink away from melee if i dont have a healer
						if not ourHealer and select(2,EnemiesAttacking("player")) > 0 and _spellCooldown(212653) == 0 and not UnitBuffID("player",45438) and (not player_blink or GetTime() - player_blink > 3) then
							local x,y,z = africa_blink()
							if x and y and z then
								blink_to_pos(x,y,z)
								Squid_Alert("Blinking Away From Shit",nil,nil,nil,212653)
							end
						end
						--sheep target if they're full hp i guess?
						-- if not combustion then
						-- 	if target_attackable and ( not sheeped_target or unit_is_unit(current_target,sheeped_target) or sheeped_target_duration < _castTime(118) ) and _CCremains(current_target) < _castTime(118) + .2 then
						-- 		if _HP(current_target) > 90 and not _immuneMagic(current_target) and _incapacitateDR(current_target) >= .5 and UnitEnemiesAttacking(current_target) == 0 then
						-- 			_Cast(118,current_target)
						-- 		end
						-- 	end
						-- end
						--cook pies into bcc
						if target_attackable and not killshot_engaged and _breakableCC(current_target) then
							_Cast(203286,current_target)
						end
						--meteor
						if load_mode_active and target_attackable and not _immuneMagic(current_target) and (_isSlowed(current_target) or _CCcheck(current_target)) then
							Squid_Meteor(current_target)
						end
						--auto block
						local block_after_caut = true
						local block_hp = 20
						if (_HP("player") <= block_hp or block_after_caut and _debuffRemains("player",108843) >= 3.5 and _HP("player") < block_hp + 17.5) and _spellCooldown(45438) <= GetGCD()+.15 then
							if not block_after_caut or UnitDebuffID("player",86949) or UnitDebuffID("player",87024) then
								if unit_casting_info("player") or UnitChannelInfo("player") then SpellStopCasting() end
								SQ_CastSpellByID(45438)
								Squid_Alert_Big("Auto Block","(You're a bot!)",1,3,45438)
							end
						end
						--blink to targo to kill his ass
						if UnitIsVisible(current_target) and not _LoS(current_target) then
							if ( _HP(current_target) < ( 10 * GetSpellCharges(212653) ) + (_stunRemains(current_target) > 2.5 and their_healer_cc and 75 or 0) or combustion ) then
								blink_to_unit(current_target,25,true)
							end
						end
						if UnitIsVisible(theirHealer) and not unit_is_unit(theirHealer,current_target) then
							--blink to healer to cc
							if _CCremains(theirHealer) > 1.75 and _incapacitateDR(theirHealer) >= .5 and (not _LoS(theirHealer) or _distance(theirHealer) > 32) then
								blink_to_unit(theirHealer,30,true)
							end
							--blink db healer for sheep
							if _incapacitateDR(theirHealer) == 1 and _disorientDR(theirHealer) == 1 and not _CCcheck(theirHealer) then
								blink_db(theirHealer)
							end
						end
						--pre blaze
						if arena_start_timer and arena_start_timer <= 20 then
							_Cast(235313)
						end
					end

				end

			end

			if class == "ROGUE" then

				-- vanish when ded
				if _HP("player") < 20 then
					_Cast(1856)
				end

				--sprint
				if arena and not UnitBuffID("player",32727) and _isMoving("player") and UnitIsVisible(current_target) and not _meleeRange(current_target) and UnitAffectingCombat("player") then
					SQ_CastSpellByID(2983)
				end

				--blind
				if theirHealer and _CCremains(theirHealer) < .25 and _disorientDR(theirHealer) == 1 and not unit_is_unit(theirHealer, current_target) then
					_Cast(2094,theirHealer,nil,true)
				end

				--blind peel
				if lowestFriend < 60 and not theirHealer then
					for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) and not _CCcheck(Enemies[i]) and _disorientDR(Enemies[i]) == 1 then
						_Cast(2094,Enemies[i])
					end end
				end

			end

			if class == "DRUID" then

				--stamp roar
				if arena and not UnitBuffID("player",32727) and _isMoving("player") then
					if _Cast(106898) then
						Squid_Alert("Stampeding Roar","(Maximum Aggression!)",nil,nil,106898)
					end
				end

				--wall
				if _HP("player") < 15 + (35 * EnemiesAttacking("player")) then
					if _Cast(61336) then
						Squid_Alert("Survival Instincts","(Less Death)",nil,nil,106898)
					end
				end

			end

		end

		function DetermineActiveCovenantAndSoulbindAndConduits()
		  local covenantID = C_Covenants.GetActiveCovenantID();
		  if ( not covenantID or covenantID == 0 ) then
			return nil;
		  end
		  local covenantData = C_Covenants.GetCovenantData(covenantID);
		  if ( not covenantData ) then
			return nil;
		  end
		  local covenantName = covenantData.name;
		  local soulbindID = C_Soulbinds.GetActiveSoulbindID();
		  if ( not soulbindID or soulbindID == 0 ) then
			return nil;
		  end
		  local soulbindData = C_Soulbinds.GetSoulbindData(soulbindID);
		  if ( not soulbindData ) then
			return nil;
		  end
		  local id = soulbindData["ID"];
		  --local covenantID = soulbindData["covenantID"];
		  local soulbindName = soulbindData["name"];
		  local description = soulbindData["description"];
		  local tree = soulbindData["tree"];
		  local nodes = tree["nodes"];
		  --BA_Data["function LogTextLine"](string.format("covenant:[%s] - soulbind ID:[%d] - id:[%d] - covenantID:[%d] - name:[%s]",covenantName,soulbindID,id,covenantID,name));
		  --BA_Data["function LogTextLine"](string.format("nodes:-"));
		  local activeConduitsSpells = {};
		  activeConduitsSpells.covenantName = covenantName;
		  activeConduitsSpells.soulbindName = soulbindName;
		  activeConduitsSpells.conduits = {};
		  for _, ve in pairs(nodes) do
			local node_id = ve["ID"];
			local node_row = ve.row;
			local node_column = ve.column;
			local node_spellID = ve.spellID; -- this will be 0 for uninit spell, not nil
			local node_conduitID = ve.conduitID; -- this will be 0 for uninit conduit, not nil
			local node_conduitRank = ve.conduitRank;
			local node_state = ve.state;
			local node_conduitType = ve.conduitType; -- this can be nil
			if ( node_state == 3 ) then
			  --[====[
			  BA_Data["function LogTextLine"](string.format("nodeid:[%s] - row:[%s] - col:[%s] - spellID:[%s] - conduitID:[%s] - conduitRank:[%s] - state:[%s][%s] - conduitType:[%s][%s]",
				  tostring(node_id),
				  tostring(node_row),
				  tostring(node_column),
				  tostring(node_spellID),
				  tostring(node_conduitID),
				  tostring(node_conduitRank),
				  tostring(node_state),
				  tostring(( node_state == 1 and "blank" or node_state == 3 and "used" or "unknown" )),
				  tostring(node_conduitType),
				  tostring(( node_conduitType == 1 and "Potency" or node_conduitType == 2 and "Endurance" or node_conduitType == 0 and "Finesse" or "Unknown"  ))
				));
			  --]====]

			  local node_spellName;
			  if ( node_spellID ~= 0 ) then
				node_spellName = GetSpellInfo(node_spellID);
			  elseif ( node_conduitID ~= 0 ) then
				local conduitSpellID = C_Soulbinds.GetConduitSpellID(node_conduitID,node_conduitRank);
				node_spellID = conduitSpellID;
				node_spellName = GetSpellInfo(conduitSpellID);
			  else
				node_spellID = nil;
				node_spellName = nil;
			  end
			  if ( node_spellID ) then
				activeConduitsSpells.conduits[#activeConduitsSpells.conduits + 1] = { spellID = node_spellID, spellName = node_spellName, rank = node_conduitRank };
			  end
			end
		  end
		  for _, ve in pairs(activeConduitsSpells.conduits) do
			-- BA_Data["function LogTextLine"](string.format("spellID:[%d] - spellName:[%s]",ve.spellID,tostring(ve.spellName)));
		  end

		  --BA_Data["function LogTextLine"](string.format("-- end nodes"));
		  return activeConduitsSpells;
		end

		if not soulbinds_update or time - soulbinds_update > 120 then
			active_soulbinds = {DetermineActiveCovenantAndSoulbindAndConduits()}
			soulbinds_update = time
		end

		if not conduit_taken then
			function conduit_taken(name, rank)
				for i=1,#active_soulbinds do
					local s = active_soulbinds[i]
					if s.conduits then
						for n=1,#s.conduits do
							if s.conduits[n] and (s.conduits[n].spellName == name or s.conduits[n].spellID == name) and (not rank or s.conduits[n].rank >= rank) then
								return true
							end
						end
					end
				end
			end
			function conduit_rank(name)
				for i=1,#active_soulbinds do
					local s = active_soulbinds[i]
					if s.conduits then
						for n=1,#s.conduits do
							if s.conduits[n] and (s.conduits[n].spellName == name or s.conduits[n].spellID == name) then
								return s.conduits[n].rank
							end
						end
					end
				end
				return 0
			end
		end

		if player_cast then mount_cast_delay = time end

		local item_broken
		local current_durability = 0
		local max_durability = 0

		for i=1,10 do
			local current,max = GetInventoryItemDurability(i)
			if current then
				max_durability = max_durability + max
				current_durability = current_durability + current
				if current <= 5 then
					item_broken = true
				end
			end
		end

		local durability_pct = (100 * current_durability / max_durability)

		if item_broken then durability_pct = 0 end

		if cap_bot and GetMapId() == 2373 and not UnitAffectingCombat("player") then
			if UnitBuffID("player",32727) then
				has_prep = time
			end
			time_since_prep = has_prep and time - has_prep or 0
			if time_since_prep > .6 and time_since_prep < 7 then
				local best_enemy
				for i=1,#Enemies do
					best_enemy = Enemies[i]
				end
				if best_enemy then
					local x,y,z = ObjectPosition(best_enemy)
					MoveTo(x,y,z)
				end
			end
		end

		--auto repair
		if cap_bot and (not ( arena or instance_type == "pvp" ) or UnitBuffID("player",32727)) and durability_pct < 70 then
			if not recently_repaired or time - recently_repaired >= 600 then
				if not UnitAffectingCombat("player") then
					if IsUsableSpell("Grand Expedition Yak") then
						if not UnitBuffID("player",122708) then
							if not mount_cast_delay or time - mount_cast_delay > .25 then
								SQ_CastSpellByName("Grand Expedition Yak")
							end
						else
							InteractUnit("Cousin Slowhands")
							if MerchantFrame and MerchantFrame:IsShown() then
								if MerchantRepairAllButton and MerchantRepairAllButton:IsShown() then
									MerchantRepairAllButton:Click()
									C_Timer.After(3,function()
										recently_repaired = time
										Dismount()
									end)
								end
							end
						end
					elseif IsUsableSpell("Traveler's Tundra Mammoth") then
						if not ( UnitBuffID("player",61425) or UnitBuffID("player",61447) ) then
							if not mount_cast_delay or time - mount_cast_delay > .25 then
								SQ_CastSpellByName("Traveler's Tundra Mammoth")
							end
						else
							InteractUnit("Gnimo")
							InteractUnit("Drix Blackwrench")
							if MerchantFrame and MerchantFrame:IsShown() then
								if MerchantRepairAllButton and MerchantRepairAllButton:IsShown() then
									MerchantRepairAllButton:Click()
									C_Timer.After(3,function()
										recently_repaired = time
										Dismount()
									end)
								end
							end
						end
					end
				end
			end
		end

		--jack shit
		if SQUID.i_am_jack then
			if arena then
				local opponents = GetNumArenaOpponents()
				for i=1,#Enemies do if _isHealer(Enemies[i]) then
					opponents = opponents - 1
				end end
				if opponents > 0 then
					-- for i=1,#Friends do
					-- 	if EnemiesAttacking(Friends[i]) >= opponents then
					-- 		tX, tY, tZ = ObjectPosition(Friends[i])
		   --                  s = 1.5
		   --                  LibDraw.SetWidth(5)
		   --                  LibDraw.SetColorRaw(1, 0, 0, 1)
		   --                  Line(tX, tY, tZ+s*2, tX, tY, tZ)
		   --                  Line(tX-s, tY, tZ, tX+s, tY, tZ)
		   --                  Line(tX, tY-s, tZ, tX, tY+s, tZ)
					-- 	end
					-- end
				end
				for i=1,#Enemies do if not _isHealer(Enemies[i]) then
					local ut = UnitTarget(Enemies[i])
					if unit_is_unit("player",ut) then
						local x,y,z = ObjectPosition(Enemies[i])
						local px,py,pz = ObjectPosition("player")
						LibDraw.SetWidth(5)
						LibDraw.SetColorRaw(1, .25, 0, 1)
						LibDraw.Line(x,y,z,px,py,pz)
					end
				end end
			end
		end

		PetPlayerEnabled=nil
		PetPlayerDraw=nil
		if PetPlayer and IsForeground() and UnitIsVisible(PetPlayer) then
			if GetKeyState(0x12) == true then
				if GetKeyState(0x01) == true then
					if not PetCommandSent or time-PetCommandSent > .5 then
						SendMovementCommand(PetPlayer)
						PetCommandSent=time
					end
					_targetLastTarget()
					C_Timer.After(.25,_targetLastTarget)
				end
				PetPlayerDraw=true
			end
		end

		--accept res
		if AutoFollow and StaticPopup1 and StaticPopup1:IsShown() then
			if StaticPopup1.which == "RESURRECT_NO_TIMER" then
				StaticPopup1Button1:Click()
			end
		end

		if big_dmg_inc and big_dmg_inc_time and time - big_dmg_inc_time > 3 then
			big_dmg_inc = nil
			big_dmg_inc_time = nil
		end

		if cc_flying_towards_player and cc_flying_towards_player_time and time - cc_flying_towards_player_time > 2.25 then
			cc_flying_towards_player = nil
			cc_flying_towards_player_time = nil
		end

		if current_target then
			if (not last_target or not unit_is_unit(last_target,current_target)) then
				last_target=current_target
			end
		else
			if last_target and UnitIsVisible(last_target) and UnitBuffID(last_target,5384) then
				TargetUnit(last_target)
				Squid_Alert("Re-Target Hunter","(Feign Death)")
			end
		end

		if SQUID.streaming_mode and player_afk then
			return
		end

		-- if IsHackEnabled then
		-- 	InteractUnit("Crackleclaw Crab")
		-- end

		if SQUID.anon then
			if GameTooltip:IsShown() and GameTooltipTextLeft1 then
				local name = GameTooltipTextLeft1:GetText()
				if name then
					if UnitIsFriend("player",name) or UnitInParty(name) then
						GameTooltipTextLeft1:SetText("Friend of Squid")
						-- GameTooltip:Hide()
					end
					if name == UnitPVPName("player") then
						GameTooltipTextLeft1:SetText("Squid")
						-- GameTooltip:Hide()
					end
				end
			end
		end

		if SQUID.anon then
			if CharacterFrameTitleText and CharacterFrameTitleText:GetText() == myName then
				CharacterFrameTitleText:SetText(custom_name)
			end
		end

		--default saved vars
		SQUID.min_combust_hp = SQUID.min_combust_hp or 40000

		if SQUID.auto_combust == nil then
			SQUID.auto_combust = false
		end

		if SQUID.solo_mode then
			local solo_instance = {
				[2192] = true, -- torghast
			}
			SQUID.solo_mode_enabled = not is_in_instance or GetNumGroupMembers() <= 1 or solo_instance[map_id]
		end

		if gpy_flying and time - gpy_flying > 4 then
			gpy_flying = nil
		end
		if (pyro_flying and time - pyro_flying > 2.5) or (pyro_flying and time - pyro_flying > .3 and not pyro_really_flying) then
			pyro_flying = nil
			pyro_really_flying = nil
		end

		if (fb_flying and time - fb_flying > 2.5) or (fb_flying and time - fb_flying > .3 and not fb_really_flying) then
			fb_flying = nil
			fb_really_flying = nil
		end

		if (pf_flying and time - pf_flying > 2.5) or (pf_flying and time - pf_flying > .3 and not pf_really_flying) then
			pf_flying = nil
			pf_really_flying = nil
		end

		--clear these tables
		--kickTable Alert / Clear
		if #kickTable > 0 then
			for i=1,#kickTable do
				if kickTable[i] then
					local spell = kickTable[i].cast
					local unit = kickTable[i].unit
					local class
					local name
					local school
					--alert
					if not kickTable[i].alert then
						if spell and UnitIsVisible(unit) then
							class = UnitClass(unit)
						end
						if spell and class then
							if locale == "zhCN" then
								Squid_Alert("æ‰“æ–­ >>",class .." ("..spell..")",1,kickTable[i].time-time,kickTable[i].kickID)
							else
								Squid_Alert("Lockout on",class .." ("..spell..")",1,kickTable[i].time-time,kickTable[i].kickID)
							end
							kickTable[i].alert=true
						end
					end
					--remove
					if kickTable[i].time and time - kickTable[i].time > 0 then
						table.remove(kickTable,i);
					end
				end
			end
		end

		-- clear kick CD table
		if #kickCooldowns > 0 then
			for i=1,#kickCooldowns do if kickCooldowns[i] and kickCooldowns[i].expire - time < 0 then
				table.remove(kickCooldowns,i);
			end end
		end

		--BigCDTable Clear
		if #BigCDTable > 0 then
			for i=1,#BigCDTable do if BigCDTable[i] and BigCDTable[i].time and time - BigCDTable[i].time > 20 then
				table.remove(BigCDTable,i);
			end end
		end
		--TrinketTracker Clear
		if #TrinketTracker > 0 then
			for i=1,#TrinketTracker do if TrinketTracker[i] and TrinketTracker[i].expires and time - TrinketTracker[i].expires > 0 then
				table.remove(TrinketTracker,i);
			end end
		end
		--jukeList Clear
		for k,v in pairs(jukeList) do
			if k then
				local r = v["Reset"]
				if r and r <= time then
					jukeList[k] = {}
				end
			end
		end
		--SpellTracker Clear
		for k,v in pairs(SpellTracker) do
			if v.expires and time > v.expires then
				SpellTracker[k] = nil
			end
		end

		prev_gcd=nil
		table.sort(PlayerSpellCasts,function(x,y) return x.time > y.time end)
		--PlayerSpellCasts Clear
		if #PlayerSpellCasts > 0 then
			for i=1,#PlayerSpellCasts do
				if not prev_gcd and PlayerSpellCasts[i] and IsSpellOnGCD(PlayerSpellCasts[i].name) then prev_gcd=PlayerSpellCasts[i].name end
				--shove spells off gcd to bottom of table
				if PlayerSpellCasts[i] and time-PlayerSpellCasts[i].time > 120 then
					table.remove(PlayerSpellCasts,i);
				end
			end
		end

		if not last_combat_time then last_combat_time = time end
		if UnitAffectingCombat("player") then
			last_combat_time = time
			if not time_combat_started then
				time_combat_started=time
			else
				time_in_combat=time-time_combat_started
			end
		else
			time_since_combat = time - last_combat_time
			time_combat_started = nil
			time_in_combat=0
		end

		arena_start_timer = nil
		if arena then
			if UnitBuffID("player",32727) then
				if TimerTrackerTimer1 then
					if TimerTrackerTimer1.time then
						arena_start_timer = TimerTrackerTimer1.time
					end
				end
			end
		end

		all_opponents_visible = true
		if arena then
			for i=1,GetNumArenaOpponents() do
				if not UnitIsVisible("arena"..i) then
					all_opponents_visible = nil
				end
			end
		end

		--keybinds to run even with script disabled
		if ring_healer_key then
			if theirHealer then
				ring_of_frost(theirHealer)
			end
		end
		if ring_focus_key then
			if current_focus then
				ring_of_frost(current_focus)
			end
		end
		if ring_target_key then
			if current_target then
				ring_of_frost(current_target)
			end
		end

		--keep SQUID table updated in savedvars every update
		Squid_Savedvars.SQUID = SQUID

		--mage no suicide lmao
		-- if select(2,UnitClass("player")) == "MAGE" and not arena and IsFalling() and GetUnitSpeed("player") >= 14 then
		-- 	local x,y,z = GetPlayerPosition()
		-- 	local gz,gy,gz = GroundZ(x,y,z)
		-- 	if gz and z - gz <= GetUnitSpeed("player") then
		-- 		if not UnitBuffID("player",130) and _Cast(130,"player") then
		-- 			Squid_Alert("Slow Fall","(Saving Your Ass)",1,nil,130)
		-- 		end
		-- 	end
		-- end

		weird_ass_spells = {
			["alter time"] = true
		}

		-- squid queued spell
		if SQ_QueuedSpell then
			local haste = UnitSpellHaste("player")
			local gcd = 1.5/(1+(haste/100))
			if time - SQ_QueuedSpell.time > min(.35 + latency,gcd-.125) then
				SQ_QueuedSpell = nil
			else
				if SQ_QueuedSpell.spell then
					local target = SQ_QueuedSpell.target ~= "healer" and SQ_QueuedSpell.target
					local spell = SQ_QueuedSpell.spell
					if SQ_QueuedSpell.target == "healer" then
						for i=1,#Enemies do if _isHealer(Enemies[i]) then target = Enemies[i] end end
					elseif not target then
						target = "target"
					end
					if spell and (IsSpellOnGCD(spell) or weird_ass_spells[strlower(spell)]) then
						if target == "cursor" then
							RunMacroText("/cast [@cursor] " .. spell)
						else
							SQ_CastSpellByName(spell, target)
							if _spellCooldown(spell) <= .215 + latency then
								local spellname, _, _, _, _, _, spellid = GetSpellInfo(spell)
								spellname = string.gsub(" "..spellname, "%W%l", string.upper):sub(2)
								Squid_Alert(spellname, "(Manual)", nil, .5, spellid)
							end
						end
					end
				end
			end
		end

		--Script Enabled
		if not SquidLobster then SetMovementLocked(false); return; end

		if ExecutingPlayerMovementCommand and time - ExecutingPlayerMovementCommand > 4 then ExecutingPlayerMovementCommand = nil end

		--auto follow, for full afk
		local t
		if AutoAssist and UnitIsVisible(AutoAssist) then
			t=UnitTarget(AutoAssist)
		elseif not t and AutoFollow and UnitIsVisible(AutoFollow) then
			t=UnitTarget(AutoFollow)
		end
		if AutoFollow and UnitIsVisible(AutoFollow) then
			AlwaysFacing=true
			if not MountInteract or time-MountInteract > 1 then
				InteractUnit(AutoFollow)
				MountInteract=time
			end
			if IsMounted() then
				if t and unit_can_attack("player",t) and not UnitIsDeadOrGhost(t) and _distance(t) < 15 then
					Dismount()
				end
			end
			if _isMoving(AutoFollow) and not unit_casting_info("player") and not ExecutingPlayerMovementCommand then
				if not autofollow_automove or time - autofollow_automove > .65 then
					local x,y,z=ObjectPosition(AutoFollow)
					MoveTo(x,y,z)
					autofollow_automove = time
				end
			elseif t then
				if not UnitAffectingCombat("player") then
					if (not arena_start_timer or arena_start_timer <= 15) and not IsMounted() then
						CallCompanion("MOUNT",math.random(1,15))
					end
				else
					if not _isMoving("player") then
						_faceUnit(t)
					end
				end
			end
			if not hasjumped or time-hasjumped > 60 then
				if _isMoving("player") and not IsSwimming() and not IsFlying() then
					JumpOrAscendStart()
					AscendStop()
					hasjumped=time
				end
			end
		end

		if player_cast_id == 133 and _castTimeLeft("player") <= latency then
			fb_flying = time
		end

		if (AutoFollow or AutoAssist) and t and not unit_is_unit(t,current_target) then TargetUnit(t) end

		wait_for_interrupt = false

		player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
		player_cast_target = UnitSpellTarget("player")
		player_cast_time_left = _castTimeLeft("player")
		player_cast_percent_complete = _castPctDone("player")

		if player_cast_id == 2948 and player_cast_time_left <= .2 then
			fb_used = time - .1
		end

		--Determine Player's Interrupt Ability
		local interrupts = {
		183752,--"Disrupt",
		6552,--"Pummel",
		96231,--"Rebuke",
		147362,--"Counter Shot",
		1766,--"Kick",
		47528,--"Mind Freeze",
		57994,--"Wind Shear",
		119911,--"Optical Blast",
		115781,--"Optical Blast",
		19647,--"Spell Lock",
		132409,--"Spell Lock",
		251523,--"Spell Lock",
		119910,--"Spell Lock",
		171138,--"Shadow Lock",
		2139,--"Counterspell",
		116705,--"Spear Hand Strike",
		106839,--"Skull Bash",
		-- 93985,--"Skull Bash"
		78675,--"Solar Beam",
		187707,--"Muzzle",
		91802,--"Shambling Rush"
		}

		for i=1,#interrupts do
			if IsPlayerSpell(interrupts[i]) then
				InterruptID = interrupts[i];
				InterruptName = GetSpellInfo(interrupts[i]);
				break
			end
		end

		--auto maledict
		if last_dispel and time - last_dispel < 4 or not theirHealer or UnitIsVisible(theirHealer) and _CCremains(theirHealer) >= 6 then

			--corrupted
			if (IsEquippedItem(GetItemInfo(172672)) and select(2,GetItemCooldown(172672)) <= GetGCD())
			--notorious
			or (IsEquippedItem(GetItemInfo(167383)) and select(2,GetItemCooldown(167383)) <= GetGCD())
			--sinister
			or (IsEquippedItem(GetItemInfo(165806)) and select(2,GetItemCooldown(165806)) <= GetGCD()) then

				if lowestEnemy < 80 then

					local best_target
					local most_targeted = 0

					for i=1,#Enemies do
						local a = UnitEnemiesAttacking(Enemies[i])
						if a > most_targeted then
							most_targeted = a
							best_target = Enemies[i]
						end
					end

					if not best_target then
						best_target = lowestEnemyName
						if not best_target then
							best_target = current_target
						end
					end

					if best_target and UnitIsVisible(best_target) and unit_is_player(best_target) then
						if not _immuneMagic(best_target) and not _breakableCC(best_target) then
							if _isHealer("player") or unit_is_unit(best_target,current_target) then
								if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,best_target) then
									if GetGCD() <= .01 and player_cast_id and player_cast_time_left > 1.25 and player_cast_id ~= 118 and (player_cast_id ~= 203286 or player_cast_time_left > 1.5) and player_cast_id ~= 113724 and player_cast_id ~= 33786 then
										SpellStopCasting()
									end
									UseItemByName(tostring(GetItemInfo(172672)),best_target);
									UseItemByName(tostring(GetItemInfo(167383)),best_target);
									UseItemByName(tostring(GetItemInfo(165806)),best_target);
									Squid_Alert_Big("Maledict " .. UnitClass(best_target),nil,1,3.25,305252)
								end
							end
						end
					end

				end

			end
			--claw
			if (IsEquippedItem(GetItemInfo(173944)) and select(2,GetItemCooldown(173944)) <= GetGCD()) then

				if lowestEnemy < 88 then
					local best_target
					local most_targeted = 0
					for i=1,#Enemies do
						local a = UnitEnemiesAttacking(Enemies[i])
						if a > most_targeted then
							most_targeted = a
							best_target = Enemies[i]
						end
					end
					if not best_target then
						best_target = lowestEnemyName
						if not best_target then
							best_target = current_target
						end
					end

					if best_target and UnitIsVisible(best_target) and unit_is_player(best_target) then
						if not _immuneMagic(best_target) and not _breakableCC(best_target) and not UnitBuffID(best_target,8178) then
							if _isHealer("player") or unit_is_unit(best_target,current_target) then
								if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,best_target) then
									if GetGCD() <= .01 and player_cast_id and player_cast_time_left > 1.25 and player_cast_id ~= 118 and (player_cast_id ~= 203286 or player_cast_time_left > 1.5) and player_cast_id ~= 113724 and player_cast_id ~= 33786 then
										SpellStopCasting()
									end
									UseItemByName(tostring(GetItemInfo(173944)),best_target);
									Squid_Alert_Big("Obsidian Claw " .. UnitClass(best_target),nil,1,3.25,313148)
								end
							end
						end
					end
				end

			end
			--voodoo doll
			if (IsEquippedItem(GetItemInfo(159624)) and select(2,GetItemCooldown(159624)) <= GetGCD()) then

				if lowestEnemy < 80 then
					local best_target
					local most_targeted = 0
					for i=1,#Enemies do
						local a = UnitEnemiesAttacking(Enemies[i])
						if a > most_targeted then
							most_targeted = a
							best_target = Enemies[i]
						end
					end
					if not best_target then
						best_target = lowestEnemyName
						if not best_target then
							best_target = current_target
						end
					end

					if best_target and UnitIsVisible(best_target) and unit_is_player(best_target) then
						if not _immuneMagic(best_target) and not _breakableCC(best_target) then
							if _isHealer("player") or unit_is_unit(best_target,current_target) then
								if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,best_target) then
									if GetGCD() <= .01 and player_cast_id and player_cast_time_left > 1.25 and player_cast_id ~= 118 and (player_cast_id ~= 203286 or player_cast_time_left > 1.5) and player_cast_id ~= 113724 and player_cast_id ~= 33786 then
										SpellStopCasting()
									end
									UseItemByName(tostring(GetItemInfo(159624)),best_target);
									Squid_Alert_Big("Voodoo Doll " .. UnitClass(best_target),nil,1,3.25,271462)
								end
							end
						end
					end
				end

			end
		end

		--m+ affix
		--quaking
		local quaking_remains = _debuffRemains("player",240447)
		if quaking_remains > 0 and unit_casting_info("player") and _castTimeLeft("player") > quaking_remains - 0.5 then
			SpellStopCasting()
			Squid_Alert("Stopcasting","(Quaking)",nil,nil,240448)
		end

		--Utility Handler
		if InterruptID == 187707 then -- muzzle
			for i=1,#Enemies do
				local int = PhysicalInterrupt(Enemies[i])
				if int then
					_Cast(187707,Enemies[i],nil,true)
				end
			end
		end
		if InterruptID == 106839 then -- skull bash
			if not (UnitBuffID("player",5215) or UnitBuffID("player",102547) or UnitBuffID("player",58984)) then
				for i=1,#Enemies do
					if PhysicalInterrupt(Enemies[i]) then
						_Cast(106839,Enemies[i],nil,true);
					end
				end
			end
		end
		if InterruptID == 96231 then --rebuke
			for i=1,#Enemies do
				if PhysicalInterrupt(Enemies[i]) then
					_Cast(96231,Enemies[i],nil,true);
				end
			end
		end
		if InterruptID == 147362 then -- counter shot
			for i=1,#Enemies do
				if PhysicalInterrupt(Enemies[i]) then
					_Cast(147362,Enemies[i],nil,true);
				end
			end
		end

		if InterruptID == 2139 and not UnitIsDeadOrGhost("player") then
			local spec = GetSpecialization()
			local block_after_caut = SQUID.block_after_caut
			--auto block
			if SQUID.auto_block then
				if SQUID.auto_block > 0 then
					--snap
					-- if spec == 3 and _spellCooldown(45438) > 2 + GetGCD() then
					-- 	if _spellCooldown(235219) == 0 then
					-- 		SQ_CastSpellByID(235219)
					-- 		Squid_Alert("Cold Snap",nil,nil,nil,235219)
					-- 	end
					-- end
					if (_HP("player") <= SQUID.auto_block or block_after_caut and _debuffRemains("player",108843) >= 3.5 and _HP("player") < SQUID.auto_block + 15 - (spec == 3 and 15 or 0)) and _spellCooldown(45438) <= GetGCD()+.15 then
						if not block_after_caut or spec ~= 2 or UnitDebuffID("player",86949) or UnitDebuffID("player",87024) then
							--hypo
							if UnitDebuffID("player",41425) and not UnitBuffID("player",45438) then
								Squid_Alert("Can't Block","(Hypothermia)",nil,nil,41425)
							else
								if unit_casting_info("player") or UnitChannelInfo("player") then SpellStopCasting() end
								SQ_CastSpellByID(45438)
								Squid_Alert_Big("Auto Block","(You asked for it.)",1,3,45438)
								return
							end
						end
					end
				end
			end
			--cold snap
			if spec == 3 and _spellCooldown(45438) > 30 then
				-- if _spellCooldown()
			end
		end

		if InterruptID == 2139 and not UnitIsDeadOrGhost("player") and player_has_control() then -- counterspell mage utility

			-- local displacement_position = {}
			-- for i=1,#AreaTriggers do if ObjectID(AreaTriggers[i]) == 11513 then
			-- 	local x,y,z = ObjectPosition(AreaTriggers[i])
			-- 	displacement_position = {x,y,z}
			-- 	break
			-- end end
			-- local dx,dy,dz = unpack(displacement_position)
			-- if dx and dy and dz then
			-- 	local x,y,z = GroundZ(dx,dy,dz)
			-- 	print(dz-z)
			-- end

			local spec = GetSpecialization()

			local klepto_enabled = IsPlayerSpell(198100)

			local their_healer_cc = (not theirHealer or _CCcheck(theirHealer))

			local cs_cd = _spellCooldown(2139)
			local db_cd = _spellCooldown(31661)

			local msperframe = (2/GetFramerate())
			local buffer = latency + msperframe + .1

			local player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
			local player_cast_target = UnitSpellTarget("player")
			local player_cast_time_left = _castTimeLeft("player")
			local player_cast_percent_complete = _castPctDone("player")

			if player_cast_id == 118 then
				poly_cast_delay = time
				poly_cast_target = player_cast_target
			end

			local cc_casts = {118,28272,277792,161354,277787,161355,161353,120140,61305,61721,61780,28271,113724}
			local player_casting_cc = player_cast and tContains(cc_casts,player_cast_id)
			local player_casting_non_cc = not player_casting_cc

			local crit_casts = {2948,133}
			local player_casting_crittable_damage = player_cast and tContains(crit_casts,player_cast_id)

			local flamecannon_stacks = _buffStacks("player",203285)

			local flamecannon_value = (flamecannon_stacks * 3)

			local gpy_range = 40

			local sheep_range = 30

			local ring_range = 30

			gpy_range = gpy_range + flamecannon_value

			sheep_range = sheep_range + flamecannon_value

			ring_range = ring_range + flamecannon_value

			blink_los_draw = nil

			--auto jukes (egg) fake cast
			if SQUID.auto_juke then
				local player_interruptable = PlayerCanBeKicked()

				local function set_juke_delay()
					auto_juke_pct = math.random(SQUID.min_jukedelay,SQUID.max_jukedelay)
					--more instant jukes are good
					if auto_juke_pct < 12 then
						local seed = math.random(1,3)
						if seed <= 1 then
							auto_juke_pct = 0
						end
					end
					if auto_juke_pct <= 1 then auto_juke_pct = 0 end
				end

				local poly_cast_time = _castTime(118)

				if not auto_juke_pct then
					set_juke_delay()
				else
					if not juke_attempts then juke_attempts = 0 end
					if player_cast_id == 118 and player_interruptable then
						if juke_attempts < SQUID.max_juke_attempts and (not _CCcheck(player_cast_target) or _CCremains(player_cast_target) > poly_cast_time + latency + .4) and (not player_blink or time - player_blink > poly_cast_time - player_cast_time_left) then
							if player_cast_percent_complete >= auto_juke_pct or player_cast_time_left < buffer + .15 then
								SpellStopCasting()
								set_juke_delay()
								juke_attempts = juke_attempts + 1
								Squid_Alert("Attempting Fake Cast","("..GetSpellInfo(player_cast_id)..") [".. juke_attempts .."]",nil,nil,player_cast_id)
								SquidPaused = time - .225
								last_juke_attempt = time
							end
						end
					end
				end

				if last_juke_attempt and time - last_juke_attempt > 6 then
					juke_attempts = 0
				end
			end

			--don't give dk sheep or gpy (dark sim avoidance)
			if UnitDebuffID("player",77606) then

				local bad_steals = {
				118,	--poly
				203286,	--gpy
				}

				if spec == 2 then

					if player_cast and tContains(bad_steals,player_cast_id) and (player_cast_time_left < .75 or player_cast_id == 118 and player_cast_time_left < .95) then
						if GetSpellCharges(108853) > 0 then
							if UnitIsVisible(current_target) and unit_can_attack("player",current_target) and not _breakableCC(current_target) then
								if not fb_used or time - fb_used > .15 then
									if _Cast(108853,current_target,nil,true) then
										Squid_Alert("Fire Blast","(Dark Sim)",4,nil,77606)
										fb_used = time
									end
								end
							else
								for i=1,#Enemies do if not _breakableCC(Enemies[i]) then
									if not fb_used or time - fb_used > .15 then
										if _Cast(108853,Enemies[i],nil,true) then
											Squid_Alert("Fire Blast","(Dark Sim)",4,nil,77606)
											fb_used = time
										end
									end
								end end
							end
						else
							-- need good conditions where it's okay to let DK have seheep
							-- if player_cast_id ~= 118 then
								SpellStopCasting()
								Squid_Alert("Stopcasting","(Dark Sim)",nil,nil,77606)
							-- end
						end
					end

				else

					if player_cast and tContains(bad_steals,player_cast_id) and player_cast_time_left < .65 then
						SpellStopCasting()
						Squid_Alert("Stopcasting","(Dark Sim)",nil,nil,77606)
					end

				end

			end

			--blink into LoS for important casts (los blink)
			if player_cast and (player_cast_id == 118 or player_cast_id == 203286 or player_cast_id == 11366) and IsPlayerSpell(212653) and (GetSpellCharges(212653) > 0 or UnitBuffID("player",212799) and _spellCooldown(212801) == 0) then
				local t = player_cast_target
				if t and not _immuneMagic(t) and not UnitBuffID(t,8178) and (unit_is_player(t) or not arena) and (player_cast_id ~= 118 or not _isBeast(t)) then
					if player_cast_time_left < 1.15 then
						if not _LoS(t,nil,true) or _distance(t) > ( player_cast_id == 118 and sheep_range or gpy_range ) then
							blink_los_draw = t
						end
					end
					if player_cast_time_left <= latency + ((player_cast_id == 203286 or player_cast_id == 11366) and .325 or .3) and player_cast_time_left > latency + ((player_cast_id == 203286 or player_cast_id == 11366) and .165 or .025) then
						if player_cast_id == 118 then
							if blink_to_unit(t,sheep_range,true) then
								Squid_Alert_Big("Blink Sheep " .. UnitClass(t),"(LoS)",1,3.5,212653)
								return
							else
								-- Squid_Alert("No LoS Blink Possible",nil,nil,nil,212653)
							end
						end
						if player_cast_id == 203286 then
							if blink_to_unit(t,gpy_range,true) then
								Squid_Alert("Blink Gpy " .. UnitClass(t),"(LoS)",1,3.5,212653)
								return
							else
								-- Squid_Alert("No LoS Blink Possible",nil,nil,nil,212653)
							end
						end
						if player_cast_id == 11366 then
							if blink_to_unit(t,gpy_range,true) then
								Squid_Alert("Blink Pyro " .. UnitClass(t),"(LoS)",1,3.5,11366)
								return
							else
								-- Squid_Alert("No LoS Blink Possible",nil,nil,nil,212653)
							end
						end
					end
				end
			end

			--no stealth
			if not _stealthCheck("player") and not IsFlying() and player_has_control() then
				-- if not (cast_id == 203286 and cast_percent > 80) then
				-- if (not poly_cast_delay or time-poly_cast_delay > .1 or not unit_is_unit(poly_cast_target,unit)) then
					local supernova_enabled = IsPlayerSpell(157980)
					local supernova_cd = _spellCooldown(157980)

					--mage interrupts

					--pvp interrupts
					if arena or Current_Mage_Rotation == "PvP" and Mage_Rotation_Override ~= "PvE" then
						for i=1,#Enemies do
							local e = Enemies[i]
							local los = _LoS(e)

							--supernova interrupts
							if supernova_enabled and not _immuneMagic(e) and los and (not poly_cast_delay or time-poly_cast_delay > .1 or not unit_is_unit(poly_cast_target,e)) then
								if supernova_cd <= GetGCD() then
									local int = Interrupt(e,true,30,nil,nil,true)
									if int then
										local d = _distance(e)
										if (unit_casting_info("player") or UnitChannelInfo("player")) and GetGCD() == 0 then
											SpellStopCasting()
										end
										if _Cast(157980,e) then
											Squid_Alert("Interrupted " .. unit_casting_info(e),"(Supernova)",1,nil,157980)
											return
										end
									end
								end
							end

							if cs_cd == 0 then
								local interrupt = Interrupt(e)
								if interrupt then
									local cast,_,_,_,_,_,_,_,id = unit_casting_info(e)
									local d = _distance(e)
									local player_cast = player_cast_time_left - .15
									local enemy_cast = _castTimeLeft(e)
									-- if load_mode_active or (_isHealer(Enemies[i]) and lowestEnemy < 88) or lowestFriend < (ourHealer and _CCcheck(ourHealer) and 35 or 0) + 35 then
										--stopcasting to interrupt if: 1. cast would've interrupted you - 2. game winning healer interrupt
										if enemy_cast < player_cast and los and d < 39.5 then
											if player_cast_id == 203286 or player_casting_cc then

												local spell_target = UnitSpellTarget(e)
												local fcds = FrendlyCooldownsUp() + 1
												if (_isHealer(Enemies[i]) and lowestEnemy < 30 * fcds) or (cast and id and tContains(ccIDs,id) and unit_is_unit("player",spell_target)) then
													poly_cast_delay=nil
													SpellStopCasting()
												end
											elseif arena or current_target and unit_is_player(current_target) then
												poly_cast_delay=nil
												SpellStopCasting()
											end
										end
										if interrupt == "important" then
											if enemy_cast > .5 then
												if enemy_cast < player_cast and los and d < 39.5 and (not id or tContains(ccIDs,id)) then
													poly_cast_delay=nil
													SpellStopCasting()
												end
												if not los and blink_to_unit(e,gpy_range,true) then
													Squid_Alert("Blink","(CS)",nil,nil,212653)
												end
											end
										end
										if los and d < 39.5 and (not poly_cast_delay or time - poly_cast_delay > .1 or not unit_is_unit(poly_cast_target,e)) then
											if not poly_cast_delay or time-poly_cast_delay > .1 or not unit_is_unit(poly_cast_target,unit) then
												-- print("Interrupt at : " .. _castTimeLeft(e))
												SQ_CastSpellByName("Counterspell",e)
												SQ_CastSpellByID(2139,e)
											end
										end
									-- end
								else
									-- Dragon's breath interrupts?
									-- local d = _distance(e)

								end
							end
						end
					else
						--latency &amp; travel time delay
						local frame_buffer = 2 / GetFramerate() -- 2 frame buffer
						local background_delay = (not IsForeground() and frame_buffer or 0)
						local interruptNetDelay = squid_avg_latency + frame_buffer + background_delay + .105 + (SQUID.extra_net_delay or 0) -- latency + frame buffer + interrupt travel time + 90 ms safety net

						local in_instance = IsInInstance()

						--Mage PvE Interrupts
						for i=1,#Enemies do
							local e = Enemies[i]
							local int,id = PvE_Interrupt(e)
							if int and not id then id = UnitClass(e) end

							if _LoS(e) then

								if int == "int" then

									if cs_cd == 0 then
										SpellStopCasting()
										SQ_CastSpellByID(2139,e)
									end

								elseif int == "int_late_or_cc" then

									local cast_time_left = _castTimeLeft(e)

									if cs_cd <= max ( 0, cast_time_left - interruptNetDelay ) then
										if cast_time_left <= interruptNetDelay then
											SpellStopCasting()
											SQ_CastSpellByID(2139,e)
										end
									elseif db_cd == 0 and cs_cd < 23.8 and _distance(e) <= 8.5 then
										if player_cast_id and player_cast_time_left > cast_time_left - .5 then
											SpellStopCasting()
										end
										if not unit_casting_info("player") and not UnitChannelInfo("player") then
											local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
											if spell and spell ~= "nil" then
												Squid_Alert_Big("Dragon's Breath",spell,nil,nil,31661)
											end
											local f = ObjectFacing("player")
											FaceDirection(GetAnglesBetweenObjects("player",e),true)
											SQ_CastSpellByID(31661)
											FaceDirection(f,true)
										end
									end

								elseif int == "int_early_or_cc" then

									local cast_time_complete = _castTimeComplete(e)

									if cs_cd == 0 then
										if cast_time_complete >= minDelayTime then
											SpellStopCasting()
											SQ_CastSpellByID(2139,e)
										end
									elseif db_cd == 0 and cs_cd < 23.8 and _distance(e) <= 8.5 then
										SpellStopCasting()
										if not unit_casting_info("player") and not UnitChannelInfo("player") then
											local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
											if spell and spell ~= "nil" then
												Squid_Alert_Big("Dragon's Breath",spell,nil,nil,31661)
											end
											local f = ObjectFacing("player")
											FaceDirection(GetAnglesBetweenObjects("player",e),true)
											SQ_CastSpellByID(31661)
											FaceDirection(f,true)
										end
									end

								elseif int == "cc" then

									if db_cd == 0 and _distance(e) <= 8.5 then
										if player_cast_id and player_cast_time_left > _castTimeLeft(e) - .5 then
											SpellStopCasting()
										end
										if not unit_casting_info("player") and not UnitChannelInfo("player") then
											local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
											if spell and spell ~= "nil" then
												Squid_Alert_Big("Dragon's Breath",spell,nil,nil,31661)
											end
											local f = ObjectFacing("player")
											FaceDirection(GetAnglesBetweenObjects("player",e),true)
											SQ_CastSpellByID(31661)
											FaceDirection(f,true)
										end
									end

								end

							end

						end
					end
				-- end
				-- end

			end

			--more pve shit
			if not arena and instance_type ~= "pvp" and instance_type ~= "none" and instance_type ~= "raid" and Current_Mage_Rotation ~= "PvP" and Mage_Rotation_Override ~= "PvP" then
				local function pve_decurse(unit)
					return PvE_Dispel(unit,{"Curse"})
				end
				--pve decurse
				if not UnitBuffID("player",190319) and not UnitBuffID("player",298357) then
					for i=1,#Friends do
						local f = Friends[i]
						local d = pve_decurse(f)
						if d and _Cast(475,f) then
							Squid_Alert("Decurse",GetSpellInfo(d),4,nil,475)
						end
					end
				end
				--pve spellsteal
				if not UnitBuffID("player",190319) and not UnitBuffID("player",298357) then
					for i=1,#Enemies do if not UnitIsCharmed(Enemies[i]) then
						local e = Enemies[i]
						local ss = PvE_Spellsteal(e)
						if ss then
							if _Cast(30449,e) then
								Squid_Alert("Spellsteal",UnitClass(e),nil,nil,30449)
							end
						end
					end end
				end
			end

			--face dest at end of cast (gpy only)
			if not pause_auto_facing or time - pause_auto_facing > .25 then
				if player_cast and (player_cast_id == 203286 or player_cast_id == 11366) then
					if player_cast_time_left <= latency+.255 then
						local dest = player_cast_target
						--no forced facing if we're already facing
						if dest and _LoS(dest) then
							FaceDirection(GetAnglesBetweenObjects("player",dest),true)
						end
					end
				end
			end

			--stop casting if it's going to be bad
			if player_cast then

				--stop casting cc
				if player_casting_cc then
					--premonition
					if premonitionUsed then
						local time_since_prem = time - premonitionUsed
						local time_til_prem_proc = 1.5-time_since_prem
						if player_cast_time_left < time_til_prem_proc then
							if premonitionPointer and UnitIsVisible(premonitionPointer) and unit_is_unit(player_cast_target,premonitionPointer) then
								Squid_Alert_Big("Stopcasting","(Death)",4,3,32379)
								SpellStopCasting()
							end
						end
					end

					--blessing of sac
					local sac_up
					local sac_source

					--small sac
					for i=1,#Enemies do
						local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],6940)
						if buff then
							sac_up = true
							sac_source = source
						end
					end

					--big sac
					for i=1,#Enemies do
						local buff,_,_,_,_,_,source = UnitBuffID(Enemies[i],199448)
						if buff then
							sac_up = true
							sac_source = source
						end
					end

					--casting on the healer
					if sac_up and unit_is_unit(player_cast_target,sac_source) then
						Squid_Alert_Big("Stopcasting","(Sac)",4,3,6940)
						SpellStopCasting()
					end

					--meteor
					if UnitDebuffID(player_cast_target,155158) then
						if player_cast_time_left < latency+.5 then

							Squid_Alert("Stopcasting " .. GetSpellInfo(player_cast_id),"(Meteor Burn)",nil,nil,player_cast_id)

							SpellStopCasting()

						end
					end

					--other cc applied while we were already casting sheep (blind, hoj etc)
					if UnitIsVisible(player_cast_target) then

						if _CCremains(player_cast_target) > 4 and player_cast_time_left < latency+.15 and _debuffRemains(player_cast_target,118) < 5 then

							Squid_Alert("Stopcasting " .. GetSpellInfo(player_cast_id),"(Too Much Overlap)",nil,nil,player_cast_id)

							SpellStopCasting()

						end

					end

					--war banner
					if UnitBuffID(player_cast_target,236321) then
						if _castTimeLeft("player") < latency+.45 then

							Squid_Alert("Stopcasting " .. GetSpellInfo(player_cast_id),"(War Banner)",nil,nil,player_cast_id)

							SpellStopCasting()

						end
					end

				end

				--stop casting dmg
				if arena and player_casting_crittable_damage then
					if UnitIsVisible(player_cast_target) and bcc_remains(player_cast_target) > 1.5 and player_cast_time_left < latency + .2 then

						Squid_Alert("Stopcasting " .. GetSpellInfo(player_cast_id),"(Breakable CC)",nil,nil,player_cast_id)

						SpellStopCasting()

					end

				end

			end

			--stop casting into immunities / reflects
			if player_cast then
				local t = player_cast_target
				local immune = {
				212295, -- Nether ward
				23920,	-- Spell Reflection
				-- 329035,	-- Overwatch (intervene reflect)
				330279,	-- Overwatch (intervene reflect?)
				213915, -- Mass Spell Reflection
				31224,  -- Cloak of Shadows
				642,	-- Divine Shield
				186265, -- Aspect of the Turtle
				-- 48707,  -- Anti-Magic Shield
				33786,  -- Cyclone
				}
				for i=1,#immune do
					local r = immune[i]
					local name = GetSpellInfo(r)
					local remains = _buffRemains(t,r)
					if remains > 0 and remains > player_cast_time_left+(latency*2) and player_cast_time_left > 0 then
						local uptime = _buffUptime(t,r)
						-- print(uptime)
						if uptime > minDelayTime + .1 or player_cast_time_left < latency + msperframe + .25 then
							-- print(remains,player_cast_time_left,player_cast_time_left+.745+latency)
							if r == 23920 and GetSpellCharges(108853) > 0 then
								if _Cast(108853, t, nil, true) then
									Squid_Alert("Fire Blast","(Spell Reflect)",4,nil,108853)
								end
							else
								-- print(remains,player_cast_time_left,player_cast_time_left+.745+latency)
								SpellStopCasting()
								Squid_Alert("Stop Casting","("..name..")",4,nil,r)
							end
						end
					end
				end
			end

		end
		if InterruptID == 47528 or InterruptID == 91802 then -- mind freeze / shambling rush
			--Mind Freeze
			if _spellCooldown(47528) == 0 then
				for i=1,#Enemies do
					if Interrupt(Enemies[i]) then
						if not waiting_for_sim or time - waiting_for_sim >= .75 or not unit_is_unit(Enemies[i],waiting_for_sim_unit) then
							_Cast(47528,Enemies[i],nil,true);
						end
					end
				end
			else
				--Shambling Rush
				if UnitExists("pet") and UnitBuffID("pet",63560) then
					for i=1,#Enemies do
						if PhysicalInterrupt(Enemies[i],nil,75,.45) then
							if not waiting_for_sim or time - waiting_for_sim >= .75 or not unit_is_unit(Enemies[i],waiting_for_sim_unit) then
								SQ_CastSpellByID(47482,Enemies[i]);
							end
						end
					end
				end
			end
		end
		if InterruptID == 1766 then
			local kick_cd = _spellCooldown(1766)
			if not UnitBuffID("player",115191) and not UnitBuffID("player",1784) then
				for i=1,#Enemies do
					local kick = PhysicalInterrupt(Enemies[i])
					if kick then
						if kick_cd == 0 then
							local melee_range=_meleeRange(Enemies[i])
							if melee_range then
								wait_for_interrupt=true
								_Cast(1766,Enemies[i],nil,true);
							end
							--step kick important
							if kick == "important" and not melee_range and not doing_execute then
								if _Cast(36554,Enemies[i]) then
									Squid_Alert("Step " .. UnitClass(Enemies[i]),"(Important Kick)",nil,nil,36554)
								end
							end
						end
					end
				end
			end
			-- shiv wild charge
			if last_wc and time - last_wc < .4 then
				if UnitIsVisible(last_wc_pointer) and _Cast(5938,last_wc_pointer,nil,true) then
					Squid_Alert("Shiv","(Wild Charge)",5,nil,5938)
				end
			end
		end
		if InterruptID == 116705 then -- windwalker monk utilities
			local interrupt_cd = _spellCooldown(116705)
			for i=1,#Enemies do
				local e = Enemies[i]
				local dist = _distance(e)
				if dist > 4.8 or (lastGapClose and time - lastGapClose < 1.8) then
					if PhysicalInterrupt(e,nil,0,0) then
						local x,y,z = GetPortCoords()
						_Cast(116705,e,nil,true);
						if dist < 4 and _spellCooldown(116705) <= .2 then
							CancelSpellByName("Roll")
						end
						if dist > 6.6 and dist <= 13.25 and interrupt_cd == 0 and (_castTimeLeft(e) > dist * .0289) then
							if roll_to_unit(e) then return end
						end
						if x and y and z and interrupt_cd == 0 and not _meleeRange(e) then
							local ex,ey,ez = ObjectPosition(e)
							if GetDistanceBetweenPositions(ex,ey,ez,x,y,z) <= 5 and _castTimeLeft(e) > .285 + GetGCD() then
								if _Cast(119996) then
									Squid_Alert_Big("Port to " .. UnitClass(e),"(Interrupt)",4,4,119996)
									return
								end
							end
						end
					end
				else
					if PhysicalInterrupt(e) then
						if dist < 5 and interrupt_cd <= .2 then
							CancelSpellByName("Roll")
						end
						_Cast(116705,e,nil,true);
					end
				end

			end
		end
		if InterruptID == 183752 then

			player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
			player_cast_target = UnitSpellTarget("player")
			player_cast_time_left = _castTimeLeft("player")
			player_cast_percent_complete = _castPctDone("player")

			--face dest at end of cast (bolt only)
			if not pause_auto_facing or time - pause_auto_facing > .25 then
				if player_cast and player_cast_id == 116858 then
					if player_cast_time_left <= latency+.255 then
						local dest = player_cast_target
						--no forced facing if we're already facing
						if dest and _LoS(dest) then
							FaceDirection(GetAnglesBetweenObjects("player",dest),true)
						end
					end
				end
			end

			--Disrupt
			if not UnitChannelInfo("player") then
				for i=1,#Enemies do
					if Interrupt(Enemies[i]) then
						_Cast(183752,Enemies[i],nil,true);
					end
				end
			end
			--Purge
			for i=1,#Enemies do if UnitBuffID(Enemies[i],210294) then
				_Cast(278326,Enemies[i])
			end end
		end
		if InterruptID == 57994 then --shaman util
			--shear
			for i=1,#Enemies do
				if Interrupt(Enemies[i]) then
					_Cast(57994,Enemies[i],nil,true)
				end
				local ss = Basic_Spellsteal(Enemies[i])
				if ss then
					if _Cast(370,Enemies[i],nil,true) then
						Squid_Alert("Purge " .. UnitClass(Enemies[i]),"(" .. GetSpellInfo(ss) .. ")",1,nil,370)
					end
				end
			end
			--ground
			local reflect = should_ground()
			if reflect then
				if reflect ~= "wait" then
					_Cast(204336)
				end
			end
		end
		if InterruptID == 6552 then
			--reflect
			local reflect_ready = _spellCooldown(23920) == 0 or UnitBuffID("player",23920)
			wait_for_reflect=false
			if reflect_ready then
				-- no_combat_debug = true --disable or enable this to test while dueling
				local reflect = should_reflect()
				if reflect then
					if reflect == "wait" then
						wait_for_reflect = true
					else
						reflect=GetSpellInfo(reflect)
						if _Cast(23920) then
							Squid_Alert("Spell Reflection","("..reflect..")",2)
						end
						wait_for_reflect = false
					end
				end
			end
			local intervene_ready = _spellCooldown(3411) == 0 or UnitBuffID(ourHealer, 147833)
			wait_for_intervene = false
			if intervene_ready then
				local intervene = should_intervene()
				if intervene and _LoS('player', ourHealer) and _distance('player', ourHealer) <= 25 then
					if intervene == 'wait' then
						wait_for_intervene = true
					else
						intervene = GetSpellInfo(intervene)
						if _Cast(3411, ourHealer) then
							Squid_Alert("Intervene","("..intervene..")",2)
						end
						wait_for_intervene = false
					end
				end
			end
			if SQUID.bs_cancel == nil then
				SQUID.bs_cancel = true
			end
			--pummel
			if not wait_for_reflect then
				for i=1,#Enemies do
					if PhysicalInterrupt(Enemies[i]) and _meleeRange(Enemies[i]) and _spellCooldown(6552) == 0 then
						if SQUID.bs_cancel then
							RunMacroText("/cancelaura bladestorm")
						end
						_Cast(6552,Enemies[i],nil,true);
					end
				end
			end
		end
		--Nether Ward
		if select(2, UnitClass('player')) == 'WARLOCK' and IsPlayerSpell(212295) and IsUsableSpell(212295) then
			local ward_ready = _spellCooldown(212295) == 0 or UnitBuffID("player", 212295)
			wait_for_ward = false
			if ward_ready then
				-- no_combat_debug = true --disable or enable this to test while dueling
				local ward = should_ward()
				if ward then
					if ward == "wait" then
						wait_for_ward = true
					else
						ward = GetSpellInfo(ward)
						if _Cast(212295) then
							Squid_Alert("Nether Ward","("..ward..")",2)
						end
						wait_for_ward = false
					end
				end
			end
		end
		if IsUsableSpell("Spell Lock") then
			--spell lock
			for i=1,#Enemies do
				if Interrupt(Enemies[i]) then
					SQ_CastSpellByName("Spell Lock",Enemies[i])
				end
				local ss = Basic_Spellsteal(Enemies[i])
				if ss then
					SQ_CastSpellByID(19505,Enemies[i])
				end
			end
		end
		--pala pve
		if select(2,UnitClass("player")) == "PALADIN" then
			if not arena and instance_type ~= "pvp" then

				--hpal pve
				if _isHealer("player") then

					local function pve_cleanse(unit)
						return PvE_Dispel(unit,{"Poison","Disease","Magic"})
					end

					-- hpal pve dispels
					for i=1,#Friends do
						local f = Friends[i]
						local d = pve_cleanse(f)
						if d and _Cast(4987,f) then
							Squid_Alert("Cleanse",GetSpellInfo(d),4,nil,4987)
						end
					end

					local cs_cd = _spellCooldown(96231)
					local hoj_cd = _spellCooldown(853)

					--latency &amp; travel time delay
					local frame_buffer = 2 / GetFramerate() -- 2 frame buffer
					local background_delay = (not IsForeground() and frame_buffer or 0)
					local interruptNetDelay = squid_avg_latency + frame_buffer + background_delay + .1 -- latency + frame buffer + interrupt travel time + 90 ms safety net

					-- hpal pve interrupts
					for i=1,#Enemies do
						local e = Enemies[i]
						local int,id = PvE_Interrupt(e)
						if int and not id then id = UnitClass(e) end

						if _LoS(e) then

							if int == "int_late_or_cc" then

								local cast_time_left = _castTimeLeft(e)

								if hoj_cd == 0 and _distance(e) <= 10 then
									SpellStopCasting()
									if not unit_casting_info("player") and not UnitChannelInfo("player") then
										local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
										if spell and spell ~= "nil" then
											Squid_Alert_Big("HoJ",spell,nil,nil,853)
										end
										_Cast(853,e)
									end
								end

							elseif int == "int_early_or_cc" then

								local cast_time_complete = _castTimeComplete(e)

								if hoj_cd == 0 and _distance(e) <= 10 then
									SpellStopCasting()
									if not unit_casting_info("player") and not UnitChannelInfo("player") then
										local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
										if spell and spell ~= "nil" then
											Squid_Alert_Big("HoJ",spell,nil,nil,853)
										end
										_Cast(853,e)
									end
								end

							elseif int == "cc" then

								if hoj_cd == 0 and _distance(e) <= 10 then
									SpellStopCasting()
									if not unit_casting_info("player") and not UnitChannelInfo("player") then
										local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
										if spell and spell ~= "nil" then
											Squid_Alert_Big("HoJ",spell,nil,nil,853)
										end
										_Cast(853,e)
									end
								end

							end

						end
					end

				-- ret pve
				else
					local cs_cd = _spellCooldown(96231)
					local hoj_cd = _spellCooldown(853)

					--latency &amp; travel time delay
					local frame_buffer = 2 / GetFramerate() -- 2 frame buffer
					local background_delay = (not IsForeground() and frame_buffer or 0)
					local interruptNetDelay = squid_avg_latency + frame_buffer + background_delay + .1 -- latency + frame buffer + interrupt travel time + 90 ms safety net

					local function pve_cleanse(unit)
						return PvE_Dispel(unit,{"Poison"})
					end

					-- ret pve dispels
					for i=1,#Friends do
						local f = Friends[i]
						local d = pve_cleanse(f)
						if d and _Cast(213644,f) then
							Squid_Alert("Cleanse",GetSpellInfo(d),4,nil,213644)
						end
					end

					--ret pve interrupts
					for i=1,#Enemies do
						local e = Enemies[i]
						local int,id = PvE_Interrupt(e)
						if int and not id then id = UnitClass(e) end

						if _LoS(e) then

							if int == "int" then

								if cs_cd == 0 then
									SpellStopCasting()
									SQ_CastSpellByID(96231,e)
								end

							elseif int == "int_late_or_cc" then

								local cast_time_left = _castTimeLeft(e)

								if cs_cd <= max ( 0, cast_time_left - interruptNetDelay ) then
									if cast_time_left <= interruptNetDelay then
										SpellStopCasting()
										SQ_CastSpellByID(96231,e)
									end
								elseif hoj_cd == 0 and cs_cd < 14.8 and _distance(e) <= 10 then
									SpellStopCasting()
									if not unit_casting_info("player") and not UnitChannelInfo("player") then
										local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
										if spell and spell ~= "nil" then
											Squid_Alert_Big("HoJ",spell,nil,nil,853)
										end
										_Cast(853,e)
									end
								end

							elseif int == "int_early_or_cc" then

								local cast_time_complete = _castTimeComplete(e)

								if cs_cd == 0 then
									if cast_time_complete >= minDelayTime then
										SpellStopCasting()
										SQ_CastSpellByID(96231,e)
									end
								elseif hoj_cd == 0 and cs_cd < 14.8 and _distance(e) <= 10 then
									SpellStopCasting()
									if not unit_casting_info("player") and not UnitChannelInfo("player") then
										local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
										if spell and spell ~= "nil" then
											Squid_Alert_Big("HoJ",spell,nil,nil,853)
										end
										_Cast(853,e)
									end
								end

							elseif int == "cc" then

								if hoj_cd == 0 and _distance(e) <= 10 then
									SpellStopCasting()
									if not unit_casting_info("player") and not UnitChannelInfo("player") then
										local spell = ( type(id) == "number" and GetSpellInfo(id) or id )
										if spell and spell ~= "nil" then
											Squid_Alert_Big("HoJ",spell,nil,nil,853)
										end
										_Cast(853,e)
									end
								end

							end

						end
					end
				end
			end
		end

		--use healthstone
		if not SQUID.dont_healthstone and GetItemCount(5512) > 0 then
			if _HP("player") <= 22 and select(2,GetItemCooldown(5512)) == 0 then
				UseItemByName(tostring(GetItemInfo(5512)));
				Squid_Alert("Healthstone",nil,nil,nil,5512)
			end
		end

		local map_id = GetMapId()

		local horrific_vision
		if map_id == 2212 then
			horrific_vision = "Orgrimmar"
		elseif map_id == 2213 then
			horrific_vision = "Stormwind"
		end

		--use health pot
		if (GetNumGroupMembers() >= 5 or horrific_vision) and instance_type ~= "none" then
			if GetItemCount(169451) > 0 then
				if _HP("player") <= 35 and select(2,GetItemCooldown(169451)) == 0 then
					UseItemByName(tostring(GetItemInfo(169451)))
					Squid_Alert("Abyssal Healing Potion",nil,nil,nil,301308)
				end
			end
		end

		if SquidPaused and time-SquidPaused < .3 then return end

		--Define ourHealer
		ourHealer=nil
		for i=1,#Friends do
			if _isHealer(Friends[i]) then
				ourHealer = Friends[i]
			end
		end

		rogueExists=nil
		for i=1,3 do if UnitExists("arena"..i) and select(2,UnitClass("arena"..i)) == "ROGUE" then rogueExists="arena"..i end end

		--Rotate
		if not SquidFrame then SquidFrame = 0 end
		if SquidFrame >= 2 and not UnitIsDeadOrGhost("player") then

			local class = select(2,UnitClass("player"))
			local spec = GetSpecialization()

			--Death Knight
			if class == "DEATHKNIGHT" then
				Squid_DeathKnight()
			end
			--Druid
			if class == "DRUID" then
				Squid_Druid()
			end
			--Paladin
			if class == "PALADIN" then
				Squid_Paladin()
			end
			--Rogue
			if class == "ROGUE" then
				local function is_charmed(unit)
					local charmbuffs = {
						269131,	-- SOTS 3rd boss MC
					}
					return _buffFromTable(unit,charmbuffs)
				end
				--player detected, combat happening
				local enemy_player_exists = arena
				if not enemy_player_exists and instance_type ~= "party" then
					for i=1,#Enemies do if unit_is_player(Enemies[i]) and not UnitIsCharmed(Enemies[i]) and not is_charmed(Enemies[i]) then
						if unit_is_unit(UnitTarget(Enemies[i]),"player") or unit_is_unit(Enemies[i],current_target) then
							enemy_player_exists = true
							break
						end
					end end
				end
				--alert user when rotation mode changes
				if Current_Rogue_Rotation then
					if not Last_Rogue_Rotation then
						Last_Rogue_Rotation = Current_Rogue_Rotation
						Squid_Alert_Big(Current_Rogue_Rotation .. " Rotation Loaded")
					else
						if Last_Rogue_Rotation ~= Current_Rogue_Rotation then
							Squid_Alert_Big(Current_Rogue_Rotation .. " Rotation Loaded")
							Last_Rogue_Rotation = Current_Rogue_Rotation
						end
					end
				end
				--Assa
				if spec == 1 then
					--run rotation
					if not Rogue_Rotation_Override then
						if enemy_player_exists then
							Current_Rogue_Rotation = "Assassination PvP"
							Squid_Rogue()
						else
							Current_Rogue_Rotation = "Assassination PvE"
							Squid_Rogue()
						end
					else
						if Rogue_Rotation_Override == "Assassination PvP" then
							Squid_Rogue()
						else
							Squid_Rogue()
						end
					end
				end
				--Outlaw
				if spec == 2 then
					--run rotation
					if not Rogue_Rotation_Override then
						if enemy_player_exists then
							Current_Rogue_Rotation = "Outlaw PvP"
							Squid_Rogue()
						else
							Current_Rogue_Rotation = "Outlaw PvE"
							Squid_Rogue()
						end
					else
						if Rogue_Rotation_Override == "Outlaw PvP" then
							Squid_Rogue()
						else
							Squid_Rogue()
						end
					end
				end
				--Sub
				if spec == 3 then
					--run rotation
					if not Rogue_Rotation_Override then
						if enemy_player_exists then
							Current_Rogue_Rotation = "Sub PvP"
							if not SQUID.i_am_xen then
								Squid_SubPvE()
							else
								Current_Rogue_Rotation = "Sub PvP"
								Squid_SubPvP()
							end
							-- Squid_SubPvE()
						else
							Current_Rogue_Rotation = "Sub PvE"
							if not SQUID.i_am_xen then
								Squid_SubPvE()
							else
								Current_Rogue_Rotation = "Sub PvP"
								Squid_SubPvP()
							end
						end
					else
						if Rogue_Rotation_Override == "PvP" then
							Squid_SubPvE()
						else
							Squid_SubPvE()
						end
					end
				end
			end
			--Demon Hunter
			if class == "DEMONHUNTER" then
				Squid_DemonHunter()
			end
			--Warrior
			if class == "WARRIOR" then
				Squid_Warrior()
			end
			--Hunter
			if class == "HUNTER" then
				Squid_Hunter()
			end
			--Shaman
			if class == "SHAMAN" then
				Squid_Shaman()
			end
			--Monk
			if class == "MONK" then
				Squid_Monk()
			end
			--Mage
			if class == "MAGE" then

				--Arcane Mage
				if spec == 1 then
					Squid_ArcaneMagePvP()
				end

				--Fire Mage
				if spec == 2 then

					local function is_charmed(unit)
						local charmbuffs = {
							269131,	-- SOTS 3rd boss MC
						}
						return _buffFromTable(unit,charmbuffs)
					end

					--player detected
					local enemy_player_exists = arena
					if not enemy_player_exists and instance_type ~= "party" then
						for i=1,#Enemies do if unit_is_player(Enemies[i]) and not UnitIsCharmed(Enemies[i]) and not is_charmed(Enemies[i]) then
							if unit_is_unit(UnitTarget(Enemies[i]),"player") or unit_is_unit(Enemies[i],current_target) then
								enemy_player_exists = true
								break
							end
						end end
					end

					--alert user when rotation mode changes
					if Current_Mage_Rotation then
						if not Last_Mage_Rotation then
							Last_Mage_Rotation = Current_Mage_Rotation
							Squid_Alert_Big(Current_Mage_Rotation .. " Rotation Loaded")
						else
							if Last_Mage_Rotation ~= Current_Mage_Rotation then
								Squid_Alert_Big(Current_Mage_Rotation .. " Rotation Loaded")
								Last_Mage_Rotation = Current_Mage_Rotation
							end
						end
					end

					--run rotation
					if not Mage_Rotation_Override then
						if enemy_player_exists or spec ~= 2 then
							Current_Mage_Rotation = "PvP"
							Squid_FireMagePvP()
						else
							Current_Mage_Rotation = "PvE"
							Squid_FireMagePvE()
						end
					else
						if Mage_Rotation_Override == "PvP" then
							Squid_FireMagePvP()
						else
							Squid_FireMagePvE()
						end
					end

				end

				--Frost Mage
				if spec == 3 then
					Squid_FrostMagePvP()
				end

			end
			--Priest
			if class == "PRIEST" then
				Squid_Priest()
			end
			--Warlock
			if class == "WARLOCK" then

			--Affliction Warlock
				if spec == 1 then
					--player detected
					local enemy_player_exists = arena
					if not enemy_player_exists and instance_type ~= "party" then
						for i=1,#Enemies do if unit_is_player(Enemies[i]) and not UnitIsCharmed(Enemies[i]) and not is_charmed(Enemies[i]) then
							if unit_is_unit(UnitTarget(Enemies[i]),"player") or unit_is_unit(Enemies[i],current_target) then
								enemy_player_exists = true
								break
							end
						end end
					end

					--alert user when rotation mode changes
					if Current_Warlock_Rotation then
						if not Last_Warlock_Rotation then
							Last_Warlock_Rotation = Current_Warlock_Rotation
							Squid_Alert_Big(Current_Warlock_Rotation .. " Rotation Loaded")
						else
							if Last_Warlock_Rotation ~= Current_Warlock_Rotation then
								Squid_Alert_Big(Current_Warlock_Rotation .. " Rotation Loaded")
								Last_Warlock_Rotation = Current_Warlock_Rotation
							end
						end
					end

					--run rotation
					if not Warlock_Rotation_Override then
						if enemy_player_exists or spec ~= 2 then
							Current_Warlock_Rotation = "PvP"
							Squid_AfflictionWarlockPvP()
						else
							Squid_Warlock()
						end
					else
						if Warlock_Rotation_Override == "PvP" then
							Squid_AfflictionWarlockPvP()
						else
							Squid_Warlock()
						end
					end

				end
			end

			if IsEquippedItem(169311) and not _stealthCheck("player") and not UnitChannelInfo("player") and not unit_casting_info("player") and player_has_control() then
				if UnitIsVisible(current_target) and unit_can_attack("player",current_target) then
					local stacks = _debuffStacks(current_target,303568,"player")
					if GetItemCD(169311) <= 1 then
						if stacks == 0 then
							UseItemByName(tostring(GetItemInfo(169311)),current_target)
						elseif (_CDcheck("player") and stacks >= 10) or _HP(current_target) < 35 then
							UseItemByName(tostring(GetItemInfo(169311)),current_target)
						end
					end
				end
			end

			SquidFrame=0;

		else
			SquidFrame=SquidFrame+1;
		end

	end)

	--Squid Trinket
	function SquidTrinket()

		local ccr = _CCremains("player")
		local sr = _stunRemains("player")

		if sr >= max(1,ccr) and not _silenceCheck("player") then
			SQ_CastSpellByName("Will to Survive")
			Squid_Alert("Human Trinket","Manual")
		end

		if ccr >= .5 then
			UseItemByName(tostring(GetItemInfo(184052))) -- Sinful Aspirant's Medallion
			UseItemByName(tostring(GetItemInfo(181333))) -- Sinful Gladiator's Medallion

			Squid_Alert("Trinket","Manual")
		end
	end

	function Squid_Rogue()

		if IsMounted() then return end
		local locale = GetLocale()
		local L = {}
		if locale == "zhCN" then
			L["Stealth"] = "æ½œè¡Œ"
		else
			L["Stealth"] = "Stealth"
		end

		local spec = GetSpecialization()

		--Assassination
		if spec == 1 then

			local time = GetTime()
			local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
			local gcd_remains = GetGCD()
			local Energy = UnitPower("player")
			local EnergyDeficit = UnitPowerMax("player")-Energy
			local ComboPoints = UnitPower("player",4)
			local ComboPointsMax = UnitPowerMax("player",4)
			local ComboPointsDeficit = ComboPointsMax-ComboPoints
			local Stealth = UnitBuffID("player",115191) or UnitBuffID("player",1784)
			local IsSubterfuge = IsPlayerSpell(108208)
			local Subterfuge = UnitBuffID("player",115192)
			local SubterfugeRemains = _buffRemains("player",115192)
			local Vanish = UnitBuffID("player",11327)
			local Evasion = UnitBuffID("player",5277)
			local Cloak = UnitBuffID("player",31224)
			local Sprint = UnitBuffID("player",2983)
			local vendetta_cd = _spellCooldown(79140)
			local bcc = _bccAM(16)
			local fan_of_knives = EnemiesAroundMe(10)
			local marked_for_death = IsPlayerSpell(137619)
			local marked_for_death_cd = _spellCooldown(137619)
			local vanish_cd = _spellCooldown(1856)
			local blind_cd = _spellCooldown(2094)

			local S = Stealth or Subterfuge

			local function _valid(unit,immune)
				return unit
				and UnitCanAttack("player",unit)
				and not UnitIsDeadOrGhost(unit)
				and not _breakableCC(unit)
				and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
				and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))));
			end

			local t = current_target

			local valid_physical_target = _valid(t,1)
			local valid_magical_target = _valid(t,2)
			local valid_target = _valid(t,3)

			local target_kidney = valid_physical_target and _debuffRemains(t,408) > .3

			local moving_towards_time = moving_towards_unit_duration(t,.11)
			local moving_towards = _movingTowards(t,.11)
			local moving_towards_target = valid_physical_target and moving_towards and moving_towards_time > .135

			local target_hp = _HP(t)

			local enemy_player_around
			for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then
				enemy_player_around=true
				break;
			end end

			local poisoned_bleeds = 0
			local rupture_count = 0
			local garrote_count = 0
			for i=1,#Enemies do
				--poisoned
				if UnitDebuffID(Enemies[i],3409,"player") or UnitDebuffID(Enemies[i],2818,"player") or UnitDebuffID(Enemies[i],8680,"player") then
					--count each bleed
					--garrote
					if UnitDebuffID(Enemies[i],703,"player") then
						poisoned_bleeds=poisoned_bleeds+1
						garrote_count=garrote_count+1
					end
					--rupture
					if UnitDebuffID(Enemies[i],1943,"player") then
						poisoned_bleeds=poisoned_bleeds+1
						rupture_count=rupture_count+1
					end
					--internal bleeding
					if UnitDebuffID(Enemies[i],154953,"player") then
						poisoned_bleeds=poisoned_bleeds+1
					end
				end
			end

			local energy_regen_combined = GetPowerRegen()+poisoned_bleeds*7/(2*UnitSpellHaste("player"))

			local energy_time_to_max = EnergyDeficit / energy_regen_combined

			function Sappable(unit)
				return not _hasDot(unit) and not UnitAffectingCombat(unit) and _incapacitateDR(unit) >= .25
			end

			function CCAvailable(unit)
				local canblind
				local blind = blind_cd <= gcd
				local vanish = vanish_cd <= gcd
				local sap = S

				local cc = 0

				if blind and _disorientDR(unit) == 1 then
					canblind=true
					cc = cc + 8
				end

				if vanish then
					local stundr = _stunDR(unit)
					local silencedr = _silenceDR(unit)
					if stundr >= .5 then
						cc = cc + (stundr*4)
					end
					if silencedr >= .5 then
						cc = cc + (silencedr*3)
					end
				end

				if Sappable(unit) or (vanish and (canblind or UnitDebuffID(unit,2094))) then
					local dr = _incapacitateDR(unit)
					cc = cc + (dr*8)
				end

				return cc
			end

			-- function LockDown(unit)

			-- end

			--Stomp
			local function Stomp(totem,name)
				if S then return false; end
				local hp = UnitHealth(totem)
				local maxhp = UnitHealthMax(totem)
				if hp <= 1 then return false; end
				--Poisoned knife
				if hp <= 2000 then
					if _Cast(185565,totem,nil,true) then
						Squid_Alert_Big(name .. " Stomped","(Throw)",1,3.5,185565)
					end
				else
				--mutilate
					if _Cast(1752,totem,nil,true) then
						Squid_Alert_Big(name .. " Stomped","(Mutilate)",1,3.5,1752)
					end
				end
			end

			local totems = {
			101398,	--Psyfiend
			119052,	--War Banner
			104818,	--Ancestral Protection Totem
			53006,	--Spirit Link Totem
			2630,	--Earthbind Totem
			60561,	--Earthgrab Totem
			-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
			5925,	--Grounding Totem
			105425,	--Skyfury Totem
			5913,	--Tremor Totem
			105451,	--Counterstrike Totem
			}

			if arena then
				for i=1,#Pets do
					local e = Pets[i]
					local name = UnitName(e);
					local id = UnitCreatureID(e)
					--only kill cap totems when they're casting
					if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
						Stomp(e,name)
					end
				end
			end

			local mainTarget = {};
			for i=1,#Enemies do
				local e=Enemies[i];
				if (arena or _isDummy(e) or UnitAffectingCombat(e))
				and not _breakableCC(e) then
					local priority=100;
					if unit_is_unit(e,"target") then
						priority=priority-1;
					end
					local d = _distance(e)
					--lowest dot duration
					local garrote = _debuffRemains(e,703,"player")
					local rupture = _debuffRemains(e,1943,"player")
					local dottime = garrote + rupture
					local gp = _garrotePower(e)
					priority = priority + dottime
					table.insert(mainTarget,{pointer=e,priority=priority,gp=gp,garrote=garrote,rupture=rupture,distance=d,hp=_HP(e)});
				end
			end
			table.sort(mainTarget, function(x,y) return x.priority < y.priority or (x.priority == y.priority and x.hp < y.hp) end)

			--Poisons
			local dp = _buffRemains("player",2823)
			local wp = _buffRemains("player",8679)
			local cp = _buffRemains("player",3408)

			local playercast = UnitCastingInfo("player")

			if playercast and strmatch(playercast,"poison") then
				poisonapplied=time
			end

			--generally doing pvp if internal bleeding
			if arena or IsPlayerSpell(154904) then
				if wp <= 3000 and dp <= 3000 then
					if not poisonapplied or time-poisonapplied > .3 then
						_Cast(8679)
						poisonapplied=time
					end
				end
			else
				if wp <= 3000 and dp <= 3000 then
					if not poisonapplied or time-poisonapplied > .3 then
						_Cast(2823)
						poisonapplied=time
					end
				end
			end

			if cp <= 120 then
				if not poisonapplied or time-poisonapplied > .3 then
					_Cast(3408)
					poisonapplied=time
				end
			end

			--CC Trinket
			local trinketPointer
			local recentTrinket
			for i=1,#TrinketTracker do
				local pointer = TrinketTracker[i].pointer
				local trinketTime = TrinketTracker[i].time
				if UnitIsVisible(pointer) and _isHealer(pointer) then
					recentTrinket = time-trinketTime <= gcd*2
					timeSinceTrinket = time-trinketTime
					trinketPointer = pointer
				end
			end

			if recentTrinket then
				if trinketPointer and not unit_is_unit(trinketPointer,"target") and _LoS(trinketPointer) and not DoNotBCC(trinketPointer) and gcd_remains <= .25 then
					--Blind
					if _spellCooldown(2094) <= gcd and _disorientDR(trinketPointer) == 1 then
						if _realDistance(trinketPointer) <= 15 then
							if _Cast(2094,trinketPointer,nil,true) then
								if locale == "zhCN" then
									Squid_Alert_Big("è‡´ç›²>>", UnitClass(trinketPointer).. " (äº¤ç« )",2,3.5,2094)
								else
									Squid_Alert_Big("Blinded " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,2094)
								end
							end
							return
						else
							_Cast(36554,trinketPointer)
							C_Timer.After(.03,function()
								if _Cast(2094,trinketPointer,nil,true) then
									if locale == "zhCN" then
										Squid_Alert_Big("è‡´ç›²>>", UnitClass(trinketPointer).. " (äº¤ç« )",2,3.5,2094)
									else
										Squid_Alert_Big("Blinded " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,2094)
									end
								end
							end)
						end
					end
					--Sap
					if (timeSinceTrinket <= gcd or S or Vanish) and Energy >= 35 and not UnitAffectingCombat(trinketPointer) and _incapacitateDR(trinketPointer) >= lowestEnemy / 100 and not _CCcheck(trinketPointer) then
						if vanish_cd == 0 or S or Vanish then
							if _realDistance(trinketPointer) <= 10 then
								if not S and _Cast(1856) then
									Squid_Alert("Vanish",nil,nil,nil,1856)
								end
								if S or Vanish then
									CastSpellByID(6770,trinketPointer)
									if _Cast(6770,trinketPointer,nil,true) then
										Squid_Alert_Big("Sapped " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,6770)
									end
								end
								return
							else
								_Cast(36554,trinketPointer)
								C_Timer.After(.03,function()
									if _Cast(6770,trinketPointer,nil,true) then
										Squid_Alert_Big("Sapped " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,6770)
									end
								end)
							end
						end
					end
				end
			end

			-- if current_focus then
			-- 	if _distance(current_focus) <= 10 then
			-- 		_Cast(6770,current_focus,nil,true)
			-- 	else
			-- 		_Cast(36554,current_focus)
			-- 		C_Timer.After(.05,function() _Cast(6770,current_focus,nil,true) end)
			-- 	end
			-- end

			--sap followup
			if vanish_cd == 0 or S or Vanish then
				for i=1,#Enemies do if _isHealer(Enemies[i]) or not theirHealer then
					local cc = _CCremains(Enemies[i])
					if cc > 0 and not UnitAffectingCombat(Enemies[i]) and not _isDummy(Enemies[i]) then
						local dr = _incapacitateDR(Enemies[i])
						if cc < 1.1 and gcd_remains < cc and dr >= .25 then
							if _distance(Enemies[i]) <= 10 then
								if dr == 1 and not S
								and (not mage_on_team_casting_cc or (mage_cc_tar and not unit_is_unit(mage_cc_tar,Enemies[i]))) then
									if _Cast(1856) then
										Squid_Alert("Vanish",nil,nil,3.5,1856)
									end
								end
								if S or Vanish then
									if _Cast(6770,Enemies[i],nil,true) then
										Squid_Alert_Big("Sapped " .. UnitClass(Enemies[i]),"(Followup)",nil,nil,6770)
									end
								end
								return
							else
								if dr == 1 then
									_Cast(36554,Enemies[i])
								end
							end
						end
					end
				end end
			end

			--Sap Stealth
			for i=1,#Enemies do
				if _stealthCheck(Enemies[i]) and Sappable(Enemies[i]) then
					if _Cast(6770,Enemies[i],nil,true) then
						Squid_Alert_Big("Sap " .. UnitClass(Enemies[i]),"(Stealth)",4,nil,6770)
					end
				end
			end

			local ourHealerCC
			if ourHealer and _CCcheck(ourHealer) then
				ourHealerCC=true
			end

			local total,melee,ranged,cds = EnemiesAttacking("player")
			local defensive_hp = 60
			defensive_hp=defensive_hp+(ourHealerCC and 35 or 0)
			local currenthp = _HP("player")

			--defensives
			local function defensives()
				if (not target_kidney or (currenthp < 25 and target_hp > 30)) and IsPlayerSpell(79008) and _spellCooldown(1966) <= gcd_remains and not _immuneCheck("player") and (currenthp < 30 or EnemiesAttacking("player") > 0) then
					if _Cast(1966) then
						Squid_Alert("Feint","Danger",2)
					end
				end
				defensive_hp=defensive_hp+10
				if currenthp < 80 and currenthp < defensive_hp then
					if _Cast(185311) then
						Squid_Alert("Crimson Vial",nil,nil,nil,185311)
					end
				end
				if AutoFollow and currenthp < 40 then
					_Cast(31224)
					_Cast(5277)
				end
			end

			if currenthp <= defensive_hp and not Stealth and not Vanish then
				if not Evasion and not Cloak then
					defensives()
				else
					local total,melee,ranged,cds = EnemiesAttacking("player")
					if (not Evasion or ranged > 0) and (not Cloak or melee > 0) then
						defensives()
					end
				end
			end

			--Stealth with enemy player around
			if enemy_player_around and IsUsableSpell("Stealth") then
				if not Stealth and (not UnitAffectingCombat("player") or Vanish) and _spellCooldown(1784) == 0 then
					if _spellCooldown(1784) == 0 and _Cast(1784) then
						Squid_Alert("Stealth",nil,nil,nil,1784)
					end
					return
				end
			end

			if valid_target then

				--Stealth
				if not Stealth and IsUsableSpell(L["Stealth"]) and (not UnitAffectingCombat("player") or Vanish) and _spellCooldown(1784) == 0 then
					_Cast(1784)
					return
				end

				local target_is_dummy = _isDummy(t)

				local snapshot = GetCurrentSnapshot()
				local garrote_ticking = UnitDebuffID(t,703,"player")
				local rupture_remains = _debuffRemains(t,1943,"player")
				local rupture_ticking = rupture_remains > 0
				local garrote_remains = _debuffRemains(t,703,"player")
				local vendetta_up = UnitDebuffID(t,79140,"player")
				local toxic_blade_up = UnitDebuffID(t,245389,"player")
				local garrote_power = _garrotePower(t)

				local kidney_cd = _spellCooldown(408)

				local vanish_up = _spellCooldown(1856) == 0

				local shrouded_suffocation = AzeritePowerTaken(408)
				local scent_of_blood = AzeritePowerTaken(406)
				local double_dose = AzeritePowerTaken(136)
				local function poison_ticking(unit) return UnitDebuffID(unit,2818,"player") or UnitDebuffID(unit,8680,"player") end

				-- # Executed every time the actor is available.
				-- # Restealth if possible (no vulnerable enemies in combat)
				-- actions=stealth
				-- actions+=/variable,name=energy_regen_combined,value=energy.regen+poisoned_bleeds*7%(2*spell_haste)
				-- actions+=/variable,name=single_target,value=spell_targets.fan_of_knives<2
				local single_target = (arena and not spread) or fan_of_knives < 2 or bcc or target_is_dummy-- or _isDummy(t)
				-- actions+=/use_item,name=azsharas_font_of_power,if=!stealthed.all&amp;master_assassin_remains=0&amp;cooldown.vendetta.remains<10&amp;!debuff.vendetta.up&amp;!debuff.toxic_blade.up
				local Nightstalker = IsPlayerSpell(14062)
				local MasterAssassin = IsPlayerSpell(255989)
				local IsSubterfuge = IsPlayerSpell(108208)
				local Exsanguinate = IsPlayerSpell(200806)
				local deeper_stratagem = IsPlayerSpell(193531)
				local venom_rush = IsPlayerSpell(152152)
				local master_assassin_enabled = IsPlayerSpell(255989)

				local mage_on_team
				local mage_on_team_casting_cc
				local mage_cc_tar
				if arena then
					for i=1,#Friends do if UnitClass(Friends[i]) == "Mage" then mage_on_team=Friends[i] end end
				end

				if mage_on_team then
					local cast = UnitCastingInfo(mage_on_team)
					if cast == "Polymorph" or cast == "Ring of Frost" then
						mage_on_team_casting_cc=true
						mage_cc_tar=UnitSpellTarget(mage_on_team)
					end
				end

				local stundr = _stunDR(t)
				local drremains = _drRemains(t,"stun")

				time_to_max_cp=nil
				if not time_to_max_cp then
					local rounded_max_cp = ComboPointsDeficit
					if rounded_max_cp % 2 ~= 0 then rounded_max_cp = rounded_max_cp + 1 end
					local gcds_req = (rounded_max_cp/2)
					local energy_gained_over_time = (energy_regen_combined*gcd)*gcds_req
					local energy_req = (gcds_req*50)-energy_gained_over_time
					local time_for_energy = (energy_req/energy_regen_combined)-(Energy / energy_regen_combined)
					time_to_max_cp = gcds_req * gcd + time_for_energy
				end
				if time_to_max_cp < 0 then time_to_max_cp=0 end

				total_time_to_max_cp=nil
				if not total_time_to_max_cp then
					local rounded_max_cp = 6
					local gcds_req = (rounded_max_cp/2)
					local energy_gained_over_time = (energy_regen_combined*gcd)*gcds_req
					local energy_req = (gcds_req*50)-energy_gained_over_time
					local time_for_energy = (energy_req/energy_regen_combined)-(Energy / energy_regen_combined)
					total_time_to_max_cp = gcds_req * gcd + time_for_energy
				end
				if total_time_to_max_cp < 0 then total_time_to_max_cp=0 end

				time_to_next_max_cp=nil
				if not time_to_next_max_cp then
					local rounded_max_cp = ComboPointsDeficit + ComboPointsMax
					if rounded_max_cp % 2 ~= 0 then rounded_max_cp = rounded_max_cp + 1 end
					local gcds_req = (rounded_max_cp/2)
					local energy_gained_over_time = (energy_regen_combined*gcd)*gcds_req
					local energy_req = (gcds_req*50)-energy_gained_over_time
					local time_for_energy = (energy_req/energy_regen_combined)-(Energy / energy_regen_combined)
					time_to_next_max_cp = gcds_req * gcd + time_for_energy
				end
				if time_to_next_max_cp < 0 then time_to_next_max_cp=0 end

				local waiting_for_kidney
				local hold_cp_for_kidney
				local hold_energy_for_kidney
				local hold_gcd_for_kidney
				local kidney_ready
				kidney_countdown = 0

				--pool energy and dont build cp if mfd off cd soon and at 0 cp
				if ComboPoints == 0 and marked_for_death and marked_for_death_cd <= gcd*2 and marked_for_death_cd <= energy_time_to_max then
					hold_energy_for_kidney=true
				end

				local function kidney(t)

					if UnitIsPlayer(t) or target_is_dummy then
						local isret = UnitClass(t) == "Paladin" and _isMeleeDps(t)
						if isret and theirHealer and _CCremains(theirHealer) < 2 then
							return false
						end
					else
						return false
					end

					local sr = _stunRemains(t)
					--go kidney
					if (stundr == 1 or (sr > 0 and sr <= gcd and stundr >= .5)) and not _immuneStuns(t) and valid_physical_target then
						if kidney_cd <= gcd and (_meleeRange(t) or _spellCooldown(36554) == 0) then
							kidney_ready = true
						end
						if ComboPointsDeficit == 0 then
							local d = _distance(t)
							local lockout = IsLocked(t,true)
							if lockout < gcd or PhysicalInterrupt(t,true,20) then
								if _Cast(408,t,true) then
									-- Squid_Alert("Kidney Shot " .. UnitClass(t),nil,2)
								end
							end
						end
					end

					local waiting_for = {}
					table.insert(waiting_for,kidney_cd)
					table.insert(waiting_for,drremains)
					table.sort(waiting_for,function(x,y) return x > y end)

					kidney_countdown = waiting_for[1] or 0

					kidney_countdown = math.ceil(kidney_countdown + time_to_max_cp)

					if kidney_countdown <= time_to_next_max_cp-1.8 and _spellCooldown(137619) > kidney_countdown then
						waiting_for_kidney=true
						hold_cp_for_kidney=true
						if energy_time_to_max > 5 and ComboPointsDeficit == 0 then
							hold_energy_for_kidney=true
						end
						if kidney_countdown <= gcd and ComboPointsDeficit == 0 then
							hold_gcd_for_kidney=true
						end
					end

					if kidney_countdown then
						kidney_countdown = math.floor(kidney_countdown)
						if (kidney_countdown == 5 or kidney_countdown == 1) and kidney_countdown > 0 then
							if locale == "zhCN" then
								Squid_Alert_Big(kidney_countdown .. "ç§’åŽè‚¾å‡»",nil,nil,4.5,408)
							else
								Squid_Alert_Big("Kidney Shot Soon","(".. kidney_countdown .. ")",nil,4.5,408)
							end
						end
						-- if kidney_countdown == 1 and ComboPoints >= 5 then
						-- 	Squid_Alert("Kidney Shot Ready","(Now)",nil,3.5,408)
						-- end
					end

				end

				local function stealthed(t)

					-- # Stealthed Actions
					--cheap offtarget / focus
					if UnitExists(current_focus) then
						if not unit_is_unit(current_target,current_focus) then
							if _valid(current_focus) and _stunDR(current_focus) == 1 and _CCremains(current_focus) <= 1 then
								if _Cast(1833,current_focus,nil,true) then
									Squid_Alert_Big("Cheap shot " .. UnitClass(current_focus),"(Focus)",nil,nil,1833)
								end
							end
						end
					end
					for i=1,#Enemies do
						if not unit_is_unit(current_target,Enemies[i]) then
							if _valid(Enemies[i]) and _stunDR(Enemies[i]) == 1 and _CCremains(Enemies[i]) <= 1 then
								if _Cast(1833,Enemies[i],nil,true) then
									Squid_Alert_Big("Cheap shot " .. UnitClass(Enemies[i]),"(Off Target)",nil,nil,1833)
								end
							end
						end
					end
					-- # Nighstalker, or Subt+Exsg on 1T: Snapshot Rupture
					-- actions.stealthed=rupture,if=combo_points>=4&amp;(talent.nightstalker.enabled|talent.subterfuge.enabled&amp;(talent.exsanguinate.enabled&amp;cooldown.exsanguinate.remains<=2|!ticking)&amp;variable.single_target)&amp;target.time_to_die-remains>6
					if not hold_cp_for_kidney and ComboPoints >= 3 and ((Nightstalker or IsSubterfuge) and ((Exsanguinate and _spellCooldown(200806) <= 2) or not rupture_ticking)) and single_target then
						_Cast(1943,t,true)
					end
					-- # Subterfuge + Shrouded Suffocation: Ensure we use one global to apply Garrote to the main target if it is not snapshot yet, so all other main target abilities profit.
					-- actions.stealthed+=/pool_resource,for_next=1
					-- actions.stealthed+=/garrote,if=azerite.shrouded_suffocation.enabled&amp;buff.subterfuge.up&amp;buff.subterfuge.remains<1.3&amp;!ss_buffed
					if (ComboPoints < 5 or not kidney_ready) and shrouded_suffocation and Subterfuge and SubterfugeRemains < 1.3 and garrote_power < snapshot then
						_Cast(703,t,true)
					end
					-- # Subterfuge: Apply or Refresh with buffed Garrotes
					-- actions.stealthed+=/pool_resource,for_next=1
					-- actions.stealthed+=/garrote,target_if=min:remains,if=talent.subterfuge.enabled&amp;(remains<12|pmultiplier<=1)&amp;target.time_to_die-remains>2
					if (ComboPoints < 5 or not kidney_ready) and IsSubterfuge and (garrote_remains < 12 or garrote_power <= 1) then
						_Cast(703,t,true)
					end
					-- # Subterfuge + Shrouded Suffocation in ST: Apply early Rupture that will be refreshed for pandemic
					-- actions.stealthed+=/rupture,if=talent.subterfuge.enabled&amp;azerite.shrouded_suffocation.enabled&amp;!dot.rupture.ticking&amp;variable.single_target
					if not hold_cp_for_kidney and single_target and IsSubterfuge and shrouded_suffocation and not rupture_ticking then
						_Cast(1943,t,true)
					end
					-- # Subterfuge w/ Shrouded Suffocation: Reapply for bonus CP and/or extended snapshot duration.
					-- actions.stealthed+=/pool_resource,for_next=1
					-- actions.stealthed+=/garrote,target_if=min:remains,if=talent.subterfuge.enabled&amp;azerite.shrouded_suffocation.enabled&amp;target.time_to_die>remains&amp;(remains<18|!ss_buffed)
					if (ComboPoints < 5 or not kidney_ready) and IsSubterfuge and shrouded_suffocation and (garrote_remains < 18 or garrote_power <= 1) then
						_Cast(703,t,true)
					end
					-- # Subterfuge + Exsg: Even override a snapshot Garrote right after Rupture before Exsanguination
					-- actions.stealthed+=/pool_resource,for_next=1
					-- actions.stealthed+=/garrote,if=talent.subterfuge.enabled&amp;talent.exsanguinate.enabled&amp;cooldown.exsanguinate.remains<1&amp;prev_gcd.1.rupture&amp;dot.rupture.remains>5+4*cp_max_spend
					if (ComboPoints < 5 or not kidney_ready) and IsSubterfuge and Exsanguinate and _spellCooldown(200806) < 1 and (lastRupture and time-lastRupture <= gcd) and rupture_remains > 5+4*ComboPointsMax then
						_Cast(703,t,true)
					end

					if (ComboPoints < 5 or not kidney_ready) and master_assassin_enabled and garrote_remains < 8 then
						_Cast(703,t,nil,true)
					end
				end

				local function essences(t)
					-- # Essences
					-- actions.essences=concentrated_flame
					if not S then
						_Cast(295373,t,true)
					end
					-- # Always use Blood with Vendetta up. Also use with TB up before a finisher (if talented) as long as it runs for 10s during Vendetta.
					-- actions.essences+=/blood_of_the_enemy,if=debuff.vendetta.up&amp;(!talent.toxic_blade.enabled|debuff.toxic_blade.up&amp;combo_points.deficit<=1|debuff.vendetta.remains<=10)|target.time_to_die<=10
					-- actions.essences+=/guardian_of_azeroth
					-- actions.essences+=/focused_azerite_beam,if=spell_targets.fan_of_knives>=2|raid_event.adds.in>60&amp;energy<70
					-- actions.essences+=/purifying_blast,if=spell_targets.fan_of_knives>=2|raid_event.adds.in>60
					-- actions.essences+=/the_unbound_force
					-- actions.essences+=/ripple_in_space
					-- actions.essences+=/worldvein_resonance,if=buff.lifeblood.stack<3
					-- actions.essences+=/memory_of_lucid_dreams,if=energy<50&amp;!cooldown.vendetta.up

				end

				local function cds(t)
					-- # Cooldowns
					-- actions.cds=call_action_list,name=essences,if=!stealthed.all&amp;dot.rupture.ticking&amp;master_assassin_remains=0
					if not S and rupture_ticking and not UnitBuffID("player",256735) then
						essences(t)
					end
					-- # If adds are up, snipe the one with lowest TTD. Use when dying faster than CP deficit or without any CP.
					-- actions.cds+=/marked_for_death,target_if=min:target.time_to_die,if=raid_event.adds.up&amp;(target.time_to_die<combo_points.deficit*1.5|combo_points.deficit>=cp_max_spend)
					-- # If no adds will die within the next 30s, use MfD on boss without any CP.
					-- actions.cds+=/marked_for_death,if=raid_event.adds.in>30-raid_event.adds.duration&amp;combo_points.deficit>=cp_max_spend
					-- actions.cds+=/vendetta,if=!stealthed.rogue&amp;dot.rupture.ticking&amp;!debuff.vendetta.up&amp;(!talent.subterfuge.enabled|!azerite.shrouded_suffocation.enabled|dot.garrote.pmultiplier>1&amp;(spell_targets.fan_of_knives<6|!cooldown.vanish.up))&amp;(!talent.nightstalker.enabled|!talent.exsanguinate.enabled|cooldown.exsanguinate.remains<5-2*talent.deeper_stratagem.enabled)
					if UnitLevel(t) == -1 then
						if not S and rupture_ticking and not vendetta_up then
							if (not IsSubterfuge or not shrouded_suffocation or garrote_power > 1 and (fan_of_knives < 6 or not vanish_up))
							and (not Nightstalker or not Exsanguinate or _spellCooldown(200806) < 5-(deeper_stratagem and 1 or 0)) then
								_Cast(79140,t,true)
							end
						end
					end
					-- # Vanish with Exsg + (Nightstalker, or Subterfuge only on 1T): Maximum CP and Exsg ready for next GCD
					-- actions.cds+=/vanish,if=talent.exsanguinate.enabled&amp;(talent.nightstalker.enabled|talent.subterfuge.enabled&amp;variable.single_target)&amp;combo_points>=cp_max_spend&amp;cooldown.exsanguinate.remains<1&amp;(!talent.subterfuge.enabled|!azerite.shrouded_suffocation.enabled|dot.garrote.pmultiplier<=1)
					-- # Vanish with Nightstalker + No Exsg: Maximum CP and Vendetta up
					-- actions.cds+=/vanish,if=talent.nightstalker.enabled&amp;!talent.exsanguinate.enabled&amp;combo_points>=cp_max_spend&amp;debuff.vendetta.up
					-- # See full comment on https://github.com/Ravenholdt-TC/Rogue/wiki/Assassination-APL-Research.
					-- actions.cds+=/variable,name=ss_vanish_condition,value=azerite.shrouded_suffocation.enabled&amp;(non_ss_buffed_targets>=1|spell_targets.fan_of_knives=3)&amp;(ss_buffed_targets_above_pandemic=0|spell_targets.fan_of_knives>=6)
					-- actions.cds+=/pool_resource,for_next=1,extra_amount=45
					-- actions.cds+=/vanish,if=talent.subterfuge.enabled&amp;!stealthed.rogue&amp;cooldown.garrote.up&amp;(variable.ss_vanish_condition|!azerite.shrouded_suffocation.enabled&amp;dot.garrote.refreshable)&amp;combo_points.deficit>=((1+2*azerite.shrouded_suffocation.enabled)*spell_targets.fan_of_knives)>?4&amp;raid_event.adds.in>12
					-- # Vanish with Master Assasin: No stealth and no active MA buff, Rupture not in refresh range, during Blood essenz if available.
					-- actions.cds+=/vanish,if=talent.master_assassin.enabled&amp;!stealthed.all&amp;master_assassin_remains<=0&amp;!dot.rupture.refreshable&amp;dot.garrote.remains>3&amp;(!essence.blood_of_the_enemy.major|debuff.blood_of_the_enemy.up)
					-- # Shadowmeld for Shrouded Suffocation
					-- actions.cds+=/shadowmeld,if=!stealthed.all&amp;azerite.shrouded_suffocation.enabled&amp;dot.garrote.refreshable&amp;dot.garrote.pmultiplier<=1&amp;combo_points.deficit>=1
					-- # Exsanguinate when both Rupture and Garrote are up for long enough
					-- actions.cds+=/exsanguinate,if=dot.rupture.remains>4+4*cp_max_spend&amp;!dot.garrote.refreshable
					-- actions.cds+=/toxic_blade,if=dot.rupture.ticking
					if rupture_ticking and (not hold_energy_for_kidney or (kidney_countdown > gcd and kidney_countdown < gcd*2.5)) then
						_Cast(245388,t,true)
					end
					-- actions.cds+=/potion,if=buff.bloodlust.react|debuff.vendetta.up
					-- actions.cds+=/blood_fury,if=debuff.vendetta.up
					-- actions.cds+=/berserking,if=debuff.vendetta.up
					-- actions.cds+=/fireblood,if=debuff.vendetta.up
					-- actions.cds+=/ancestral_call,if=debuff.vendetta.up
					-- actions.cds+=/use_item,name=galecallers_boon,if=cooldown.vendetta.remains>45
					-- actions.cds+=/use_item,name=ashvanes_razor_coral,if=debuff.razor_coral_debuff.down|debuff.vendetta.remains>10|target.time_to_die<20+cooldown.latent_arcana.remains
					-- actions.cds+=/use_item,name=lurkers_insidious_gift,if=debuff.vendetta.up
					-- actions.cds+=/use_item,name=lustrous_golden_plumage,if=debuff.vendetta.up
					-- actions.cds+=/use_item,effect_name=gladiators_medallion,if=debuff.vendetta.up
					-- actions.cds+=/use_item,effect_name=gladiators_badge,if=debuff.vendetta.up
					-- actions.cds+=/use_item,effect_name=cyclotronic_blast,if=master_assassin_remains=0&amp;!debuff.vendetta.up&amp;!debuff.toxic_blade.up&amp;buff.memory_of_lucid_dreams.down&amp;energy<80&amp;dot.rupture.remains>4
					-- # Default fallback for usable items: Use on cooldown.
					-- actions.cds+=/use_items
				end

				local function dot(t)
					-- # Damage over time abilities
					-- # Limit Garrotes on non-primrary targets for the priority rotation if 5+ bleeds are already up
					-- actions.dot=variable,name=skip_cycle_garrote,value=priority_rotation&amp;spell_targets.fan_of_knives>3&amp;(dot.garrote.remains<cooldown.garrote.duration|poisoned_bleeds>5)
					skip_cycle_garrote = mage_on_team or (fan_of_knives > 3 and (garrote_remains <= _spellCooldown(703) or poisoned_bleeds > 5))
					-- # Limit Ruptures on non-primrary targets for the priority rotation if 5+ bleeds are already up
					-- actions.dot+=/variable,name=skip_cycle_rupture,value=priority_rotation&amp;spell_targets.fan_of_knives>3&amp;(debuff.toxic_blade.up|(poisoned_bleeds>5&amp;!azerite.scent_of_blood.enabled))
					skip_cycle_rupture = mage_on_team or (fan_of_knives > 3 and (not toxic_blade_up or (poisoned_bleeds > 5 and not scent_of_blood)))
					-- # Limit Ruptures if Vendetta+Toxic Blade is up and we have 2+ seconds left on the Rupture DoT
					-- actions.dot+=/variable,name=skip_rupture,value=debuff.vendetta.up&amp;debuff.toxic_blade.up&amp;dot.rupture.remains>2
					skip_rupture = vendetta_up and toxic_blade_up and rupture_remains > 2
					-- # Special Rupture setup for Exsg
					-- actions.dot+=/rupture,if=talent.exsanguinate.enabled&amp;((combo_points>=cp_max_spend&amp;cooldown.exsanguinate.remains<1)|(!ticking&amp;(time>10|combo_points>=2)))
					if not hold_cp_for_kidney and Exsanguinate and ((ComboPoints >= ComboPointsMax and _spellCooldown(200806) < 1) or (rupture_remains <= 2 + ComboPoints and (time_in_combat > 10 or ComboPoints >= 2))) then
						_Cast(1943,t,true)
					end
					-- # Garrote upkeep, also tries to use it as a special generator for the last CP before a finisher
					-- actions.dot+=/pool_resource,for_next=1
					-- actions.dot+=/garrote,if=(!talent.subterfuge.enabled|!(cooldown.vanish.up&amp;cooldown.vendetta.remains<=4))&amp;combo_points.deficit>=1+3*(azerite.shrouded_suffocation.enabled&amp;cooldown.vanish.up)&amp;refreshable&amp;(pmultiplier<=1|remains<=tick_time&amp;spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&amp;(!exsanguinated|remains<=tick_time*2&amp;spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&amp;!ss_buffed&amp;(target.time_to_die-remains)>4&amp;(master_assassin_remains=0|!ticking&amp;azerite.shrouded_suffocation.enabled)
					if (ComboPoints < 5 or not kidney_ready) then -- and not hold_energy_for_kidney
						if (ComboPointsDeficit == 1 or garrote_remains < 11 - (max(3,kidney_countdown))) and garrote_remains < 14 - max(4,kidney_countdown) and ComboPointsDeficit >= 1 then
							_Cast(703,t,true)
						end
					end
					-- actions.dot+=/pool_resource,for_next=1
					-- actions.dot+=/garrote,cycle_targets=1,if=!variable.skip_cycle_garrote&amp;target!=self.target&amp;(!talent.subterfuge.enabled|!(cooldown.vanish.up&amp;cooldown.vendetta.remains<=4))&amp;combo_points.deficit>=1+3*(azerite.shrouded_suffocation.enabled&amp;cooldown.vanish.up)&amp;refreshable&amp;(pmultiplier<=1|remains<=tick_time&amp;spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&amp;(!exsanguinated|remains<=tick_time*2&amp;spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&amp;!ss_buffed&amp;(target.time_to_die-remains)>12&amp;(master_assassin_remains=0|!ticking&amp;azerite.shrouded_suffocation.enabled)
					if not skip_cycle_garrote and (ComboPoints < 5 or not kidney_ready) then -- and not hold_energy_for_kidney
						for i=1,#mainTarget do
							local tar=mainTarget[i].pointer
							if not unit_is_unit(tar,t) and (arena or not IsSubterfuge or not (vanish_up and vendetta_cd <= 4) or target_is_dummy)
							and ComboPointsDeficit >= 1 + (3* ((((shrouded_suffocation and vanish_up and not arena))
							and (mainTarget[i].gp <= 1 or mainTarget[i].garrote <= 1.5 and fan_of_knives >= 3 + (shrouded_suffocation and 1 or 0))
							and (not Exsanguinated or garrote_remains <= 1.5*2 and fan_of_knives >= 3 + (shrouded_suffocation and 1 or 0))
							and mainTarget[i].gp <= 1) and 1 or 0) ) then
								_Cast(703,tar,true)
							end
						end
					end
					-- # Crimson Tempest only on multiple targets at 4+ CP when running out in 2s (up to 4 targets) or 3s (5+ targets)
					-- actions.dot+=/crimson_tempest,if=spell_targets>=2&amp;remains<2+(spell_targets>=5)&amp;combo_points>=4
					-- # Keep up Rupture at 4+ on all targets (when living long enough and not snapshot)
					-- actions.dot+=/rupture,if=!variable.skip_rupture&amp;combo_points>=4&amp;refreshable&amp;(pmultiplier<=1|remains<=tick_time&amp;spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&amp;(!exsanguinated|remains<=tick_time*2&amp;spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&amp;target.time_to_die-remains>4
					if not hold_cp_for_kidney and not skip_rupture then
						local refreshable = rupture_remains <= 11 - (max(4,kidney_countdown)) and ComboPoints >= 4
						if refreshable and target_hp > 20 then
							_Cast(1943,t,true)
						end
					end
					-- actions.dot+=/rupture,cycle_targets=1,if=!variable.skip_cycle_rupture&amp;!variable.skip_rupture&amp;target!=self.target&amp;combo_points>=4&amp;refreshable&amp;(pmultiplier<=1|remains<=tick_time&amp;spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&amp;(!exsanguinated|remains<=tick_time*2&amp;spell_targets.fan_of_knives>=3+azerite.shrouded_suffocation.enabled)&amp;target.time_to_die-remains>4
					if not hold_cp_for_kidney and not skip_cycle_rupture and (rupture_count <= 2 or arena) then
						for i=1,#mainTarget do
							local tar=mainTarget[i].pointer
							local remains = mainTarget[i].rupture
							local refreshable = remains < 5 and ComboPoints >= 4
							if refreshable and mainTarget[i].hp > 20 then
								_Cast(1943,tar,true)
							end
						end
					end
				end

				local function direct(t)
					-- # Direct damage abilities
					-- # Envenom at 4+ (5+ with DS) CP. Immediately on 2+ targets, with Vendetta, or with TB; otherwise wait for some energy. Also wait if Exsg combo is coming up.
					-- actions.direct=envenom,if=combo_points>=4+talent.deeper_stratagem.enabled&amp;(debuff.vendetta.up|debuff.toxic_blade.up|energy.deficit<=25+variable.energy_regen_combined|!variable.single_target)&amp;(!talent.exsanguinate.enabled|cooldown.exsanguinate.remains>2)
					if not hold_cp_for_kidney and ComboPoints >= 4 + (deeper_stratagem and 1 or 0) and (not vendetta_up or toxic_blade_up or EnergyDeficit <= 25+energy_regen_combined or single_target)
					and (not Exsanguinate or _spellCooldown(200806) > 2) then
						_Cast(196819,t,true)
					end
					-- actions.direct+=/variable,name=use_filler,value=combo_points.deficit>1|energy.deficit<=25+variable.energy_regen_combined|!variable.single_target
					use_filler = (not hold_cp_for_kidney or energy_time_to_max < kidney_countdown-gcd or ComboPoints < 5) and (ComboPointsDeficit > 1 or EnergyDeficit <= 25+energy_regen_combined or not single_target) and not hold_energy_for_kidney
					if not use_filler then use_filler = waiting_for_kidney and ComboPoints < 5 and not hold_energy_for_kidney end
					-- # With Echoing Blades, Fan of Knives at 2+ targets.
					-- actions.direct+=/fan_of_knives,if=variable.use_filler&amp;azerite.echoing_blades.enabled&amp;spell_targets.fan_of_knives>=2
					-- # Fan of Knives at 19+ stacks of Hidden Blades or against 4+ (5+ with Double Dose) targets.
					-- actions.direct+=/fan_of_knives,if=variable.use_filler&amp;(buff.hidden_blades.stack>=19|(!priority_rotation&amp;spell_targets.fan_of_knives>=4+(azerite.double_dose.rank>2)+stealthed.rogue))
					-- # Fan of Knives to apply Deadly Poison if inactive on any target at 3 targets.
					-- actions.direct+=/fan_of_knives,target_if=!dot.deadly_poison_dot.ticking,if=variable.use_filler&amp;spell_targets.fan_of_knives>=3
					if not mage_on_team_casting_cc and fan_of_knives >= 3 and use_filler and not bcc then
						if fan_of_knives >= 4 and ComboPointsDeficit > 0 then
							_Cast(51723)
						end
						for i=1,#mainTarget do if mainTarget[i].distance <= 10 then
							local tar=mainTarget[i].pointer
							if not UnitDebuffID(tar,2818,"player") and not UnitDebuffID(tar,8680,"player") then
								_Cast(51723)
								return
							end
						end end
					end
					-- actions.direct+=/blindside,if=variable.use_filler&amp;(buff.blindside.up|!talent.venom_rush.enabled&amp;!azerite.double_dose.enabled)
					if use_filler and (UnitBuffID("player",121153) or (not venom_rush and not double_dose)) then
						_Cast(111240,t,true)
					end
					-- # Tab-Mutilate to apply Deadly Poison at 2 targets
					-- actions.direct+=/mutilate,target_if=!dot.deadly_poison_dot.ticking,if=variable.use_filler&amp;spell_targets.fan_of_knives=2
					if use_filler then
						if fan_of_knives == 2 then
							for i=1,#mainTarget do if mainTarget[i].distance <= 6 then
								local tar=mainTarget[i].pointer
								if not poison_ticking(tar) then
									_Cast(1752,tar,true)
								end
							end end
						end
						_Cast(1752,t,true)
					end
					-- actions.direct+=/mutilate,if=variable.use_filler
				end

				-- actions+=/call_action_list,name=stealthed,if=stealthed.rogue
				if S then
					if Subterfuge or Vanish or AutoFollow then
						kidney(t)
						stealthed(t)
					end
					if Stealth then return; end
				end

				if valid_physical_target then
					if not start_attack_time or time - start_attack_time > .5 then
						StartAttack()
						start_attack_time=time
					end
				end

				--kidneys
				kidney(t)

				--MFD
				if (time_in_combat > 5 or kidney_ready) and (kidney_countdown > time_to_max_cp or kidney_countdown <= GetGCD()) then
					if target_hp < ComboPointsDeficit*1.5 or ComboPoints == 0 or kidney_ready then
						if ComboPoints < 3 then
							if _meleeRange(t) then
								_Cast(137619,t)
							end
						end
					end
				end

				--no gcd actions when kidney is next global, except in stealth
				if hold_gcd_for_kidney then return end

				-- actions+=/call_action_list,name=cds,if=(!talent.master_assassin.enabled|dot.garrote.ticking)&amp;(!equipped.azsharas_font_of_power|!cooldown.latent_arcana.up)
				if (not IsPlayerSpell(255989) or garrote_ticking) then
					cds(t)
				end
				-- actions+=/call_action_list,name=dot
				dot(t)
				-- actions+=/call_action_list,name=direct
				direct(t)
				-- actions+=/arcane_torrent,if=energy.deficit>=15+variable.energy_regen_combined
				-- actions+=/arcane_pulse
				-- actions+=/lights_judgment


			end

		end

	end

	function Squid_SubPvE()
		--if nil == nil then return end

		local racials = {

		}

		local covenant = {
			ids = {
				none = 0,
				kyrian = 1,
				venthyr = 2,
				nightFae = 3,
				necroLord = 4,
			},
			--kyrian
			kyrian = {
				echoingReprimand = 323547,
				summonSteward = 324739,
			},
			--Night Fae
			nightFae = {
				sepsis = 328305,
				soulShape = 310143,
			},
		}

		local rogue = {
			blind = 2094,
			cheapShot = 1833,
			cloakOfShadows = 31224,
			crimsonVial = 185311,
			distract = 1725,
			evasion = 5277,
			eviscerate = 196819,
			feint = 1966,
			kick = 1766,
			kidneyShot = 408,
			pickLock = 1804,
			pickPocket = 921,
			sap = 6770,
			shiv = 5938,
			smokeBomb = 212182,
			shroudOfConcealment = 114018,
			sliceAndDice = 315496,
			sprint = 2983,
			stealth = 1784,
			tricksOfTheTrade = 57934,
			vanish = 1856,

			buffs = {
				crimsonVial = 185311, -- Mainly for torghast when you can get it to no cooldown
				sliceAndDice = 315496,
				vanish = 11327,
			},
			debuffs = {
				cheapShot = 1833,
				kidneyShot = 408,
				smokeBomb = 212183
			},
		}

		local sub = {
			backstab = 53,
			blackPowder = 319175,
			coldBlood = 213981,
			shadowyDuel = 207736,
			rupture = 1943,
			shadowBlades = 121471,
			shadowDance = 185313,
			shadowStep = 36554,
			shadowStrike = 185438,
			shurikenStorm = 197835,
			shurikenToss = 114014,
			shurikenTornado = 277925,
			symbolsOfDeath = 212283,

			buffs = {
				masterAssassinsMark = 340094,
				premeditation = 343173,
				shadowBlades = 121471,
				shadowDance = 185422,
				shurikenTornado = 277925,
				subterfure = 115192,
				symbolsOfDeath = 212283,
				symbolsOfDeathAutoCrit = 227151,
				theRotten = 341134,
			},

			debuffs = {
				findWeakness = 316220,
				rupture = 1943,
			},
		}

		local dungeon = {

		}
		local raid = {
			bossDebuffs = {
				--Sludgefist
				destructiveImpact = 331314, -- Sludgefist Destructive Impact, Damage taken increased by 100%. Stunned.
				--Huntsman
				destabilize = 334695,  --334695 - Destabilize 100% damage taken increased per stack
				brokenBonds = 345902,  -- broken bond
			},
		}

		--talents
		local vigorEnabled = IsPlayerSpell(14983)
		local masterOfShadowsEnabled = IsPlayerSpell(196976)
		local shadowFocusEnabled = IsPlayerSpell(108209)
		local alacrityEnabled = IsPlayerSpell(193539)
		local premeditationEnabled = IsPlayerSpell(343160)
		local nightStalkerEnabled = IsPlayerSpell(14062)
		local darkShadowEnabled = IsPlayerSpell(245687)
		local shurikenTornadoEnabled = IsPlayerSpell(277925)
		local envelopingShadowsEnabled = IsPlayerSpell(238104)
		local subterfugeEnabled = IsPlayerSpell(108208)
		local deeperStrategemEnabled = IsPlayerSpell(193531)
		local markedForDeathEnabled = IsPlayerSpell(137619)
		local elusivenessEnabled = IsPlayerSpell(79008)

		--Player shit
		local UnitBuffID = UnitBuffID
		local UnitDebuffID = UnitDebuffID
		local UnitCanAttack = UnitCanAttack
		local squid_ttd = squid_ttd
		local haste = UnitSpellHaste("player")
		local gcd = 1.5/(1+(haste/100))
		local gcd_remains = GetGCD()
		local player_hp = _HP("player")
		local Stealth = UnitBuffID("player",115191) or UnitBuffID("player",1784)
		local Subterfuge = UnitBuffID("player",115192)
		local SubterfugeRemains = _buffRemains("player",115192)
		local S = Stealth or Subterfuge
		local pooling = false
		local inInstance, instanceType = IsInInstance()
		local instanceName, _, _, _, _, _, _, _, _ = GetInstanceInfo()
		local Vanish = UnitBuffID("player",11327)
		local bcc8 = _bccAM(8)
		local battleground = instanceType == 'pvp'


		--Settings
		SQUID.auto_vial_percent = SQUID.auto_vial_percent or 50

		--Combo Points
		local combo_points_max = UnitPowerMax("player", 4)
		local combo_points = UnitPower("player",4)
		local combo_points_deficit = combo_points_max - combo_points

		--Energy
		local energy = UnitPower("player")
		local energy_max = UnitPowerMax("player")
		local energy_deficit = energy_max - energy
		local energy_regen = GetPowerRegen()
		local energy_time_to_max = energy_deficit / energy_regen
		local function energy_time_to(amount)
			return max ( 0, ( amount - energy ) / energy_regen )
		end

		--Shadow Dance
		local dance_base_cd = 60
		local dance_charges,dance_max_charges = GetSpellCharges(sub.shadowDance)
		local dance_total_cd = dance_base_cd * dance_max_charges
		local dance_charges_frac = _spellChargeFrac(sub.shadowDance)
		local dance_full_recharge_time = dance_total_cd - (dance_charges_frac*dance_base_cd)
		local dance_next_charge_cd = (math.ceil(dance_charges_frac) - dance_charges_frac) * dance_base_cd
		local dance_remains = _buffRemains("player",185422)
		local dance_up = dance_remains > 0

		--MFD
		local marked_for_death_cd = _spellCooldown(137619)

		--Estimated number of dance cooldown seconds refunded by deepening shadows over a given time
		--@param given_time - the time given
		--@param dances_saved - how many dance charges you want to save, altering the # of seconds refunded for future dances
		--@returns (number) - estimated number of dance cooldown seconds refunded by deepening shadows over given time
		local function deepening_shadows_reset(given_time, dances_saved)

			-- max gcds in the given time, with perfect uptime and no energy starvation
			local max_gcds = given_time / gcd
			local max_dances = dance_charges

			-- max time in dance
			local max_time_in_dance = 0
			max_time_in_dance = max_time_in_dance + dance_remains
			max_time_in_dance = dance_charges * 8
			if dance_charges ~= dance_max_charges and dance_next_charge_cd < given_time then
				local next_charge_value = min(8, given_time - dance_next_charge_cd)
				max_time_in_dance = max_time_in_dance + next_charge_value
				max_dances = max_dances + 1
			end
			max_time_in_dance = max_time_in_dance - (not dances_saved and 0 or dances_saved * 8)

			--max time in dance and max dances can't be more than the time alotted
			max_time_in_dance = min(given_time, max_time_in_dance)
			max_dances = min(round(given_time/8,0),max_dances)

			--marked for death finishers
			local marked_for_death_value = 0
			if markedForDeathEnabled then
				marked_for_death_value = marked_for_death_value + (marked_for_death_cd < given_time and 1 or 0)
				marked_for_death_value = marked_for_death_value + (math.floor((given_time-marked_for_death_cd)/60))
			end

			--time spent outside of dance in the given time
			local time_outside_dance = max(0, given_time-max_time_in_dance)

			-- rough estimate of gcds required per finisher with and without dance up, these estimates will probably always be high because procs, but can be adjusted
			local gcds_per_finisher = 4/1 --it feels like it rarely takes 5 entire gcds backstabbing to get to 5 cp.. we will just act like we have 4 max cp here
			local gcds_per_finisher_dance = 5/2 --where we step into the unknown we can average it out... 2.5 gcds per finisher during dance

			--energy spent per finisher during and outside of dance
			local energy_spent_per_finisher_dance = (gcds_per_finisher_dance * 40)
			local energy_spent_per_finisher = (gcds_per_finisher * 35)

			--add the gcd of the actual finisher to this after energy spending is calculated since energy from finishers is refunded
			gcds_per_finisher = gcds_per_finisher + 1
			gcds_per_finisher_dance = gcds_per_finisher_dance + 1

			--energy gained can be calculated after adding finisher to gcds per finisher since you're still gaining energy while using the gcd on finisher
			local energy_gained_per_finisher_dance = (energy_regen*gcd) * gcds_per_finisher_dance
			local energy_gained_per_finisher = (energy_regen*gcd) * gcds_per_finisher

			local mos_energy_gain = (masterOfShadowsEnabled and 25*max_dances or 0)

			--max finishers during dance (unadjusted)
			local max_finishers_during_dance = max_time_in_dance / (gcds_per_finisher_dance * gcd)

			local net_energy_loss_dance = max_finishers_during_dance * energy_spent_per_finisher_dance
			local net_energy_gain_dance = max_finishers_during_dance * energy_gained_per_finisher_dance
			--net energy over time in dance
			local net_energy_during_dance = net_energy_gain_dance - net_energy_loss_dance + mos_energy_gain

			--max finishers outside of dance (unadjusted)
			local max_finishers_outside_dance = time_outside_dance / (gcds_per_finisher * gcd)

			--net energy over time outside dance
			local net_energy_loss = max_finishers_outside_dance * energy_spent_per_finisher
			local net_energy_gain = max_finishers_outside_dance * energy_gained_per_finisher
			local net_energy_outside_dance = net_energy_gain - net_energy_loss

			--net energy over time, and time spent pooling energy
			local net_energy = energy + net_energy_outside_dance + net_energy_during_dance
			local time_pooling_energy = max(0, -net_energy / energy_regen)

			--max finishers adjusted
			local max_finishers_during_dance_adjusted = (max_time_in_dance - time_pooling_energy) / (gcds_per_finisher_dance * gcd)
			local max_finishers_outside_dance_adjusted = (time_outside_dance - time_pooling_energy) / (gcds_per_finisher * gcd)

			local max_finishers = max_finishers_outside_dance_adjusted + max_finishers_during_dance_adjusted + marked_for_death_value

			local deepening_shadows_mod = 5 + (envelopingShadowsEnabled and 2.5 or 0)

			return max_finishers * deepening_shadows_mod, max_finishers

		end

		local function _valid(unit)
			return UnitIsVisible(unit)
			and UnitCanAttack("player",unit)
			and not UnitIsDeadOrGhost(unit)
			and not _breakableCC(unit)
			and (arena or UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))
		end

		--Special Functions
		-----------------------------------------------------------------------------------------------------------------

		local function debuff_remains(unit, spellID)
			if not UnitDebuffID(unit, spellID) then
				return 0;
			else
				return _debuffRemains(unit, spellID);
			end
		end

		local function valid_enemies_around(unit, dist)
			local count = 0
			for i = 1, #Enemies do
				if _valid(Enemies[i]) and _distance(Enemies[i], unit) <= dist and not _breakableCC(Enemies[i], false) then
					count = count + 1
				end
			end
			return count;
		end

		local function dynamicTargeting(range)
			--Target enemies above 75% or below 35% preferably
			local bestUnit = bestUnit or nil
			if bestUnit == nil then
				if #Enemies > 0 then
					for i = 1, #Enemies do
						local thisUnit = Enemies[i]
						if _distance('player', thisUnit) <= range and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
							bestUnit = thisUnit
						end
					end
				end
			end
			if not UnitExists("target") and UnitAffectingCombat('player') then
				TargetUnit(bestUnit)
			end
		end

		local function is_instance_boss(unit)
			if IsInInstance() then
				local _, _, encountersTotal = GetInstanceLockTimeRemaining()
				for i = 1, encountersTotal do
					if unit == 'player' then
						local bosses = select(1, GetInstanceLockTimeRemainingEncounter(i))
					end
					if (UnitIsVisible(unit) or false) then
						local boss = GetInstanceLockTimeRemainingEncounter(i)
						local tar = UnitName(unit)
						if tar == boss then return true end
					end
				end
				for j = 1, 5 do
					local num = 'boss' .. j
					if unit_is_unit(num, unit) then return true end
				end
			end
			return false
		end

		local function encounter_name(index)
			--Total of 10 Encounters
			if inInstance and instanceType == 'raid' and instanceName == "Castle Nathria" then
				local boss = GetInstanceLockTimeRemainingEncounter(index)
				return boss
			end
		end

		-- this wasn't defined before the functions so the functions will never find it
		local t = current_target

		local function is_boss(unit)
			if unit == nil then
				unit = t
			end
			--Probably needs locales set for totems
			if (UnitIsVisible(unit) or false) and UnitCreatureType(unit) ~= 'Totem' then
				local unitClass = UnitClassification(unit)
				local hMax = UnitHealthMax(unit)
				local pMax = UnitHealthMax('player')
				local instance = select(2, IsInInstance())
				return is_instance_boss(unit)
						or _isDummy(unit)
						or not UnitIsTrivial(unit) and instance ~= 'party' and (unitClass == "rare" and hMax > 4 * pMax) or UnitLevel(unit) < 0
			end
			return false
		end
		local function shouldUseCDs()
			local bossID
			local targetForCDs
			local targetHasAppeared = false
			if inInstance and instanceType == 'raid' then
				--Huntsman
				for i = 1, #Enemies do
					if UnitName(Enemies[i]) == 'Huntsman Altimor' then
						bossID = Enemies[i]
					end
					if UnitName(Enemies[i]) == 'Bargast' then
						targetHasAppeared = true
						targetForCDs = Enemies[i]
					end
				end
				if UnitAffectingCombat(bossID) then
					--We in combat with the damn encounter
					if targetHasAppeared and _debuffStacks(targetForCDs, raid.bossDebuffs.destabilize) >= 10 then
						if _meleeRange('player', targetForCDs) then
							return true;
						elseif targetHasAppeared and UnitIsDead(targetForCDs) or not UnitIsVisible(targetForCDs) then
							if _meleeRange('player', t) then
								return true;
							end
						else
							return false;
						end
					end
				else
					return false;
				end
			elseif inInstance and instanceType == 'party' then
				if is_boss(t) then
					return true;
				else
					return false;
				end
			else
				return false;
			end
		end

		local function valid_stun_target(unit)
			return _CCremains(unit) <= .35 and (_stunDR(unit) == 1 or _drRemains(unit,"stun") > 17.5) and _stunDR(unit) >= .25 and not _immunePhysical(unit)
		end
		local function valid_kidney_target(unit)
			return _CCremains(unit) <= .35 and (_stunDR(unit) == 1) and not _immunePhysical(unit)
		end
		------------------------------------------------------------------------------------------------------------------

		local covenantID = C_Covenants.GetActiveCovenantID()
		local t_is_boss = (t and is_boss(t) or false)

		------------------------------------------------------------------------------------------------------------------
		--PvP
		local enemy_player_around
		for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then
			enemy_player_around=true
			break;
		end end

		local function Sappable(unit)
			return energy > 35 and not unit_has_dot(unit) and not UnitAffectingCombat(unit) and _incapacitateDR(unit) >= .25 and _CCremains(unit) <= .7 and (_incapacitateDR(unit) == 1 or _drRemains(unit,"incapacitate") > 17)
		end

		local function CCAvailable(unit)
			local canblind
			local blind = blind_cd <= gcd
			local vanish = vanish_cd <= gcd
			local sap = S

			local cc = 0

			if blind and _disorientDR(unit) == 1 then
				canblind=true
				cc = cc + 8
			end

			if vanish then
				local stundr = _stunDR(unit)
				local silencedr = _silenceDR(unit)
				if stundr >= .5 then
					cc = cc + (stundr*4)
				end
				if silencedr >= .5 then
					cc = cc + (silencedr*3)
				end
			end

			if Sappable(unit) or (vanish and (canblind or UnitDebuffID(unit,2094))) then
				local dr = _incapacitateDR(unit)
				cc = cc + (dr*8)
			end

			return cc
		end
		local function t_is_stunned(unit)
			if UnitDebuffID(unit, rogue.debuffs.cheapShot) then
				return rogue.debuffs.cheapShot
			elseif UnitDebuffID(unit, rogue.debuffs.kidneyShot) then
				return rogue.debuffs.kidneyShot
			end
		end
		local t_stun_remains = debuff_remains(t, t_is_stunned(t))

		local their_healer = theirHealer
		local their_healer_cc
		local their_healer_cc_remains = 0
		local their_healer_incapacitate_dr
		local their_healer_incapacitate_dr_remains = 0
		local their_healer_disorient_dr
		local their_healer_disorient_dr_remains = 0
		local their_healer_important_lockout
		if their_healer then
			if not UnitIsDeadOrGhost(their_healer) then
				their_healer_cc_remains = _CCremains(their_healer)
				their_healer_cc = their_healer_cc_remains > 0
				their_healer_incapacitate_dr = _incapacitateDR(their_healer)
				their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
				their_healer_disorient_dr = _disorientDR(their_healer)
				their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

				local class = select(2,UnitClass(their_healer))

				local locked,remaining,school = UnitIsLocked(their_healer)

				if locked and remaining > .25 then
					if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
					or ( class == "SHAMAN" and school == "Nature" )
					or ( class == "PALADIN" and school == "Holy" )
					or ( class == "MONK" and school == "Nature" )
					or ( class == "DRUID" and school == "Nature" )  then
						their_healer_important_lockout = true
					end
				end
			else -- no healer if he dead
				their_healer = nil
			end
		end
		if not their_healer then
			their_healer_cc = true
			their_healer_cc_remains = 100 - (lowestEnemy*1.5)
			their_healer_cc_remains = their_healer_cc_remains > 8 and 8 or their_healer_cc_remains
			their_healer_cc_remains = their_healer_cc_remains < 0 and 0 or their_healer_cc_remains
		end

		------------------------------------------------------------------------------------------------------------------


		------------------------------------------------------------------------------------------------------------------

			--Tricks
		------------------------------------------------------------------------------------------------------------------

		local tricksTarget
		local auto_tricks = SQUID.auto_tricks_of_the_trade
		if auto_tricks and _spellCooldown(rogue.tricksOfTheTrade) == 0 and gcd_remains == 0 then
			for i = 1, #Friends do
				local thisUnit = Friends[i]
				if UnitGroupRolesAssigned(thisUnit) == "TANK" and not UnitIsDeadOrGhost(thisUnit) and _LoS('player', thisUnit) then
					tricksTarget = thisUnit
					break
				end
			end
		end

		------------------------------------------------------------------------------------------------------------------

			--equipped items
		local equipped_items = {}

		local trinkets = {
			173087, --Darkmoon Deck: Voracity
			178715, --Mistcaller Ocarina
		}

		for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then table.insert( equipped_items, trinkets[i] ) end end


		---------------------------------------------------------------------------------------------------------------------
		--Restealth if Possible .. probably never

		--variable,name=snd_condition,value=buff.slice_and_dice.up|spell_targets.shuriken_storm>=6
		--Used to determine whether cooldowns wait for SnD based on targets.
		local snd_condition = UnitBuffID("player", rogue.sliceAndDice) or Enemies_Around_Unit("player", 10) >= 6

		--	call_action_list,name=cds
		--  Check CDs at first

		--run_action_list,name=stealthed,if=stealthed.all
		--Run fully switches to the Stealthed Rotation (by doing so, it forces pooling if nothing is available).

		--slice_and_dice,if=spell_targets.shuriken_storm<6&amp;fight_remains>6&amp;buff.slice_and_dice.remains<gcd.max&amp;combo_points>=4-(time<10)*2
		--Apply Slice and Dice at 2+ CP during the first 10 seconds, after that 4+ CP if it expires within the next GCD or is not up
		local slice_and_dice = Enemies_Around_Unit("player", 10) < 6 and squid_ttd(t) > 6 and _buffRemains("player", rogue.sliceAndDice) < (gcd or nil)
			and combo_points >= 4 - (time_in_combat < 10 and 1 or 0) * 2

		--variable,name=use_priority_rotation,value=priority_rotation&amp;spell_targets.shuriken_storm>=2
		--Only change rotation if we have priority_rotation set and multiple targets up.
		local priority_rotation = false
		local use_priority_rotation = priority_rotation == true and Enemies_Around_Unit("player", 10) >= 2

		--variable,name=stealth_threshold,value=25+talent.vigor.enabled*20+talent.master_of_shadows.enabled*20+talent.shadow_focus.enabled*25+talent.alacrity.enabled*20+25*(spell_targets.shuriken_storm>=4)
		--Used to define when to use stealth CDs or builders
		local stealth_threshold = 25 + (vigorEnabled and 1 or 0) * 20 + (masterOfShadowsEnabled and 1 or 0) * 20 + (shadowFocusEnabled and 1 or 0)
			* 25 + (alacrityEnabled and 1 or 0) * 20 + 25 * ((Enemies_Around_Unit("player", 10) >= 4) and 1 or 0)

		--call_action_list,name=stealth_cds,if=variable.use_priority_rotation
		--Priority Rotation? Let's give a crap about energy for the stealth CDs (builder still respect it). Yup, it can be that simple.
		local stealth_cds = use_priority_rotation or energy_deficit <= stealth_threshold

		--call_action_list,name=finish,if=combo_points=animacharged_cp

		--call_action_list,name=finish,if=combo_points.deficit<=1|fight_remains<=1&amp;combo_points>=3|buff.symbols_of_death_autocrit.up&amp;combo_points>=4
		--Finish at 4+ without DS or with SoD crit buff, 5+ with DS (outside stealth)
		local finish = (combo_points_deficit <= 1 or (squid_ttd(t) <= 1 and combo_points >= 3) or UnitBuffID('player', sub.symbolsOfDeath) and combo_points >= 4)

		--call_action_list,name=finish,if=spell_targets.shuriken_storm>=4&amp;combo_points>=4
		--With DS also finish at 4+ against 4 targets (outside stealth)
			or Enemies_Around_Unit("player", 10) >= 4 and combo_points >= 4

		--call_action_list,name=build,if=energy.deficit<=variable.stealth_threshold
		--Use a builder when reaching the energy threshold
		local build = energy_deficit <= stealth_threshold

		--arcane torrent Lowest priority in all of the APL because it causes a GCD
		local arcane_torrent = energy_deficit >= 15 + energy_regen

		--Stealth with enemy player around
		if enemy_player_around and IsUsableSpell("Stealth") then
			if not Stealth and (not UnitAffectingCombat("player") or Vanish) and _spellCooldown(1784) == 0 then
				if _spellCooldown(1784) == 0 and _Cast(1784) then
					Squid_Alert("Stealth",nil,nil,nil,1784)
				end
				return
			end
		end

		if (arena or battleground) then

			--arena cds
			if _meleeRange('player', t) and _valid(t) and UnitAffectingCombat('player') then
				if (GetInventoryItemID('player', 13) == 175884 or GetInventoryItemID('player', 14) == 175884) and select(2,GetItemCooldown(175884)) == 0 then
					UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
				end
			end

			local enemies_on_player,enemy_melee_on_player,enemy_ranged_on_player,enemy_cds_on_player = EnemiesAttacking("player")
			if enemy_cds_on_player >= 1 and elusivenessEnabled then
				_Cast(rogue.feint)
			end

			--blind peel
			if lowestFriend < 80 and not theirHealer then
				for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) and not _CCcheck(Enemies[i]) and _disorientDR(Enemies[i]) == 1 and UnitEnemiesAttacking(Enemies[i]) == 0 then
					_Cast(2094,Enemies[i])
				end end
			end

			--CC Trinket
			local trinketPointer
			local recentTrinket
			for i=1,#TrinketTracker do
				local pointer = TrinketTracker[i].pointer
				local trinketTime = TrinketTracker[i].time
				if UnitIsVisible(pointer) and _isHealer(pointer) then
					recentTrinket = time-trinketTime <= gcd*2
					timeSinceTrinket = time-trinketTime
					trinketPointer = pointer
				end
			end

			if recentTrinket then
				if trinketPointer and not unit_is_unit(trinketPointer,"target") and _LoS(trinketPointer) and not DoNotBCC(trinketPointer) and gcd_remains <= .25 then
					--Blind
					if _spellCooldown(rogue.blind) <= gcd and _disorientDR(trinketPointer) == 1 then
						if _realDistance(trinketPointer) <= 15 then
							if _Cast(rogue.blind,trinketPointer,nil,true) then
								if locale == "zhCN" then
									Squid_Alert_Big("è‡´ç›²>>", UnitClass(trinketPointer).. " (äº¤ç« )",2,3.5,2094)
								else
									Squid_Alert_Big("Blinded " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,2094)
								end
							end
							return
						else
							_Cast(sub.shadowStep,trinketPointer)
							C_Timer.After(.03,function()
								if _Cast(rogue.blind,trinketPointer,nil,true) then
									if locale == "zhCN" then
										Squid_Alert_Big("è‡´ç›²>>", UnitClass(trinketPointer).. " (äº¤ç« )",2,3.5,2094)
									else
										Squid_Alert_Big("Blinded " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,2094)
									end
								end
							end)
						end
					end
					--Sap
					if (timeSinceTrinket <= gcd or S or Vanish) and Energy >= 35 and not UnitAffectingCombat(trinketPointer) and _incapacitateDR(trinketPointer) >= lowestEnemy / 100 and not _CCcheck(trinketPointer) then
						if vanish_cd == 0 or S or Vanish then
							if _realDistance(trinketPointer) <= 10 then
								if not S and _Cast(1856) then
									Squid_Alert("Vanish",nil,nil,nil,1856)
								end
								if S or Vanish then
									CastSpellByID(6770,trinketPointer)
									if _Cast(6770,trinketPointer,nil,true) then
										Squid_Alert_Big("Sapped " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,6770)
									end
								end
								return
							else
								_Cast(36554,trinketPointer)
								C_Timer.After(.03,function()
									if _Cast(6770,trinketPointer,nil,true) then
										Squid_Alert_Big("Sapped " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,6770)
									end
								end)
							end
						end
					end
				end
			end

			--sap followup
			if vanish_cd == 0 or S or Vanish then
				for i=1,#Enemies do if _isHealer(Enemies[i]) or not theirHealer then
					local cc = _CCremains(Enemies[i])
					if cc > 0 and not UnitAffectingCombat(Enemies[i]) and not _isDummy(Enemies[i]) then
						local dr = _incapacitateDR(Enemies[i])
						if cc < 1.1 and gcd_remains < cc and dr >= .25 then
							if _distance(Enemies[i]) <= 10 then
								if dr == 1 and not S
								and (not mage_on_team_casting_cc or (mage_cc_tar and not unit_is_unit(mage_cc_tar,Enemies[i]))) then
									if _Cast(1856) then
										Squid_Alert("Vanish",nil,nil,3.5,1856)
									end
								end
								if S or Vanish then
									if _Cast(6770,Enemies[i],nil,true) then
										Squid_Alert_Big("Sapped " .. UnitClass(Enemies[i]),"(Followup)",nil,nil,6770)
									end
								end
								return
							else
								if dr == 1 then
									_Cast(36554,Enemies[i])
								end
							end
						end
					end
				end end
			end

			local sapped_target
			for i=1,#Enemies do if UnitDebuffID(Enemies[i],6770,"player") then
				sapped_target = Enemies[i]
			end end

			--Sap Stealth
			for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) then
				if Sappable(Enemies[i]) and (not sapped_target or _isHealer(Enemies[i]) or unit_is_unit(Enemies[i],sapped_target)) then
					if IsStealthed() or UnitBuffID('player', sub.buffs.shadowDance) or UnitBuffID('player', rogue.buffs.vanish) then
						if _distance(Enemies[i]) < 10 then
							if _Cast(6770,Enemies[i],nil,true) then
								Squid_Alert_Big("Sap " .. UnitClass(Enemies[i]),nil,4,nil,6770)
								return
							end
						elseif UnitAffectingCombat("player") and (_isHealer(Enemies[i]) or not their_healer) then
							if _Cast(36554,Enemies[i],nil,true) then
								Squid_Alert("Step " .. UnitClass(Enemies[i]),"(Sap)",4,nil,36554)
								return
							end
						end
					elseif _distance(Enemies[i]) < 10 or _spellCooldown(36554) == 0 then
						_Cast(185313)
					end
				end
			end end


			--Kidney
			for i = 1, #Enemies do
				if not _breakableCC(Enemies[i]) and valid_kidney_target(Enemies[i]) and _spellCooldown(rogue.kidneyShot) == 0 then
					if combo_points_deficit == 0 then
						if _meleeRange('player', Enemies[i]) then
							_Cast(rogue.kidneyShot, Enemies[i], nil, true)
						else
							_Cast(rogue.shadowStep, Enemies[i], nil, true)
						end
					end
				end
			end

			--mfd
			if UnitAffectingCombat("player") and combo_points_deficit >= 4 then
				for i=1,#Enemies do
					if _distance(Enemies[i]) < 30 then
						 _Cast(137619, Enemies[i], nil, true)
					end
				end
			end

			--Cheap shots
			for i = 1, #Enemies do
				if not _breakableCC(Enemies[i]) and valid_stun_target(Enemies[i]) and (dance_up or S) and _meleeRange('player', Enemies[i]) then
					if energy > 40 and (_stunDR(Enemies[i]) == 1 or unit_is_unit(Enemies[i],current_target) or lowestFriend < 25 or _isHealer(Enemies[i]) and lowestEnemy < 35) then
						_Cast(rogue.cheapShot, Enemies[i])
					end
				end
			end

			--Bomb the kidney
			if recentTrinket then
				if unit_is_unit(trinketPointer, "target") and _meleeRange('player', trinketPointer) and gcd <= .25 then
					if timeSinceTrinket <= 110 and (t_stun_remains >= 3 or _isSlowed(t)) and their_healer_cc_remains <= 1 then
						_Cast(rogue.smokeBomb)
					end
				end
			end

			-- claok evasion
			if _HP("player") < 40 + ((EnemiesAttacking("player") and 1 or 0) * 20) then
				_Cast(31224)
				_Cast(5277)
			end

		end

		--Action lists with call requirements
		local function Builders()
			if _valid(t) and build and gcd_remains == 0 then
				--Shuriken Storm
				if valid_enemies_around('player', 8) >= 2 and energy >= GetSpellCost(sub.shurikenStorm) and combo_points_deficit >= 1 then
					if _meleeRange(t) and not bcc8 then
						_Cast(sub.shurikenStorm)
					end
				end
				--Backstab
				if _meleeRange(t) and energy >= (GetSpellCost(sub.backstab) or 0) then
					if (deeperStrategemEnabled and combo_points <= 5) or (not deeperStrategemEnabled and combo_points <= 4) then
						_Cast(sub.backstab, t, true)
					end
				end
			end
		end

		local function offGCDCooldowns()
			--shadow_dance,use_off_gcd=1,if=!buff.shadow_dance.up&amp;buff.shuriken_tornado.up&amp;buff.shuriken_tornado.remains<=3.5
			if enemy_player_around then
				if current_target and _meleeRange(current_target) then
					if _stunDR(current_target) == 1 or _HP(current_target) < 30 + (their_healer_cc_remains * 4) then
						_Cast(sub.shadowDance)
					end
				end
			else
				--Use Dance off-gcd before the first Shuriken Storm from Tornado comes in.
				if not UnitBuffID('player', sub.buffs.shadowDance) and UnitBuffID('player', sub.buffs.shurikenTornado) and _buffRemains('player', sub.buffs.shurikenTornado) <= 3.5 then
					if _meleeRange(t) and _valid(t) then
						_Cast(sub.shadowDance)
					end
				end
			end
			--symbols_of_death,use_off_gcd=1,if=buff.shuriken_tornado.up&amp;buff.shuriken_tornado.remains<=3.5
			--(Unless already up because we took Shadow Focus) use Symbols off-gcd before the first Shuriken Storm from Tornado comes in.
			if UnitBuffID('player', sub.buffs.shurikenTornado) and _buffRemains('player', sub.buffs.shurikenTornado) <= 3.5 then
				if _meleeRange(t) and _valid(t) then
					_Cast(sub.symbolsOfDeath)
				end
			end
			--symbols_of_death,if=variable.snd_condition&amp;(talent.enveloping_shadows.enabled|cooldown.shadow_dance.charges>=1)&amp;(!talent.shuriken_tornado.enabled|talent.shadow_focus.enabled|cooldown.shuriken_tornado.remains>2)
			--Use Symbols on cooldown (after first SnD) unless we are going to pop Tornado and do not have Shadow Focus.
			if snd_condition and (envelopingShadowsEnabled or _spellChargeFrac(sub.shadowDance >= 1)) and (not shurikenTornadoEnabled or shadowFocusEnabled or _spellCooldown(sub.shurikenTornado) > 2) then
				if _meleeRange(t) and _valid(t) then
					_Cast(sub.symbolsOfDeath)
				end
			end
			--shadow_blades,if=variable.snd_condition&amp;combo_points.deficit>=2
			if snd_condition and combo_points_deficit >= 2 then
				if _meleeRange(t) and _valid(t) and t_is_boss then
					_Cast(sub.shadowBlades)
				end
			end

			--Castle Nathria Specific Blades Scenario
			if inInstance and instanceType == 'raid' and instanceName == "Castle Nathria" then
				--Boss specific cooldown management here.
				--[[
					~* Thought FLow *~
					Is the boss set to do something at a certain percentage? If so we want to use CDs whenever best ie. if boss has a damage taken debuff,
						so I think we would want to try and determine if we used our CDs on the opener would they be up during the actual burst phase?
						if ttd > base cooldown duration then its safe, if not we hold it
				--]]

			--shadow_dance,if=!buff.shadow_dance.up&amp;fight_remains<=8+talent.subterfuge.enabled
			elseif not UnitBuffID('player', sub.buffs.shadowDance) and squid_ttd(t) <= 8 + (subterfugeEnabled and 1 or 0) then
				if _valid(t) and _meleeRange(t) then
					_Cast(sub.shadowDance)
				end
			else
				--do nothing
			end

			--use_items,if=buff.symbols_of_death.up|fight_remains<20
			--Default fallback for usable items: Use with Symbols of Death.
			if UnitBuffID('player', sub.buffs.symbolsOfDeath) or squid_ttd(t) < 20 and t_is_boss and _valid(t) and _meleeRange(t) then
				if tContains( equipped_items, 173087 ) and GetItemCD ( ( 173087 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 173087 ) ) )
					Squid_Alert( "Darkmoon Deck: Voracity", nil, nil, nil, 3717310 )
				end
			end

		end

		local function Cooldowns()
				--flagellation,if=variable.snd_condition&amp;!stealthed.mantle
				--flagellation_cleanse,if=debuff.flagellation.remains<2
				--vanish,if=(runeforge.mark_of_the_master_assassin&amp;combo_points.deficit<=3|runeforge.deathly_shadows&amp;combo_points<1)&amp;buff.symbols_of_death.up&amp;buff.shadow_dance.up&amp;master_assassin_remains=0&amp;buff.deathly_shadows.down
				if (GetInventoryItemID('player', 9) == 172321 and combo_points_deficit <= 3) and UnitBuffID('player', sub.buffs.symbolsOfDeath) and UnitBuffID('player', sub.buffs.shadowDance) and (_buffRemains('player', sub.buffs.masterAssassinsMark) == 0 or nil) then
					if _meleeRange(t) and _valid(t) and t_is_boss then
						_Cast(rogue.vanish)
					end
				end
				--pool_resource,for_next=1,if=talent.shuriken_tornado.enabled&amp;!talent.shadow_focus.enabled
				--Pool for Tornado pre-SoD with ShD ready when not running SF.
				--Use Tornado pre SoD when we have the energy whether from pooling without SF or just generally.
				local pool_resource_for_next = shurikenTornadoEnabled and not shadowFocusEnabled
				--shuriken_tornado,if=energy>=60&amp;variable.snd_condition&amp;cooldown.symbols_of_death.up&amp;cooldown.shadow_dance.charges>=1
				if shurikenTornadoEnabled then
					if not pool_resource_for_next and energy >= GetSpellCost(sub.shurikenTornado) and snd_condition and _spellCooldown(sub.symbolsOfDeath) == 0 and _spellChargeFrac(sub.shadowDance) >= 1 then
						_Cast(sub.shurikenTornadoEnabled)
					end
				end
				--serrated_bone_spike,cycle_targets=1,if=variable.snd_condition&amp;!dot.serrated_bone_spike_dot.ticking&amp;target.time_to_die>=21|fight_remains<=5&amp;spell_targets.shuriken_storm<3

				--Covenant Stuff
				------------------------------------------------------------------------------------------------------------------------------------------------------
				--sepsis,if=variable.snd_condition&amp;combo_points.deficit>=1
				if covenantID == covenant.ids.nightFae then
					if snd_condition and combo_points_deficit >= 1 then
						if _meleeRange(t) and energy >= 20 and gcd_remains == 0 and _valid(t) and (t_is_boss or (arena or battleground)) then
							_Cast(covenant.nightFae.sepsis, t, true)
						end
					end
				end
				--echoing_reprimand,if=variable.snd_condition&amp;combo_points.deficit>=2&amp;(variable.use_priority_rotation|spell_targets.shuriken_storm<=4)
				if covenantID == covenant.ids.kyrian then
					if snd_condition and combo_points_deficit >= 2 and (use_priority_rotation or valid_enemies_around(t, 8) <= 4) then
						if _meleeRange('player', t) and energy >= 10 then
							_Cast(covenant.kyrian.echoingReprimand)
						end
					end
				end
				------------------------------------------------------------------------------------------------------------------------------------------------------
				--marked_for_death,target_if=min:target.time_to_die,if=raid_event.adds.up&amp;(target.time_to_die<combo_points.deficit|!stealthed.all&amp;combo_points.deficit>=cp_max_spend)
				--If adds are up, snipe the one with lowest TTD. Use when dying faster than CP deficit or not stealthed without any CP.

				--marked_for_death,if=raid_event.adds.in>30-raid_event.adds.duration&amp;combo_points.deficit>=cp_max_spend
				--If no adds will die within the next 30s, use MfD on boss without any CP.

				--echoing_reprimand,if=variable.snd_condition&amp;combo_points.deficit>=2&amp;(variable.use_priority_rotation|spell_targets.shuriken_storm<=4)

				--shuriken_tornado,if=talent.shadow_focus.enabled&amp;variable.snd_condition&amp;buff.symbols_of_death.up
				--With SF, if not already done, use Tornado with SoD up.
				if shurikenTornadoEnabled then
					if shadowFocusEnabled and snd_condition and UnitBuffID('player', sub.buffs.symbolsOfDeath) then
						if _meleeRange(t) and energy >= GetSpellCost(sub.shurikenTornado) then
							_Cast(sub.shurikenTornado)
						end
					end
				end
				--potion,if=buff.bloodlust.react|buff.symbols_of_death.up&amp;(buff.shadow_blades.up|cooldown.shadow_blades.remains<=10)
				--blood_fury,if=buff.symbols_of_death.up
				--berserking,if=buff.symbols_of_death.up
				--fireblood,if=buff.symbols_of_death.up
				--ancestral_call,if=buff.symbols_of_death.up
				--use_items,if=buff.symbols_of_death.up|fight_remains<20
				--Default fallback for usable items: Use with Symbols of Death.

				--Use Whenever it's up and no one has the buff .. cuz why not.
				if GetInventoryItemID('player', 13) == 178715 or GetInventoryItemID('player', 14) == 178715 and not UnitAffectingCombat('player') then
					if select(2,GetItemCooldown(178715)) == 0 then
						for i = 1, #Friends do
							if not UnitBuffID(Friends[i], 330067) and _distance('player', Friends[i]) <= 20 then
								if tContains( equipped_items, 178715 ) and GetItemCD ( ( 178715 ) ) == 0 then
									UseItemByName( tostring( GetItemInfo ( 178715 ) ) )
									Squid_Alert( "Mistcaller Ocarina", nil, nil, nil, 3717310 )
								end
							end
						end
					end
				end
		end

		local function Finishers()
			if gcd_remains == 0 then
				--variable,name=premed_snd_condition,value=talent.premeditation.enabled&amp;spell_targets<(5-covenant.necrolord)&amp;!covenant.kyrian
				--While using Premeditation, avoid casting Slice and Dice when Shadow Dance is soon to be used, except for Kyrian
				local premed_snd_condition = premeditationEnabled and Enemies_Around_Unit(t, 10) < (5 - (covenantID == covenant.ids.necroLord and 1 or 0)) and covenantID ~= covenant.ids.kyrian

				--variable,name=skip_rupture,value=master_assassin_remains>0  |!talent.nightstalker.enabled&amp;talent.dark_shadow.enabled&amp;buff.shadow_dance.up|spell_targets.shuriken_storm>=5
				--Helper Variable for Rupture. Skip during Master Assassin or during Dance with Dark and no Nightstalker.
				local skip_rupture = UnitBuffID('player', masterAssassinsMark) or (not nightStalkerEnabled and darkShadowEnabled and UnitBuffID('player', sub.buffs.shadowDance)) or Enemies_Around_Unit('player', 10) >= 5

				--slice_and_dice,if=!variable.premed_snd_condition&amp;spell_targets.shuriken_storm<6&amp;!buff.shadow_dance.up&amp;buff.slice_and_dice.remains<fight_remains&amp;refreshable
				if not premed_snd_condition and Enemies_Around_Unit('player', 10) < 6 and not UnitBuffID('player', sub.buffs.shadowDance) then
					if (UnitBuffID('player', rogue.buffs.sliceAndDice) and _buffRemains('player', rogue.sliceAndDice) < squid_ttd(t)) then
						if energy >= GetSpellCost(rogue.sliceAndDice) and _buffRemains('player', rogue.buffs.sliceAndDice) <= (3 or nil) then
							_Cast(rogue.sliceAndDice)
						end
					end
				end

				--rupture,if=!variable.skip_rupture&amp;target.time_to_die-remains>6&amp;refreshable
				--Keep up Rupture if it is about to run out.
				if _meleeRange(t) and _valid(t) and debuff_remains(t, sub.debuffs.rupture) <= 1 then
					if not skip_rupture and (squid_ttd(t) - debuff_remains(t, sub.debuffs.rupture)) > 6 and energy >= GetSpellCost(sub.rupture) then
						_Cast(sub.rupture, t, true)
					end
				end

				--rupture,cycle_targets=1,if=!variable.skip_rupture&amp;!variable.use_priority_rotation&amp;spell_targets.shuriken_storm>=2&amp;target.time_to_die>=(5+(2*combo_points))&amp;refreshable
				--Multidotting targets that will live for the duration of Rupture, refresh during pandemic.
				if not skip_rupture and not use_priority_rotation and Enemies_Around_Unit('player', 10) >= 2 and squid_ttd(t) >= (5 + (2 * combo_points)) then
					--refreshable
					for i = 1, #Enemies do
						if _meleeRange(Enemies[i]) and _valid(Enemies[i]) then
							if debuff_remains(Enemies[i], sub.debuffs.rupture) <= 1.2 and energy >= GetSpellCost(sub.rupture) then
								_Cast(sub.rupture, Enemies[i], true)
							end
						end
					end
				end

				--rupture,if=!variable.skip_rupture&amp;remains<cooldown.symbols_of_death.remains+10&amp;cooldown.symbols_of_death.remains<=5&amp;target.time_to_die-remains>cooldown.symbols_of_death.remains+5
				--Refresh Rupture early if it will expire during Symbols. Do that refresh if SoD gets ready in the next 5s.
				if not skip_rupture and debuff_remains(t, sub.debuffs.rupture) < _spellCooldown(sub.symbolsOfDeath) + 10 and _spellCooldown(sub.symbolsOfDeath) <= 5 and squid_ttd(t) - debuff_remains(t, sub.debuffs.rupture) > _spellCooldown(sub.symbolsOfDeath) + 5 then
					if _meleeRange(t) and _valid(t) and energy >= GetSpellCost(sub.rupture) then
						_Cast(sub.rupture, t, true)
					end
				end

				--black_powder,if=!variable.use_priority_rotation&amp;spell_targets>=4-debuff.find_weakness.down (316220)
				if not use_priority_rotation and valid_enemies_around('player', 10) >= 4 - (UnitDebuffID(t, sub.debuffs.findWeakness) and 1 or 0) then
					if energy >= GetSpellCost(sub.blackPowder) + 1 then
						_Cast(sub.blackPowder, t, true)
					end
				end

				--Eviscerate
				if _valid(t) and _meleeRange(t) and energy >= GetSpellCost(rogue.eviscerate) + 1 then
					_Cast(rogue.eviscerate, t, true)
				end
			end
		end

		local function stealthCooldowns()


			--Pvp
			--Use cold blood on CD for now?
			if (arena or battleground) and _valid(t) and _meleeRange(t) and _spellCooldown(sub.coldBlood) == 0 then
				_Cast(sub.coldBlood, t, true)
			end

			--variable,name=shd_threshold,value=cooldown.shadow_dance.charges_fractional>=1.75
			--Helper Variable
			local shd_threshold = _spellChargeFrac(sub.shadowDance) >= 1.75
			--vanish,if=(!variable.shd_threshold|!talent.nightstalker.enabled&amp;talent.dark_shadow.enabled)&amp;combo_points.deficit>1&amp;!runeforge.mark_of_the_master_assassin
			--Vanish if we are capping on Dance charges. Early before first dance if we have no Nightstalker but Dark Shadow in order to get Rupture up (no Master Assassin).
			if (not shd_threshold or not nightStalkerEnabled and darkShadowEnabled) and combo_points_deficit > 1 and GetInventoryItemID('player', 9) ~= 172321 then
				if t_is_boss and _valid(t) and _meleeRange(t) then
					_Cast(rogue.vanish)
				end
			end
			--variable,name=shd_combo_points,value=combo_points.deficit>=2+buff.shadow_blades.up
			--CP thresholds for entering Shadow Dance
			local shd_combo_points = combo_points_deficit >= 2 + (UnitBuffID('player', sub.buffs.shadowBlades) and 1 or 0)
			--variable,name=shd_combo_points,value=combo_points.deficit>=3,if=covenant.kyrian
				or combo_points_deficit >= 3 and covenantID == covenant.ids.kyrian
			--variable,name=shd_combo_points,value=combo_points.deficit<=1,if=variable.use_priority_rotation&amp;spell_targets.shuriken_storm>=4
				or combo_points_deficit <= 1 and use_priority_rotation and Enemies_Around_Unit('player', 10) >= 4

			--shadow_dance,if=variable.shd_combo_points&amp;(variable.shd_threshold|buff.symbols_of_death.remains>=1.2|spell_targets.shuriken_storm>=4&amp;cooldown.symbols_of_death.remains>10)
			--Dance during Symbols or above threshold.
			if shd_combo_points and (shd_threshold or _buffRemains('player', sub.buffs.symbolsOfDeath) >= 1.2 or Enemies_Around_Unit('player', 10) >= 4 and _spellCooldown(sub.symbolsOfDeath) > 10) then
				if _valid(t) and _meleeRange(t) then
					_Cast(sub.shadowDance)
				end
			end
			--shadow_dance,if=variable.shd_combo_points&amp;fight_remains<cooldown.symbols_of_death.remains
			--Burn remaining Dances before the fight ends if SoD won't be ready in time.
			if shd_combo_points and squid_ttd(t) < _spellCooldown(sub.symbolsOfDeath) then
				if not UnitBuffID('player', sub.buffs.shadowDance) then
					if _valid(t) and _meleeRange(t) then
						_Cast(sub.shadowDance)
					end
				end
			end
		end

		local function stealth()

			--Shadowstrike whenever possible
			if _valid(t) and _meleeRange(t) and GetSpellCost(sub.shadowStrike) then
				if gcd_remains == 0 and combo_points_deficit >= 1 then
					_Cast(sub.shadowStrike, t, true)
				end
			end

			--call_action_list,name=finish,if=buff.shuriken_tornado.up&amp;combo_points.deficit<=2
			--Finish at 3+ CP without DS / 4+ with DS with Shuriken Tornado buff up to avoid some CP waste situations.
			if UnitBuffID('player', sub.buffs.shurikenTornado) and combo_points_deficit <= 2 then
				Finishers()
			end

			--call_action_list,name=finish,if=spell_targets.shuriken_storm>=4&amp;combo_points>=4
			--Also safe to finish at 4+ CP with exactly 4 targets. (Same as outside stealth.)
			if valid_enemies_around('player', 10) >= 4 and combo_points >= 4 then
				Finishers()
			end

			--call_action_list,name=finish,if=combo_points.deficit<=1-(talent.deeper_stratagem.enabled&amp;buff.vanish.up)
			--Finish at 4+ CP without DS, 5+ with DS, and 6 with DS after Vanish
			if combo_points_deficit <= 1 - ((deeperStrategemEnabled and UnitBuffID('player', rogue.buffs.vanish)) and 1 or 0 ) then
				Finishers()
			end

			--shadowStrike,cycle_targets=1,if=debuff.find_weakness.remains<1&amp;spell_targets.shuriken_storm<=3&amp;target.time_to_die-remains>6
			--Up to 3 targets keep up Find Weakness by cycling Shadowstrike.
			for i = 1, #Enemies do
				if _valid(Enemies[i]) and _meleeRange(Enemies[i]) and gcd_remains == 0 and combo_points_deficit >= 1 then
					if debuff_remains(Enemies[i], sub.debuffs.findWeakness) < 1 and valid_enemies_around('player', 10) <= 3 and (squid_ttd(Enemies[i]) - debuff_remains(Enemies[i], sub.debuffs.findWeakness)) > 6 then
						_Cast(sub.shadowStrike, Enemies[i], true)
					end
				end
			end

			--shadowStrike,if=variable.use_priority_rotation&amp;(debuff.find_weakness.remains<1|talent.weaponmaster.enabled&amp;spell_targets.shuriken_storm<=4)
			--For priority rotation, use Shadowstrike over Storm with WM against up to 4 targets or if FW is running off (on any amount of targets)

			--shuriken_storm,if=spell_targets>=3+(buff.the_rotten.up|runeforge.akaaris_soul_fragment&amp;conduit.deeper_daggers.rank>=7)&amp;(buff.symbols_of_death_autocrit.up|!buff.premeditation.up|spell_targets>=5)
			local stealthedStorm = 0
			if UnitBuffID(sub.buffs.premeditation) then stealthedStorm = 1 else stealthedStorm = 0 end
			if UnitAffectingCombat('player') and gcd_remains == 0 and valid_enemies_around('player', 10) >= 3 + stealthedStorm and energy >= GetSpellCost(sub.shurikenStorm) and combo_points_deficit >= 1 then
				if _meleeRange(t) and not bcc8 then
					_Cast(sub.shurikenStorm)
				end
			end

			--shadowStrike,if=debuff.find_weakness.remains<=1|cooldown.symbols_of_death.remains<18&amp;debuff.find_weakness.remains<cooldown.symbols_of_death.remains
			--Shadowstrike to refresh Find Weakness and to ensure we can carry over a full FW into the next SoD if possible.
			if debuff_remains(t, sub.debuffs.findWeakness) <= 1 or _spellCooldown(sub.symbolsOfDeath) < 18 and debuff_remains(t, sub.debuffs.findWeakness) < _spellCooldown(sub.symbolsOfDeath) then
				if _valid(t) and _meleeRange(t) and energy >= GetSpellCost(sub.shadowStrike) and gcd_remains == 0 and combo_points_deficit >= 1 then
					_Cast(sub.shadowStrike, t, true)
				end
			end

			--gloomblade,if=buff.perforated_veins.stack>=5&amp;conduit.perforated_veins.rank>=13

			--Shadowstrike if nothing to do
			if _valid(t) and _meleeRange(t) and energy >= GetSpellCost(sub.shadowStrike) and gcd_remains == 0 then
				if combo_points_deficit >= 1 then
					_Cast(sub.shadowStrike, t, true)
				end
			end

		end

		local function auto_defensives()
			local auto_vial = SQUID.auto_vial
			local vial_hpp = SQUID.auto_vial_percent or 50
			if auto_vial and player_hp <= vial_hpp and energy >= GetSpellCost(rogue.crimsonVial) and gcd_remains == 0 and _spellCooldown(rogue.crimsonVial) == 0 then
				if not UnitBuffID('player', rogue.buffs.crimsonVial) then --This is mainly for Torghast where you can get no cooldown on vial, so not to spam it.
					_Cast(rogue.crimsonVial)
				end
			end
		end

		dynamicTargeting(10)
		--ALWAYS try to restealth .. need to code to not attack immune things later on, or buffs we don't like
		--if IsUsableSpell(rogue.stealth) then
		--    _Cast(rogue.stealth)
		--end

		--Run Rotation
		if not IsMounted() and not UnitChannelInfo('player') then
			--Poisons
			if not (arena or battleground) and not UnitIsAFK('player') and not UnitChannelInfo('player') and not _isMoving('player') then
				if not UnitBuffID('player', 315584) and (not GetBattlefieldStatus(1) == "none" or select(6,GetBattlefieldStatus(1)) ~= "ARENA") then
					_Cast(315584)
				elseif not UnitBuffID("player", 8679) and select(6,GetBattlefieldStatus(1)) == "ARENA" then
					_Cast(8679)
				end
				if not UnitBuffID('player', 3408) then
					_Cast(3408)
				end
			elseif (arena or battleground) and not UnitChannelInfo('player') and not _isMoving('player') then
				if not UnitBuffID('player', 8679) then
					_Cast(8679)
				end
				if not UnitBuffID('player', 3408) then
					_Cast(3408)
				end
			end

			--Auto Tricks
			if tricksTarget ~= nil and _valid(t) and _distance('player', t) < 5 and UnitThreatSituation('player') and UnitThreatSituation('player') > 0 then
				_Cast(rogue.tricksOfTheTrade, tricksTarget)
			end
			--Slice and Dice Pre combat
			if slice_and_dice and gcd_remains == 0 then
				_Cast(rogue.sliceAndDice)
			end
			----------- Defensives --------------
			if auto_defensives() then return true end;
			-------------------------------------
			----------- CDs ---------------------
			if Cooldowns() then return true end;
			if offGCDCooldowns() then return true end;
			-------------------------------------
			----------- Stealth -----------------
			if IsStealthed() or UnitBuffID('player', sub.buffs.shadowDance) or UnitBuffID('player', rogue.buffs.vanish) or UnitBuffID('player', sub.buffs.premeditation) then
				if stealth() then return true end;
			end
			-------------------------------------
			----------- Stealth CDs -------------
			if use_priority_rotation then
				if stealthCooldowns() then return true end;
			end
			if energy_deficit <= stealth_threshold then
				if stealthCooldowns() then return true end;
			end
			-------------------------------------
			----------- Finishers ---------------
			if combo_points_deficit <= 1 or squid_ttd(t) <= 1 and combo_points >= 3 or UnitBuffID('player', sub.buffs.symbolsOfDeathAutoCrit) and combo_points >= 4 then
				if Finishers() then return true end;
			end
			if Enemies_Around_Unit('player', 10) >= 4 and combo_points >= 4 then
				if Finishers() then return true end;
			end
			-------------------------------------
			----------- Builders ----------------
			if energy_deficit <= stealth_threshold then
				if Builders() then return true end;
			end
			--------------------------------------
		end


	end
















	--Get combat time stuff
		--[[
		local function get_combat_time(self,event,...)
			if SubPvE_combat_start_time == nil then
				SubPvE_combat_start_time = 0
			end
			SubPvE_combat_start_time = GetTime()
		end

		local cTime = CreateFrame("Frame")
		cTime:RegisterEvent("PLAYER_REGEN_DISABLED")
		cTime:SetScript("OnEvent",get_combat_time)

		local function getCombatTime()
			local combat_time
			if SubPvE_combat_start_time == nil then
				SubPvE_combat_start_time = 0
			end
			if combat_time == nil then
				combat_time = 0
			end
			if UnitAffectingCombat("player") then
				combat_time = GetTime() - SubPvE_combat_start_time
			end
			return combat_time
		end
		--]]

	----------> top priority <------------- ---
	-- fix time_to_max_cp and make energy + combo point pooling line up properly
	-- step kidney trinkets
	-- blinds
	-- stop auto into immunities
	-- wildseed buff needs to be immunity

	-- -------> nex priority <------------- ---

	-- cheap shot guardian of queens

	-- don't step / do stupid shit while disarmed

	-- shiv druid shapeshift onevent

	-- something else is happening that refreshes combat timer that i don't track, no idea what it is
		-- also think when combat drops on the unit a healer is healing, they lose combat too

	-- cheap healer over kidney if mage can 100% get sheep

	-- jesus takes the wheel while people are in seed

	-- if already in a sheep, don't need to kidney healer - kidney is exclusively better on the healer when he can be sapped out of it, otherwise kidney on KT is better for KP

	-- ccing the healer when target is low is really good when the target could die during it or a long chain can be made from it

	-- set use_symbols, use_dance, use_blades on goes

	-- kyrian potion

	-- sap stealth external

	-- sap gpy before it land

	-- cheap shot interrupt + fists/convoke

	-- kidney / blind cc target trinket

	-- cancel panda incap with stun ?????

	-- team offensive cooldowns as one unit, but what's most important is diminishing returns
		-- whether or not they can be used due to lockouts or cc on your teammates
		-- calculate how much damage your mage can do or whatever based on fire blast tracking and cooldowns and meteor and other cooldowns and shit
		-- calculate how much damage total you can do to someone in a double or triple cheap shot go

	-- pool combo points / energy ~6 sec before go, meanwhile draw for the user to move to the healer to kidney
		-- pool before every dance

	-- to get triple cheap shot and do full damage, either
		-- 1. have shot in the dark or shadow focus
		-- 2. pool to 90+ energy - symbols and 35, have MFD, and only use symbols after the first cheap

	-- initiate cc chain, maintain cc chain as long as possible, once you pull a defensive cooldown stop the go and wait for next dr

	-- enemy team has both personal cds and shared cds, amz / darkness is a shared cd, shaman wall is personal cd, trinkets can be shared cooldowns but also personal cds

	-- not only are goes where a kill is guaranteed necessary, if going on one target could pull more cooldowns or set your next go up for a guaranteed kill it's the best

	-- diminishing returns on all units

	-- dance goes
		-- 1. subterfuge + prey on the weak
			-- a. mfd ready: pool 60+ energy > kidney healer > step + dance + cold blood > cheap shot > symbols > (echoing / shadowstrike) > eviscerate + mfd > eviscerate > cheap shot > (echoing / shadowstrike) > cheap shot > eviscerate
				-- a notes: if echoing replaced shadowstrike in this variant, there is 1 extra shadowstrike usable at the end, often resulting in another finisher
			-- b. no mfd: pool 90+ energy > kidney healer > step + dance + cold blood > cheap shot > symbols >
																												-- echoing if available >
																													----> 4+ cp eviscerate > shadowstrike > cheap shot > eviscerate > cheap shot > shadowstrike > eviscerate
																													----> <4 cp shadowstrike > eviscerate > cheap shot > shadowstrike > cheap shot > eviscerate > shadowstrike
																												-- shadowstrike >
																													----> 4+ cp eviscerate > shadowstrike > cheap shot > eviscerate > cheap shot > no more energy :(

	-- energy costs:
		-- 1.a. = (200 - echoing_usable*30) over 8 second dance


	-- whenever a go with cross cc on the healer is possible on your target, on screen drawing will show
		-- 1. what offensive cooldowns are available to use into the stun on the kill target
		-- 2. what cc will be available to chain on the healer after the initial cc
		-- 2. defensives and trinkets that could be used to survive your go, including cooldowns that can disrupt your cc chain and STOP your go (like sanc/bop/reverse magic/bubble)
			-- we need to classify the debuff types of ALL crowd control's debuff type and which debuff types these cooldowns disrupt. (blind = physical, bop disrupts = physical, poly = magic, reverse disrupts = magic, sanc disrupts = stuns/fears/whatever)
		-- 3. upcoming offensive cooldowns and enemy defensive cooldowns will be displayed

	-- cooldowns = {
	-- 	defensives = {
	-- 		survival = {
	-- 			["Barkskin"] = {reduction=20, base_cd=60, usable_in_cc={["Stuns"]=true}},
	-- 			["Feint"] = {reduction=30, base_cd=15},
	-- 		}
	-- 		disruptive = {
	-- 			["Blessing of Sanctuary"] = {debufftypes={["Fear"]=true, ["Stun"]=true, ["Silence"]=true}, base_cd=45},
	-- 			["Reverse Magic"] = {debufftypes={["Magic"]=true}, base_cd=90},
	-- 			["Blessing of Protection"] = {debufftypes={["Physical"]=true, base_cd=69}},
	-- 		}
	-- 	}
	-- }

	-- crowd_control = {
	-- 	["Stun"] = {
	-- 		["HoJ"] = {debufftype="Magic"},
	-- 		["Kidney"] = {debufftype="Physical"},
	-- 	},
	-- 	["Incapacitate"] = {
	-- 		["Sheep"] = {debufftype="Magic"},
	-- 		["Sap"] = {debufftype="Physical"},
	-- 	},
	-- 	["Disorient"] = {
	-- 		["Blind"] = {debufftype="Physical"},
	-- 	},
	-- 	["Fear"] = {
	-- 		["Fear"] = {debufftype="Magic"},
	-- 		["Psychic Scream"] = {debufftype="Magic"},
	-- 	},
	-- 	["Silence"] = {
	-- 		["Silence"] = {debufftype="Magic"},
	-- 	}
	-- }

	-- player can choose to press the button at any time to start the go, or wait for upcoming offensives
	-- if script sees an opportunity to land a guaranteed kill because of no trinkets or immunities available from the enemy team, it will automatically swap on that target
	-- after giving both the rogue and mage players a heads up alert

	-- cc, defensives,

	-- get trinket data like arenaframe addons do so we know if people are playing relent or adap

	-- get enemy rogue's current position from distract missile ???

	-- set load mode to "kill" when we have a go where the enemy we are attacking is in a stun or < 30% hp, cannot receive heals or is below 30% hp, does not have a trinket or life saving defensive, and cannot be saved by another person's trinket or defensive
		-- like during a bomb go for example, or when both the healer and target are in cc without trinkets and no go-stopping defensives are up

	-- don't do goes when running away from enemies and healer is in cc?

	-- kidney off target on goes - stun dr on target is <= gcd, dance is ready, target is not immune and cds don't extend past this window
		-- pool energy before this ( time to the drs lining up - energy time to max )
		-- step if necessary, not running towards target
		-- blind healer is better here if they have trinket

	-- blind on trinket

	-- bomb on stun go
		-- target has no trinket? don't need to go for kidney
		-- healer is far away?
		-- healer is missing, but our mage is here with us to pump and we have all cds? so we bomb here and our opener will handle blades and such

	-- kick certain spells out of stealth, don't overlap stuns with certain important interrupts unless they're running away fast or on events like roll and shit

	-- auto attack totems, track auto attack timer to do it perfectly inbetween autos with minimal time off target?

	-- lsit of every cooldown in arena
		-- which ones can be used while ccd (and what type of cc)
		-- which ones do teammates give to each other
			-- use this info to pick the best kill target based on trinkets and usable cds!
	-- otherwise, goes are on target and we can swap focus with keybind

	-- keybinds to perform certain openers,
		-- cheap shot - cold blood, cheaps target (step if far), dance + symbols, blinds healer if applicable, step sap / kidney's trinket, blades once healer is cc'd or on bomb
		-- shadowstrike - cold blood, shadow blades, shadow strike + dance + symbols, cheap shot, evisc, mfd, evisc
			-- auto kidney healer if we're close on one of these openers? - cold blood, mfd+kidney healer, step kill target and continue rotation

	-- auto re-target last target if they were not a visible unit recently (last_target_time_visible?, start tracking when UnitIsVisible(last_target) is no more

	-- continue cc chains as long as possible until cooldowns are forced and your cds are over
		-- know what we have for the healer, display alerts of how we're going to chain cc off of what he's in
		-- track how long they have been in cc for, maybe make an alert for how long the cc chain was lmao
		-- don't followup with sap when mage is casting sheep or ring on the target

	-- dr is set to 18.45 - something up to like 200 ms / 18.25 drr is ok for cheap shot gap

	-- prioritize shadowstrike over triple dr cheap shot when load mode is "kill" or master assassin is up

	-- symbols dmg increase doesn't affect cold blood but it does give us a guaranteed crit shadowstrike
		-- don't use offensive vanish before using the free crit shadowstrike from symbols? (just don't use symbols at capped-1 combo points?)
	--

	-- Covenant Data
	local covenants = {
		["None"] = 0,
		["Kyrian"] = 1,
		["Venthyr"] = 2,
		["NightFae"] = 3,
		["Necrolord"] = 4
	}

	local function bin(arg)
		return arg and 1 or 0
	end

	function Squid_CheapShot_Opener()
	end
	function Squid_Shadowstrike_Opener()
	end
	function Squid_FocusSwap()
	end
	function Squid_HealerSwap()
	end
	function Squid_CancelSwap()
	end

	-- our team is one unit, with different CC abilities, we can work to chain cc on the healer
	-- draw when someone on your team is trying to chain cc, and stop the script from doing it
	local function build_our_unit()

		local unit = {}

		-- we are a part of the unit :)
		unit["player"] = {
			cc = { name="blind", dr="disorient", duration=8, can_do_it=function(unit) return _distance(unit) < 10 and not _immunePhysical(unit) end }
		}

		unit["player"] = {
			cc = { name="hoj", dr="stun", duration=6, can_do_it=function(unit) return _distance(unit) < 15 and not _immuneMagic(unit) end }
		}

		local groupsize = GetNumGroupMembers()

	end

	local go_stopping_defensives = {

		-- Rogue
		1966, -- Feint, 30% damage reduction

		-- Mage
		110909, -- Alter Time, Heals Back to Initial HP - Worthless if we can purge

	}

	function go_stopping_defensive_remains(unit)

		-- how long does a defensive remain on this person which makes starting a go pointless?
		local buffs = _buffFromTable(unit,go_stopping_defensives,true,true);

		table.insert(buffs,{r=physical_immunity_remains(unit),id=select(2,physical_immunity_remains(unit))})

		-- we can start our go into certain buffs like feint before they're completely over
		for i=1,#buffs do
			if buffs[i].id == 1966 then
				buffs[i].r = buffs[i].r - 1 -- we can go if 1 sec of feint remains
			end
		end

		table.sort(buffs,function(x,y) return x.r > y.r end);

		return buffs[1].r, buffs[1].id
		-- return max( physical_immunity_remains(unit), buffs[1] and buffs[1].r or 0 ), buffs[1] ~= 0 and buffs[1].id or physical_immunity_remains(unit) and select(2, physical_immunity_remains(unit))
	end

	-- execute with double eviscerate ?
	function eviscerate_damage(unit, cp, threshold, double)

		if _immunePhysical(unit) then return 0 end

		cp = cp or UnitPower("player",4)

		if cp == 0 then return 0 end

		if not unit_is_player(unit) then return 0 end

		local class = select(2,UnitClass(unit))

		local armor_type = {
			["PRIEST"] = (1 - .11),--"Cloth", ~ 9-12% physical damage reduction from cloth?
			["MAGE"] = (1 - .11),--"Cloth",
			["WARLOCK"] = (1 - .13), --"Leather", -- cause demon armor? we'll just put them between cloth and leather
			["ROGUE"] = (1 - .15), --"Leather",
			["DRUID"] = (1 - .15), --"Leather",
			["DEMONHUNTER"] = (1 - .165), --"Leather", -- these fuckers don't take damage
			["MONK"] = (1 - .15), --"Leather",
			["HUNTER"] = (1 - .275), --"Mail",
			["SHAMAN"] = (1 - .275), --"Mail",
			["PALADIN"] = (1 - .425), --"Plate",
			["WARRIOR"] = (1 - .425), --"Plate",
			["DEATHKNIGHT"] = (1 - .425), --"Plate",
		}

		-- table of all the damaging cooldown shits here and their "cost",
		-- function inside the function that does necessary crit calculations post addup only when vanish is part of the combination,
		-- returns the cheapest combination to kill the unit with an evisc?

		-- just redo the calculations in the evisc damage function before giving them here
		-- then put the cooldowns in a table here, sort by least expensive, add up from each extra cd and compare to hp
		-- then assign upvalues to which cds we are going to use and then use them

		local prev_gcd = Prev_GCD(1)

		local er_stacks = max(_buffStacks("player", 323558), _buffStacks("player", 323559), _buffStacks("player", 323560))
		local er_ready = er_stacks > 0 and cp == er_stacks

		local fw_up = UnitDebuffID(unit, 316220, "player")
		local ma_up = UnitBuffID("player",340094)
		local dance_bonus = UnitBuffID("player",185422) and IsPlayerSpell(245687)
		local dance_bonus2 = UnitBuffID("player",185422) and IsPlayerSpell(14062)
		local symbols_up = UnitBuffID("player", 212283)
		local raw_effect = GetSpellEffect(196819)
		local eviscerate_effect = (raw_effect / 5) * (er_ready and 7 or cp) + (double and (raw_effect / 5) * 5 or 0)

		local runeforge = (GetInventoryItemID("player",9) == 172321 and "Crit") -- Master assassin
					  or (GetInventoryItemID("player",11) == 178926 and "Crit")
					  or (GetInventoryItemID("player",12) == 178926 and "Crit")

		local dance_cost = _spellCooldown(185313)
		local vanish_cost = _spellCooldown(212283)

		local magic_immune = _immuneMagic(unit)

		-- arg: threshold, return the cheapest combination of cooldowns needed to reach this amount of damage
		-- potential mods sorted by lowest to highest cost...
		local potential_mods = {
			{item="Badge", mod=0.08, cost=20, usable=(IsEquippedItem(175884) and GetItemCD(175884) <= 0 or IsEquippedItem(175921) and GetItemCD(175921) <= 0)}, -- badge, ~8% damage increase
			{spell=212283, mod=0.15, cost=30, usable=(_spellCooldown(212283) == 0)}, -- symbols of death, +15% increase
			{spell=185313, mod=0.3, cost=80, usable=(IsPlayerSpell(245687) and _spellCooldown(185313) == 0)}, -- dance with dark shadow, +30% increase
			{spell=185313, mod=0.12-bin(arena)*0.04, cost=80, usable=(IsPlayerSpell(14062) and _spellCooldown(185313) == 0)}, -- dance with nightstalker, +8-12% increase
		}

		table.sort(potential_mods,function(x,y) return x.cost < y.cost end)

		local current_damage = eviscerate_effect

		local additive_mods = 1

		-- Currently active additive modifiers

		-- 5% badge
		if UnitBuffID("player", "Gladiator's Badge") then
			additive_mods = additive_mods + .08 -- 8% from badge...?
		end
		-- 15% symbols
		additive_mods = additive_mods + (symbols_up and .15 or 0)
		-- 30% dance + dark shadow
		additive_mods = additive_mods + (dance_bonus and .3 or 0)
		-- 8-12% dance + nightstalker
		additive_mods = additive_mods + (dance_bonus2 and 0.12-bin(arena)*0.04 or 0)

		local function post_additive(number, simulate_ma)

			-- guaranteed crit from master assassin
			number = number * ((ma_up or simulate_ma) and 1.75 or 1)

			-- 50% extra shadow damage with find weakness... is it indirectly affected by armor because it's calculated post armor damage reduction? nah right?
			local shadow_damage = 0
			shadow_damage = shadow_damage + (fw_up and not magic_immune and number * .5 or 0)

			-- base physical damage of eviscerate modified by armor
			number = number * (armor_type[unit] and (armor_type[unit] * (1 - (fw_up and .3 or 0))) or 1)

			-- add the shadow damage after armor mitigation
			number = number + shadow_damage

			return number

		end

		local can_vanish = runeforge == "Crit" and _spellCooldown(1856) == 0 and not ma_up
		local vanish_cost = 120 - bin(IsPlayerSpell(212081))*45

		-- table that will store the mods we use to meet the threshold
		local mods_used = { }

		local function current_mod()
			local mods = additive_mods -- current additive mods
			-- add together any mods used in potential damage calculation
			for i=1,#mods_used do if mods_used[i] and mods_used[i].mod then
				mods = mods + mods_used[i].mod
			end end
			return mods
		end

		local calculate_for_vanish
		local potential_damage = current_damage

		for i=1,#potential_mods do
			local cd = potential_mods[i]
			if cd.usable then
				some_usable_mods = true
				local new_potential = potential_damage
				-- simulate for vanish first if the cost is lower
				if can_vanish and vanish_cost < cd.cost then
					if post_additive(new_potential, true) >= threshold then
						table.insert(mods_used,{spell=1856, usable=can_vanish})
						calculate_for_vanish = true
						break -- break the loop if vanish was cheaper than this cd and met the threshold
					else
						-- apply all current additive modifiers + mods to be used + the mod of the current cd
						new_potential = new_potential * (current_mod() + cd.mod)
						-- apply post additive modifiers
						new_potential = post_additive(new_potential)
						if new_potential >= threshold then
							table.insert(mods_used,cd)
							break -- break the loop if we have met the threshold
						else
							-- calculate post-additive and/or potential vanish if it's the last cooldown and we haven't met the threshold
							if i >= #potential_mods then
								-- local final_potential = post_additive(potential_damage * (current_mod() + cd.mod), can_vanish)
								if can_vanish then
									table.insert(mods_used,cd)
									table.insert(mods_used,{spell=1856, usable=can_vanish})
									calculate_for_vanish = true
								end
							else
								table.insert(mods_used,cd) -- add this cd to the table of cds that will be used if it didn't meet the threshold
							end
						end
					end
				else
					-- apply all current additive modifiers + mods to be used + the mod of the current cd
					new_potential = new_potential * (current_mod() + cd.mod)
					-- apply post additive modifiers
					new_potential = post_additive(new_potential)
					if new_potential >= threshold then
						table.insert(mods_used,cd)
						break -- break the loop if we have met the threshold
					else
						-- calculate post-additive and/or potential vanish if it's the last cooldown and we haven't met the threshold
						if i >= #potential_mods then
							-- local final_potential = post_additive(potential_damage * (current_mod() + cd.mod), can_vanish)
							if can_vanish then
								table.insert(mods_used,cd)
								table.insert(mods_used,{spell=1856, usable=can_vanish})
								calculate_for_vanish = true
							end
						else
							table.insert(mods_used,cd) -- add this cd to the table of cds that will be used if it didn't meet the threshold
						end
					end
				end
			elseif i >= #potential_mods then
				local final_potential = post_additive(potential_damage * (current_mod() + cd.mod), can_vanish)
				if can_vanish then
					table.insert(mods_used,{spell=1856, usable=can_vanish})
					calculate_for_vanish = true
				end
			end
		end

		potential_damage = post_additive(current_damage * current_mod(), calculate_for_vanish)

		-- apply all additive modifiers to current damage before armor reduction
		current_damage = current_damage * additive_mods

		-- calculate current damage post additive modifiers
		current_damage = post_additive(current_damage)

		-- returns
		-- 1, current eviscerate effect
		-- 2, potential eviscerate effect
		-- 3, whether potential damage was greater than given threshold
		-- 4, table of cooldowns used in the potential damage calculations
		return current_damage, potential_damage, threshold and potential_damage >= threshold or false, mods_used
	end

	local function smooth_step(unit, ml_or)
		if _spellCooldown(36554) > 0 then return false end
		if already_stepped and GetTime() - already_stepped < .2 then return false end
		local px,py,pz = GetPlayerPosition()
		local fdir = ObjectFacing("player")
		local x,y,z = px + 2 * math.cos(fdir), py + 2 * math.sin(fdir), pz
		if _Cast(36554,unit) then
			StopMovingAndLock()
			C_Timer.After((ml or .245),function() SetMovementLocked(false) end)
			C_Timer.After(.15, function() if player_step and GetTime() - player_step <= .15 then _faceLocation(x,y,z) end end)
			already_stepped = GetTime()
			return true
		end
	end

	function Squid_SubPvP()

		-- disable the shit
		-- if nil == nil then return end

		local time = GetTime()
		local latency = squid_avg_latency
		local groupsize = GetNumGroupMembers()
		local update = 2/GetFramerate()
		local buffer = latency + update + .1
		local haste = UnitSpellHaste("player")
		local gcd = 1.5/(1+(haste/100))
		local gcd_remains = GetGCD()
		local combat = UnitAffectingCombat("player")
		local player_hp = _HP("player")
		local player_disarmed = unit_disarmed("player")
		local player_combat = UnitAffectingCombat("player")
		local player_has_dot = unit_has_dot("player")
		local player_immune = _immuneCheck("player",nil,true)
		local bcc10 = _bccAM(10)

		local cap_bot = SQUID.cap_bot

		local combat_ends = player_combat and 6 or 0
		if player_combat_tracker then
			combat_ends = 6 - (time - player_combat_tracker)
		end

		if player_combat and combat_ends <= 4 then
			Squid_Alert("Combat Ends in " .. max(math.floor(combat_ends),1))
		end

		-- stop script while eating, stealth while eating
		local eating = UnitBuffID("player",167152)
		if eating then
			if not player_combat and _Cast(1784) then
				Squid_Alert("Stealth",nil,nil,nil,1784)
				return
			end
			return
		end

		-- stop script while mounted or flying
		if IsMounted() or IsFlying() then return end

		--check if unit is valid (immunes, dead, breakable cc etc)
		local function _valid(unit,immune,nocheck)
			if not unit then return false end
			return (nocheck or UnitCanAttack("player",unit))
			and (nocheck or not UnitIsDeadOrGhost(unit))
			and not _breakableCC(unit)
			and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
			and ((arena and unit_is_player(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))));
		end

		--our current target
		local t = current_target
		if not UnitIsVisible(t) then t = nil end

		local function valid_physical(after,unit)

			if not unit then unit = t end
			if not unit then return false end
			if not UnitIsVisible(unit) then return false end

			if UnitIsDeadOrGhost(unit) then return false end

			if arena and not unit_is_player(unit) then return "pet" end

			if not arena and not UnitAffectingCombat(unit) and not _isDummy(unit) and not unit_is_player(unit) then return false end

			if UnitCanAttack("player",unit)
			and (not _breakableCC(unit) or not arena and not unit_is_player(unit))
			and physical_immunity_remains(unit) <= after then
				return true
			end

		end

		local valid_attackable_target = t and UnitCanAttack("player",t)
		local valid_physical_target = valid_physical(0)

		local target_hp = valid_attackable_target and _HP(t) or 100
		local target_in_combat = valid_attackable_target and UnitAffectingCombat(t)

		--dots on target
		local target_rupture_remains = valid_attackable_target and _debuffRemains(t, 1943, "player") or 0
		local target_rupture_ticking = target_rupture_remains > 0

		local moving_towards_time = moving_towards_unit_duration(t,.11)
		local moving_towards = _movingTowards(t,.11)
		local moving_towards_target = valid_attackable_target and moving_towards and moving_towards_time > .15
		local moving_towards_long = valid_attackable_target and _unitIsFacingUnit("player",t,45) and moving_towards and moving_towards_time > .265
		local moving_towards_verylong = valid_attackable_target and _unitIsFacingUnit("player",t,45) and moving_towards and moving_towards_time > .5

		local moving_away = moving_away_from(t, select(2,GetUnitSpeed("player")) * .6)
		local fleeing_from_target = valid_attackable_target and moving_away

		local target_stun_remains = valid_attackable_target and _stunRemains(t) or 0

		local function fleeing_from_unit(unit, eh) return moving_away_from(unit, eh or select(2,GetUnitSpeed("player")) * .6) end

		local melee_range_target = valid_physical_target and _meleeRange(t)
		local distance_target = valid_physical_target and _distance(t) or 0

		local los_target = valid_attackable_target and _LoS(t)

		if follow_unit_until then
			local unit, endtime = unpack(follow_unit_until)
			if unit and UnitIsVisible(unit) and endtime - time > 0 then
				local x,y,z = ObjectPosition(unit)
				if not _amIfacing(unit) then
					MoveTo(x,y,z,true)
				else
					MoveTo(x,y,z)
				end
			end
		end

		if valid_physical_target and last_suck and time - last_suck < .5 and was_moving_towards_target and distance_target > 5 and (not last_shadowstep or time - last_shadowstep > 5) then
			if smooth_step(current_target,.1) then
				Squid_Alert("Shadowstep", "(Ursol's Vortex)", 5, nil, 36554)
				last_shadowstep = time
				follow_unit_until = {current_target, time + .55}
			end
		end

		if moving_towards_target then
			was_moving_towards_target = true
		elseif (not last_suck or time - last_suck > .5) and not UnitDebuffID("player",127797) then
			was_moving_towards_target = false
		end

		local energy = UnitPower("player")
		local energy_max = UnitPowerMax("player")
		local energy_deficit = energy_max - energy
		local energy_regen = GetPowerRegen()
		local energy_time_to_max = energy_deficit / energy_regen

		-- 8.33 repeating energy per second after dance
		local master_of_shadows_remains = _buffRemains("player",196980)

		function energy_after_time(elapsed)
			local mas_benefit = (min(elapsed,master_of_shadows_remains))*8.3333
			local regen_over_time = energy_regen*elapsed
			return min(energy_max, energy + mas_benefit + regen_over_time)
		end

		function energy_gained_over_time(elapsed)
			local mas_benefit = (min(elapsed,master_of_shadows_remains))*8.3333
			local regen_over_time = energy_regen*elapsed
			return mas_benefit + regen_over_time
		end

		local function energy_time_to(amount)
			local time_to_amount = max ( 0, ( amount - energy ) / energy_regen )
			return time_to_amount
		end

		local combo_points = UnitPower("player",4)
		local combo_points_max = UnitPowerMax("player",4)
		local combo_points_deficit = combo_points_max - combo_points

		local cp = combo_points

		local dance_remains = _buffRemains("player",185422)
		local dance_up = dance_remains > 0

		local dance_base_cd = 60
		local dance_charges,dance_max_charges = GetSpellCharges(185313)

		local dance_total_cd = dance_base_cd * dance_max_charges
		local dance_charges_frac = _spellChargeFrac(185313)
		local dance_full_recharge_time = dance_total_cd - (dance_charges_frac*dance_base_cd)
		local dance_next_charge_cd = (math.ceil(dance_charges_frac) - dance_charges_frac) * dance_base_cd

		local dance_cd = _spellCooldown(185313)

		local dance_adjusted_cd = (dance_cd > 0 and dance_cd*.8 or 0)

		local time_to_max_cp
		if not time_to_max_cp then
			local rounded_max_cp = combo_points_deficit
			if rounded_max_cp % (dance_up and 2 or 1) ~= 0 then rounded_max_cp = rounded_max_cp + 1 end
			local gcds_req = (rounded_max_cp/(dance_up and 2.25 or 1.25))
			local energy_gained_over_time = (energy_regen*gcd)*gcds_req
			local energy_req = (gcds_req*37.5)-energy_gained_over_time
			local time_for_energy = (energy_req/energy_regen)-(energy/energy_regen)
			time_to_max_cp = gcds_req * gcd + time_for_energy
		end
		if time_to_max_cp < 0 then time_to_max_cp=0 end

		local time_to_next_max_cp
		if not time_to_next_max_cp then
			local rounded_max_cp = 6
			local gcds_req = (rounded_max_cp/(dance_up and 2 or 1.15))
			local energy_gained_over_time = (energy_regen*gcd)*gcds_req
			local energy_req = (gcds_req*37.5)-energy_gained_over_time
			local time_for_energy = (energy_req/energy_regen)-(energy/energy_regen)
			time_to_next_max_cp = gcds_req * gcd + time_for_energy
		end
		if time_to_next_max_cp < 0 then time_to_next_max_cp=0 end

		local enveloping_shadows_enabled = IsPlayerSpell(238104)
		local mfd_enabled = IsPlayerSpell(137619)
		local subterfuge_enabled = IsPlayerSpell(108208)
		local nightstalker_enabled = IsPlayerSpell(14062)
		local snd_remains = _buffRemains("player", 315496)
		local snd_up = snd_remains > 0

		local vigor_enabled = IsPlayerSpell(14983)
		local master_of_shadows_enabled = IsPlayerSpell(196976)
		local shadow_focus_enabled = IsPlayerSpell(108209)
		local alacrity_enabled = IsPlayerSpell(193539)
		local dark_shadow_enabled = IsPlayerSpell(245687)

		local stealth_id = subterfuge_enabled and 115191 or 1784
		local stealth_up = UnitBuffID("player",stealth_id)
		local subterfuge_remains = _buffRemains("player",115192)
		local subterfuge_up = subterfuge_remains > 0

		local shot_in_the_dark_up = UnitBuffID("player",257506)
		local shot_in_the_dark_enabled = IsPlayerSpell(108209)

		local vanish_up = UnitBuffID("player",11327)
		local vanish_cd = _spellCooldown(1856)

		local symbols_remains = _buffRemains("player", 212283)
		local symbols_up = symbols_remains > 0
		local symbols_cd = _spellCooldown(212283)
		local symbols_crit_up = UnitBuffID("player", 227151)

		local kidney_cd = _spellCooldown(408)
		local step_cd = _spellCooldown(36554)
		local blind_cd = _spellCooldown(2094)
		local mfd_cd = _spellCooldown(137619)

		local is_kyrian =  C_Covenants.GetActiveCovenantID() == covenants["Kyrian"]-- IsPlayerSpell(323547)

		-- Call Kyrian Steward
		if is_kyrian then
			if GetItemCount(177278) < 3 and Free_Bag_Slots() > 0 then
				if UnitBuffID("player", 32727) and GetNumGroupMembers() > 1 then
					_Cast(324739)
				end
			end
		end

		local er_ready
		if GetUnitChargedPowerPoints("player") then
			local points = GetUnitChargedPowerPoints("player")
			for i=1,#points do
				er_ready = combo_points == points[i]
			end
		end

		local runeforge = (GetInventoryItemID("player",9) == 172321 and "Crit") -- Master assassin
					  or (GetInventoryItemID("player",11) == 178926 and "Crit")
					  or (GetInventoryItemID("player",12) == 178926 and "Crit")


		local master_assassin_remains = _buffRemains("player",340094)
		local master_assassin_up = master_assassin_remains > 0

		-- set use_symbols, use_dance, use_blades
		local use_blades
		if should_use_blades and time - should_use_blades < 1 then
			use_blades = true
		end

		-- sprint gapclose
		if moving_towards_cctar then
			if _Cast(2983) then
				Squid_Alert("Sprint",nil,nil,nil,2983)
			end
		end

		--- fucking shit potion
		if player_hp < 25 then
			if GetItemCount(177278) > 0 and select(2,GetItemCooldown(177278)) == 0 then
				UseItemByName(tostring(GetItemInfo(177278)))
				Squid_Alert("Kyrian Shit Soup",nil,nil,nil,69)
			end
		end

		-- Poisons
		if not vanish_up and not dance_up then
			-- Wound
			if _buffRemains("player",8679) < 600 - (player_combat and 595 or 0) then
				if _Cast(8679) then
					Squid_Alert("Wound Poison", nil, nil, nil, 8679)
					return
				end
			end
			-- Crippling
			if _buffRemains("player",3408) < 600 - (player_combat and 595 or 0) then
				if _Cast(3408) then
					Squid_Alert("Crippling Poison", nil, nil, nil, 3408)
					return
				end
			end
		end

		object_first_detected = object_first_detected or {}

		local totems = {
			101398,	--Psyfiend
			119052,	--War Banner
			104818,	--Ancestral Protection Totem
			53006,	--Spirit Link Totem
			2630,	--Earthbind Totem1
			60561,	--Earthgrab Totem
			-- 61245,	--Capacitor Totem
			5925,	--Grounding Totem
			-- 105425,	--Skyfury Totem
			105427,	--Skyfury Totem
			11137,	--Skyfury Totem
			-- 5913,	--Tremor Totem
			105451,	--Counterstrike Totem
			6112,	-- windfury totem?
		}

		-- totem stomp
		local function Stomp(totem,name,important)
			local hp = UnitHealth(totem)
			local maxhp = UnitHealthMax(totem)
			if hp <= 1 then return false; end
			if not object_first_detected[totem] then
				object_first_detected[totem] = time
			else
				if time - object_first_detected[totem] > max(.35,minDelayTime*1.8) then
					if not load_mode or important then
						if _LoS(totem) then

							-- auto attack
							if hp <= 100 and _meleeRange(totem) then
								if _amIfacing(totem) then
									if not t or not tContains(totems, ObjectID(t)) then
										TargetUnit(totem)
										StartAttack(totem)
										recent_totem_stomp = time
										Squid_Alert_Big("Stomp " .. name, "(Auto Attack)", 4, nil, 6603)
										object_first_detected[totem] = nil
									end
								elseif _distance(totem) < 2 then
									-- move to it and attack?
									-- local x,y,z=ObjectPosition(totem)
									-- MoveTo(x,y,z)
									-- TargetUnit(totem)
									-- StartAttack(totem)
									-- recent_totem_stomp = time
									-- Squid_Alert_Big("Stomp " .. name, "(Auto Attack)", 4, nil, 6603)
									-- object_first_detected[totem] = nil
								end
							end

							if unit_is_unit(totem,current_target) and hp < 300 then
								if not auto_attack_totem or time - auto_attack_totem > .1 then
									StartAttack(totem)
									auto_attack_totem = time
									object_first_detected[totem] = nil
								end
								return
							end

							if _meleeRange(totem) then
								-- shadowstrike
								if dance_up or subterfuge_up then
									if _Cast(185438,totem,nil,true) then
										Squid_Alert_Big("Stomp " .. name,"(Shadowstrike)",4,nil,185438)
										object_first_detected[totem] = nil
										return
									end
								end

								-- backstab
								if _Cast(53,totem,nil,true) then
									Squid_Alert_Big("Stomp " .. name,"(Backstab)",4,nil,53)
									object_first_detected[totem] = nil
									return
								end
							else
								-- shuriken toss
								if _Cast(114014,totem,nil,true) then
									Squid_Alert_Big("Stomp " .. name,"(Throw)",4,nil,114014)
									object_first_detected[totem] = nil
									return
								end
							end

						end
					end
				end
			end
		end

		local function target_last_non_totem_target()
			if last_non_totem_target and UnitIsVisible(last_non_totem_target) then
				TargetUnit(last_non_totem_target)
			end
		end

		local target_id = valid_attackable_target and ObjectID(t) or 999
		if tContains(totems,target_id) then
			if UnitHealth(t) <= 1 then
				if not totem_tlt_queued then
					C_Timer.After((max(.25,minDelayTime*1.5)),function() target_last_non_totem_target() totem_tlt_queued = nil end)
					totem_tlt_queued = true
				end
			end
		elseif not UnitIsVisible(t) then
			if recent_totem_stomp and time - recent_totem_stomp < 2 then
				if not totem_tlt_queued then
					C_Timer.After((max(.25,minDelayTime*1.5)),function() target_last_non_totem_target() totem_tlt_queued = nil end)
					totem_tlt_queued = true
				end
			end
		else
			if t and target_id ~= 61245 then
				last_non_totem_target = t
			end
		end

		local totems_to_stomp = {}

		-- do the totem stomp
		if arena then
			if not _CCcheck("player") then
				for i=1,#Pets do
					local e = Pets[i]
					local name = UnitName(e);
					local id = ObjectID(e)
					--only kill cap totems when they're casting
					if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e) and _castTimeLeft(e) < latency + 1.5 and Friends_Around_Unit(e, 10) > 0) then
						-- prio cap if it's going to stun anyone
						if id == 61245 and UnitCastingInfo(e) and _castTimeLeft(e) < latency + 1 and Friends_Around_Unit(e, 10) > 0 then
							table.insert(totems_to_stomp,{pointer=e, name=name, prio=1})
						-- prio spirit link totem
						elseif id == 53006 then
							table.insert(totems_to_stomp,{pointer=e, name=name, prio=2})
						else
							table.insert(totems_to_stomp,{pointer=e, name=name, prio=3})
						end
					end
					--shiv abomination
					if id == 149555 and not _slowImmuneCheck(e) and _CCremains(e) + _rootRemains(e) < 2 then
						if _Cast(5938,e,nil,true) then
							Squid_Alert("Shiv","Abomination",nil,nil,5938)
							return
						end
					end
				end
			end
		end
		table.sort(totems_to_stomp, function(x,y) return x.prio < y.prio end)

		if not stealth_up and combat_ends > 3.5 then
			for i=1,#totems_to_stomp do
				local t = totems_to_stomp[i]
				Stomp(t.pointer, t.name, true)
			end
		end

		local function auto_defensives()
			local auto_vial = SQUID.auto_vial
			local vial_hpp = SQUID.auto_vial_percent or 50

			local total,melee,ranged,cds = EnemiesAttacking("player")

			-- vial
			if auto_vial and player_hp <= vial_hpp + total*5 and energy >= GetSpellCost(185311) and _spellCooldown(185311) == 0 then
				if not UnitBuffID('player',185311) then --This is mainly for Torghast where you can get no cooldown on vial, so not to spam it.
					if _Cast(185311) then
						Squid_Alert("Crimson Vial",nil,nil,nil,185311)
						return true
					end
				end
			end

			-- cloak
			if cap_bot and player_hp <= 50 + (ranged * 25) then
				if _Cast(31224) then
					Squid_Alert("Cloak of Shadows",nil,nil,nil,31224)
					return true
				end
			end

			-- evasion
			if cap_bot and player_hp <= 50 + (melee * 35) then
				if _Cast(5277) then
					Squid_Alert("Evasion",nil,nil,nil,5277)
					return true
				end
			end

		end

		auto_defensives()

		local friendly_mage
		for i=1,#Friends do
			local class = select(2,UnitClass(Friends[i]))
			--mage
			if class == "MAGE" then
				friendly_mage = Friends[i]
			end
		end

		-- alerts for friendly mage cooldowns coming back
		if friendly_mage then

			if UnitCooldown(friendly_mage, 190319) <= 6.5 then
				if combustion_alert == false then
					Squid_Alert_Big("Combust Ready Soon", nil, nil, 3, 190319)
					combustion_alert = true
				end
			else
				combustion_alert = false
			end

			if UnitCooldown(friendly_mage, 153561) <= 3.5 then
				if meteor_alert == false then
					Squid_Alert_Big("Meteor Ready Soon", nil, nil, 1.8, 153561)
					meteor_alert = true
				end
			else
				meteor_alert = false
			end

		end

		local rogue_mage = friendly_mage and true

		local sepsis_stealth = UnitBuffID("player", 347037)

		-- if=buff.perforated_veins.stack>=5&amp;conduit.perforated_veins.rank>=13
		local pv_stacks = _buffStacks("player", 341572)
		local pv_rank = conduit_rank("Perforated Veins")

		-- premed gives 2 extra combo points if slice and dice is up, otherwise 10 sec slice and dice
		local premed_up = UnitBuffID("player",343173)
		local premed_enabled = IsPlayerSpell(343160)

		-- enemy players around
		local enemy_player_around
		local enemy_player_close
		for i=1,#Enemies do
			if unit_is_player(Enemies[i]) then
				local d = _distance(Enemies[i])
				if d < 40 then
					enemy_player_around = true
					if d < 10 then
						enemy_player_close = true
					end
				end
			end
		end

		-- team cc casts
		local team_sheep_cast = {}
		local team_clone_cast = {}
		for i=1,#Friends do
			local cast = UnitCastingInfo(Friends[i])

			if cast == "Cyclone" then
				local target = UnitSpellTarget(Friends[i])
				if target then
					team_clone_cast[target] = _castTimeLeft(Friends[i])
				end
			elseif cast == "Polymorph" then
				local target = UnitSpellTarget(Friends[i])
				if target then
					team_sheep_cast[target] = _castTimeLeft(Friends[i])
				end
			end

		end

		local function Sappable(unit)
			return energy > 35 and unit_is_player(unit) and not UnitAffectingCombat(unit) and not _immunePhysical(unit) and _incapacitateDR(unit) >= .25 and _CCremains(unit) <= .5 and (_incapacitateDR(unit) == 1 or _drRemains(unit,"incapacitate") > 17) and (not team_sheep_cast[unit] or team_sheep_cast[unit] > _CCremains(unit) + .1) and not unit_has_dot(unit) and not _isDummy(unit)
		end

		-- sap stealth
		local stealthed_sappable
		if energy >= 35 then
			for i=1,#Enemies do if unit_is_player(Enemies[i]) and _stealthCheck(Enemies[i]) and Sappable(Enemies[i]) then
				stealthed_sappable = Enemies[i]
			end end
		end
		if stealth_up or dance_up or vanish_up then
			if stealthed_sappable and _Cast(6770, stealthed_sappable, nil, true) then
				Squid_Alert_Big("Sap " .. UnitClass(stealthed_sappable), "(".. GetSpellInfo(_stealthCheck(stealthed_sappable)) .. ")", 6, nil, 6770)
				return
			end
		end
		--/run local stealthed_sappable = "player" Squid_Alert_Big("Sap " .. UnitClass(stealthed_sappable), "(".. GetSpellInfo(_stealthCheck(stealthed_sappable)) .. ")", 6, nil, 6770)

		-- sapped target
		local sapped_target
		local sapped_target_remains = 0
		for i=1,#Enemies do
			local sap_remains = _debuffRemains(Enemies[i],6770,"player")
			if sap_remains > 0 then
				sapped_target = Enemies[i]
				sapped_target_remains = sap_remains
			end
		end

		local their_healer = {}

		local no_healer
		if not their_healer and not their_healer_hiding then no_healer = true end

		local their_healer_cc
		local their_healer_cc_remains = 0
		local their_healer_incapacitate_dr
		local their_healer_incapacitate_dr_remains = 0
		local their_healer_disorient_dr
		local their_healer_disorient_dr_remains = 0
		local their_healer_important_lockout

		if theirHealer then
			their_healer.p = theirHealer
			if not UnitIsDeadOrGhost(theirHealer) then
				their_healer.cc_remains = _CCremains(their_healer.p)
				their_healer.cc = their_healer.cc_remains > 0
				their_healer.incapacitate_dr = _incapacitateDR(their_healer.p)
				their_healer.incapacitate_dr_remains = _drRemains(their_healer.p,"incapacitate")
				their_healer.disorient_dr = _disorientDR(their_healer.p)
				their_healer.disorient_dr_remains = _drRemains(their_healer.p,"disorient")

				local class = select(2,UnitClass(their_healer.p))
				their_healer.class = class

				local locked,remaining,school = UnitIsLocked(their_healer.p)
				their_healer.lockout = {locked,remaining,school}

				if locked and remaining > .25 then
					if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
					or ( class == "SHAMAN" and school == "Nature" )
					or ( class == "PALADIN" and school == "Holy" )
					or ( class == "MONK" and school == "Nature" )
					or ( class == "DRUID" and school == "Nature" )  then
						their_healer.important_lockout = true
					end
				end
			else -- no healer if he dead
				their_healer = {}
			end
		end

		-- rogue_mage=true -- testing
		local healer_sheep_ready = rogue_mage and their_healer.incapacitate_dr_remains or 99

		local our_healer_cc_remains = ourHealer and _CCremains(ourHealer) or 0
		local our_healer_cc = ourHealer and our_healer_cc_remains > 0

		--sap targets that fall out of combat
		if not player_disarmed then
			for i=1,#Enemies do if unit_is_player(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) and not do_not_sap(Enemies[i]) then
				local e = Enemies[i]
				local is_healer = _isHealer(e)
				local idr = _incapacitateDR(e)
				if Sappable(e) and (not sapped_target or is_healer or unit_is_unit(e,sapped_target)) then                                             -- dance                     -- vanish
					if stealth_up and target_in_combat and (lowestEnemy <= 90 or recently_trinketed(e, 3) or _stealthCheck(e)) or UnitBuffID('player', 185422) or UnitBuffID('player', 11327) then
						if (_isHealer(Enemies[i]) or no_healer) and time_since_combat < 15 and _distance(Enemies[i]) > 10 then
							if smooth_step(Enemies[i]) then
								Squid_Alert("Step " .. UnitClass(Enemies[i]),"(Sap)",4,nil,36554)
								SquidFrame = 2
								return
							end
						end
						if _Cast(6770,Enemies[i],nil,true) then
							Squid_Alert_Big("Sap " .. UnitClass(Enemies[i]),nil,5,nil,6770)
							return
						end
					elseif _isHealer(Enemies[i]) and (_distance(Enemies[i]) < 10 or _spellCooldown(36554) == 0 and _distance(Enemies[i]) <= 23 and _LoS(Enemies[i])) and idr == 1 and not stealth_up and not dance_up and player_combat then
						if _Cast(185313) then
							Squid_Alert("Dance","(Sap " .. UnitClass(Enemies[i]) .. ")", nil, nil, 185313)
							SquidFrame = 2
							return
						end
					end
				end
			end end
		end

		if UnitIsVisible(theirHealer) then
			-- shiv healer out of los
			if valid_attackable_target then
				if not unit_is_unit(theirHealer,t) and not _breakableCC(theirHealer) and _CCremains(theirHealer) <= .1 and not _immunePhysical(theirHealer) and UnitAffectingCombat(theirHealer) and (_distance(theirHealer,t) > 43 or not _LoS(theirHealer,t)) then
					if _Cast(5938, theirHealer, nil, true) then
						Squid_Alert_Big("Shiv Healer","(Bad Position)",4,3.5,5938)
						return
					end
				end
				-- shiv target out of los
				if _CCremains(theirHealer) <= 3.5 and (_distance(theirHealer,t) > 43 or not _LoS(theirHealer,t)) and _CCremains(t) < .1 then
					if _Cast(5938, t, nil, true) then
						Squid_Alert_Big("Shiv Target","(Bad Position)",4,3.5,5938)
						return
					end
				end
			end
		end

		-- stealth breaking soon
		if stealth_up and not vanish_up and unit_has_dot("player") then

			Squid_Alert_Big("|cFFfef367Stealth Breaking Soon!", nil, nil, .25)

			-- we could use this var elsewhere to set up a go on someone with master assassin
			stealth_breaking_soon = true

			-- shadowstrike
			if valid_physical_target and (moving_towards_long or moving_towards and not fleeing_from_target) then
				if _Cast(185438,current_target,nil,true) then
					Squid_Alert("Shadowstrike", "(Stealth Breaking)",5,nil,185438)
					return true
				end
			end

		else
			stealth_breaking_soon = false
		end

		-- restealth when possible and enemy player is around or enemy is targeted, or when an arena is starting
		if not stealth_up and not player_combat and (not offensive_vanish or time - offensive_vanish > 3) then
			if enemy_player_around or (UnitIsVisible(t) and UnitCanAttack("player",t)) or enemy_player_close or (arena and not UnitBuffID("player",32727)) then
				if time_since_combat < 3 or enemy_player_close then
					if player_has_dot and valid_physical_target and moving_towards then
						local tx,ty,tz = ObjectPosition(t)
						local px,py,pz = PredictUnitPosition("player",.5)
						if not TraceLine(tx,ty,tz+1.8,px,py,pz+1.8,0x100030) then
							if _Cast(1784) then
								recent_restealth = time
								Squid_Alert("Restealth","(|cFFc31d39Dotted)",7,nil,1784)
								SquidFrame = 2
								return
							end
						end
					elseif not player_has_dot then
						if _Cast(1784) then
							recent_restealth = time
							Squid_Alert("Restealth",nil,7,nil,1784)
							return
						end
					else
						Squid_Alert("|cFFfef367Not Stealthing","|cFFc31d39(Dotted)",nil,nil,1784)
					end
				else
					if player_has_dot and valid_physical_target and moving_towards then
						local tx,ty,tz
						local px,py,pz = PredictUnitPosition("player",.5)
						if not TraceLine(tx,ty,tz+1.8,px,py,pz+1.8,0x100030) then
							if _Cast(1784) then
								recent_restealth = time
								Squid_Alert("Stealth","(Dotted)",7,nil,1784)
								return
							end
						end
					elseif not player_has_dot then
						if _Cast(1784) then
							recent_restealth = time
							Squid_Alert("Stealth",nil,nil,nil,1784)
							return
						end
					else
						Squid_Alert("|cFFfef367Not Stealthing","|cFFc31d39(Dotted)",nil,nil,1784)
					end
				end
			end
		end

		-- returns a modifier, like .4 if they take 40% of normal damage from the given damage source
		local function unit_damage_taken_modifier(unit)
			local physical_mod = 0
			local magic_mod = 0
			local any_mod = 0
			-- gather any defensive buffs and add the value
			if damagetype == "magic" then

			elseif damagetype == "physical" then

			end
			-- full immunities = 100
			return any_mod, physical_mod, magic_mod
		end

		local peel_mode
		local peel_unit
		for i=1,#Friends do

			local f = Friends[i]

			local hp = 30
			local severe_hp = 10

			local count,melee,range,cds = EnemiesAttacking(f)

			local any_mod,physical_mod,magic_mod = unit_damage_taken_modifier(f)

			if any_mod == 0 then
				hp = 0
			else
				hp = hp + ((melee * 10) * physical_mod)
				hp = hp + ((range * 10) * magic_mod)
				hp = hp + (cds * 20)
				hp = hp + ((not ourHealer or our_healer_cc) and 25 or 0)
			end

			hp = hp * any_mod

			if any_mod == 0 then
				severe_hp = 0
			else
				severe_hp = severe_hp + ((melee * 7) * physical_mod)
				severe_hp = severe_hp + ((range * 7) * magic_mod)
				severe_hp = severe_hp + (cds * 18)
				severe_hp = severe_hp * ((not ourHealer or our_healer_cc) and 1.3 or 1)
			end

			local current_hp = math.floor(_HP(f))
			if current_hp < severe_hp then
				peel_mode = "severe"
				peel_unit = f
				break
			else
				peel_mode = true
				peel_unit = f
			end

		end

		local kidney_ready = kidney_cd == 0 and combo_points >= 5 - bin(mfd_enabled and mfd_cd == 0)*5

		local target_go_ready = 999
		if t and valid_attackable_target then
			local reasons_to_wait = {
				{r = _drRemains(t,"stun"), reason = "Stun DR"},	-- remaining stun DR
				{r = go_stopping_defensive_remains(t), reason = GetSpellInfo(select(2,go_stopping_defensive_remains(t)))}, -- go stopping defensives
				{r = dance_cd, reason = "Dance Cooldown"}, -- dance cd
			}
			table.sort(reasons_to_wait, function(x,y) return x.r > y.r end)
			target_go_ready = reasons_to_wait[1].r
			target_go_reason = reasons_to_wait[1].reason
		end

		-- print(target_go_reason)
		if valid_attackable_target and target_go_ready > gcd and target_go_reason then
			-- Squid_Alert("Delaying Go for " .. target_go_reason)
		end

		local off_target
		for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) then
			off_target = Enemies[i]
		end end

		-- engage load mode during cc or when we might still have a kill on the target after cc
		local load_mode = valid_physical_target and (their_healer.cc or target_hp < 65) and go_stopping_defensive_remains(t) == 0

		-- REMOVE ME
		load_mode = valid_physical_target and _stunCheck(t) and "kill" or load_mode

		local cc_chain = {}

		local pooling_combo_points
		local pooling_energy = force_pool or load_mode and 0 or 35 -- we can pool less energy when symbols is available .. ?
		local pooling_energy_reason

		local energy_needed_for_go = (mfd_enabled and mfd_cd == 0 and 50 or 90)

		cc_draw_line = nil
		local function healer_cc()

			local unit = theirHealer or "focus"

			--stop if no unit
			if not unit or not UnitIsVisible(unit) then return 69 end

			--do not sap? (ext. func)
			local dont_sap = do_not_sap(unit)

			--dist to unit
			local dist = _distance(unit)
			-- melee range?
			local melee_range = _meleeRange(unit)

			-- immunities
			local immunity_remains = max( physical_immunity_remains(unit), cc_immunity_remains(unit) )

			--druid?
			local is_druid = select(2,UnitClass(unit)) == "DRUID"

			--check root
			local root = ( not is_druid and _rootRemains(unit) or 0 )

			--check cc
			local ccr = _CCremains(unit)
			local cc = ccr > 0

			--incapacitate info
			local idr = _incapacitateDR(unit)
			local idr_remains = _drRemains(unit,"incapacitate")
			local incap_remains, incap = incapacitate_remains(unit)

			--disorient drs
			local ddr = _disorientDR(unit)
			local ddr_remains = _drRemains(unit,"disorient")

			--sheep immunities. beast or dummy is all i can think of right now. added in Moonkin Form for resto
			local immune_sheep = _isBeast(unit) or _isDummy(unit) or UnitBuffID(unit, 197625)

			--meteor?
			local standing_in_meteor = UnitDebuffID(unit,155158)

			--banner?
			local banner = UnitBuffID(unit,236321)

			--yea dont cc into it...unless
			if banner then return 69 end

			--incap on unit?
			local incap = _incapacitateCheck(unit)

			-- stun dr
			local sdr_remains = _drRemains(unit,"stun")

			--healer?
			local is_healer = _isHealer(unit)

			--lockout? (only important lockout...)
			-- local lockout = IsLocked(unit,true)
			local locked,lockout_remaining,school = UnitIsLocked(unit)

			local important_lockout_remaining = 0
			if locked and lockout_remaining > 0 then
				if ( class == "PRIEST" and school == "Shadow" )
				or ( class == "SHAMAN" and school == "Nature" )
				or ( class == "PALADIN" and school == "Holy" )
				or ( class == "MONK" and school == "Nature" )
				or ( class == "DRUID" and school == "Nature" )
				or ( class == "MAGE" and school == "Arcane" )
				or ( class == "WARLOCK" and school == "Shadowflame" ) then
					important_lockout_remaining = lockout_remaining
				end
			end

			--los?
			local los = _LoS(unit)

			--charmed friend?
			local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

			if friendly then return 69 end

			local unit_type = _isHealer(unit) and "Healer" or UnitClass(unit)

			-- kidney healer
								-- target "hp" needs to be adjusted by defensives
			local time_to_stun = max(0, (target_hp > 75 or dance_cd > 0) and target_go_ready-gcd or 0, ccr - latency - .15, sdr_remains, rogue_mage and ccr == 0 and (idr_remains < 14 and idr_remains) or 0, kidney_cd, _CCremains(friendly_mage) - 3, mfd_enabled and min(mfd_cd, time_to_max_cp + energy_time_to(energy_needed_for_go)) or time_to_max_cp + energy_time_to(energy_needed_for_go), immunity_remains, energy_time_to(energy_needed_for_go), symbols_cd - gcd*2)
			if not stealth_up and player_combat or player_forced then
				if unit and not team_sheep_cast[unit] then
					if time_to_stun <= 0 and immunity_remains == 0 then
						if combo_points >= combo_points_max - bin(melee_range) then
							if _Cast(408, unit, nil, true) then
								Squid_Alert_Big("Kidney "..unit_type,"(Going)", 1, .8, 408)
								return 0
							end
							-- out of range
							if _distance(unit) > 5 then
								local fleeing = fleeing_from_unit(unit,.3)
								if _movingTowards(unit, .13) and moving_towards_unit_duration(t,.13) > .3 and not fleeing then
									-- wait to get in melee range
									Squid_Alert("Please move to "..unit_type,"(Kidney)", nil, .8, 408)
								elseif _distance(unit) > 8 + bin(_movingTowards(unit,.14))*5 - bin(_isSlowed("player"))*3 and not fleeing then
									-- step to them
									if smooth_step(unit) then
										Squid_Alert_Big("Step "..unit_type,"(Kidney)", nil, .8, 36554)
										SquidFrame = 2
										return 0
									elseif step_cd > 1 then
										Squid_Alert_Big("Please move to "..strlower(unit_type),"(Kidney)", nil, .8, 408)
									end
								else
									Squid_Alert_Big("Please move to "..strlower(unit_type),"(Kidney)", nil, .8, 408)
								end
							end
						elseif mfd_cd == 0 and combo_points <= 3 and _distance(unit) <= 5 + bin(_spellCooldown(36554) == 0 and _LoS(unit))*18 then
							for i=1,#Enemies do if _Cast(137619,Enemies[i]) then Squid_Alert("Marked for Death","(Kidney)",nil,nil,137619) SquidFrame = 2 return 0 end end
						end
						pooling_combo_points = true
						cc_draw_line = {unit=unit, spellID=408, countdown=time_to_stun, ready=true}
					elseif time_to_stun < 6.25 then
						if time_to_stun > energy_time_to(energy_needed_for_go + 30*combo_points_deficit) then
							pooling_energy = energy_needed_for_go
						end
						pooling_combo_points = true
						if time_to_stun <= 6 and time_to_stun > 5 then
							Squid_Alert("Kidney " .. unit_type .. " in 5 sec.", nil, nil, 3, 408)
						end
						cc_draw_line = {unit=unit, spellID=408, countdown=time_to_stun}
					end
				end
			end

			return min( time_to_stun )

		end

		local max_cast_time = 69
		max_cast_time = healer_cc()

		if max_cast_time > gcd and valid_physical_target and distance_target < 23.5 and los_target and ( dance_remains >= 4 - bin(dance_charges > 0)*4 ) then
			if load_mode == "kill" then
				if runeforge == "Crit" then
					if (combo_points_deficit <= 1 - bin(deeper_strategem_enabled or runeforge == "DS" and combo_points == 0) or dance_up and symbols_up and target_stun_remains > 3.2 - gcd and energy >= 80 and (not mfd_enabled or mfd_cd == 0)) and symbols_up and dance_up and master_assassin_remains == 0 and not deathly_shadows_up and gcd_remains <= buffer + .125 and energy - pooling_energy >= 45 then
						if _Cast(1856) then
							Squid_Alert_Big("Vanish","(Offensive)",6,nil,1856)
							should_use_blades = time
							offensive_vanish = time
							SquidFrame = 2 -- run again next frame
						end
					end
				end
			end
		end

		local function dance_go(unit)

			if not dance_up or max_cast_time < gcd then return end

			local relent_mod = 0 -- need to find out if the unit is playing relentless
			local ogre_mod = select(2,UnitRace(unit)) == "Orc" and 0.2 or 0
			local cc_mod = 1 - ogre_mod - relent_mod

			local stun_dr = _stunDR(unit)
			if stun_dr < .25 then stun_dr = 0 end

			local sdr_remains = _drRemains(unit,"stun")
			local immune_cheap = _immuneStuns(unit,true)

			local cs_duration = (4 * stun_dr) * cc_mod

			local stun_remains = _stunRemains(unit)

			local dance_spells = {
				["Echoing Reprimand"] = {id=323547, cd=_spellCooldown(323547), cost=10},
				["Shadowstrike"] = {id=185438, cd=gcd_remains, cost=40},
				["Cheap Shot"] = {id=1833, cd=gcd_remains, cost=40, free=shot_in_the_dark_up},
			}

			-- shadow focus energy cost reduction
			if IsPlayerSpell(108209) then
				for k, v in pairs(dance_spells) do
					v.cost = v.cost * .8
				end
			end

			local melee_range = _meleeRange(unit)

			local acceptable_gap = .41 * (1 + (max(ogre_mod*4,relent_mod*4)))
			local gcds_before_stun = math.floor( (stun_remains + acceptable_gap + .01 - gcd_remains) / gcd )

			if stun_remains > 0 and combo_points == 0 and stun_remains <= (4 * cc_mod)-gcd and gcds_before_stun > 0 then
				if _Cast(137619, t) then
					Squid_Alert("Marked for Death", nil, nil, nil, 137619)
					SquidFrame = 2
					return true
				end
			end

			-- general symbols usage
			if melee_range and (energy_deficit >= 30 + (combo_points >= 4 and energy_gained_over_time(gcd) or 0) or stun_remains > 0 and (shadow_focus_enabled or shot_in_the_dark_enabled) or master_assassin_remains > gcd_remains+latency) then
				if _Cast(212283) then
					Squid_Alert("Symbols of Death",nil,nil,nil,212283)
				end
			end

			-- damage higher prio than 1/4 stun w crit
			if stun_dr <= .25 and master_assassin_remains > latency + gcd_remains then
				-- eviscerate with 4+
				if combo_points >= 4 then
					-- eviscerate?
					if _Cast(196819,unit,nil,true) then
						SquidFrame = 2 -- run script again on next frame
						return true
					end
				else
					-- cold blood
					if gcd_remains <= .4 and dance_remains > gcd_remains + .1 and _Cast(213981) then
						Squid_Alert("Cold Blood",nil,nil,nil,213981)
					end
					-- shadowstrike
					if _Cast(185438,unit,nil,true) then
						SquidFrame = 2
						return true
					end
				end
			end

			-- stuns
			if cs_duration > 0 and (sdr_remains == 0 or sdr_remains >= 17.5) and not immune_cheap then
				-- cheap again if stun on target remains < gcd - acceptable gap
				if stun_remains < gcd - acceptable_gap then
					if melee_range then
						if stun_remains > buffer and gcds_before_stun <= 0 then
							SquidFrame = 2
							return "wait"
						else
							-- cold blood
							if gcd_remains <= .4 and dance_remains > gcd_remains + .1 and _Cast(213981) then
								Squid_Alert("Cold Blood",nil,nil,nil,213981)
							end
							-- cheap
							if _Cast(1833,unit,nil,true) then
								SquidFrame = 2 -- run script again on next frame
								return true
							end
						end
					elseif _distance(unit) > 6 + bin(_movingTowards(unit,.11))*2 and stun_dr == 1 and not fleeing_from_unit(unit,.9) then
						if smooth_step(unit) then
							Squid_Alert("Shadowstep", "(Going)", nil, nil, 36554)
							SquidFrame = 2 -- run script again on next frame
							return true
						end
					end
				end
			end

			-- finishers
			if combo_points >= 4 - bin(gcds_before_stun == 2 and mfd_enabled and mfd_cd == 0) or er_ready then
				-- rupture
				if _HP(unit) > 75 and not target_rupture_ticking and not master_assassin_up then
					if _Cast(1943, unit, nil, true) then SquidFrame = 2 return true end
				end
				-- eviscerate?
				if _Cast(196819,unit,nil,true) then
					SquidFrame = 2 -- run script again on next frame
					return true
				end
			end

			-- echoing
			if (energy_deficit + dance_spells["Echoing Reprimand"].cost) - energy_gained_over_time(gcd) >= 20 then
				if _Cast(323547,unit,nil,true) then
					SquidFrame = 2
					return true
				end
			end

			if melee_range and combo_points <= 3 and energy_deficit >= 35 then
				if _Cast(212283) then
					Squid_Alert("Symbols of Death",nil,nil,nil,212283)
				end
			end

			-- cold blood
			if gcd_remains <= .4 and dance_remains > gcd_remains + .1 and _Cast(213981) then
				Squid_Alert("Cold Blood",nil,nil,nil,213981)
			end
			-- shadowstrike
			if _Cast(185438,unit,nil,true) then
				SquidFrame = 2
				return true
			end


		end

		if valid_physical_target and dance_go(t) then return true end

		local equipped_items = {}

		local trinkets = {
			173087, --Darkmoon Deck: Voracity
			178715, --Mistcaller Ocarina
			175884, --Sinful Aspirant's Badge of Ferocity
			175921,	--Sinful Gladiator's Badge of Ferocity
		}

		for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then
			equipped_items[trinkets[i]] = GetItemCD(trinkets[i])
		end end

		-- REMOVEME
		-- use_dance = use_dance or target_go_ready <= 0 and not pooling_combo_points and melee_range_target or dance_charges_frac >= 1.8 and melee_range_target

		if valid_physical_target and _stunRemains(t) > 2.8 then
			if _Cast(212182) then Squid_Alert("Bomb","(Ø§Ù„Ù„Ù‡ Ø£ÙƒØ¨Ø±))",nil,4,212182) return end
		end

		-- force following
		if target_to_follow and UnitIsVisible(target_to_follow) and not _immunePhysical(target_to_follow) then
			local x,y,z = PredictUnitPosition(target_to_follow,.09)
			if _distance(target_to_follow) > 1 then
				JesusMoveTo(x,y,z)
			end
			Squid_Alert_Big("JESUS IS TAKING THE WHEEL")
		end

		-- reset execute persistence
		if doing_execute and time - doing_execute >= 1 then doing_execute = nil end

		-- execute
		if get_squid_var("SubPvP - Execute") then
			if gcd_remains <= .55 + latency or doing_execute then
				for i=1,#Enemies do if unit_is_player(Enemies[i]) and not _immunePhysical(Enemies[i]) and (GetUnitSpeed(Enemies[i]) <= GetUnitSpeed("player")+2 or doing_execute or _meleeRange(Enemies[i])) and (unit_is_unit(Enemies[i],current_target) or _HP(Enemies[i]) < target_hp) then

					local e = Enemies[i]

					local effective_hp = UnitHealth(e) + UnitGetTotalAbsorbs(e)
					local current_damage, potential_damage, threshold_passed, cds_used

					-- execute power with current combo points
					if combo_points >= 4 or er_ready or mfd_enabled and mfd_cd == 0 then -- let the function know if we can use mfd after the first evisc
						current_damage, potential_damage, threshold_passed, cds_used = eviscerate_damage(e, combo_points < 4 and mfd_enabled and mfd_cd == 0 and 5 or combo_points, effective_hp, get_squid_var("SubPvP - Execute GCDs") >= 2 and (combo_points >= 4 or er_ready) and mfd_enabled and mfd_cd == 0)
						-- print(1,e, combo_points < 4 and mfd_enabled and mfd_cd == 0 and 5 or combo_points, effective_hp, get_squid_var("SubPvP - Execute GCDs") >= 2 and (combo_points >= 4 or er_ready) and mfd_enabled and mfd_cd == 0)
					else -- execute power without at least 4 combo points, let the function know we have the potential of 5 combo points with mfd
						current_damage, potential_damage, threshold_passed, cds_used = eviscerate_damage(e, mfd_enabled and mfd_cd == 0 and 5 or combo_points, effective_hp)
						-- print(2,e, mfd_enabled and mfd_cd == 0 and 5 or combo_points, effective_hp)
					end


					if cds_used then
						-- testing
						-- print(current_damage, potential_damage, threshold_passed, #cds_used)
						-- for i=1,#cds_used do print(cds_used[i].spell or cds_used[i].item) end
						local symbols_used
						for i=1,#cds_used do
							if cds_used[i].spell == 212283 then
								symbols_used = true
							end
						end
						if current_damage and cds_used and (energy >= 35 or symbols_used) then
							if (threshold_passed or (combo_points >= 4 and (_meleeRange(e) and potential_damage >= effective_hp*.75 or _stunRemains(e) >= 2 and potential_damage >= effective_hp*.7) or load_mode == "kill" and potential_damage >= effective_hp*.6)) or doing_execute then
								local cds = {}
								local items = {}
								for i=1,#cds_used do
									if cds_used[i].item then table.insert(items,cds_used[i].item) end
									if cds_used[i].spell then table.insert(cds,cds_used[i].spell) end
								end
								if _meleeRange(e) then
									if cp >= 4 or er_ready or _Cast(137619,Enemies[i]) and Squid_Alert("Marked for Death", nil, nil, nil, 137619) then
										-- persistent execute
										doing_execute = doing_execute or time
										if not unit_is_unit(e,current_target) then TargetUnit(e) end
										-- use items
										for i=1,#items do
											-- badge
											if items[i] == "Badge" then
												UseItemByName(tostring(GetItemInfo(175921)))
												UseItemByName(tostring(GetItemInfo(175884)))
												Squid_Alert("Gladiator's Badge", nil, nil, nil, 277185)
											end
										end
										-- use spells
										for i=1,#cds do
											-- dance
											if cds[i] == 185313 and _Cast(185313) then
												Squid_Alert("Dance", "(Execute)", nil, nil, 185313)
											end
											-- symbols
											if cds[i] == 212283 and _Cast(212283) then
												Squid_Alert("Smybols of Death", "(Execute)", nil, nil, 212283)
											end
											-- symbols
											if cds[i] == 1856 and not master_assassin_up and _Cast(1856) then
												Squid_Alert("Vanish", "(Execute)", 5, nil, 1856)
												offensive_vanish = time
											end
										end
										-- eviscerate
										if _Cast(196819,Enemies[i],nil,true) then
											StartAttack(Enemies[i])
											Squid_Alert("Eviscerate", "(Execute)", 6, nil, 196819)
											SquidFrame = 2 -- force the script to run again next frame
											return
										end
									end
								elseif not get_squid_var("SubPvP - No Execute Step") and (cp >= 4 or er_ready or _Cast(137619,Enemies[i]) and Squid_Alert("Marked for Death", nil, nil, nil, 137619)) then
									if _spellCooldown(36554) == 0 and _distance(Enemies[i]) <= 23.5 and _LoS(Enemies[i]) then
										StopMovingAndLock()
										target_to_follow = Enemies[i]
										-- print("ttf set, movement stopped")
										C_Timer.After(1,function() SetMovementLocked(false) target_to_follow = nil end)
									end
									if gcd_remains <= .2 + latency and _Cast(36554, Enemies[i]) then
										-- persistent execute
										doing_execute = doing_execute or time
										-- use items
										for i=1,#items do
											-- badge
											if items[i] == "Badge" then
												UseItemByName(tostring(GetItemInfo(175921)))
												UseItemByName(tostring(GetItemInfo(175884)))
												Squid_Alert("Gladiator's Badge", nil, nil, nil, 277185)
											end
										end
										-- use spells
										for i=1,#cds do
											-- dance
											if cds[i] == 185313 and _Cast(185313) then
												Squid_Alert("Dance", "(Execute)", nil, nil, 185313)
											end
											-- symbols
											if cds[i] == 212283 and _Cast(212283) then
												Squid_Alert("Smybols of Death", "(Execute)", nil, nil, 212283)
											end
											-- symbols
											if cds[i] == 1856 and not master_assassin_up and _Cast(1856) then
												Squid_Alert("Vanish", "(Execute)", 5, nil, 1856)
												offensive_vanish = time
											end
										end
										-- eviscerate
										if _Cast(196819,Enemies[i],nil,true) then
											StartAttack(Enemies[i])
											Squid_Alert("Eviscerate", "(Execute)", 6, nil, 196819)
											SquidFrame = 2 -- force the script to run again next frame
											return
										end
										SquidFrame = 2 -- force the script to run again next frame
										return
									end
									-- stop the script from doing other things than stepping to the guy and eviscerating
									if doing_execute and _spellCooldown(36554) == 0 and not _meleeRange(e) then return end
								end
							end
						end
					end
				end end
			end
		end

		-- alert when energy is being pooled
		if pooling_energy > energy and pooling_energy > 35 then
			Squid_Alert_Big("Pooling to " .. pooling_energy .. " Energy", pooling_energy_reason and "(" .. pooling_energy_reason .. ")", nil, .75)
		end

		-- alert when combo points are being pooled
		if pooling_combo_points then
			Squid_Alert("Pooling Combo Points")
		end

		-- alert when moving towards target
		-- if moving_towards_long then Squid_Alert_Big("Moving Towards Long",nil,nil,.5) elseif moving_towards then Squid_Alert("Moving Towards",nil,nil,.5) end

		-- stealth breaking soon
		if stealth_up and not vanish_up and unit_has_dot("player") then

			Squid_Alert_Big("|cFFfef367Stealth Breaking Soon!", nil, nil, .25)

			-- we could use this var elsewhere to set up a go on someone with master assassin
			stealth_breaking_soon = true

			-- shadowstrike
			if valid_physical_target and (moving_towards_long or moving_towards and not fleeing_from_target) then
				if _Cast(185438,current_target,nil,true) then
					Squid_Alert("Shadowstrike", "(Stealth Breaking)",5,nil,185438)
					return true
				end
			end

		else
			stealth_breaking_soon = false
		end

		if theirHealer or their_healer_hiding then

		else
			-- cc chain on dps
		end

		-- target is valid and attackable
		if valid_attackable_target then

			local snd_condition

			local usable_energy = energy - pooling_energy

			-- auto focus the best focus target
			if arena then
				if not UnitIsVisible(current_focus) or unit_is_unit(current_focus,current_target) then
					if their_healer.p and not unit_is_unit(their_healer.p,current_target) then
						FocusUnit(their_healer.p)
						Squid_Alert("Focusing Healer")
					elseif their_healer_hiding then
						-- do nothing
					else
						if UnitIsVisible(off_target) and not UnitIsDeadOrGhost(off_target) then
							FocusUnit(off_target)
							Squid_Alert("Focusing Off Target")
						end
					end
				end
			end

			local function use_items()

				-- badge
				if equipped_items[175884] and equipped_items[175884] <= 0
				or equipped_items[175921] and equipped_items[175921] <= 0 then
					UseItemByName(tostring(GetItemInfo(175921)))
					UseItemByName(tostring(GetItemInfo(175884)))
					Squid_Alert("Gladiator's Badge", nil, nil, nil, 277185)
					return true
				end

				-- that one trinket from the raid

			end

			local function cds()

				if not valid_physical_target then return end

				-- cold blood
				if dance_up and symbols_up then
					if _Cast(213981) then
						Squid_Alert_Big("Cold Blood",nil,nil,nil,213981)
					end
				end

				-- actions.cds+=/vanish,if=(runeforge.mark_of_the_master_assassin&amp;combo_points.deficit<=1-talent.deeper_strategem.enabled|runeforge.deathly_shadows&amp;combo_points<1)&amp;buff.symbols_of_death.up&amp;buff.shadow_dance.up&amp;master_assassin_remains=0&amp;buff.deathly_shadows.down
				if load_mode == "kill" then
					if runeforge == "Crit" then
						if (combo_points_deficit <= 1 - bin(deeper_strategem_enabled or runeforge == "DS" and combo_points == 0) or dance_up and symbols_up and target_stun_remains > 3.2 - gcd and energy >= 80 and (not mfd_enabled or mfd_cd == 0)) and symbols_up and dance_up and master_assassin_remains == 0 and not deathly_shadows_up and gcd_remains <= buffer + .125 and usable_energy >= 45 then
							if _Cast(1856) then
								Squid_Alert_Big("Vanish","(Offensive)",6,nil,1856)
								should_use_blades = time
								offensive_vanish = time
								SquidFrame = 2 -- run again next frame
								return true
							end
						end
					end
				end

				-- actions.cds+=/serrated_bone_spike,cycle_targets=1,if=variable.snd_condition&amp;!dot.serrated_bone_spike_dot.ticking&amp;target.time_to_die>=21|fight_remains<=5&amp;spell_targets.shuriken_storm<3

				-- actions.cds+=/sepsis,if=variable.snd_condition&amp;combo_points.deficit>=1

				if melee_range_target then
					-- actions.cds+=/symbols_of_death,if=variable.snd_condition&amp;(talent.enveloping_shadows.enabled|cooldown.shadow_dance.charges>=1)
					if snd_condition and use_symbols then
						if enveloping_shadows_enabled or dance_charges >= 1 then
							if _Cast(212283) then
								Squid_Alert("Symbols of Death", nil, nil, nil, 212283)
								-- return true
							end
						end
					end
					-- actions.cds+=/marked_for_death,target_if=combo_points.deficit>=cp_max_spend
					if not pooling_combo_points and combo_points_deficit >= combo_points_max and not dance_up and (target_go_ready > 15 or load_mode == "kill")  then
						if _Cast(137619, t) then
							Squid_Alert("Marked for Death", nil, nil, nil, 137619)
							return true
						end
					end
					-- actions.cds+=/shadow_blades,if=variable.snd_condition&amp;combo_points.deficit>=2
					if use_blades and combo_points_deficit >= 2 then
						if _Cast(121471) then
							Squid_Alert_Big("Shadow Blades", nil, 5, nil, 121471)
							return true
						end
					end
				end

				-- actions.cds+=/echoing_reprimand,if=variable.snd_condition&amp;combo_points.deficit>=2
				if max_cast_time >= gcd and is_kyrian and snd_condition and combo_points_deficit >= 2 then
					if _Cast(323547, t, true) then
						Squid_Alert("Echoing Reprimand", nil, nil, nil, 323547)
						return true
					end
				end

				-- actions.cds+=/shadow_dance,if=!buff.shadow_dance.up&amp;fight_remains<=8+talent.subterfuge.enabled
				if use_dance then
					if _Cast(185313) then
						Squid_Alert("Shadow Dance", nil, nil, nil, 185313)
						return true
					end
				end

				-- racials
				if symbols_up then
					-- actions.cds+=/blood_fury,if=buff.symbols_of_death.up
					if _Cast(20572) then
						Squid_Alert("Blood Fury", nil, nil, nil, 20572)
					end
					-- actions.cds+=/berserking,if=buff.symbols_of_death.up
					if _Cast(26297) then
						Squid_Alert("Berserking", nil, nil, nil, 26297)
					end
					-- actions.cds+=/fireblood,if=buff.symbols_of_death.up
					if _Cast(265221) then
						Squid_Alert("Fireblood", nil, nil, nil, 265221)
					end
					-- actions.cds+=/ancestral_call,if=buff.symbols_of_death.up
					if _Cast(274738) then
						Squid_Alert("Ancestral Call", nil, nil, nil, 274738)
					end

				end

				-- # Default fallback for usable items: Use with Symbols of Death.
				-- actions.cds+=/use_items,if=buff.symbols_of_death.up|fight_remains<20
				if symbols_up and load_mode then
					if use_items() then return true end
				end
			end

			local function build()

				if valid_physical_target and (combo_points_deficit > 0 or energy >= energy_max - 5) then

					-- # Builders
					-- actions.build=shiv,if=!talent.nightstalker.enabled&amp;runeforge.tiny_toxic_blade&amp;spell_targets.shuriken_storm<5
					if max_cast_time >= gcd and usable_energy >= GetSpellCost(5938) and not nightstalker_enabled and runeforge == "TTB" then
						if _Cast(5938, t, true) then Squid_Alert("Why are you using tiny toxic blade?",nil,nil,nil,5938) return true end
					end

					-- actions.build+=/shuriken_storm,if=spell_targets>=2
					if not dance_up and max_cast_time >= gcd and not bcc10 and AllEnemiesAroundMe(8) >= 2 and usable_energy >= GetSpellCost(197835) then
						if _Cast(197835) then return true end
					end

					-- actions.build+=/serrated_bone_spike,if=cooldown.serrated_bone_spike.charges_fractional>=2.75|soulbind.lead_by_example.enabled&amp;!buff.lead_by_example.up

					-- actions.build+=/gloomblade
					if max_cast_time >= gcd and usable_energy >= GetSpellCost(200758) and _Cast(200758, t, true) then return true end
					-- actions.build+=/backstab
					if max_cast_time >= gcd and usable_energy >= GetSpellCost(53) and _Cast(53, t, true) then return true end

					-- knife target
					if usable_energy >= energy_max and max_cast_time >= gcd and (not fleeing_from_target or pooling_combo_points) and combat_ends > 3.5 and not er_ready and combo_points_deficit > 0 and (not dance_up or _rootCheck("player")) then
						if _Cast(114014, t, nil, true) then return true end
					end

				end
			end

			local function finish()

				if not valid_physical_target then return end
				if pooling_combo_points then return end

				-- # While using Premeditation, avoid casting Slice and Dice when Shadow Dance is soon to be used, except for Kyrian
				-- actions.finish=variable,name=premed_snd_condition,value=talent.premeditation.enabled&amp;spell_targets.shuriken_storm<(5-covenant.necrolord)&amp;!covenant.kyrian
				local premed_snd_condition = premed_enabled and not is_kyrian
				if not er_ready and not master_assassin_up and usable_energy > GetSpellCost(315496) then
					-- actions.finish+=/slice_and_dice,if=!variable.premed_snd_condition&amp;spell_targets.shuriken_storm<6&amp;!buff.shadow_dance.up&amp;buff.slice_and_dice.remains<fight_remains&amp;refreshable
					if max_cast_time >= gcd and not load_mode and not premed_snd_condition and not dance_up and snd_remains < 4 and (not player_combat or fleeing_from_target) and not pooling_combo_points then
						if _Cast(315496) then
							Squid_Alert("Slice and Dice",nil,nil,nil,315496)
							return true
						end
					end
					-- actions.finish+=/slice_and_dice,if=variable.premed_snd_condition&amp;cooldown.shadow_dance.charges_fractional<1.75&amp;buff.slice_and_dice.remains<cooldown.symbols_of_death.remains&amp;(cooldown.shadow_dance.ready&amp;buff.symbols_of_death.remains-buff.shadow_dance.remains<1.2)
					if max_cast_time >= gcd and premed_snd_condition and dance_charges_frac < 1.75 and snd_remains < symbols_cd and dance_cd == 0 and symbols_remains - dance_remains < 1.2 and (not player_combat or fleeing_from_target) then
						if _Cast(315496) then
							Squid_Alert("Slice and Dice",nil,nil,nil,315496)
							return true
						end
					end
				end

				-- # Helper Variable for Rupture. Skip during Master Assassin or during Dance with Dark and no Nightstalker.
				-- actions.finish+=/variable,name=skip_rupture,value=master_assassin_remains>0|!talent.nightstalker.enabled&amp;talent.dark_shadow.enabled&amp;buff.shadow_dance.up|spell_targets.shuriken_storm>=5
				local skip_rupture = master_assassin_remains > 0 or not nightstalker_enabled and dark_shadow_enabled and dance_up
				-- # Keep up Rupture if it is about to run out.
				-- actions.finish+=/rupture,if=(!variable.skip_rupture|variable.use_priority_rotation)&amp;target.time_to_die-remains>6&amp;refreshable
				if not master_assassin_up then
					if max_cast_time >= gcd and not skip_rupture and target_hp > 25 and target_rupture_remains < 4 + bin(not load_mode)*3 - combo_points_deficit*2 then
						if _Cast(1943, t, nil, true) then return true end
					end
				end
				-- actions.finish+=/secret_technique
				if max_cast_time >= gcd and not bcc10 and _Cast(280719, t, true) then return true end

				-- # Multidotting targets that will live for the duration of Rupture, refresh during pandemic.
				-- actions.finish+=/rupture,cycle_targets=1,if=!variable.skip_rupture&amp;!variable.use_priority_rotation&amp;spell_targets.shuriken_storm>=2&amp;target.time_to_die>=(5+(2*combo_points))&amp;refreshable

				-- # Refresh Rupture early if it will expire during Symbols. Do that refresh if SoD gets ready in the next 5s.
				-- actions.finish+=/rupture,if=!variable.skip_rupture&amp;remains<cooldown.symbols_of_death.remains+10&amp;cooldown.symbols_of_death.remains<=5&amp;target.time_to_die-remains>cooldown.symbols_of_death.remains+5
				if not master_assassin_up then
					if max_cast_time >= gcd and not skip_rupture and target_rupture_remains < symbols_cd + 10 and symbols_cd <= 5 then
						if _Cast(1943, t, nil, true) then return true end
					end
				end

				-- actions.finish+=/eviscerate
				if max_cast_time >= gcd and _Cast(196819, t, true) then return true end

			end

			local function stealthed()

				if not valid_physical_target then return end
				local ss_cost = GetSpellCost(185438)

				-- # If Stealth/vanish are up, use Shadowstrike to benefit from the passive bonus and Find Weakness, even if we are at max CP (unless using Master Assassin)
				-- perform the shadowstrike opener?
				-- actions.stealthed=shadowstrike,if=(buff.stealth.up|buff.vanish.up)&amp;master_assassin_remains=0

				-- # Finish at 4+ CP without DS, 5+ with DS, and 6 with DS after Vanish
				-- actions.stealthed+=/call_action_list,name=finish,if=combo_points.deficit<=1-(talent.deeper_stratagem.enabled&amp;buff.vanish.up)
				if combo_points_deficit <= 1 - bin(deeper_stratagem_enabled and vanish_up) or er_ready then
					if finish() then return true end
				end

				-- actions.stealthed+=/shadowstrike,if=stealthed.sepsis&amp;spell_targets.shuriken_storm<4
				if max_cast_time >= gcd and sepsis_stealth and usable_energy >= ss_cost then
					if _Cast(185438, t, true) then return true end
				end

				-- actions.stealthed+=/shiv,if=talent.nightstalker.enabled&amp;runeforge.tiny_toxic_blade&amp;spell_targets.shuriken_storm<5
				if max_cast_time >= gcd and nightstalker_enabled and runeforge == "TTB" then
					if _Cast(5938, t, true) then Squid_Alert("Why are you using tiny toxic blade?",nil,nil,nil,5938) return true end
				end

				-- spread mode
				-- # Up to 3 targets (no prio) keep up Find Weakness by cycling Shadowstrike.
				-- actions.stealthed+=/shadowstrike,cycle_targets=1,if=!variable.use_priority_rotation&amp;debuff.find_weakness.remains<1&amp;spell_targets.shuriken_storm<=3&amp;target.time_to_die-remains>6

				-- # For priority rotation, use Shadowstrike over Storm with WM against up to 4 targets or if FW is running off (on any amount of targets)

				-- actions.stealthed+=/shadowstrike,if=variable.use_priority_rotation&amp;(debuff.find_weakness.remains<1|talent.weaponmaster.enabled&amp;spell_targets.shuriken_storm<=4)
				local fw_remains = _debuffRemains(t, 316220, "player")
				if max_cast_time >= gcd and fw_remains < 1 and usable_energy >= ss_cost then
					if _Cast(185438, t, true) then return true end
				end
				-- actions.stealthed+=/shuriken_storm,if=spell_targets>=3+(buff.the_rotten.up|runeforge.akaaris_soul_fragment&amp;conduit.deeper_daggers.rank>=7)&amp;(buff.symbols_of_death_autocrit.up|!buff.premeditation.up|spell_targets>=5)
				if not dance_up and max_cast_time >= gcd and not bcc10 and AllEnemiesAroundMe(8) >= 3 + bin(target_hp < 45) and usable_energy >= GetSpellCost(197835) then
					if _Cast(197835) then return true end
				end
				-- # Shadowstrike to refresh Find Weakness and to ensure we can carry over a full FW into the next SoD if possible.
				-- actions.stealthed+=/shadowstrike,if=debuff.find_weakness.remains<=1|cooldown.symbols_of_death.remains<18&amp;debuff.find_weakness.remains<cooldown.symbols_of_death.remains
				if max_cast_time >= gcd and usable_energy >= ss_cost and (fw_remains < 1 or symbols_cd < 18 and fw_remains < symbols_cd) then
					if _Cast(185438, t, true) then return true end
				end
				-- actions.stealthed+=/gloomblade,if=buff.perforated_veins.stack>=5&amp;conduit.perforated_veins.rank>=13
				if max_cast_time >= gcd and pv_stacks >= 5 and pv_rank >= 13 and usable_energy >= GetSpellCost(200758) then
					if _Cast(200758, t, true) then return true end
				end
				-- actions.stealthed+=/shadowstrike
				if max_cast_time >= gcd and usable_energy >= ss_cost then
					if _Cast(185438, t, true) then return true end
				end
				-- actions.stealthed+=/cheap_shot,if=!target.is_boss&amp;combo_points.deficit>=1&amp;buff.shot_in_the_dark.up&amp;energy.time_to_40>gcd.max
				-- uhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
			end

			local function stealth_cds()
				-- # Stealth Cooldowns
				-- # Helper Variable
				-- actions.stealth_cds=variable,name=shd_threshold,value=cooldown.shadow_dance.charges_fractional>=1.75
				-- # Vanish if we are capping on Dance charges. Early before first dance if we have no Nightstalker but Dark Shadow in order to get Rupture up (no Master Assassin).
				-- actions.stealth_cds+=/vanish,if=(!variable.shd_threshold|!talent.nightstalker.enabled&amp;talent.dark_shadow.enabled)&amp;combo_points.deficit>1&amp;!runeforge.mark_of_the_master_assassin
				-- # Pool for Shadowmeld + Shadowstrike unless we are about to cap on Dance charges. Only when Find Weakness is about to run out.
				-- actions.stealth_cds+=/pool_resource,for_next=1,extra_amount=40,if=race.night_elf
				-- actions.stealth_cds+=/shadowmeld,if=energy>=40&amp;energy.deficit>=10&amp;!variable.shd_threshold&amp;combo_points.deficit>1&amp;debuff.find_weakness.remains<1
				-- # CP thresholds for entering Shadow Dance
				-- actions.stealth_cds+=/variable,name=shd_combo_points,value=combo_points.deficit>=2+buff.shadow_blades.up
				-- actions.stealth_cds+=/variable,name=shd_combo_points,value=combo_points.deficit>=3,if=covenant.kyrian
				-- actions.stealth_cds+=/variable,name=shd_combo_points,value=combo_points.deficit<=1,if=variable.use_priority_rotation&amp;spell_targets.shuriken_storm>=4
				-- # Dance during Symbols or above threshold.
				-- actions.stealth_cds+=/shadow_dance,if=variable.shd_combo_points&amp;(variable.shd_threshold|buff.symbols_of_death.remains>=1.2|spell_targets.shuriken_storm>=4&amp;cooldown.symbols_of_death.remains>10)
				-- # Burn remaining Dances before the fight ends if SoD won't be ready in time.
				-- actions.stealth_cds+=/shadow_dance,if=variable.shd_combo_points&amp;fight_remains<cooldown.symbols_of_death.remains

			end

			local function actions()

				-- # Used to determine whether cooldowns wait for SnD based on targets.
				snd_condition = snd_up

				if (stealth_up or vanish_up) and (not offensive_vanish or time - offensive_vanish >= 3) then return true end

				-- actions+=/call_action_list,name=cds
				if cds() then return true end

				-- # Run fully switches to the Stealthed Rotation (by doing so, it forces pooling if nothing is available).
				-- actions+=/run_action_list,name=stealthed,if=stealthed.all
				if dance_up or subterfuge_up or ( vanish_up or stealth_up ) and offensive_vanish and time - offensive_vanish < 3 then
					if stealthed() then return true end
				end

				-- # Apply Slice and Dice at 2+ CP during the first 10 seconds, after that 4+ CP if it expires within the next GCD or is not up
				-- actions+=/slice_and_dice,if=spell_targets.shuriken_storm<6&amp;fight_remains>6&amp;buff.slice_and_dice.remains<gcd.max&amp;combo_points>=4-(time<10)*2
				-- if max_cast_time >= gcd and snd_remains < gcd and combo_points >= 4 - bin(time_in_combat<10) * 2 and not pooling_combo_points and (not player_combat or fleeing_from_target) then
				-- 	if _Cast(315496) then
				-- 		Squid_Alert("Slice and Dice",nil,nil,nil,315496)
				-- 		return true
				-- 	end
				-- end

				-- # Only change rotation if we have priority_rotation set and multiple targets up.
				-- actions+=/variable,name=use_priority_rotation,value=priority_rotation&amp;spell_targets.shuriken_storm>=2
				-- # Priority Rotation? Let's give a crap about energy for the stealth CDs (builder still respect it). Yup, it can be that simple.
				-- actions+=/call_action_list,name=stealth_cds,if=variable.use_priority_rotation
				-- # Used to define when to use stealth CDs or builders
				-- actions+=/variable,name=stealth_threshold,value=25+talent.vigor.enabled*20+talent.master_of_shadows.enabled*20+talent.shadow_focus.enabled*25+talent.alacrity.enabled*20+25*(spell_targets.shuriken_storm>=4)
				local stealth_threshold = 25 + bin(vigor_enabled)*20 + bin(master_of_shadows_enabled)*20 + bin(shadow_focus_enabled)*25 + bin(alacrity_enabled)*20
				-- # Consider using a Stealth CD when reaching the energy threshold
				-- actions+=/call_action_list,name=stealth_cds,if=energy.deficit<=variable.stealth_threshold
				if energy_max - usable_energy <= stealth_threshold then
					if stealth_cds() then return true end
				end
				-- actions+=/call_action_list,name=finish,if=combo_points=animacharged_cp

				if er_ready and not pooling_combo_points then
					if finish() then return true end
				end
				-- # Finish at 4+ without DS or with SoD crit buff, 5+ with DS (outside stealth)
				-- actions+=/call_action_list,name=finish,if=combo_points.deficit<=1|fight_remains<=1&amp;combo_points>=3|buff.symbols_of_death_autocrit.up&amp;combo_points>=4
				if combo_points_deficit <= 1 or symbols_crit_up and combo_points >= 4 then
					if finish() then return true end
				end

				-- ? ? ? ?
				-- # With DS also finish at 4+ against 4 targets (outside stealth)
				-- actions+=/call_action_list,name=finish,if=spell_targets.shuriken_storm>=4&amp;combo_points>=4

				-- # Use a builder when reaching the energy threshold
				-- actions+=/call_action_list,name=build,if=energy.deficit<=variable.stealth_threshold
				if energy_deficit <= stealth_threshold then
					if build() then return true end
				end

				-- # Lowest priority in all of the APL because it causes a GCD
				-- actions+=/arcane_torrent,if=energy.deficit>=15+energy.regen
				-- actions+=/arcane_pulse
				-- actions+=/lights_judgment
				-- actions+=/bag_of_tricks

			end


			-- stealth_openers()

			-- stealth_finishers()

			actions()

			-- if lockdown() then return true end

			-- if cooldowns() then return true end

			-- if spend() then return true end

			-- if generate() then return true end

		end

	end

	function Squid_DeathKnight()

		if IsMounted() or IsFlying() then return; end

		local auto_chains = SQUID.auto_chains

		-- Priorities (actions.precombat):
	 --    flask/food/augmentation/snapshot_stats/potion/raise_dead/army_of_the_dead,delay=2
		local time = GetTime()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
		local gcd_remains = GetGCD()
		local spec = GetSpecialization();
		local pet_up = UnitExists("pet") and not UnitIsDeadOrGhost("pet")
		local RunicPower = UnitPower("player");
		local function PlayerRunesUp() local count=0; for i=1,6 do if select(3,GetRuneCooldown(i)) == true then count=count+1; end end return count,6-count; end
		local Runes = PlayerRunesUp();
		local frenzy = UnitBuffID("player",207289);
		local wounds = current_target and _debuffStacks(current_target,194310);
		local leap_cd = _spellCooldown(47482)
		local dark_transformation = pet_up and UnitBuffID("pet",63560)
		local controlling_pet
		--grip gap closers on units moving away from player
		-- if _movingAwayFrom("player",.11,unit) then
		--Unholy
		if spec == 3 then

			local function priority_actions()
				--dark sim
				local sim = {
					--mage
					28272,		-- Pig
					118,		-- Sheep
					277792,		-- Bee
					161354,		-- Monkey
					277787,		-- Direhorn
					161355,		-- Penguin
					161353,		-- Polar Bear
					120140,		-- Porcupine
					61305,		-- Cat
					61721,		-- Rabbit
					61780,		-- Turkey
					28271,		-- Turtle
					82691,		-- Ring of Frost
					203286,		-- Greater Pyroblast
					199786,		-- Glacial Spike

					--warlock
					116858,		-- Chaos Bolt
					157695,   	-- Demon Bolt
					5782,		-- Fear
					118699,		-- Fear

					--shaman
					51514,		-- Hex

					--paladin
					20066,		-- Repentance

					--druid
					33786,		-- Cyclone
					202771,		-- full moon

					--priest
					2060,       -- Greater Heal
				}

				if IsPlayerSpell(77606) and _spellCooldown(77606) <= .45 then
					for i=1,#Enemies do
						local cast,_,_,_,_,_,_,_,id = UnitCastingInfo(Enemies[i])
						if cast and tContains(sim,id) and _distance(Enemies[i]) < 40 then
							local timeleft = _castTimeLeft(Enemies[i])
							if timeleft <= gcd + .5 then
								if timeleft <= .4 then
									if _Cast(77606,Enemies[i],nil,true) then
										Squid_Alert_Big("Dark Sim","(".. GetSpellInfo(id) ..")",1,3.5,77606)
									end
								end
								waiting_for_sim = time
								waiting_for_sim_unit = Enemies[i]
							end
						end
					end
				end

				--grip gap openers
				if enemy_gapclose and time - enemy_gapclose <= gcd then
					if unit_is_unit(enemy_gapclose_pointer,current_target) and _movingAwayFrom("player",.11,current_target) then
						if _Cast(49576,current_target,true) then
							Squid_Alert_Big("Grip " .. UnitClass(current_target),"(Gap Opener)",1,3.5,49576)
							gap_opener_gripped = time
							gap_opener_gripped_pointer = current_target
						end
					end
				end
				--chains after gripping a gap opener
				if gap_opener_gripped and time - gap_opener_gripped <= gcd+.5 then
					local e = gap_opener_gripped_pointer
					if not _slowImmuneCheck(e) and not _immuneMagic(e) then
						_Cast(45524,e)
					end
				end
				--keep pet 5 yds from target when petkick is available
				if dark_transformation and leap_cd <= 2 then--and not _isMeleeDps(current_target) then
					local pet_dist = _distance("pet",current_target)
					if pet_dist <= 5.5 or pet_dist > 8 then
						local x,y,z = ObjectPosition("pet")
						local tx,ty,tz = ObjectPosition(current_target)
						local direction
						for i=0,math.pi*2,.05 do
							if not TraceLine(tx - 9 * math.cos(i), ty - 9 * math.sin(i), tz+1, x, y, z+1, 0x100111) then
								direction = i
								break
							end
						end
						--sometimes we end up with a nil TraceLine result
						if not tx or not ty then
							tx,ty,tz = ObjectPosition(current_target)
						end
						tx = tx - 9 * math.cos(direction)
						ty = ty - 9 * math.sin(direction)
						RunMacroText("/petmoveto")
						ClickPosition(tx,ty,tz)
						CancelPendingSpell()
						_targetLastTarget()
					end
					controlling_pet=true
				end
				--offensive icebound
				if lowestEnemy <= 30 then
					if _stunCheck("player") then
						if _spellCooldown(48792) == 0 then
							CastSpellByID(48792)
							Squid_Alert_Big("Icebound Fortitude","(Offensive)",4,3.5,48792)
						end
					end
				end
			end

			local function essences()
				_Cast(295373,current_target,true);
			end

			local function aoe()

				local dndticking = UnitBuffID("player",188290)
				-- actions.aoe=death_and_decay,if=cooldown.apocalypse.remains
				if _spellCooldown(275699) > 3 then
					_AeCast(43265,current_target,30)
				end
				-- actions.aoe+=/defile
				-- actions.aoe+=/epidemic,if=death_and_decay.ticking&amp;rune<2&amp;!variable.pooling_for_gargoyle
				if dndticking and Runes < 2 and RunicPower >= 30 then
					_Cast(207317)
				end
				-- actions.aoe+=/death_coil,if=death_and_decay.ticking&amp;rune<2&amp;!variable.pooling_for_gargoyle
				if Runes < 2 and dndticking then
					if _HP("player") < 80 then
						_Cast(49998)
					else
						_Cast(47541)
					end
				end
				-- actions.aoe+=/scourge_strike,if=death_and_decay.ticking&amp;cooldown.apocalypse.remains
				if not arena then
					if dndticking and _spellCooldown(275699) > 3 then
						if IsPlayerSpell(223829) then
							_Cast(223829)
						else
							_Cast(55090)
						end
					end
				end
				-- actions.aoe+=/clawing_shadows,if=death_and_decay.ticking&amp;cooldown.apocalypse.remains
				-- actions.aoe+=/epidemic,if=!variable.pooling_for_gargoyle
				if RunicPower >= 30 then
					_Cast(207317)
				end
				-- actions.aoe+=/festering_strike,target_if=debuff.festering_wound.stack<=1&amp;cooldown.death_and_decay.remains
				if wounds <= 1 and _spellCooldown(43265) > 2 then
					_Cast(85948)
				end
				-- actions.aoe+=/festering_strike,if=talent.bursting_sores.enabled&amp;spell_targets.bursting_sores>=2&amp;debuff.festering_wound.stack<=1
				-- actions.aoe+=/death_coil,if=buff.sudden_doom.react&amp;rune.deficit>=4
				if UnitBuffID("player",49530) and Runes <= 2 then
					_Cast(47541)
				end
				-- actions.aoe+=/death_coil,if=buff.sudden_doom.react&amp;!variable.pooling_for_gargoyle|pet.gargoyle.active
				if UnitBuffID("player",49530) then
					_Cast(47541)
				end
				-- actions.aoe+=/death_coil,if=runic_power.deficit<14&amp;(cooldown.apocalypse.remains>5|debuff.festering_wound.stack>4)&amp;!variable.pooling_for_gargoyle
				if RunicPower > 86 and (_spellCooldown(275699) > 5 or wounds > 4) then
					if _HP("player") < 80 then
						_Cast(49998)
					else
						_Cast(47541)
					end
				end
				-- actions.aoe+=/scourge_strike,if=((debuff.festering_wound.up&amp;cooldown.apocalypse.remains>5)|debuff.festering_wound.stack>4)&amp;cooldown.army_of_the_dead.remains>5
				if ((wounds > 0 and _spellCooldown(275699) > 5) or wounds > 4) and _spellCooldown(288853) > 5 then
					_Cast(223829);
				end
				-- actions.aoe+=/clawing_shadows,if=((debuff.festering_wound.up&amp;cooldown.apocalypse.remains>5)|debuff.festering_wound.stack>4)&amp;cooldown.army_of_the_dead.remains>5
				-- actions.aoe+=/death_coil,if=runic_power.deficit<20&amp;!variable.pooling_for_gargoyle
				if RunicPower > 80 then
					if _HP("player") < 80 then
						_Cast(49998)
					else
						_Cast(47541)
					end
				end
				-- actions.aoe+=/festering_strike,if=((((debuff.festering_wound.stack<4&amp;!buff.unholy_frenzy.up)|debuff.festering_wound.stack<3)&amp;cooldown.apocalypse.remains<3)|debuff.festering_wound.stack<1)&amp;cooldown.army_of_the_dead.remains>5
				if ((((wounds < 4 and not frenzy) or wounds < 3) and _spellCooldown(275699) < 3) or wounds < 1) and _spellCooldown(288853) > 5 then
					_Cast(85948)
				end
				-- actions.aoe+=/death_coil,if=!variable.pooling_for_gargoyle
				if _HP("player") < 80 then
					_Cast(49998)
				else
					_Cast(47541)
				end

			end
			-- print(Runes)
			local function cooldowns()
				-- Priorities (actions.cooldowns):
			   --abomb
				if IsPlayerSpell(288853) then
					_AeCast(288853,current_target,40)
				else
					_Cast(42650)
				end
				-- army_of_the_dead/apocalypse,if=debuff.festering_wound.stack>=4/dark_transformation,if=!raid_event.adds.exists|raid_event.adds.in>15
				if wounds >= 4 then
					if _Cast(275699) then
						Squid_Alert("Apocalypse",nil,nil,nil,275699)
					end
				end
				if frenzy or lowestEnemy <= 50 or lowestFriend <= 35 then
					_Cast(63560)
				end
				-- summon_gargoyle,if=runic_power.deficit<14
				-- unholy_frenzy,if=debuff.festering_wound.stack<4&amp;!(equipped.ramping_amplitude_gigavolt_engine|azerite.magus_of_the_dead.enabled)
				-- unholy_frenzy,if=cooldown.apocalypse.remains<2&amp;(equipped.ramping_amplitude_gigavolt_engine|azerite.magus_of_the_dead.enabled)
				if (_spellCooldown(275699) < 2 or _spellCooldown(275699) > 35) and _distance(current_target) < 5 then
					_Cast(207289)
				end
				-- unholy_frenzy,if=active_enemies>=2&amp;((cooldown.death_and_decay.remains<=gcd&amp;!talent.defile.enabled)|(cooldown.defile.remains<=gcd&amp;talent.defile.enabled))
				-- soul_reaper,target_if=target.time_to_die<8&amp;target.time_to_die>4
				-- soul_reaper,if=(!raid_event.adds.exists|raid_event.adds.in>20)&amp;rune<=(1-buff.unholy_frenzy.up)/unholy_blight
				if Runes < 3 and wounds > 0 then
					_Cast(130736)
				end

			end

			local function generic()

				--  death_coil,if=buff.sudden_doom.react&amp;!variable.pooling_for_gargoyle|pet.gargoyle.active
				if UnitBuffID("player",49530) then
					_Cast(47541,current_target)
				end
				--  death_coil,if=runic_power.deficit<14&amp;(cooldown.apocalypse.remains>5|debuff.festering_wound.stack>4)&amp;!variable.pooling_for_gargoyle
				if RunicPower >= 86 then
					if _HP("player") < 80 then
						_Cast(49998,current_target)
					else
						_Cast(47541,current_target)
					end
				end
				--  death_and_decay,if=talent.pestilence.enabled&amp;cooldown.apocalypse.remains/defile,if=cooldown.apocalypse.remains
				--  scourge_strike,if=((debuff.festering_wound.up&amp;cooldown.apocalypse.remains>5)|debuff.festering_wound.stack>4)&amp;cooldown.army_of_the_dead.remains>5
				if wounds > 0 then
					if _spellCooldown(275699) > 5 or wounds > 4 then
						-- if IsPlayerSpell(223829) then
							_Cast(223829,current_target)
						-- end
					end
				end
				--  clawing_shadows,if=((debuff.festering_wound.up&amp;cooldown.apocalypse.remains>5)|debuff.festering_wound.stack>4)&amp;cooldown.army_of_the_dead.remains>5
				--  death_coil,if=runic_power.deficit<20&amp;!variable.pooling_for_gargoyle
				if RunicPower >= 80 then
					if _HP("player") < 80 then
						_Cast(49998)
					else
						_Cast(47541)
					end
				end
				-- festering_strike,if=((((debuff.festering_wound.stack<4&amp;!buff.unholy_frenzy.up)|debuff.festering_wound.stack<3)&amp;cooldown.apocalypse.remains<3)|debuff.festering_wound.stack<1)&amp;cooldown.army_of_the_dead.remains>5
				if ((((wounds <= 4 and not frenzy) or wounds <= 3) and _spellCooldown(275699) < 3) or wounds < 1) and (_spellCooldown(288853) > 3 or _spellCooldown(42650) > 3) then
					_Cast(85948)
				end

			end
			--get pet
			if not UnitExists("pet") or UnitIsDeadOrGhost("pet") then
				_Cast(46584)
			end


			--totem stomp
			function Stomp(totem,name)
				local hp = UnitHealth(totem)
				local maxhp = UnitHealthMax(totem)
				if hp <= 1 then return false; end
				--DEATH COIL
				if hp <= 12500 then
					_Cast(47541,totem)
				end
				--SCOURGE STRIKE
				if hp <= 9000 then
					_Cast(55090,totem)
				end
			end

			local totems = {
			101398,	--Psyfiend
			119052,	--War Banner
			104818,	--Ancestral Protection Totem
			53006,	--Spirit Link Totem
			2630,	--Earthbind Totem
			60561,	--Earthgrab Totem
			-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
			5925,	--Grounding Totem
			105425,	--Skyfury Totem
			5913,	--Tremor Totem
			105451,	--Counterstrike Totem
			}

			if arena then
				for i=1,#Pets do
					local e = Pets[i]
					local name = UnitName(e);
					local id = UnitCreatureID(e)
					--only kill cap totems when they're casting
					if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
						Stomp(e,name)
					end
				end
			end

			--Combat
			if current_target and UnitCanAttack("player",current_target) and not UnitIsDeadOrGhost(current_target) and not _immuneCheck(current_target) and (UnitAffectingCombat(current_target) or UnitIsPlayer(current_target) or _isDummy(current_target)) then

				--wraith
				if _rootCheck("player") and _rootRemains("player") >= 1.5 and _distance(current_target) > 7 then
					if _Cast(212552) then
						Squid_Alert_Big("Wraith Walk","(Root)",nil,nil,212552)
					end
				end

				--death's advance
				if frenzy or lowestEnemy < 35 then
					if _Cast(48265) then
						Squid_Alert_Big("Death's Advence","(Offensive)",nil,nil,48265)
					end
				end

				priority_actions();

				--Chains Target
				if UnitIsPlayer(current_target) and _distance(current_target) > 4 and not _isSlowed(current_target) and not _CCcheck(current_target) then
					if not _slowImmuneCheck(current_target) and _movingAwayFrom("player",.11,current_target) then
						if _Cast(45524,current_target) then
							Squid_Alert("Chains","(Target)",nil,nil,45524)
						end
					end
				end

				--chains peel
				if auto_chains then
					if lowestFriend <= 60 then
						for i=1,#Enemies do if _isMeleeDps(Enemies[i]) then
							local e = Enemies[i]
							if not _isSlowed(e) and not _CCcheck(e) and not _slowImmuneCheck(e) then
								if not _slowImmuneCheck(e) then
									if _Cast(45524,e) then
										Squid_Alert("Chains " .. UnitClass(e),"(Peel)",nil,nil,45524)
									end
								end
							end
						end end
					end
				end

				if _HP("player") < 50 then
					_Cast(49998,current_target);
				end

				-- actions+=/outbreak,target_if=dot.virulent_plague.remains<=gcd
				if _debuffRemains(current_target,191587) < 2.5 then
					_Cast(77575,current_target);
				end

				if (not PetAttackSent or time-PetAttackSent > 2) and not controlling_pet then
					PetAttack();
					-- RunMacroText("/use 14")
					PetAttackSent=time
				end

				if not AutoAttackSent or time-AutoAttackSent > 2 then
					StartAttack()
				end

				--auto_attack/variable,name=pooling_for_gargoyle,value=cooldown.summon_gargoyle.remains<5&amp;talent.summon_gargoyle.enabled
				essences();

				cooldowns();

				aoe();

				generic();


			end


		end


	end

	function Squid_DemonHunter()

		if IsMounted() then return; end

		local spec = GetSpecialization()

		local function _valid(unit)
			return UnitIsVisible(unit)
			and UnitCanAttack("player",unit)
			and not UnitIsDeadOrGhost(unit)
			and not _breakableCC(unit)
			and not _immuneCheck(unit)
			and (arena or UnitAffectingCombat(unit) or instance_type == "none" or UnitIsPlayer(unit) or _isDummy(unit))
		end

		local time = GetTime()

		local AutoFelRush = SQUID.AutoFelRush

		--Vengeance
		if spec == 1 then

			local gcd = 1.5/(1+(UnitSpellHaste("player")/100));

			local Fury = UnitPower("player")
			local FuryDeficit = UnitPowerMax("player") - Fury

			local BladeDance = UnitBuffID("player",162264) and 210152 or 188499 -- Blade Dance / Death Sweep
			local ChaosStrike = UnitBuffID("player",162264) and 201427 or 162794 -- Chaos Strike / Annihilation
			local DemonsBite = 162243
			local ConsumeMagic = 278326
			local ImmolationAura = 258920
			local FelRush = 195072
			local VengefulRetreat = 198793
			local Imprison = 217832
			local ThrowGlaive = 185123
			local ManaRift = 235903
			local Metamorphosis = 191427
			local FelEruption = 211881

			local gcdRemains = _spellCooldown(ChaosStrike)

			local mana_rift_enabled = IsPlayerSpell(ManaRift)
			local fel_eruption_enabled = IsPlayerSpell(FelEruption)

			--CHECK FEL ERUPTION TAKEN BEFORE CONSIDERING CD

			local mana_rift_cd = _spellCooldown(ManaRift)
			local fel_eruption_cd = _spellCooldown(FelEruption)
			local imprison_cd = _spellCooldown(221527)

			local fel_eruption_ready = fel_eruption_enabled and fel_eruption_cd <= gcd
			local imprison_ready = imprison_cd <= gcd

			local mana_rift_ready = mana_rift_enabled and mana_rift_cd <= 2

			-- local dk_on_team
			-- local dk_grip_cd = 20
			-- if arena then
			-- 	for i=1,#Friends do if UnitClass(Friends[i]) == "Death Knight" then
			-- 		dk_on_team=Friends[i]
			-- 	end end
			-- end

			-- if dk_on_team then
			-- 	dk_grip_cd = UnitCooldown(dk_on_team,"Death Grip")
			-- end



			local theirHealerCC
			local theirHealerStunDR
			local theirHealerStunDRRemains
			local theirHealerIncapDR
			local theirHealerIncapDRRemains
			local theirHealerImprison
			local theirHealerImprisonRemains
			local pool_for_burn
			local willBurn

			-- if theirHealer and UnitIsVisible(theirHealer) then
			-- 	theirHealerCC = _CCremains(theirHealer)
			-- 	theirHealerStunDR = _stunDR(theirHealer)
			-- 	theirHealerImprison = UnitDebuffID(theirHealer,217832) or UnitDebuffID(theirHealer,221527) or UnitDebuffID(theirHealer,33786)
			-- 	if theirHealerImprison then
			-- 		local amt = _debuffRemains(theirHealer,217832)
			-- 		if _debuffRemains(theirHealer,221527) > amt then amt = _debuffRemains(theirHealer,221527) end
			-- 		if _debuffRemains(theirHealer,33786) > amt then amt = _debuffRemains(theirHealer,33786) end
			-- 		theirHealerImprisonRemains = amt
			-- 	end
			-- 	theirHealerStunDRRemains = _drRemains(theirHealer,"stun")
			-- 	theirHealerIncapDR = _incapacitateDR(theirHealer)
			-- 	theirHealerIncapDRRemains = _drRemains(theirHealer,"incapacitate")
			-- 	-- local grip_pool_value = dk_grip_cd < 4 and 10 or 0
			-- 	pool_for_burn = IsManaRift and Fury < 50+grip_pool_value and (theirHealerCC >= 1.5 or (stunAvailable and (theirHealerStunDR == 1 or theirHealerStunDRRemains <= 3)) or (incapAvailable and (theirHealerIncapDR == 1 or theirHealerIncapDRRemains <= 3)))
			-- 	willBurn = IsManaRift and not UnitChannelInfo("player") and Fury >= 50 and (theirHealerCC >= 1.5 or theirHealerImprison) and _spellCooldown(ManaRift) <= gcd and _distance(theirHealer) < 6.5
			-- end

			-- if _spellCooldown(ManaRift) > 3 then pool_for_burn=nil end

			-- local timeTilBurn =2.5-(_spellCooldown(ManaRift)-10)
			-- if timeTilBurn < 0 then timeTilBurn=100 end

			-- local readyToBurn = theirHealer and burnReady and _distance(theirHealer) < 11

			-- if theirHealerStunDR then
			-- 	if theirHealerStunDR < 1 then
			-- 		stunAvailable = nil
			-- 	end
			-- end

			-- if theirHealerIncapDR then
			-- 	if theirHealerIncapDR < 1 then
			-- 	 	incapAvailable = nil
			-- 	end
			-- end

			-- --burn
			-- if willBurn then
			-- 	local minCC = 1.2 - (_spellCooldown(VengefulRetreat) <= gcdRemains and .3 or 0)
			-- 	if theirHealerCC >= minCC then
			-- 		if theirHealerImprison then
			-- 			if theirHealerImprisonRemains < 2.5 - ((select(4,GetNetStats())/1000)/1.05) then
			-- 				CastSpellByID(ManaRift,theirHealer)
			-- 			end
			-- 			return;
			-- 		elseif theirHealerCC > minCC then
			-- 			CastSpellByID(ManaRift,theirHealer)
			-- 		end
			-- 	end
			-- 	return
			-- end

			-- if theirHealer and theirHealerCC and not UnitChannelInfo("player") then
			-- 	if UnitDebuffID(theirHealer,127797) then
			-- 		CastSpellByID(ManaRift,theirHealer)
			-- 	end
			-- end

			-- if theirHealer and timeTilBurn <= 2.5 and theirHealerCC == 0 and not theirHealerImprison then
			-- 	if _distance(theirHealer) < 5 then
			-- 		if _valid("target") then
			-- 			RetreatToUnit("target",true)
			-- 		else
			-- 			RetreatForward()
			-- 		end
			-- 	end
			-- end

			-- if theirHealerCC and theirHealerCC < .5 and not theirHealerImprison and not _immuneCheck(theirHealer) and pool_for_burn then
			-- 	if Fury >= 60 and (stunAvailable or incapAvailable or theirHealerCC >= 2 or (theirHealerImprison and theirHealerImprisonRemains >= 2)) then
			-- 		if _movingTowards(theirHealer) then
			-- 			local t=theirHealer
			-- 			if _distance(t) > 11 and gcdRemains <= .35 and (GetSpellCharges(195072) > 0 or _spellCooldown(198793) <= gcdRemains) then
			-- 				if GetSpellCharges(195072) > 0 then
			-- 					_Cast(195072);
			-- 				else
			-- 					RetreatForward();
			-- 				end
			-- 			end
			-- 		end
			-- 	end
			-- end

			-- if IsManaRift and readyToBurn and theirHealerCC and theirHealerCC < .5 and not theirHealerImprison and not _immuneCheck(theirHealer) then
			-- 	if Fury >= 60 then
			-- 		--Fel Eruption
			-- 		if stunAvailable then
			-- 			_Cast(211881,theirHealer,true)
			-- 			return
			-- 		end
			-- 		if incapAvailable then
			-- 			_Cast(217832,theirHealer,true)
			-- 			_Cast(221527,theirHealer,true)
			-- 			return
			-- 		end
			-- 	elseif Fury >= 50 then
			-- 		if incapAvailable then
			-- 			_Cast(217832,theirHealer,true)
			-- 			_Cast(221527,theirHealer,true)
			-- 		end
			-- 	end
			-- end

			local function Stomp(totem,name)
				-- if ComboPoints >= 5 then return false; end
				local hp = UnitHealth(totem)
				local maxhp = UnitHealthMax(totem)
				if hp <= 1 then return false; end
				--Glaive Toss
				if hp < 2000 then
					_Cast(185123,totem,nil,true)
				end
				--Chaos Strike
				_Cast(ChaosStrike,totem,nil,true)
				--Demon's Bite
				_Cast(162243,totem,nil,true)
			end

			local totems = {
			101398,	--Psyfiend
			119052,	--War Banner
			104818,	--Ancestral Protection Totem
			53006,	--Spirit Link Totem
			2630,	--Earthbind Totem
			60561,	--Earthgrab Totem
			-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
			5925,	--Grounding Totem
			105425,	--Skyfury Totem
			5913,	--Tremor Totem
			105451,	--Counterstrike Totem
			}

			if arena then
				for i=1,#Pets do
					local e = Pets[i]
					local name = UnitName(e);
					local id = UnitCreatureID(e)
					--only kill cap totems when they're casting
					if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
						Stomp(e,name)
					end
				end
			end

			--pool above 50 while healer is off stun dr
			--we have cc avail or healer is in cc + time to get there
			--pool

			local t=current_target

			local VT = _valid(t)

			--Simcraft Action Priority List (rotation)
			local BladeDanceTargets = EnemiesAroundMe(8)
			local IsDemonic = IsPlayerSpell(213410)
			local MetaCooldown = _spellCooldown(Metamorphosis)
			local IsNemesis = IsPlayerSpell(206491)
			local NemesisCooldown = _spellCooldown(206491)
			local FirstBlood = IsPlayerSpell(206416)
			local BlindFury = IsPlayerSpell(203550)
			local EyeBeamCooldown = _spellCooldown(198013)
			local IsDarkSlash = IsPlayerSpell(258860)
			local DarkSlashCooldown = _spellCooldown(258860)
			local ChaoticTransformation = AzeritePowerTaken(220)
			local BladeDanceCooldown = _spellCooldown(BladeDance)
			local DemonBlades = IsPlayerSpell(203555)

			-- # Executed every time the actor is available.
			-- actions=auto_attack
			-- actions+=/variable,name=blade_dance,value=talent.first_blood.enabled|spell_targets.blade_dance1>=(3-talent.trail_of_ruin.enabled)
			local blade_dance = (FirstBlood and _distance(t) < 8.5) or BladeDanceTargets >= (3 - (IsPlayerSpell(258881) and 1 or 0))
			-- actions+=/variable,name=waiting_for_nemesis,value=!(!talent.nemesis.enabled|cooldown.nemesis.ready|cooldown.nemesis.remains>target.time_to_die|cooldown.nemesis.remains>60)
			-- local waiting_for_nemesis = not (not IsNemesis or NemesisCooldown == 0 ) ?????
			-- actions+=/variable,name=pooling_for_meta,value=!talent.demonic.enabled&amp;cooldown.metamorphosis.remains<6&amp;fury.deficit>30&amp;(!variable.waiting_for_nemesis|cooldown.nemesis.remains<10)
			local pooling_for_meta = not IsDemonic and MetaCooldown < 6 and FuryDeficit > 30 and (not waiting_for_nemesis or NemesisCooldown < 10)
			-- actions+=/variable,name=pooling_for_blade_dance,value=variable.blade_dance&amp;(fury<75-talent.first_blood.enabled*20)
			local pooling_for_blade_dance = blade_dance and (Fury < 75 - (FirstBlood and 20 or 0))
			-- actions+=/variable,name=pooling_for_eye_beam,value=talent.demonic.enabled&amp;!talent.blind_fury.enabled&amp;cooldown.eye_beam.remains<(gcd.max*2)&amp;fury.deficit>20
			local pooling_for_eye_beam = IsDemonic and not BlindFury and EyeBeamCooldown < gcd*2 and FuryDeficit > 20 and (not UnitBuffID("player",162264) or _buffRemains("player",162264) < 3)
			-- actions+=/variable,name=waiting_for_dark_slash,value=talent.dark_slash.enabled&amp;!variable.pooling_for_blade_dance&amp;!variable.pooling_for_meta&amp;cooldown.dark_slash.up
			local waiting_for_dark_slash = IsDarkSlash and not pooling_for_blade_dance and not pooling_for_meta and DarkSlashCooldown <= gcd

			local function essences(t)
				--breath of the dying (reaping flames)
				-- if valid_magical_target and (not squid_clone_delay or time - squid_clone_delay > 1 or cat or moving_towards_long) then
					if IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd and not _immuneMagic(t) then
						local a_hp = _HP(t)
						local hp = (100 * (UnitHealth(t)-GetSpellEffect(310690)) / UnitHealthMax(t));
						if hp < 20 or (a_hp < 95 + (their_healer_cc and 18 or 0) and a_hp > 80) then
							if hp < 20 or a_hp > 80 then
								if _Cast(310690,t,true) then
									Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
								end
							end
						end
					end
				-- end
				-- actions.essences=concentrated_flame
				if IsPlayerSpell(295373) then
					_Cast(295373,t,true)
				end
				-- actions.essences+=/blood_of_the_enemy,if=buff.metamorphosis.up|target.time_to_die<=10
				-- actions.essences+=/guardian_of_azeroth
				if IsPlayerSpell(295840) and _spellCooldown(295840) <= gcd then
					if _buffRemains("player",162264) >= 20 then _Cast(295840,t) end
				end
				-- actions.essences+=/focused_azerite_beam,if=spell_targets.blade_dance1>=2|raid_event.adds.in>60
				-- actions.essences+=/purifying_blast,if=spell_targets.blade_dance1>=2|raid_event.adds.in>60
				-- actions.essences+=/the_unbound_force
				-- actions.essences+=/ripple_in_space
				-- actions.essences+=/worldvein_resonance,if=buff.lifeblood.stack<3
				-- actions.essences+=/memory_of_lucid_dreams,if=fury<40&amp;buff.metamorphosis.up
			end

			local function cooldown(t)
				--purge
				if _purgeAnything(t) and not UnitChannelInfo("player") then
					_Cast(278326,t,true)
				end
				-- actions.cooldown=metamorphosis,if=!(talent.demonic.enabled|variable.pooling_for_meta|variable.waiting_for_nemesis)|target.time_to_die<25
				if Squid_Burst then
					if _AeCast(191427,t,40,8) then
						Squid_Alert("Metamorphosis",nil,nil,nil,191427)
					end
				end
				-- if not (IsDemonic or pooling_for_meta or waiting_for_nemesis) or (_HP(t) < 25 and not UnitBuffID("player",162264)) then
				-- 	if not UnitBuffID("player",162264) then
				-- 		_AeCast(191427,t,40,8);
				-- 	end
				-- end
				-- actions.cooldown+=/metamorphosis,if=talent.demonic.enabled&amp;(!azerite.chaotic_transformation.enabled|(cooldown.eye_beam.remains>20&amp;cooldown.blade_dance.remains>gcd.max))
				-- if IsDemonic and (not ChaoticTransformation or (EyeBeamCooldown > 20 and BladeDanceCooldown > gcd)) then
				-- 	if not UnitBuffID("player",162264) then
				-- 		_AeCast(191427,t,40,8);
				-- 	end
				-- end
				-- actions.cooldown+=/nemesis,target_if=min:target.time_to_die,if=raid_event.adds.exists&amp;debuff.nemesis.down&amp;(active_enemies>desired_targets|raid_event.adds.in>60)
				-- actions.cooldown+=/nemesis,if=!raid_event.adds.exists
				-- actions.cooldown+=/potion,if=buff.metamorphosis.remains>25|target.time_to_die<60
				-- actions.cooldown+=/use_item,name=galecallers_boon,sync=fel_barrage
				-- actions.cooldown+=/use_item,name=galecallers_boon,if=!talent.fel_barrage.enabled
				-- actions.cooldown+=/use_item,name=lustrous_golden_plumage
				-- actions.cooldown+=/call_action_list,name=essences
				essences(t)
			end

			local function demonic(t)
				-- actions.demonic=death_sweep,if=variable.blade_dance
				if blade_dance then
					if _Cast(210152) then return end
				end
				-- actions.demonic+=/eye_beam,if=raid_event.adds.up|raid_event.adds.in>25
				if not pool_for_burn and _spellCooldown(198013) <= gcdRemains then
					if _amIfacing(t) and _LoS(t) and _distance(t) <= 8 then
						if _Cast(198013) then return end
					end
				end
				-- actions.demonic+=/fel_barrage,if=((!cooldown.eye_beam.up|buff.metamorphosis.up)&amp;raid_event.adds.in>30)|active_enemies>desired_targets
				-- actions.demonic+=/blade_dance,if=variable.blade_dance&amp;!cooldown.metamorphosis.ready&amp;(cooldown.eye_beam.remains>(5-azerite.revolving_blades.rank*3)|(raid_event.adds.in>cooldown&amp;raid_event.adds.in<25))
				if not pool_for_burn and blade_dance and MetaCooldown > gcdRemains and EyeBeamCooldown > 5 then
					if _Cast(188499) then return end
				end
				-- actions.demonic+=/immolation_aura
				if _Cast(258920) then return end
				-- actions.demonic+=/annihilation,if=!variable.pooling_for_blade_dance
				if not pool_for_burn and not pooling_for_blade_dance then
					if _Cast(201427,t) then return end
				end
				-- actions.demonic+=/felblade,if=fury.deficit>=40
				if FuryDeficit >= 40 then
					if _Cast(232893,t) then return end
				end
				-- actions.demonic+=/chaos_strike,if=!variable.pooling_for_blade_dance&amp;!variable.pooling_for_eye_beam
				if not pool_for_burn and not pooling_for_blade_dance and not pooling_for_eye_beam then
					if _Cast(162794,t) then return end
				end
				-- actions.demonic+=/fel_rush,if=talent.demon_blades.enabled&amp;!cooldown.eye_beam.ready&amp;(charges=2|(raid_event.movement.in>10&amp;raid_event.adds.in>10))
				-- if IsPlayerSpell(203555) and EyeBeamCooldown > gcdRemains and GetSpellCharges == 2 then
				-- 	_Cast(195072);
				-- end
				-- actions.demonic+=/demons_bite
				if _Cast(162243,t) then return end
				-- actions.demonic+=/throw_glaive,if=buff.out_of_range.up
				if _distance(t) > 13 then
					if _Cast(185123,t,true) then return end
				end
				-- actions.demonic+=/fel_rush,if=movement.distance>15|buff.out_of_range.up
				-- actions.demonic+=/vengeful_retreat,if=movement.distance>15
				-- actions.demonic+=/throw_glaive,if=talent.demon_blades.enabled
			end

			local function normal(t)
				-- actions.normal=vengeful_retreat,if=talent.momentum.enabled&amp;buff.prepared.down&amp;time>1
				-- actions.normal+=/fel_rush,if=(variable.waiting_for_momentum|talent.fel_mastery.enabled)&amp;(charges=2|(raid_event.movement.in>10&amp;raid_event.adds.in>10))
				-- actions.normal+=/fel_barrage,if=!variable.waiting_for_momentum&amp;(active_enemies>desired_targets|raid_event.adds.in>30)
				-- actions.normal+=/death_sweep,if=variable.blade_dance
				if blade_dance then
					if _Cast(210152) then return end
				end
				-- actions.normal+= /immolation_aura
				if _Cast(258920) then return end
				-- actions.normal+=/eye_beam,if=active_enemies>1&amp;(!raid_event.adds.exists|raid_event.adds.up)&amp;!variable.waiting_for_momentum
				if not pool_for_burn and BladeDanceTargets >= 2 and _spellCooldown(198013) <= gcdRemains then
					if _amIfacing(t) and _LoS(t) and _distance(t) <= 8 then
						if _Cast(198013) then return end
					end
				end
				-- actions.normal+=/blade_dance,if=variable.blade_dance
				if not pool_for_burn and blade_dance then
					if _Cast(188499) then return end
				end
				-- actions.normal+=/felblade,if=fury.deficit>=40
				if FuryDeficit >= 40 then
					if _Cast(232893,t) then return end
				end
				-- actions.normal+=/eye_beam,if=!talent.blind_fury.enabled&amp;!variable.waiting_for_dark_slash&amp;raid_event.adds.in>cooldown
				if not pool_for_burn and not BlindFury and not waiting_for_dark_slash then
					if _spellCooldown(198013) <= gcdRemains then
						if _amIfacing(t) and _LoS(t) and _distance(t) <= 8 then
							if _Cast(198013) then return end
						end
					end
				end
				-- actions.normal+=/annihilation,if=(talent.demon_blades.enabled|!variable.waiting_for_momentum|fury.deficit<30|buff.metamorphosis.remains<5)&amp;!variable.pooling_for_blade_dance&amp;!variable.waiting_for_dark_slash
				if (DemonBlades or not waiting_for_momentum or FuryDeficit < 30 or _buffRemains("player",162264) < 5) and not pooling_for_blade_dance and not pool_for_burn and not waiting_for_dark_slash then
					if _Cast(201427,t) then return end
				end
				-- actions.normal+=/chaos_strike,if=(talent.demon_blades.enabled|!variable.waiting_for_momentum|fury.deficit<30)&amp;!variable.pooling_for_meta&amp;!variable.pooling_for_blade_dance&amp;!variable.waiting_for_dark_slash
				if (DemonBlades or not waiting_for_momentum or FuryDeficit < 30) and not pooling_for_meta and not pooling_for_blade_dance and not pool_for_burn and not waiting_for_dark_slash then
					if _Cast(162794,t) then return end
				end
				-- actions.normal+=/eye_beam,if=talent.blind_fury.enabled&amp;raid_event.adds.in>cooldown
				if BlindFury then
					if _spellCooldown(198013) <= gcdRemains then
						if _amIfacing(t) and _LoS(t) and _distance(t) <= 8 then
							if _Cast(198013) then return end
						end
					end
				end
				-- actions.normal+=/demons_bite
				if _Cast(162243,t) then return end
				-- actions.normal+=/fel_rush,if=!talent.momentum.enabled&amp;raid_event.movement.in>charges*10&amp;talent.demon_blades.enabled
				-- actions.normal+=/felblade,if=movement.distance>15|buff.out_of_range.up
				-- actions.normal+=/fel_rush,if=movement.distance>15|(buff.out_of_range.up&amp;!talent.momentum.enabled)
				-- actions.normal+=/vengeful_retreat,if=movement.distance>15
				-- actions.normal+=/throw_glaive,if=talent.demon_blades.enabled
				if DemonBlades then
					if _Cast(185123,t,true) then return end
				end
			end

			-- actions+=/variable,name=waiting_for_momentum,value=talent.momentum.enabled&amp;!buff.momentum.up
			if VT then

				--auto attack
				if not start_attack_time or time - start_attack_time > .5 then
					StartAttack()
					start_attack_time=time
				end
				-- actions+=/call_action_list,name=cooldown,if=gcd.remains=0
				cooldown(t)
				-- actions+=/pick_up_fragment,if=fury.deficit>=35
				-- actions+=/call_action_list,name=dark_slash,if=talent.dark_slash.enabled&amp;(variable.waiting_for_dark_slash|debuff.dark_slash.up)
				-- actions+=/run_action_list,name=demonic,if=talent.demonic.enabled
				if IsDemonic then
					demonic(t)
				end
				-- actions+=/run_action_list,name=normal
				normal(t)


				if AutoFelRush then
					if _distance(t) > 15 and gcdRemains <= .35 and (GetSpellCharges(195072) > 0 or _spellCooldown(198793) <= gcdRemains) then
						if _movingTowards(t) then
							if GetSpellCharges(195072) > 0 then
								_Cast(195072);
							else
								RetreatForward();
							end
						end
					end
				end

			end

			-- actions.dark_slash=dark_slash,if=fury>=80&amp;(!variable.blade_dance|!cooldown.blade_dance.ready)
			-- actions.dark_slash+=/annihilation,if=debuff.dark_slash.up
			-- actions.dark_slash+=/chaos_strike,if=debuff.dark_slash.up

			-- actions.normal=vengeful_retreat,if=talent.momentum.enabled&amp;buff.prepared.down&amp;time>1
			-- actions.normal+=/fel_rush,if=(variable.waiting_for_momentum|talent.fel_mastery.enabled)&amp;(charges=2|(raid_event.movement.in>10&amp;raid_event.adds.in>10))
			-- actions.normal+=/fel_barrage,if=!variable.waiting_for_momentum&amp;(active_enemies>desired_targets|raid_event.adds.in>30)
			-- actions.normal+=/death_sweep,if=variable.blade_dance
			-- actions.normal+=/immolation_aura
			-- actions.normal+=/eye_beam,if=active_enemies>1&amp;(!raid_event.adds.exists|raid_event.adds.up)&amp;!variable.waiting_for_momentum
			-- actions.normal+=/blade_dance,if=variable.blade_dance
			-- actions.normal+=/felblade,if=fury.deficit>=40
			-- actions.normal+=/eye_beam,if=!talent.blind_fury.enabled&amp;!variable.waiting_for_dark_slash&amp;raid_event.adds.in>cooldown
			-- actions.normal+=/annihilation,if=(talent.demon_blades.enabled|!variable.waiting_for_momentum|fury.deficit<30|buff.metamorphosis.remains<5)&amp;!variable.pooling_for_blade_dance&amp;!variable.waiting_for_dark_slash
			-- actions.normal+=/chaos_strike,if=(talent.demon_blades.enabled|!variable.waiting_for_momentum|fury.deficit<30)&amp;!variable.pooling_for_meta&amp;!variable.pooling_for_blade_dance&amp;!variable.waiting_for_dark_slash
			-- actions.normal+=/eye_beam,if=talent.blind_fury.enabled&amp;raid_event.adds.in>cooldown
			-- actions.normal+=/demons_bite
			-- actions.normal+=/fel_rush,if=!talent.momentum.enabled&amp;raid_event.movement.in>charges*10&amp;talent.demon_blades.enabled
			-- actions.normal+=/felblade,if=movement.distance>15|buff.out_of_range.up
			-- actions.normal+=/fel_rush,if=movement.distance>15|(buff.out_of_range.up&amp;!talent.momentum.enabled)
			-- actions.normal+=/vengeful_retreat,if=movement.distance>15
			-- actions.normal+=/throw_glaive,if=talent.demon_blades.enabled


		--Vengeance
		elseif spec == 2 then

			local t="target"
			lowThreat = {};
			for i=1,#Enemies do
				local e=Enemies[i];
				if UnitAffectingCombat(e) then
					--lowThreat enemy--
					local priority=0;
					if unit_is_unit(e,"target") then
						priority=priority+1;
					end
					--threat prio
					local threat = UnitThreatSituation("player",e)
					if threat then priority = priority + threat else priority = priority + 4 end
					table.insert(lowThreat,{pointer=e,priority=priority,hp=_HP(e)});
				end
			end
			table.sort(lowThreat, function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hp < y.hp) end)

			-- # Executed every time the actor is available.
			-- actions=auto_attack
			-- actions+=/consume_magic
			if not UnitAffectingCombat("player") then return false; end

			local soul_fragments = _buffStacks("player",203981)
			local pain = UnitPower("player")
			local mainTarget

			if lowThreat[1] then
				mainTarget = lowThreat[1].pointer
			end

			-- _Cast(185245,mainTarget or t)

			local function defensives()
				-- # Defensives
				_Cast(295373)
				-- actions.defensives=demon_spikes
				_Cast(203720)
				-- actions.defensives+=/metamorphosis
				_Cast(191427)
				-- actions.defensives+=/fiery_brand
				_Cast(204021,mainTarget or t)
			end

			local function normal()
				-- actions.normal=infernal_strike
				-- _AeCast(195072,mainTarget or t,40)
				-- actions.normal+=/spirit_bomb,if=soul_fragments>=4
				if soul_fragments >= 4 then
					_Cast(247454)
				end
				-- actions.normal+=/soul_cleave,if=!talent.spirit_bomb.enabled
				-- actions.normal+=/soul_cleave,if=talent.spirit_bomb.enabled&amp;soul_fragments=0
				if soul_fragments == 0 then
					_Cast(228477)
				end
				-- actions.normal+=/immolation_aura,if=pain<=90
				if pain <= 90 then
					_Cast(178740)
				end
				-- actions.normal+=/felblade,if=pain<=70
				-- actions.normal+=/fracture,if=soul_fragments<=3
				if soul_fragments <= 3 then
					_Cast(263642,mainTarget or t)
				end
				-- actions.normal+=/fel_devastation
				-- actions.normal+=/sigil_of_flame
				_AeCast(188499,mainTarget or t,30)
				-- actions.normal+=/shear
				_Cast(203782)
				-- actions.normal+=/throw_glaive
				_Cast(204157,mainTarget or t)
			end

			-- actions+=/call_action_list,name=brand,if=talent.charred_flesh.enabled
			-- actions+=/call_action_list,name=defensives
			defensives()
			-- actions+=/call_action_list,name=normal
			normal()

			-- # Fiery Brand Rotation
			-- actions.brand=sigil_of_flame,if=cooldown.fiery_brand.remains<2
			-- actions.brand+=/infernal_strike,if=cooldown.fiery_brand.remains=0
			-- actions.brand+=/fiery_brand
			-- actions.brand+=/immolation_aura,if=dot.fiery_brand.ticking
			-- actions.brand+=/fel_devastation,if=dot.fiery_brand.ticking
			-- actions.brand+=/infernal_strike,if=dot.fiery_brand.ticking
			-- actions.brand+=/sigil_of_flame,if=dot.fiery_brand.ticking

			-- # Defensives
			-- actions.defensives=demon_spikes
			-- actions.defensives+=/metamorphosis
			-- actions.defensives+=/fiery_brand

			-- # Normal Rotation
			-- actions.normal=infernal_strike
			-- actions.normal+=/spirit_bomb,if=soul_fragments>=4
			-- actions.normal+=/soul_cleave,if=!talent.spirit_bomb.enabled
			-- actions.normal+=/soul_cleave,if=talent.spirit_bomb.enabled&amp;soul_fragments=0
			-- actions.normal+=/immolation_aura,if=pain<=90
			-- actions.normal+=/felblade,if=pain<=70
			-- actions.normal+=/fracture,if=soul_fragments<=3
			-- actions.normal+=/fel_devastation
			-- actions.normal+=/sigil_of_flame
			-- actions.normal+=/shear
			-- actions.normal+=/throw_glaive

		end


	end

	function Squid_Druid()

		if IsMounted() or IsFlying() or IsAoEPending() then return end
		local spec = GetSpecialization()
		local time = GetTime()
		local latency = select(4,GetNetStats())/1000

		local utilities = SQUID.UtilitiesOnly

		--Feral
		if spec == 2 then

			--swiftmended out of stealth? (maybe had dot)
			--crucible of flamed out of stealth (also maybe broke to dot..idk)
			--add primal wrath
			--add pre bear
			--add clones
			--add auto dash / sr
			--add get people out of stealth
			--add auto stuns
			--add shift roots
			--add war banner check for stuns
			--add minimum flat hp for rip, smth like this UnitHealthMax("player")/9 * groupsize

			local spread = SQUID.spread_mode
			local auto_burst = SQUID.auto_burst

			local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
			local gcd_remains = GetGCD()

			local groupsize = GetNumGroupMembers()

			local human = GetShapeshiftForm() == 0
			local cat = UnitBuffID("player",768)
			local bear = UnitBuffID("player",5487)
			local travel = UnitBuffID("player",783)

			local cp = UnitPower("player",4)
			local energy = UnitPower("player",3)
			local energy_max = UnitPowerMax("player",3)
			local energy_deficit = energy_max-energy
			local energy_regen = GetPowerRegen()
			local energy_time_to_max = energy_deficit/energy_regen
			local player_hp = _HP("player")
			local player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")

			local prowl = UnitBuffID("player",5215) or UnitBuffID("player",102547)
			local shadowmeld = UnitBuffID("player",58984)
			local ps_remains = _buffRemains("player",69369)
			local ps = ps_remains > 0
			local clearcasting = UnitBuffID("player",135700)
			local clearcasting_remains = _buffRemains("player",135700)
			local berserk_remains = _buffRemains("player",106951)
			local incarn_remains = _buffRemains("player",102543)
			local berserk_incarn = berserk_remains > 0 or incarn_remains > 0
			local berserk_incarn_remains = berserk_remains > 0 and berserk_remains or incarn_remains
			local tigers_fury_remains = _buffRemains("player",5217)
			local tigers_fury = tigers_fury_remains > 0
			local iron_jaws = UnitBuffID("player",276026)
			local bloodtalons_stacks = _buffStacks("player",145152)
			local bloodtalons_up = bloodtalons_stacks > 0
			local dash = UnitBuffID("player",1850)
			local dash_cd = _spellCooldown(1850)
			local stampeding_roar = UnitBuffID("player",77764)
			local savage_roar_remains = _buffRemains("player",52610)
			local savage_roar_up = savage_roar_remains > 0

			local existing_root_remains = 0
			local existing_root
			for i=1,#Enemies do
				local r = _debuffRemains(Enemies[i],339,"player")
				if r > 0 then
					existing_root_remains = r
					existing_root = true
				end
			end

			local wild_fleshrending_enabled = AzeritePowerTaken(359)
			local feral_frenzy_enabled = IsPlayerSpell(274837)
			local bloodtalons_enabled = IsPlayerSpell(155672)
			local savage_roar_enabled = IsPlayerSpell(52610)
			local sabertooth_enabled = IsPlayerSpell(202031)
			local incarn_enabled = IsPlayerSpell(102543)
			local balance_affinity = IsPlayerSpell(197488)
			local lunar_inspiration = IsPlayerSpell(155580)
			local thorns_enabled = IsPlayerSpell(305497)
			local fresh_wound = IsPlayerSpell(203224)

			local tigers_fury_cd = _spellCooldown(5217)
			local feral_frenzy_cd = _spellCooldown(274837)
			local berserk_cd = _spellCooldown(106951)
			local incarn_cd = _spellCooldown(102543)
			local berserk_incarn_cd = berserk_cd > 0 and berserk_cd or incarn_cd
			local swiftmend_cd = IsPlayerSpell(18562) and _spellCooldown(18562) or 1000
			local remove_corruption_cd = _spellCooldown(2782)
			local wild_charge_cd = _spellCooldown(102401)
			local thorns_cd = _spellCooldown(305497)
			local maim_cd = _spellCooldown(22570)

			local function rip_remains(unit) return _debuffRemains(unit,1079,"player") end
			local function rake_remains(unit) return _debuffRemains(unit,155722,"player") end
			local rip_power = _ripPower
			local rake_power = _rakePower
			local current_rake_snapshot = GetCurrentSnapshot(1822)
			local current_rip_snapshot = GetCurrentSnapshot()
			local hold_cp_for_maim

			local combat = UnitAffectingCombat("player")
			local group_size = GetNumGroupMembers()

			if SQUID.cap_bot then
				ok_to_cat = time
			end

			if not bite_effect_checked or time-bite_effect_checked > 5 then
				bite_effect = GetSpellEffect(22568)
				if not bite_effect then
					--for clients in other langs
					bite_effect = (UnitAttackPower("player")*.7) * 5
				end
				bite_effect_checked=time
			end

			--really good bite effect (not accounting for armor and defensives)
			local bite_effect = bite_effect / 5 * cp
			local bite_mod = 1 + ((energy-25)*.04)
			if bite_mod < 1 then bite_mod = 1 end
			if bite_mod > 2 then bite_mod = 2 end
			bite_effect = bite_effect * bite_mod

			local their_healer
			local their_healer_cc
			local their_healer_cc_remains = 0
			if theirHealer then
				their_healer = theirHealer
				their_healer_cc_remains = _CCremains(theirHealer)
				their_healer_cc = their_healer_cc_remains > 0
			end

			local enemy_player_around
			for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then
				enemy_player_around=true
				break
			end end

			local enemy_rogue
			local enemy_rogue_kidney_cd
			local enemy_rogue_cp
			for i=1,#Enemies do if UnitClass(Enemies[i]) == "Rogue" then
				enemy_rogue = Enemies[i]
				break
			end end
			if enemy_rogue then
				enemy_rogue_kidney_cd = UnitCooldown(enemy_rogue,408)
				-- enemy_rogue_cp = UnitPower(enemy_rogue,) --fix
				enemy_rogue_cc = _CCremains(enemy_rogue) >= .05
			end

			local our_healer = ourHealer
			local our_healer_cc
			local our_healer_cc_remains = 0
			if our_healer then
				our_healer_cc_remains = _CCremains(ourHealer)
				our_healer_cc = our_healer_cc_remains > 0
			end

			local our_mage
			local our_mage_casting_cc
			local our_mage_cc_target
			for i=1,#Friends do if UnitClass(Friends[i]) == "Mage" then
				our_mage = Friends[i]
				break
			end end
			if arena and our_mage then
				local magecc = {
				"Polymorph",
				"Ring of Frost",
				}
				our_mage_casting_cc = tContains(magecc,UnitCastingInfo(our_mage))
				if our_mage_casting_cc then
					our_mage_cc_target = UnitSpellTarget(our_mage)
				end
			end

			if player_cast and player_cast_id == 33786 then
				squid_clone_delay = time
			end

			local nature_lockout = _spellCooldown(33786) > gcd_remains or _spellCooldown(8936) > gcd_remains

			--reset shifting delay after clone cast if it was interrupted, or completed
			if nature_lockout or (player_clone and time - player_clone < .35) then squid_clone_delay = nil end

			local aoe_range = 8.5 + (balance_affinity and 5 or 0)

			local enemies_around = EnemiesAroundMe(aoe_range)
			local bcc = _bccAM(aoe_range)

			local function root_value(unit)
				local root = _rootRemains(unit)
				if root > 1 then
					if lowestFriend < 40 then
						local friend = lowestFriendName
					end
				end
			end

			--check if unit is valid (immunes, dead, breakable cc etc)
			local function valid(unit,immune,nocheck)
				if not unit then return false end
				return (nocheck or UnitCanAttack("player",unit))
				and (nockeck or not UnitIsDeadOrGhost(unit))
				and not _breakableCC(unit)
				and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
				and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))));
			end

			--our current target
			local t = current_target
			local valid_attackable_target = t and UnitCanAttack("player",t)
			local valid_physical_target = valid(t,1)
			local valid_magical_target = valid(t,2)

			--dots on target
			local target_rip_ticking = valid_physical_target and rip_remains(t) > 0
			local target_rip_remains = target_rip_ticking and rip_remains(t) or 0
			local target_rip_power = target_rip_ticking and rip_power(t) or 0

			-- print(target_rip_power)

			local target_rake_ticking = valid_physical_target and rake_remains(t) > 0
			local target_rake_remains = target_rake_ticking and rake_remains(t) or 0
			local target_rake_power = target_rake_ticking and rake_power(t) or 0

			local moving_towards_time = moving_towards_unit_duration(t,.11)
			local moving_towards = _movingTowards(t,.11)
			local moving_towards_target = valid_physical_target and moving_towards and moving_towards_time > .135
			local moving_towards_long = valid_physical_target and moving_towards and moving_towards_time > .18
			local melee_range_target = valid_physical_target and _meleeRange(t)
			local distance_target = valid_physical_target and _distance(t) or 0
			local function target_outruns_player(dist)
				if valid_attackable_target and moving_towards_target then
					local px,py,pz = GetPlayerPosition()
					px,py,pz = PredictUnitPosition("player",.25)
					local x,y,z = ObjectPosition(t)
					x,y,z = PredictUnitPosition(t,.25)
					local estimated_dist = GetDistanceBetweenPositions(x,y,z,px,py,pz) - UnitCombatReach("player") - UnitCombatReach("target")
					return estimated_dist > dist
				end
				return false
			end

			local function valid_stun_target(unit)
				return _CCremains(unit) <= .35 and (_stunDR(unit) == 1 or _drRemains(unit,"stun") > 8) and not _immunePhysical(unit)
			end

			--offtargets, prioritized by hp or lowest dot duration
			local offtargets = {}
			local riptargets = {}
			local raketargets = {}
			local thrashtargets = {}
			for i=1,#Enemies do
				local e=Enemies[i]
				if valid(e,1,true) then
					local hp = _HP(e)
					local melee_range = _meleeRange(e)
					local prio = 0
					local rake = rake_remains(e)
					local rip = rip_remains(e)
					local thrash = _debuffRemains(e,106830,"player")
					table.insert(offtargets,{pointer=e,hp=hp,rake=rake,rip=rip,thrash=thrash,mr=melee_range})
					table.insert(riptargets,{pointer=e,hp=hp,rake=rake,rip=rip,thrash=thrash,mr=melee_range})
					table.insert(raketargets,{pointer=e,hp=hp,rake=rake,rip=rip,thrash=thrash,mr=melee_range})
					table.insert(thrashtargets,{pointer=e,hp=hp,rake=rake,rip=rip,thrash=thrash,mr=melee_range})
				end
			end
			table.sort(offtargets,function(x,y) return x.hp < y.hp end)
			table.sort(riptargets,function(x,y) return x.rip < y.rip or (x.rip == y.rip and x.hp < y.hp) end)
			table.sort(raketargets,function(x,y) return x.rake < y.rake or (x.rake == y.rake and x.hp < y.hp) end)
			table.sort(thrashtargets,function(x,y) return x.thrash < y.thrash or (x.thrash == y.thrash and x.hp < y.hp) end)

			local lowestfriends = {}
			for i=1,#Friends do
				local e=Friends[i]
				if UnitIsPlayer(e) then
					local hp = _HP(e)
					table.insert(lowestfriends,{pointer=e,hp=hp})
				end
			end
			table.sort(lowestfriends,function(x,y) return x.hp < y.hp end)

			local dispellable ={
			80240,	--havoc
			51514,	--hex
			211015,	--hex cockroach
			210873,	--hex compy
			211010,	--hex snake
			211004,	--hex spider
			277784,	--hex wicker mongrel
			277778,	--hex zandalari tendonripper
			309328,	--hex living honey
			199954,	--curse of frag (removed?)
			202914,	--spider sting
			202797,	--viper sting
			};

			local function remove_corruption(unit)
				local lessDelay = minDelayTime/1.3;
				for i=1,#dispellable do
					local debuff,_,_,five,six,seven = UnitDebuffID(unit,dispellable[i]);
					if debuff and seven-time < six-lessDelay then
						return dispellable[i];
					end
				end
			end

			local function hibernate_inc()
				for i=1,#Enemies do
					if UnitCastingInfo(Enemies[i]) == "Hibernate" then
						local e = Enemies[i]
						local dest = UnitSpellTarget(Enemies[i])
						if unit_is_unit(dest,player_pointer) and _distance(e) < 40 then
							local time_left = _castTimeLeft(e)
							if time_left <= latency + .23 then
								return true
							end
						end
					end
				end
			end

			local function stealth()
				--rake stun stealthed targets
				for i=1,#Enemies do if _stealthCheck(Enemies[i]) then
					if _Cast(1822,Enemies[i],nil,true) then
						Squid_Alert_Big("Rake Stun " .. UnitClass(Enemies[i]),"(Stealth)",1,nil,1822)
						return
					end
				end end
				--stampeding roar invis mage (after arena preparation)
				if our_mage and not UnitBuffID("player",32727) and _distance(our_mage) < 12 then
					if UnitBuffID(our_mage,66) then
						if _Cast(106898) then
							Squid_Alert("Stampeding Roar","Mage Invis")
							return
						end
					end
				end
				--rake target if not immune
				if valid_physical_target and melee_range_target then
					if _Cast(1822,t,true) then
						Squid_Alert("Rake Stun",UnitClass(t),nil,nil,1822)
						return
					end
				end
			end

			local function root_healer_los()
				if gcd_remains > .4 then return end
				if their_healer and their_healer_cc_remains < gcd+1 and _rootRemains(their_healer) < gcd+1 and _rootDR(their_healer) >= .25 then
					if valid_attackable_target and not _LoS(their_healer,t) then
						if _Cast(339,their_healer) then
							Squid_Alert_Big("Root " .. UnitClass(their_healer),"(LoS)",4,nil,339)
							return
						end
					end
				end
			end

			local function priority_ps()
				if gcd_remains > .4 then return end
				--root healer los
				root_healer_los()
				--root target to gapclose
				if moving_towards_target
					and _isMoving(current_target)
					and (distance_target > 7.75 or _isSlowed("player") and not _isSlowed(current_target))
					and (select(4,GetUnitSpeed("player")) <= select(4,GetUnitSpeed(current_target)) or distance_target > 13.65) then
					if not _slowImmuneCheck(current_target) and not _immuneMagic(current_target) then
						if _Cast(339,current_target) then
							Squid_Alert("Root Target","(Gapclose)",nil,nil,339)
							return true
						end
					end
				end
				--root melee
				if (group_size < 5 or instance_type == "pvp") then
					for i=1,#Enemies do
						local d = _distance(Enemies[i])
						if d <= 38 then
							local e = Enemies[i]
							if (not unit_is_unit(e,current_target) or d > 7) and (existing_root_remains < 2 or d > 7) then
								if _isMeleeDps(e) and not _slowImmuneCheck(e) and not _immuneMagic(e) and select(2,UnitClass(e)) ~= "DRUID" then
									local cc = _CCremains(e)
									if cc < 1 then
										local root = _rootRemains(e)
										local rootdr = _rootDR(e)
										local dr_remains = _drRemains(e,"root")
										if (rootdr == 1 or dr_remains > 15 and rootdr >= .5) and root < 1 then
											if _Cast(339,e) then
												Squid_Alert("Root " .. UnitClass(e),"(Melee)",nil,nil,339)
												return true
											end
											return
										end
									end
								end
							end
						end
					end
				end
				--regrowths on people who need
				local rghp = 85
				rghp=rghp+(bloodtalons_enabled and 25 or 0)
				for i=1,#lowestfriends do
					local f = lowestfriends[i].pointer
					local hp = _HP(f)
					if hp <= rghp and _distance(f) < 38 and _LoS(f) then
						if _Cast(8936,f) then
							Squid_Alert("Regrowth "..UnitClass(f),nil,nil,nil,8936)
							return true
						end
						return
					end
				end
			end

			local function use_ps()
				if gcd_remains > .4 then return end
				if priority_ps() then return true end
				--roots on everything else
				if group_size < 5 or instance_type == "pvp" then
					for i=1,#Enemies do if not unit_is_unit(Enemies[i],t) then
						if _distance(Enemies[i]) <= 35 then
							local e = Enemies[i]
							local cc = _CCremains(e)
							if cc < 1 and not _slowImmuneCheck(e) and not _immuneMagic(e) and existing_root_remains < 2 then
								local root = _rootRemains(e)
								local rootdr = _rootDR(e)
								local dr_remains = _drRemains(e,"root")
								if (rootdr == 1 or dr_remains > 12 and rootdr >= .5) and root < 1 then
									if _Cast(339,e) then
										Squid_Alert("Root " .. UnitClass(e),"(PS)",nil,nil,339)
										return true
									end
									return
								end
							end
						end
					end end
				end
				--regrowths on anything
				local rghp = 101
				for i=1,#lowestfriends do
					local f = lowestfriends[i].pointer
					local hp = _HP(f)
					if hp <= rghp and _distance(f) < 38 and _LoS(f) then
						if _Cast(8936,f) then
							Squid_Alert("Regrowth "..UnitClass(f),nil,nil,nil,8936)
							return true
						end
						return
					end
				end
			end

			local function priority_actions()

				--auto attack
				if cat and valid_physical_target then
					if not start_attack_time or time - start_attack_time > .5 then
						StartAttack()
						start_attack_time=time
					end
				end

				--queued maim
				if squid_maim_queued then
					if time - squid_maim_queued < 8 then
						if UnitIsVisible(squid_maim_target) and valid_stun_target(squid_maim_target) then
							if maim_cd < 5 then
								if cp == 5 and maim_cd <= gcd_remains+1 then
									if _meleeRange(squid_maim_target) then
										if energy >= 30 * (berserk_incarn and .6 or 1) and _Cast(22570,squid_maim_target,nil,true) then
											Squid_Alert_Big("Maim " .. UnitClass(squid_maim_target),"(Queued)",nil,nil,22570)
											C_Timer.After(.3,function()
												-- Squid_Alert("|cFFc31d39Maim no longer queued",nil,nil,nil,22570)
												squid_maim_queued=nil
												squid_maim_target=nil
											end)
											return
										end
									elseif wild_charge_cd == 0 and maim_cd <= gcd_remains+.3 then
										local d = _distance(squid_maim_target)
										if d < 8 then
											Squid_Alert("Maim Ready","(Move Closer)",nil,nil,22570)
										elseif d > 25 then
											Squid_Alert("Too far to leap for maim",nil,nil,nil,22570)
										elseif d >= 8 and d <= 25 then
											if _Cast(102401,squid_maim_target,nil,true) then
												Squid_Alert("Wild Charge","(Maim Ready)",nil,nil,102401)
												return
											end
										end
									end
								end
								hold_cp_for_maim=true
							end
						end
					else
						Squid_Alert("|cFFc31d39Maim no longer queued",nil,nil,nil,22570)
						squid_maim_queued=nil
						squid_maim_target=nil
					end
				end

				--leap to healer when they are in breakable cc nether tempest / living bomb while they are in breakable cc

				--root their healer out of LoS of your target
				if ps then
					root_healer_los()
				end

				--pre bear
				if not bear then
					--healer cc or vendetta up or hp < 65 or no healer present
					if our_healer_cc or UnitDebuffID("player",79140) or (player_hp < 65 and (not our_healer or player_hp < 35)) then
						--don't spam pre bear. if the player wants to force cat after a pre bear, let them.
						if not pre_bear or time - pre_bear > 9 then
							--step was on player, kidney is off cd, and we're off dr
							if enemy_shadowstep and time-enemy_shadowstep <= gcd then
								if unit_is_unit("player",enemy_shadowstep_target)
								and enemy_rogue
								and enemy_rogue_kidney_cd <= gcd
								and not enemy_rogue_cc
								and _drRemains(player_pointer,"stun") <= gcd then
									if _Cast(5487) then
										Squid_Alert_Big("Pre Bear","(Step Kidney)",2,4.5,5487)
										C_Timer.After(.1,function() if UnitBuffID("player",5487) then pre_bear=time end end)
									end
								end
							end
							--rogue targeting player
							if enemy_rogue and enemy_rogue_kidney_cd <= gcd and not enemy_rogue_cc and _distance(enemy_rogue) < 8 then
								--player off dr
								if _drRemains(player_pointer,"stun") <= gcd then
									local rogue_target = UnitTarget(enemy_rogue)
									--player is rogue's target
									if unit_is_unit("player",rogue_target) then
										if _Cast(5487) then
											Squid_Alert_Big("Pre Bear","(Kidney)",2,4.5,5487)
											C_Timer.After(.1,function() if UnitBuffID("player",5487) then pre_bear=time end end)
										end
									end
								end
							end
						end
					end

				else
					--bear actions
					if _HP("player") < 50 + ((not our_healer or our_healer_cc) and 20 or 0) then
						_Cast(22842)
					end
				end


				--shift hibernate
				if cat then
					if hibernate_inc() then
						RunMacroText("/cancelform")
						Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
					end
				elseif travel then
					if hibernate_inc() then
						RunMacroText("/cancelform")
						Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
					end
				elseif bear then
					if hibernate_inc() then
						if EnemiesAttacking("player") == 0 then
							RunMacroText("/cancelform")
							Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
						end
					end
				end

				--rooting on event
				if lowestFriend < 30 or not bloodtalons_enabled or cp >= 4 then
					if ps then
						if shouldRootUnit
						and UnitIsVisible(shouldRootUnit)
						and shouldRootTime
						and time-shouldRootTime < gcd
						and _rootDR(shouldRootUnit) >= .25
						and not _slowImmuneCheck(shouldRootUnit)
						and not _immuneMagic(shouldRootUnit) then
							if shouldRootReason ~= "Cat Form" or _distance(shouldRootUnit) > 9 then
								if _Cast(339,shouldRootUnit) then
									Squid_Alert_Big("Rooted ",shouldRootReason,4,3.5,339)
								end
							end
						end
						if valid_magical_target
						and _debuffRemains(t,113942) >= 88.3
						and not _slowImmuneCheck(t) then
							if _Cast(339,t) then
								Squid_Alert_Big("Rooted","Demonic Gateway",4,3.5,339)
							end
						end
					end
				end

				--dispel
				if remove_corruption_cd <= gcd_remains then
					for i=1,#Friends do
						local dispel = remove_corruption(Friends[i])
						if dispel and _LoS(Friends[i]) and _Cast(2782,Friends[i]) then
							Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,2782)
						end
					end
				end

				--priority rooting
				-- if lowestFriend <= 75 or travel then
				-- 	--root melee to peel
				-- 	if ps then
				-- 		for i=1,#Enemies do
				-- 			local e = Enemies[i]
				-- 			--melee, lowest friend < 50%hp, or cds up and 75
				-- 			if _isMeleeDps(e) and (lowestFriend <= 50 or _CDcheck(e) or bear) then
				-- 				--rootdr
				-- 				local rootdr = _rootDR(e)
				-- 				local drremains = _drRemains(e,"root")
				-- 				if (rootdr == 1 or drremains > 14 and rootdr >= .5) and not _slowImmuneCheck(e) and not _immuneMagic(e) then
				-- 					if _Cast(339,e) then
				-- 						Squid_Alert("Rooted " .. UnitClass(e),"(Peel)",nil,nil,339)
				-- 					end
				-- 				end
				-- 			end
				-- 		end
				-- 	end
				-- end

				--totem stomp
				local function Stomp(totem,name)
					local hp = UnitHealth(totem)
					local maxhp = UnitHealthMax(totem)
					if hp <= 1 then return false; end
					--LI MOONFIRE TOTEMS
					if lunar_inspiration and hp <= 5000 then
						if _Cast(155625,totem,nil,true) then
							Squid_Alert_Big(name .. " Stomped","(Moonfire)",1,3.5,155625)
							return
						end
					end
					--REGULAR MOONFIRE PSYFIEND
					if name == "Psyfiend" then
						if _meleeRange(totem) then
							if _Cast(1822,totem,nil,true) then
								Squid_Alert_Big(name .. " Stomped","(Rake)",1,4,1822)
								return
							end
						else
							if _Cast(8921,totem,nil,true) then
								Squid_Alert_Big(name .. " Stomped","(Moonfire)",1,3.5,8921)
								return
							end
						end
					end
					--SHRED TOTEMS (CLEARCASTING)
					if clearcasting then
						if _Cast(5221,totem,nil,true) then
							Squid_Alert_Big(name .. " Stomped","(Shred)",1,4,5221)
							return
						end
					end
					--RAKE TOTEMS
					if hp <= 3400 then
						if _Cast(1822,totem,nil,true) then
							Squid_Alert_Big(name .. " Stomped","(Rake)",1,4,1822)
							return
						end
					end
					--SHRED TOTEMS
					if hp <= 13000 then
						if _Cast(5221,totem,nil,true) then
							Squid_Alert_Big(name .. " Stomped","(Shred)",1,4,5221)
							return
						end
					end
				end

				local totems = {
				101398,	--Psyfiend
				119052,	--War Banner
				104818,	--Ancestral Protection Totem
				53006,	--Spirit Link Totem
				2630,	--Earthbind Totem
				60561,	--Earthgrab Totem
				-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
				5925,	--Grounding Totem
				105425,	--Skyfury Totem
				5913,	--Tremor Totem
				105451,	--Counterstrike Totem
				"Twisted Appendage", -- tentacle
				}

				if arena then
					for i=1,#Pets do
						local e = Pets[i]
						local name = UnitName(e);
						local id = UnitCreatureID(e)
						--only kill cap totems when they're casting
						if tContains(totems,id) or tContains(totems,name) or (id == 61245 and UnitCastingInfo(e)) then
							Stomp(e,name)
						end
						--root abomination
						if id == 149555 and ps and _rootDR(e) >= .5 and _CCremains(e) + _rootRemains(e) < gcd then
							if _Cast(339,e) then
								Squid_Alert("Root","Abomination",nil,nil,339)
								return
							end
						end
					end
				end

				if _rootCheck("player") and (not squid_clone_delay or time - squid_clone_delay > 1) then
					if cat then
						if _Cast(783) then
							Squid_Alert("Travel Form","(Shift Root)",nil,nil,783)
							ok_to_cat=time
							return
						end
					else
						if _Cast(768) then
							Squid_Alert("Cat Form","(Shift Root)",nil,nil,768)
							return
						end
					end
				end

				if not utilities then
					if _isSlowed("player") and (not squid_clone_delay or time - squid_clone_delay > 1) then
						if target_outruns_player(12) then
							if cat then
								if _Cast(783) then
									Squid_Alert("Travel Form","(Shift Slow)",nil,nil,783)
									ok_to_cat=time
									return
								end
							else
								if _Cast(768) then
									Squid_Alert("Cat Form","(Shift Slow)",nil,nil,768)
									return
								end
							end
						end
					end
				end

				--cloning??

				--valid physical
				if valid_physical_target and not utilities then

					if player_has_control() then
						--tigers fury (root / slow break)
						if _rootCheck("player")
						  or ( _isSlowed("player") and valid_physical_target and distance_target > 4 and distance_target < 10 and target_outruns_player(10) ) then
							if tigers_fury_cd == 0 then
								--cancel form if in form, otherwise cast TF
								if not human and not tigers_fury then RunMacroText("/cancelform"); tf_powershift = time; return; else _Cast(5217); end
							end
						end
						--follow thru
						if tf_powershift and time - tf_powershift < 1 then
							if _Cast(5217) then Squid_Alert("Tiger's Fury","(Powershift)",nil,nil,5217) end
						end
					end

					--tigers fury (normal usage)
					if energy_deficit >= 60 and melee_range_target and (not squid_clone_delay or time - squid_clone_delay > 1 or cat or moving_towards_long) and not _rootCheck("player") then
						if (_isSlowed("player") or _rootCheck("player")) and _spellCooldown(5217) == 0 and player_has_control() and not human then RunMacroText("/cancelform"); return; end
						if _Cast(5217) then Squid_Alert("Tiger's Fury",nil,nil,nil,5217) return end
					end

					--burst (berserk / incarn) only when moving towards target. would rather not burst when trying to play defensive.
					if auto_burst and (moving_towards_target or not _isMoving("player")) and melee_range_target then
						--berserk
						local tf_returning_cd = 5 + (incarn_enabled and 10 or 0)
						if energy >= 30 and (_spellCooldown(5217) > tf_returning_cd or tigers_fury or their_healer_cc_remains > 5) then
							if _Cast(106951) then
								Squid_Alert("Berserk",nil,nil,nil,106951)
								return
							end
							if _Cast(102543) then
								Squid_Alert("Incarnation",nil,nil,nil,102543)
								return
							end
						end
					end

					if Squid_Burst then
						if _Cast(106951) then
							Squid_Alert("Berserk",nil,nil,nil,106951)
							return
						end
						if _Cast(102543) then
							Squid_Alert("Incarnation",nil,nil,nil,102543)
							return
						end
					end

					if (not savage_roar_enabled or savage_roar_remains >= 3) and sabertooth_enabled and target_rip_remains == 0 and cp > 0 and melee_range_target and (not squid_clone_delay or time - squid_clone_delay > 1 or cat or moving_towards_long) then
						_Cast(5217)
					end

					--apply TF rip on target if more powerful than current rip and sabertooth
					if (not savage_roar_enabled or savage_roar_remains >= 3) and sabertooth_enabled and (target_rip_remains == 0 or (target_rip_power < current_rip_snapshot and UnitHealth(t) > 25000 * groupsize)) then

						--tiger's fury up, in melee and ready to go, do it with at least 1 cp
						if cp > 0 and melee_range_target then

							--tf
							if (not squid_clone_delay or time - squid_clone_delay > 1 or cat or moving_towards_long) and (bloodtalons_stacks > 0 or not bloodtalons_enabled) and _Cast(5217) then
								Squid_Alert("Tiger's Fury",nil,nil,nil,5217)
							end

							if tigers_fury then
								--only with bloodtalons up if it's taken
								if bloodtalons_enabled then
									if bloodtalons_stacks > 0 then
										if _Cast(1079,t,true) then
											return
										end
									end
								else--otherwise just do it
									if _Cast(1079,t,true) then
										return
									end
								end
							end

						end

					end

				end

				--thorns
				if thorns_enabled and thorns_cd <= gcd then
					for i=1,#Friends do
						local f=Friends[i]
						if _HP(f) < 85 and select(2,EnemiesAttacking(f)) > 0 then
							if _Cast(305497,f) then
								Squid_Alert("Thorns " .. UnitClass(f),nil,nil,nil,305497)
							end
						end
					end
				end

				--feral frenzy
				if valid_physical_target then
					if cp == 0 then
						_Cast(274837,t,true)
					end
				end

				--essences here

				--breath of the dying (reaping flames)
				if valid_magical_target and (not squid_clone_delay or time - squid_clone_delay > 1 or cat or moving_towards_long) then
					if IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd_remains then
						local hp = (100 * (UnitHealth(t)-GetSpellEffect(310690)) / UnitHealthMax(t));
						if hp < 20 or (hp < 82 + (their_healer_cc and 18 or 0) and hp > 80) then
							if hp < 20 or _HP(t) > 80 then
								if _Cast(310690,t,true) then
									Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
								end
							end
						end
					end
				end

				--concentrated flame
				if valid_magical_target and (not squid_clone_delay or time - squid_clone_delay > 1 or cat or moving_towards_long) then
					if energy <= 25 or energy <= 40 and _buffStacks("player",295378) < 2 or energy <= 60 and _spellChargeFrac(295373) >= 1.85 or distance_target > 8 then
						_Cast(295373,t,true)
					end
				end

			end

			local function finishers()

				if hold_cp_for_maim then return end

				--execute bite (anyone, pvp or targeted)
				if energy >= 25 then
					for i=1,#offtargets do
						local t = offtargets[i].pointer
						local mr = offtargets[i].mr
						if mr and (arena or unit_is_unit(t,current_target)) then
							local hp = UnitHealth(t)
							if bite_effect > hp then
								if _Cast(22568,t,true) then
									Squid_Alert("Bite "..UnitClass(t),"(Execute)",nil,nil,22568)
								end
							end
						end
					end
				end

				if utilities then return end

				--savage roar maintain
				if cp > 0 and savage_roar_enabled then
					if savage_roar_remains < 2 then
						_Cast(52610)
					end
				end

				--rip maintenance bite spread
				if cp == 5 then
					for i=1,#riptargets do
						local t = riptargets[i].pointer
						local rip = riptargets[i].rip
						local mr = riptargets[i].mr
						if rip > 0 and rip < (gcd*2) + .2 then
							_Cast(22568,t,true)
						end
					end
				end

				--priority ps
				if ps and ((cp >= 4 and not berserk_incarn) or energy < 40 or ps_remains <= gcd or bloodtalons_enabled) and (not tigers_fury or energy < 25 or bloodtalons_enabled) and (not bloodtalons_enabled or cp >= 4) then
					if priority_ps() then return end
				end

				--spread rips to other targets if spread mode is on
				if spread and (bloodtalons_enabled and cp == 5 or bloodtalons_enabled and bloodtalons_stacks == 1 and cp >= 4 or not bloodtalons_enabled and cp >= 4) and not waiting_for_cp then
					for i=1,#riptargets do if UnitIsPlayer(riptargets[i].pointer) or _isDummy(riptargets[i].pointer) then
						local t = riptargets[i].pointer
						local mr = riptargets[i].mr
						local rip = riptargets[i].rip
						if mr and rip < 7.2 and (rip == 0 or not sabertooth_enabled) then
							if _Cast(1079,t,true) then return end
						end
					end end
				end

				--rip maintenance bite spread
				if cp == 5 then
					for i=1,#riptargets do
						local t = riptargets[i].pointer
						local rip = riptargets[i].rip
						local mr = riptargets[i].mr
						if rip > 0 then
							_Cast(22568,t,true)
						end
					end
				end

				local waiting_for_cp

				--auto maims
				-- if valid_physical_target and iron_jaws and cp >= 4 then
				-- 	local dr = _stunDR(t)
				-- 	local drremains = _drRemains(t,"stun")
				-- 	local ccr = _CCremains(t)
				-- 	if dr == 1 or ccr > 0 and ccr <= gcd_remains + .1 and dr >= .5 or drremains >= 16 and dr >= .5 then
				-- 		if cp == 5 then
				-- 			_Cast(22570,t,true)
				-- 		else
				-- 			waiting_for_cp=true
				-- 		end
				-- 	end
				-- end

				--maintain rip on target (5 cp or 3 with sabertooth)
				if valid_physical_target and not waiting_for_cp and (cp == 5 or (sabertooth_enabled and not bloodtalons_enabled and cp >= 4)) then
					local rip = target_rip_remains
					--if no rip on the target....
					if rip == 0 then
						--wait until tiger's fury comes back
						if tigers_fury_cd > 2 then
							if _Cast(1079,t,true) then return end
						end
					else
						if not sabertooth_enabled and rip <= 7.2 then
							if _Cast(1079,t,true) then return end
						end
						if (rip <= 19.2 or sabertooth_enabled) and (current_rip_snapshot > target_rip_power and UnitHealth(t) > 25000 * groupsize) then
							if _Cast(1079,t,true) then return end
						end
					end
				end

				--refresh rips to other targets if spread mode is on
				if spread and (bloodtalons_enabled and cp == 5 or bloodtalons_enabled and bloodtalons_stacks == 1 and cp >= 4 or not bloodtalons_enabled and cp >= 4) and not waiting_for_cp then
					for i=1,#riptargets do if UnitIsPlayer(riptargets[i].pointer) then
						local t = riptargets[i].pointer
						local mr = riptargets[i].mr
						local rip = riptargets[i].rip
						if mr and rip < 7.2 and (rip == 0 or not sabertooth_enabled) then
							if _Cast(1079,t,true) then return end
						end
					end end
				end

				--bite target
				if cp == 5 and valid_physical_target then
					if (energy >= 50 * (berserk_incarn and .6 or 1) or target_rip_remains <= 4.5) and target_rip_remains > 0 then
						if _Cast(22568,t,true) then return end
					end
				end

			end

			local function generators()

				--root melee / regrowth >= 4 cp if bloodtalons enabled
				if ps and bloodtalons_enabled and (cp >= 4 or ps_remains <= gcd) then
					if use_ps() then return end
				end

				if utilities then return end

				--no generating while capped cp
				if cp == 5 or feral_frenzy_cd > 43 then return end

				--rake generator w/ fresh wound
				if fresh_wound and cp <= 3 then
					for i=1,#raketargets do
						local t = raketargets[i].pointer
						local mr = raketargets[i].mr
						local rake = raketargets[i].rake
						if rake == 0 then
							if _Cast(1822,t,true) then return end
						end
					end
				end

				--thrash cleave clearcasting w/ spread
				if valid_physical_target and spread then
					if not bcc and enemies_around >= 2 then
						if clearcasting then
							if _Cast(106830) then return end
						end
					end
				end

				--brutal slash cleave if spread mode (if > 3 targets)
				if valid_physical_target and spread then
					if not bcc and enemies_around >= 3 then
						if _Cast(202028) then return end
					end
				end

				--rake target < 4.5 without bloodtalons, or not ticking with bloodtalons
				if valid_physical_target then
					if target_rake_remains < 2.65 or not bloodtalons_enabled and target_rake_remains < 4.5 then
						if not fresh_wound or target_rake_remains == 0 then
							if _Cast(1822,t,true) then return end
						end
					end
				end

				--rake bloodtalons up and 7s and current multiplier > power * .85
				if valid_physical_target then
					if bloodtalons_up and (bloodtalons_stacks > 1 or not lunar_inspiration) then
						if target_rake_remains < 7 and current_rake_snapshot > target_rake_power * .85 then
							if not fresh_wound or target_rake_remains == 0 then
								if _Cast(1822,t,true) then return end
							end
						end
					end
				end

				--maintain rake on multiple targets, not ticking or multiplier > power
				if spread or fresh_wound then
					for i=1,#raketargets do
						local t = raketargets[i].pointer
						local mr = raketargets[i].mr
						local rake = raketargets[i].rake
						if rake < 5 or current_rake_snapshot > _rakePower(t) then
							if not fresh_wound or rake == 0 then
								if _Cast(1822,t,true) then return end
							end
						end
					end
				end

				--thrash cleave w/ spread
				if valid_physical_target and spread and not bcc then
					local count = 0
					for i=1,#thrashtargets do
						if thrashtargets[i].mr and thrashtargets[i].thrash < 4 then
							count = count + 1
						end
					end
					if count >= 2 then
						if _Cast(106830) then return end
					end
				end

				--brutal slash cleave (> 2 targets)
				if valid_physical_target and melee_range_target then
					if not bcc and enemies_around >= 2 then
						if _Cast(202028) then return end
					end
				end

				--brutal slash with tigers fury up
				if valid_physical_target and melee_range_target and tigers_fury then
					if not bcc then
						if _Cast(202028) then return end
					end
				end

				--thrash maintain w/ spread
				if valid_physical_target and spread and not bcc then
					local dur_deficit = 0
					for i=1,#thrashtargets do
						if thrashtargets[i].mr then
							dur_deficit = dur_deficit + (15 - thrashtargets[i].thrash)
						end
					end
					if dur_deficit >= 13 then
						if _Cast(106830) then return end
					end
				end

				--shred with clearcasting
				if valid_physical_target and clearcasting then
					if _Cast(5221,t,true) then return end
				end

				--brutal slash filler
				if valid_physical_target and melee_range_target then
					if not bcc then
						if _Cast(202028) then return end
					end
				end

				--maintain rake on multiple targets, not ticking or multiplier > power
				if spread or fresh_wound then
					for i=1,#raketargets do
						local t = raketargets[i].pointer
						local mr = raketargets[i].mr
						local rake = raketargets[i].rake
						if rake < 5 or current_rake_snapshot > _rakePower(t) then
							if not fresh_wound or rake == 0 then
								if _Cast(1822,t,true) then return end
							end
						end
					end
				end

				--shred fallthru
				if valid_physical_target then
					if _Cast(5221,t,true) then return end
				end

			end

			--acceptable stealth actions
			if valid_physical_target and moving_towards_target and distance_target > 8 and (not prowl or UnitAffectingCombat(t)) then
				if not dash and not stampeding_roar then
					if _Cast(102401,t,true) then
						Squid_Alert("Wild Charge","Gapclose",nil,nil,102401)
						return
					end
				end
				if not stampeding_roar then
					if wild_charge_cd > 1 and distance_target > 16 then
						if _spellCooldown(1850) <= gcd and _isSlowed("player") then RunMacroText("/cancelform") end
						if _Cast(1850) then
							Squid_Alert("Dash","Gapclose",nil,nil,1850)
							return
						end
					end
				end
				if wild_charge_cd > 1 and dash_cd > 0 and not dash and distance_target > 16 then
					if _Cast(77764) then
						Squid_Alert("Stampeding Roar","Gapclose",nil,nil,106898)
						return
					end
				end
			end

			--prowl
			if (not combat or shadowmeld) and not prowl and (valid_attackable_target or enemy_player_around) then
				if _Cast(5215) then
					Squid_Alert("Prowl",nil,nil,nil,5215)
					return
				end
				if _spellCooldown(5215) <= 1.5 then return end
			end

			--stealth actions
			if prowl or shadowmeld then
				stealth()
				return
			end

			--cat
			if (human or not cat and ok_to_cat and time-ok_to_cat < 2.5) and valid_attackable_target then
				if not squid_clone_delay or time - squid_clone_delay > 1.2 or moving_towards_long then
					if _Cast(768) then
						return
					end
				end
			end

			priority_actions()

			finishers()

			--swiftmend
			if swiftmend_cd <= gcd_remains and not bear and not feral_frenzy_active then
				local maxhp = 45
				maxhp = maxhp + (our_healer_cc and 30 or 0)
				--less swiftmending with energy available, when on target
				if valid_physical_target and distance_target < 7 then
					maxhp = maxhp - (energy/2.5)
				end
				--much less swiftmending with high combo points, especially when a rip will fall off

				for i=1,#lowestfriends do
					local f = lowestfriends[i].pointer
					local hp = lowestfriends[i].hp
					if hp < maxhp then
						if _Cast(18562,f) then
							Squid_Alert("Swiftmend " .. UnitClass(f),nil,nil,nil,18562)
							return
						end
					end
				end
			end

			generators()

		--end of feral
		elseif spec == 1 then

			--balance
			local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
			local gcd_remains = GetGCD()
			local astral_power = UnitPower("player",8)

			local prowl = UnitBuffID("player",5215)
			if prowl then return end --pause in prowl
			local cat = UnitBuffID("player",768)
			local bear = UnitBuffID("player",5487)
			local moonkin = UnitBuffID("player",24858)
			local travel = UnitBuffID("player",783) or (GetShapeshiftForm() == 6 and not (cat or bear or moonkin))

			local starlord_enabled = IsPlayerSpell(202345)
			local stellar_flare_enabled = IsPlayerSpell(202347)
			local new_moon_enabled = IsPlayerSpell(274281)
			local twin_moons_enabled = IsPlayerSpell(279620)
			local incarn_enabled = IsPlayerSpell(102560)
			local lucid_dreams_taken = IsPlayerSpell(298357)

			local lucid_dreams_up = UnitBuffID("player",298357)
			local starlord_up = UnitBuffID("player",279709)
			local starlord_remains = _buffRemains("player",279709)
			local starlord_stacks = _buffStacks("player",279709)
			local arcanic_pulsar_stacks = _buffStacks("player",287790)
			local lunar_empowerment_stacks = _buffStacks("player",164547)
			local solar_empowerment_stacks = _buffStacks("player",164545)

			if UnitCastingInfo("player") == "Stellar Flare" then SFDelay=time end

			local ca_inc_remains = 0
			if UnitBuffID("player",102560) then
				ca_inc_remains = _buffRemains("player",102560)
			end
			if UnitBuffID("player",194223) then
				ca_inc_remains = _buffRemains("player",194223)
			end

			local ca_inc = ca_inc_remains > 0

			local ca_inc_cd = 0
			local incarn_cd = _spellCooldown(102560)
			local ca_cd = _spellCooldown(194223)
			local lucid_dreams_cd = _spellCooldown(298357)

			if incarn_cd > ca_inc_cd then ca_inc_cd = incarn_cd end
			if ca_cd > ca_inc_cd then ca_inc_cd = ca_cd end

			-- actions.precombat+=/variable,name=az_ss,value=azerite.streaking_stars.rank
			local az_ss = GetNumAzeritePowerTaken(122)
			-- actions.precombat+=/variable,name=az_ap,value=azerite.arcanic_pulsar.rank
			local az_ap = GetNumAzeritePowerTaken(200)

			local lively_spirit = AzeritePowerTaken(364)

			-- # Starfall v Starsurge target cutoff
			-- actions.precombat+=/variable,name=sf_targets,value=4
			local sf_targets = 4
			local starfall_count = 0
			local starfall_target
			for i=1,#Enemies do if _distance(Enemies[i]) < 40 then
				local ea = Enemies_Around_Unit(Enemies[i],10)
				if ea >= starfall_count then
					starfall_count=ea
					starfall_target=Enemies[i]
				end
			end end

			-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=azerite.arcanic_pulsar.enabled
			sf_targets = sf_targets + (az_ap > 0 and 1 or 0)
			-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=talent.starlord.enabled
			sf_targets = sf_targets + (starlord_enabled and 1 or 0)
			-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=azerite.streaking_stars.rank>2&amp;azerite.arcanic_pulsar.enabled
			sf_targets = sf_targets + ((az_ss > 2 and az_ap > 0) and 1 or 0)
			-- actions.precombat+=/variable,name=sf_targets,op=sub,value=1,if=!talent.twin_moons.enabled
			sf_targets = sf_targets - (not twin_moons_enabled and 1 or 0)


			local function moonfire_ticking(unit)
				return _debuffRemains(unit,164812,"player") >= 1.7
			end

			local function moonfire_remains(unit)
				return _debuffRemains(unit,164812,"player")
			end

			local function sunfire_ticking(unit)
				return _debuffRemains(unit,164815,"player") >= 1.7
			end

			local function sunfire_remains(unit)
				return _debuffRemains(unit,164815,"player")
			end

			local function stellar_flare_ticking(unit)
				return _debuffRemains(unit,202347,"player") >= 1.7
			end

			local function stellar_flare_remains(unit)
				return _debuffRemains(unit,202347,"player")
			end

			local function spell_ap_gen(spell)
				local spells = {
				{id=8921,value=3},		--moonfire
				{id=93402,value=3},		--sunfire
				{id=190984,value=8},	--wrath
				{id=194153,value=12},	--lunar strike
				{id=202347,value=8},	--stellar flare
				{id=274281,value=10},	--new moon
				{id=274282,value=20},   --half moon
				{id=274283,value=40},	--full moon
				{id=194223,value=40},	--celestial alignment
				}
				for i=1,#spells do
					local name = GetSpellInfo(spells[i].id)
					local id = spells[i].id
					if spell == id or spell == name then
						return spells[i].value
					end
				end
				return 0
			end

			function ap_check(spell)
				if nil==nil then return true end --wtf is this garbage??? this apl makes no sense
				if not spell then return astral_power >= 40 end
				if spell then return astral_power >= 40-spell_ap_gen(spell) end
			end

			-- actions.precombat+=/moonkin_form
			if not bear and (not cat or (not UnitBuffID("player",252216) and not Prowl)) and not travel and not moonkin then
				_Cast(24858)
			end

			local enemies_in_range = {}
			for i=1,#Enemies do if _distance(Enemies[i]) < 50 then
				table.insert(enemies_in_range,Enemies[i])
			end end

			local function _valid(unit,immune)
				return unit
				and UnitCanAttack("player",unit)
				and not UnitIsDeadOrGhost(unit)
				and not _breakableCC(unit)
				and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
				and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))));
			end

			local e=enemies_in_range
			local t=current_target
			local vt=_valid(t,2)

			-- # CDs
			-- actions+=/berserking,if=buff.ca_inc.up
			-- actions+=/use_item,name=azsharas_font_of_power,if=!buff.ca_inc.up,target_if=dot.moonfire.ticking&amp;dot.sunfire.ticking&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
			-- actions+=/guardian_of_azeroth,if=(!talent.starlord.enabled|buff.starlord.up)&amp;!buff.ca_inc.up,target_if=dot.moonfire.ticking&amp;dot.sunfire.ticking&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
			if (not starlord_enabled or starlord_up) and not ca_inc then
				if vt then
					if moonfire_ticking(t) and sunfire_ticking(t) and (not stellar_flare_enabled or stellar_flare_ticking(t)) then
						CastSpellByName("Guardian of Azeroth",t)
					end
				end
			end
			-- actions+=/use_item,effect_name=cyclotronic_blast,if=!buff.ca_inc.up,target_if=dot.moonfire.ticking&amp;dot.sunfire.ticking&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
			-- actions+=/use_item,name=shiver_venom_relic,if=!buff.ca_inc.up,target_if=dot.shiver_venom.stack>=5
			-- actions+=/blood_of_the_enemy,if=cooldown.ca_inc.remains>30
			-- actions+=/memory_of_lucid_dreams,if=!buff.ca_inc.up&amp;(astral_power<25|cooldown.ca_inc.remains>30),target_if=dot.sunfire.remains>10&amp;dot.moonfire.remains>10&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.remains>10)
			if lucid_dreams_taken and not ca_inc and (astral_power < 25 or ca_inc_cd > 30) then
				if vt then
					if sunfire_remains(t) > 10 and moonfire_remains(t) > 10 and (not stellar_flare_enabled or stellar_flare_remains(t) > 10) then
						_Cast(298357)
					end
				end
			end
			-- actions+=/purifying_blast
			-- actions+=/ripple_in_space
			-- actions+=/concentrated_flame
			if vt then
				if IsPlayerSpell(295373) then
					_Cast(295373,t,true)
				end
			end
			-- actions+=/the_unbound_force,if=buff.reckless_force.up,target_if=dot.moonfire.ticking&amp;dot.sunfire.ticking&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
			-- actions+=/worldvein_resonance
			-- actions+=/focused_azerite_beam,if=(!variable.az_ss|!buff.ca_inc.up),target_if=dot.moonfire.ticking&amp;dot.sunfire.ticking&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
			-- actions+=/thorns
				for i=1,#Friends do
					if _HP(Friends[i]) < 85 and EnemiesAttacking(Friends[i],1) >= 1 then
						_Cast(305497,Friends[i]);
					end
				end
			-- actions+=/use_items,slots=trinket1,if=!trinket.1.has_proc.any|buff.22.up
			-- actions+=/use_items,slots=trinket2,if=!trinket.2.has_proc.any|buff.ca_inc.up
			-- actions+=/use_items
			-- actions+=/warrior_of_elune
			if vt then _Cast(202425) end
			-- actions+=/innervate,if=azerite.lively_spirit.enabled&amp;(cooldown.incarnation.remains<2|cooldown.celestial_alignment.remains<12)
			if lively_spirit and ((incarn_enabled and incarn_cd < 2) or (not incarn_enabled and ca_cd < 12)) then
				for i=1,#Friends do if UnitGroupRolesAssigned(Friends[i]) == "HEALER" then
					_Cast(29166,Friends[i])
				end end
			end
			-- actions+=/incarnation,if=!buff.ca_inc.up&amp;
			-- (buff.memory_of_lucid_dreams.up|((cooldown.memory_of_lucid_dreams.remains>20|!essence.memory_of_lucid_dreams.major)&amp;ap_check))&amp;(buff.memory_of_lucid_dreams.up|ap_check),target_if=dot.sunfire.remains>8&amp;dot.moonfire.remains>12&amp;(dot.stellar_flare.remains>6|!talent.stellar_flare.enabled)
			if incarn_enabled then
				if not ca_inc and (lucid_dreams_up or ((lucid_dreams_cd > 20 or not lucid_dreams_taken) and ap_check())) and (lucid_dreams_up or ap_check()) and sunfire_remains(t) > 8 and moonfire_remains(t) > 12 and (not stellar_flare_enabled or stellar_flare_remains(t) > 6) then
					_Cast(102560)
				end
			end
			-- actions+=/celestial_alignment,if=!buff.ca_inc.up&amp;
			--(buff.memory_of_lucid_dreams.up|((cooldown.memory_of_lucid_dreams.remains>20|!essence.memory_of_lucid_dreams.major)&amp;ap_check))&amp;(!azerite.lively_spirit.enabled|buff.lively_spirit.up),target_if=(dot.sunfire.remains>2&amp;dot.moonfire.ticking&amp;(dot.stellar_flare.ticking|!talent.stellar_flare.enabled))
			if not incarn_enabled then
				if not ca_inc and (lucid_dreams_up or ((lucid_dreams_cd > 20 or not lucid_dreams_taken) and ap_check(194223))) and (not lively_spirit or lively_spirit_up) and sunfire_remains(t) > 2 and moonfire_ticking(t) and (not stellar_flare_enabled or stellar_flare_ticking(t)) then
					_Cast(194223)
				end
			end
			-- actions+=/fury_of_elune,if=(buff.ca_inc.up|cooldown.ca_inc.remains>30)&amp;solar_wrath.ap_check
			-- actions+=/force_of_nature,if=(buff.ca_inc.up|cooldown.ca_inc.remains>30)&amp;ap_check
			-- # Spenders
			-- actions+=/cancel_buff,name=starlord,if=buff.starlord.remains<3&amp;!solar_wrath.ap_check
			if starlord_up and starlord_remains < 3 and not ap_check(190984) then
				for i=1,40 do
					local buff=UnitBuff("player",i)
					if not buff then break end
					if buff == "Starlord" then
						CancelUnitBuff("player",i);
					end
				end
			end
			-- actions+=/starfall,if=(buff.starlord.stack<3|buff.starlord.remains>=8)&amp;spell_targets>=variable.sf_targets&amp;(target.time_to_die+1)*spell_targets>cost%2.5
			if (starlord_stacks < 3 or starlord_remains >= 8) and starfall_count >= sf_targets and _HP(starfall_target) > 30 then
				_AeCast(191034,starfall_target,45,15)
			end
			-- actions+=/starsurge,if=(talent.starlord.enabled&amp;(buff.starlord.stack<3|buff.starlord.remains>=5&amp;buff.arcanic_pulsar.stack<8)|!talent.starlord.enabled&amp;(buff.arcanic_pulsar.stack<8|buff.ca_inc.up))&amp;spell_targets.starfall<variable.sf_targets&amp;buff.lunar_empowerment.stack+buff.solar_empowerment.stack<4&amp;buff.solar_empowerment.stack<3&amp;buff.lunar_empowerment.stack<3&amp;(!variable.az_ss|!buff.ca_inc.up|!prev.starsurge)|target.time_to_die<=execute_time*astral_power%40|!solar_wrath.ap_check
			if vt then
				if starlord_enabled and (starlord_stacks < 3 or starlord_remains >= 5 and arcanic_pulsar_stacks < 8) then
					_Cast(78674,t,true)
				else
					if not starlord_enabled
					and (arcanic_pulsar_stacks < 8 or ca_inc)
					and starfall_count < sf_targets
					and lunar_empowerment_stacks + solar_empowerment_stacks < 4
					and solar_empowerment_stacks < 3
					and lunar_empowerment_stacks < 3
					and (az_ss == 0 or not ca_inc or prev_gcd ~= "Starsurge")
					or _HP(t) < 15 then
						_Cast(78674,t,true)
					end
				end
			end
			-- actions+=/sunfire,if=buff.ca_inc.up&amp;buff.ca_inc.remains<gcd.max&amp;variable.az_ss&amp;dot.moonfire.remains>remains
			if vt then
				if ca_inc and ca_inc_remains < gcd and az_ss > 0 and moonfire_remains(t) > sunfire_remains(t) then
					_Cast(93402,t,nil,true)
				end
			end
			-- actions+=/moonfire,if=buff.ca_inc.up&amp;buff.ca_inc.remains<gcd.max&amp;variable.az_ss
			if vt then
				if ca_inc and ca_inc_remains < gcd and az_ss > 0 then
					_Cast(8921,t,nil,true)
				end
			end
			-- # DoTs
			-- actions+=/sunfire,target_if=refreshable,if=ap_check&amp;floor(target.time_to_die%(2*spell_haste))*spell_targets>=ceil(floor(2%spell_targets)*1.5)+2*spell_targets&amp;
			--(spell_targets>1+talent.twin_moons.enabled|dot.moonfire.ticking)&amp;(!variable.az_ss|!buff.ca_inc.up|!prev.sunfire)&amp;(buff.ca_inc.remains>remains|!buff.ca_inc.up)
			if ap_check(93402) then
				if sunfire_remains(t) < 6 and (moonfire_ticking(t) or Enemies_Around_Unit(t,8) > 1 + (twin_moons_enabled and 1 or 0)) and (az_ss == 0 or not ca_inc or prev_gcd ~= "Sunfire") and (ca_inc_remains > sunfire_remains(t) or not ca_inc) then
					_Cast(93402,t,nil,true)
				end
			end
			-- actions+=/moonfire,target_if=refreshable,if=ap_check&amp;floor(target.time_to_die%(2*spell_haste))*spell_targets>=6
			--&amp;(!variable.az_ss|!buff.ca_inc.up|!prev.moonfire)&amp;(buff.ca_inc.remains>remains|!buff.ca_inc.up)
			if ap_check(8921) then
				if vt then
					if moonfire_remains(t) < 6 and (az_ss == 0 or not ca_inc or prev_gcd ~= "Moonfire") and (ca_inc_remains > moonfire_remains(t) or not ca_inc) then
						_Cast(8921,t,nil,true)
					end
				end
			end
			-- actions+=/stellar_flare,target_if=refreshable,if=ap_check&amp;floor(target.time_to_die%(2*spell_haste))>=5&amp;(!variable.az_ss|!buff.ca_inc.up|!prev.stellar_flare)
			if stellar_flare_enabled and ap_check(202347) then
				if vt and (not SFDelay or time-SFDelay > .15) then
					if not stellar_flare_ticking(t) and (az_ss == 0 or not ca_inc or prev_gcd ~= "Moonfire") and (ca_inc_remains > moonfire_remains(t) or not ca_inc) then
						_Cast(202347,t,nil,true)
					end
				end
			end
			-- # Generators
			-- actions+=/new_moon,if=ap_check
			-- actions+=/half_moon,if=ap_check
			-- actions+=/full_moon,if=ap_check
			-- actions+=/lunar_strike,if=buff.solar_empowerment.stack<3&amp;(ap_check|buff.lunar_empowerment.stack=3)&amp;((buff.warrior_of_elune.up|buff.lunar_empowerment.up|spell_targets>=2&amp;!buff.solar_empowerment.up)&amp;(!variable.az_ss|!buff.ca_inc.up)|variable.az_ss&amp;buff.ca_inc.up&amp;prev.solar_wrath)
			if vt then
				if solar_empowerment_stacks < 3 and (ap_check(194153) or lunar_empowerment_stacks == 3) and ((warrior_of_elune_up or lunar_empowerment_stacks > 0 or Enemies_Around_Unit(t,8) >= 2 and solar_empowerment_stacks == 0) and (az_ss == 0 or not ca_inc) or az_ss > 0 and ca_inc and prev_gcd == "Solar Wrath") then
					_Cast(194153,t,true)
				end
			end
			-- actions+=/solar_wrath,if=variable.az_ss<3|!buff.ca_inc.up|!prev.solar_wrath
			if vt then
				if az_ss < 3 or not ca_inc or prev_gcd ~= "Solar Wrath" then
					_Cast(190984,t,true)
				end
			end

			for i=1,#enemies_in_range do
				local e=enemies_in_range[i]
				if not sunfire_ticking(e) and (moonfire_ticking(e) or Enemies_Around_Unit(e,8) > 1) and (az_ss == 0 or not ca_inc or prev_gcd ~= "Sunfire") and (ca_inc_remains > sunfire_remains(e) or not ca_inc) then
					_Cast(93402,e,nil,true)
				end
			end

			for i=1,#enemies_in_range do
				local e=enemies_in_range[i]
				if not moonfire_ticking(e) and (moonfire_ticking(e) or Enemies_Around_Unit(e,8) > 1) and (az_ss == 0 or not ca_inc or prev_gcd ~= "Moonfire") and (ca_inc_remains > moonfire_remains(e) or not ca_inc) then
					_Cast(8921,e,nil,true)
				end
			end

			for i=1,#enemies_in_range do
				local e=enemies_in_range[i]
				if not stellar_flare_ticking(e) and (az_ss == 0 or not ca_inc or prev_gcd ~= "Moonfire") and (ca_inc_remains > moonfire_remains(e) or not ca_inc) then
					_Cast(202347,e,nil,true)
				end
			end

			-- # Fallthru for movement
			-- actions+=/sunfire

			-- guardian
		elseif spec == 3 then

			local rage = UnitPower("player")
			local enemies_on_me = EnemiesAttacking("player")
			local cds_on_me = select(4, EnemiesAttacking("player"))
			local melee_on_me = select(2, EnemiesAttacking("player"))
			local bcc = _bccAM(10)
			local galactic_guardian = UnitBuffID("player", 213708)
			local anima_stacks = UnitBuffID("player", 294966)
			local human = GetShapeshiftForm() == 0
			local cat = UnitBuffID("player",768)
			local bear = UnitBuffID("player",5487)
			local travel = UnitBuffID("player",783)
			local remove_corruption_cd = _spellCooldown(2782)
			local gcd_remains = GetGCD()
			local player_hp = _HP("player")
			local prowl = UnitBuffID("player",5215) or UnitBuffID("player",102547)

			local lowestfriends = {}
			for i=1,#Friends do
				local e=Friends[i]
				if UnitIsPlayer(e) then
					local hp = _HP(e)
					table.insert(lowestfriends,{pointer=e,hp=hp})
				end
			end
			table.sort(lowestfriends,function(x,y) return x.hp < y.hp end)

			local dispellable ={
			80240,	--havoc
			51514,	--hex
			211015,	--hex cockroach
			210873,	--hex compy
			211010,	--hex snake
			211004,	--hex spider
			277784,	--hex wicker mongrel
			277778,	--hex zandalari tendonripper
			309328,	--hex living honey
			199954,	--curse of frag (removed?)
			202914,	--spider sting
			202797,	--viper sting
			};

			local function remove_corruption(unit)
				local lessDelay = minDelayTime/1.3;
				for i=1,#dispellable do
					local debuff,_,_,five,six,seven = UnitDebuffID(unit,dispellable[i]);
					if debuff and seven-time < six-lessDelay then
						return dispellable[i];
					end
				end
			end

			local function hibernate_inc()
				for i=1,#Enemies do
					if UnitCastingInfo(Enemies[i]) == "Hibernate" then
						local e = Enemies[i]
						local dest = UnitSpellTarget(Enemies[i])
						if unit_is_unit(dest,"player") and _distance(e) < 40 then
							local time_left = _castTimeLeft(e)
							if time_left <= latency + .2 then
								return true
							end
						end
					end
				end
			end

			local function moonfire_ticking(unit)
				return _debuffRemains(unit,164812,"player") >= 6.24
			end

			local function _valid(unit,immune)
				return unit
				and UnitCanAttack("player",unit)
				and not UnitIsDeadOrGhost(unit)
				and not _breakableCC(unit)
				and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
				and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))));
			end

			--dispel
			if remove_corruption_cd <= gcd_remains then
				for i=1,#Friends do
					local dispel = remove_corruption(Friends[i])
					if dispel and _LoS(Friends[i]) and _Cast(2782,Friends[i]) then
						Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,2782)
					end
				end
			end


			--auto
			if _valid(current_target) then
				if not auto_atack_sent or time - auto_atack_sent > 1 then
					StartAttack()
					auto_atack_sent = time
				end
			end

			--defensives

			-- survival instincts
			if (cds_on_me and player_hp <= 80 or (player_hp <= 50 and enemies_on_me >=1 )) and not UnitBuffID("player", 61336) then
				_Cast(61336)
			end

			-- barkskin
			if player_hp <= 80 and enemies_on_me <=1 and not UnitBuffID("player", 61336) then
				_Cast(22812)
			end

			-- frenzy regen
			if player_hp <= 68 and not UnitBuffID("player", 22842) then
				_Cast(22842)
			end

			-- ironfur
			if melee_on_me >= 1 and player_hp <= 80 then
				_Cast(192081)
			end

			--healing
			if guardian_heal then
				for i=1,#lowestfriends do
					local friend = lowestfriends[i]

					--swiftmend
					if _LoS(friend.pointer) then
						_Cast(18562, friend.pointer)
					end

					--regrowth w/ swiftmend buff
					if _LoS(friend.pointer) and UnitBuffID("player", 236185) then
						_Cast(8936, friend.pointer)
					end

					-- rejuv
					if _LoS(friend.pointer) and not UnitBuffID(friend.pointer, 774) then
						_Cast(774, friend.pointer)
					end

					-- regrowth
					if _LoS(friend.pointer) then
						_Cast(8936, friend.pointer)
					end
				end
			end

			--shift hibernate
			if cat then
				if hibernate_inc() then
					RunMacroText("/cancelform")
					Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
				end
			elseif travel then
				if hibernate_inc() then
					RunMacroText("/cancelform")
					Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
				end
			elseif bear then
				if hibernate_inc() then
					if EnemiesAttacking("player") == 0 then
						RunMacroText("/cancelform")
						Squid_Alert_Big("Cancel Form","(Hibernate)",nil,nil,2637)
					end
				end
			end

			--shift roots
			if _rootCheck("player") then
				if bear then
					-- dont come out of bear unless we arent being attacked
					if EnemiesAttacking("player") == 0 then
						if _Cast(768) then
							Squid_Alert("Cat Form","(Shift Root)",nil,nil,339)
							ok_to_cat=time
							return
						end
					end
				else
					if _Cast(5487) then
						Squid_Alert("Bear Form","(Shift Root)",nil,nil,768)
						return
					end
				end
			end

			-- go bear
			if human and not hibernate_inc() then
				_Cast(5487)
			end

			-- thrash on cd
			if Enemies_Around_Unit("player",8) > 0 then
				_Cast(77758)
			end

			-- moonfire all the things
			for i=1,#Enemies do if not moonfire_ticking(Enemies[i]) and _valid(Enemies[i], 2) and _LoS(Enemies[i]) then
				_Cast(8921, Enemies[i])
			end end

			-- auto attack
			local t = UnitGUID("target")
			if not attack_guid or attack_guid ~= t then
				AttackTarget()
				attack_guid = t
			end

			-- anima essence
			if _HP("target") <= 70 and _meleeRange("target") and not bcc then
				_Cast(294926)
			end

			-- maul
			if not galactic_guardian and _valid("target", 1) and (enemies_on_me == 0 or player_hp > 70) then
				_Cast(6807, "target")
			end

			-- mangle
			-- if _valid("target", 1) and enemies_on_me == 0 then
				_Cast(33917, "target")
			-- end

			--thrash
			if _valid("target", 1) and not bcc and _meleeRange("target") then
				_Cast(77758, "target")
			end

			-- moonfire with buff
			if galactic_guardian and _valid("target", 2) and _LoS("target") then
				_Cast(8921, "target")
			end

			--swipe
			if _valid("target", 1) and not bcc and _meleeRange("target") then
				_Cast(213771, "target")
			end

			--moonfire fallthru
			_Cast(8921, "target")

		end

	-- 	# Executed before combat begins. Accepts non-harmful actions only.
	-- actions.precombat=flask
	-- actions.precombat+=/food
	-- actions.precombat+=/augmentation
	-- # Azerite variables
	-- actions.precombat+=/variable,name=az_ss,value=azerite.streaking_stars.rank
	-- actions.precombat+=/variable,name=az_ap,value=azerite.arcanic_pulsar.rank
	-- # Starfall v Starsurge target cutoff
	-- actions.precombat+=/variable,name=sf_targets,value=4
	-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=azerite.arcanic_pulsar.enabled
	-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=talent.starlord.enabled
	-- actions.precombat+=/variable,name=sf_targets,op=add,value=1,if=azerite.streaking_stars.rank>2&amp;azerite.arcanic_pulsar.enabled
	-- actions.precombat+=/variable,name=sf_targets,op=sub,value=1,if=!talent.twin_moons.enabled
	-- actions.precombat+=/moonkin_form
	-- # Snapshot raid buffed stats before combat begins and pre-potting is done.
	-- actions.precombat+=/snapshot_stats
	-- actions.precombat+=/potion
	-- actions.precombat+=/solar_wrath,if=!bfa.font_of_power_precombat_channel

	-- # Executed every time the actor is available.
	-- actions=potion,if=buff.ca_inc.remains>6
	-- # CDs
	-- actions+=/berserking,if=buff.ca_inc.up
	-- actions+=/use_item,name=azsharas_font_of_power,if=!buff.ca_inc.up,target_if=dot.moonfire.ticking&amp;dot.sunfire.ticking&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
	-- actions+=/guardian_of_azeroth,if=(!talent.starlord.enabled|buff.starlord.up)&amp;!buff.ca_inc.up,target_if=dot.moonfire.ticking&amp;dot.sunfire.ticking&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
	-- actions+=/use_item,effect_name=cyclotronic_blast,if=!buff.ca_inc.up,target_if=dot.moonfire.ticking&amp;dot.sunfire.ticking&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
	-- actions+=/use_item,name=shiver_venom_relic,if=!buff.ca_inc.up,target_if=dot.shiver_venom.stack>=5
	-- actions+=/blood_of_the_enemy,if=cooldown.ca_inc.remains>30
	-- actions+=/memory_of_lucid_dreams,if=!buff.ca_inc.up&amp;(astral_power<25|cooldown.ca_inc.remains>30),target_if=dot.sunfire.remains>10&amp;dot.moonfire.remains>10&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.remains>10)
	-- actions+=/purifying_blast
	-- actions+=/ripple_in_space
	-- actions+=/concentrated_flame
	-- actions+=/the_unbound_force,if=buff.reckless_force.up,target_if=dot.moonfire.ticking&amp;dot.sunfire.ticking&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
	-- actions+=/worldvein_resonance
	-- actions+=/focused_azerite_beam,if=(!variable.az_ss|!buff.ca_inc.up),target_if=dot.moonfire.ticking&amp;dot.sunfire.ticking&amp;(!talent.stellar_flare.enabled|dot.stellar_flare.ticking)
	-- actions+=/thorns
	-- actions+=/use_items,slots=trinket1,if=!trinket.1.has_proc.any|buff.ca_inc.up
	-- actions+=/use_items,slots=trinket2,if=!trinket.2.has_proc.any|buff.ca_inc.up
	-- actions+=/use_items
	-- actions+=/warrior_of_elune
	-- actions+=/innervate,if=azerite.lively_spirit.enabled&amp;(cooldown.incarnation.remains<2|cooldown.celestial_alignment.remains<12)
	-- actions+=/incarnation,if=!buff.ca_inc.up&amp;(buff.memory_of_lucid_dreams.up|((cooldown.memory_of_lucid_dreams.remains>20|!essence.memory_of_lucid_dreams.major)&amp;ap_check))&amp;(buff.memory_of_lucid_dreams.up|ap_check),target_if=dot.sunfire.remains>8&amp;dot.moonfire.remains>12&amp;(dot.stellar_flare.remains>6|!talent.stellar_flare.enabled)
	-- actions+=/celestial_alignment,if=!buff.ca_inc.up&amp;(buff.memory_of_lucid_dreams.up|((cooldown.memory_of_lucid_dreams.remains>20|!essence.memory_of_lucid_dreams.major)&amp;ap_check))&amp;(!azerite.lively_spirit.enabled|buff.lively_spirit.up),target_if=(dot.sunfire.remains>2&amp;dot.moonfire.ticking&amp;(dot.stellar_flare.ticking|!talent.stellar_flare.enabled))
	-- actions+=/fury_of_elune,if=(buff.ca_inc.up|cooldown.ca_inc.remains>30)&amp;solar_wrath.ap_check
	-- actions+=/force_of_nature,if=(buff.ca_inc.up|cooldown.ca_inc.remains>30)&amp;ap_check
	-- # Spenders
	-- actions+=/cancel_buff,name=starlord,if=buff.starlord.remains<3&amp;!solar_wrath.ap_check
	-- actions+=/starfall,if=(buff.starlord.stack<3|buff.starlord.remains>=8)&amp;spell_targets>=variable.sf_targets&amp;(target.time_to_die+1)*spell_targets>cost%2.5
	-- actions+=/starsurge,if=(talent.starlord.enabled&amp;(buff.starlord.stack<3|buff.starlord.remains>=5&amp;buff.arcanic_pulsar.stack<8)|!talent.starlord.enabled&amp;(buff.arcanic_pulsar.stack<8|buff.ca_inc.up))&amp;spell_targets.starfall<variable.sf_targets&amp;buff.lunar_empowerment.stack+buff.solar_empowerment.stack<4&amp;buff.solar_empowerment.stack<3&amp;buff.lunar_empowerment.stack<3&amp;(!variable.az_ss|!buff.ca_inc.up|!prev.starsurge)|target.time_to_die<=execute_time*astral_power%40|!solar_wrath.ap_check
	-- actions+=/sunfire,if=buff.ca_inc.up&amp;buff.ca_inc.remains<gcd.max&amp;variable.az_ss&amp;dot.moonfire.remains>remains
	-- actions+=/moonfire,if=buff.ca_inc.up&amp;buff.ca_inc.remains<gcd.max&amp;variable.az_ss
	-- # DoTs
	-- actions+=/sunfire,target_if=refreshable,if=ap_check&amp;floor(target.time_to_die%(2*spell_haste))*spell_targets>=ceil(floor(2%spell_targets)*1.5)+2*spell_targets&amp;(spell_targets>1+talent.twin_moons.enabled|dot.moonfire.ticking)&amp;(!variable.az_ss|!buff.ca_inc.up|!prev.sunfire)&amp;(buff.ca_inc.remains>remains|!buff.ca_inc.up)
	-- actions+=/moonfire,target_if=refreshable,if=ap_check&amp;floor(target.time_to_die%(2*spell_haste))*spell_targets>=6&amp;(!variable.az_ss|!buff.ca_inc.up|!prev.moonfire)&amp;(buff.ca_inc.remains>remains|!buff.ca_inc.up)
	-- actions+=/stellar_flare,target_if=refreshable,if=ap_check&amp;floor(target.time_to_die%(2*spell_haste))>=5&amp;(!variable.az_ss|!buff.ca_inc.up|!prev.stellar_flare)
	-- # Generators
	-- actions+=/new_moon,if=ap_check
	-- actions+=/half_moon,if=ap_check
	-- actions+=/full_moon,if=ap_check
	-- actions+=/lunar_strike,if=buff.solar_empowerment.stack<3&amp;(ap_check|buff.lunar_empowerment.stack=3)&amp;((buff.warrior_of_elune.up|buff.lunar_empowerment.up|spell_targets>=2&amp;!buff.solar_empowerment.up)&amp;(!variable.az_ss|!buff.ca_inc.up)|variable.az_ss&amp;buff.ca_inc.up&amp;prev.solar_wrath)
	-- actions+=/solar_wrath,if=variable.az_ss<3|!buff.ca_inc.up|!prev.solar_wrath
	-- # Fallthru for movement
	-- actions+=/sunfire
	end

	function Squid_Hunter()

		-- local selectedSpec = select(1,GetSpecializationInfo(GetSpecialization())) -- More object oriented
		-- local spells = sq.lists.spells.HUNTER[selectedSpec]
		-- local sharedHunterSpells = sq.lists.spells.HUNTER.Shared
		-- local sharedSpells = sq.lists.spells.Shared.Shared
		local spec = GetSpecialization()

		--Focus
		local time = GetTime()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
		local gcd_remains = GetGCD()
		local focus = UnitPower("player")
		local focus_deficit = UnitPowerMax("player")-focus
		local focus_max = UnitPowerMax("player" , 2)
		local focus_regen = GetPowerRegen()
		local focus_time_to_max = (UnitPowerMax("player")-focus)/GetPowerRegen()

		--Pet
		local pet_exists = UnitExists("pet")
		local pet_in_cc
		local pet_in_range
		local petbcc
		local enemies_around_pet = 0

		--Target Checks
		local function _valid(unit)
			return UnitIsVisible(unit)
			and UnitCanAttack("player",unit)
			and not UnitIsDeadOrGhost(unit)
			and not _breakableCC(unit)
			and (arena or UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))
		end

		if IsAoEPending() or IsMounted() or IsFlying() or UnitBuffID("player",199483) or not player_has_control() then return end

		local feigning = should_feign()
		if feigning then
			if feigning ~= "wait" then
				StopMovingAndLock()
				C_Timer.After(.1,function() SetMovementLocked(false) end)
				if _Cast(5384) then
					Squid_Alert_Big("Feing Death","("..GetSpellInfo(feigning)..")",4,2.5,5384)
				end
			else
				Squid_Alert("Holding GCD for Feign Death",nil,nil,3.5,5384)
				return
			end
		end

		--Marksman
		if spec == 2 then

			local t = current_target

			local their_healer = theirHealer
			if their_healer and _CCcheck(their_healer) then their_healer_cc = true end
			if not their_healer then their_healer_cc = time_in_combat > 15 or UnitIsVisible(t) and _stunCheck(t) end

			local target_hp = _HP(t)
			local target_absorbs = 0
			local target_effective_hp = 100

			if UnitIsVisible(t) then
				target_absorbs = UnitGetTotalAbsorbs(t)
				target_effective_hp = (100 * (UnitHealth(t)+target_absorbs) / UnitHealthMax(t))
			end

			local load_mode = _valid(t) and ( their_healer_cc or _stunRemains(t) > 1.5 or target_effective_hp < 30 * ((their_healer or not arena) and 1 or 2.3) or unit_is_unit(their_healer,t) and target_effective_hp < 55 + ( ( _stunCheck(t) or _drRemains(t,"stun") > 15 ) and 35 or 0 ) )

			if Squid_Burst then load_mode = true end

			local lnl_remains = _buffRemains("player",194594)
			local lnl = lnl_remains > 0

			local rapid_fire_cd = _spellCooldown(257044)
			local aimed_shot_cd = _spellCooldown(19434)
			local aimed_shot_cast_time = _castTime(19434)

			local ca_active = IsPlayerSpell(260228) and UnitIsVisible(t) and target_hp > 70
			local double_tap = UnitBuffID("player",260402)
			local trueshot = UnitBuffID("player",288613)
			local precise_shots = UnitBuffID("player",260242)

			local pet_in_cc
			if pet_exists then

				enemies_around_pet=Enemies_Around_Unit("pet",8)
				pet_in_cc=_CCcheck("pet")

				if _valid(current_target) then
					pet_in_range=_distance("pet",current_target) < 6.5
				end
				if IsPlayerSpell(53480) and _spellCooldown(53480) == 0 and not UnitIsDeadOrGhost("pet") and not _CCcheck("pet") then
					for i=1,#Friends do
						local hp = 35
						hp = hp + (EnemiesAttacking(Friends[i]) * 10)
						hp = hp + (EnemiesAttacking(Friends[i],nil,true) * 15)
						hp = hp + ( (not ourHealer or _CCcheck(ourHealer)) and 20 or 0)
						local current = math.floor(_HP(Friends[i]))
						if current < hp then
							if _distance("pet",Friends[i]) < 40 then
								CastSpellByID(53480,Friends[i])
								Squid_Alert("|cffff6060 Roar of Sac " .. UnitClass(Friends[i]),"|cffffff00" .. current .. "% (Danger)",2,nil,53480)
							end
						end
					end
				end
				if _spellCooldown(53271) == 0 then
					for i=1,#Friends do if not _CCcheck(Friends[i]) then
						if _isMeleeDps(Friends[i]) then
							if _distance("pet",Friends[i]) < 40 then
								if _rootCheck(Friends[i]) then
									if _Cast(53271,Friends[i]) then
										Squid_Alert("Freedom " .. UnitClass(Friends[i]),"(Rooted)",2)
									end
								end
								if (lowestEnemy < 45 or _rootCheck("pet")) and _isSlowed(Friends[i]) then
									if _Cast(53271,Friends[i]) then
										Squid_Alert("Freedom " .. UnitClass(Friends[i]),"(Slowed, Low Enemy)",2)
									end
								end
							end
						end
						if _isHealer(Friends[i]) then
							if UnitDebuffID(Friends[i],81261) then
								if _distance("pet",Friends[i]) < 40 then
									if _Cast(53271,Friends[i]) then
										Squid_Alert("Freedom " .. UnitClass(Friends[i]),"(Root Beam)",2)
									end
								end
							end
						end
					end end
				end
			end

			--Stomp
			local function Stomp(totem,name)
				if S then return false; end
				local hp = UnitHealth(totem)
				local maxhp = UnitHealthMax(totem)
				if hp <= 1 then return false; end
				--arcane shot
				if _Cast(185358,totem,true) then
					Squid_Alert("Stomped " .. name,"(Arcane Shot)",1,nil,185358)
					return
				end
			end

			local totems = {
			"Psyfiend",
			"War Banner",
			"Ancestral Protection Totem",
			"Spirit Link Totem",
			"Counterstrike Totem",
			"Grounding Totem",
			"Skyfury Totem",
			"Windfury Totem",
			}

			if arena then
				for i=1,#Pets do
					local e = Pets[i]
					local name = UnitName(e);
					if tContains(totems,name) or (name == "Capacitor Totem" and UnitCastingInfo(e)) then
						Stomp(e,name)
					end
				end
			end

			if _spellCooldown(109304) <= gcd then
				local hp = 15
				hp = hp + EnemiesAttacking("player") * 10
				hp = hp + EnemiesAttacking("player",nil,true) * 5
				local current = math.floor(_HP("player"))
				if current < hp then
					if _Cast(109304) then
						Squid_Alert("|cffff6060Exhilharation Heal","|cffffff00" .. current.."% (Danger)",2)
						return
					end
				end
			end


			-- local theirHealer="focus" -- testing purposes
			if UnitIsVisible(current_focus) then
				theirHealer=current_focus
			end
			if focus_trap_queued then
				theirHealer = current_focus
			end
			if healer_trap_queued then
				theirHealer = theirHealer
			end
			if theirHealer and _spellCooldown(187650) <= 5 then

				local dr = _incapacitateDR(theirHealer)
				local drrem = _drRemains(theirHealer,"incapacitate")
				local ua = UnitEnemiesAttacking(theirHealer)

				--no friends attacking
				if ua == 0 then

					local los = _LoS(theirHealer)

					local buffer = (select(4,GetNetStats())/1000) + ((1/GetFramerate())*15)

					if _spellCooldown(781) == 0 and trap_cc(theirHealer) then
						if not _LoS(theirHealer) then
							buffer=buffer+.65
						end
					end

					local cc = trap_cc(theirHealer)
					local ccr = trap_cc_remains(theirHealer)
					local tt = trap_travel_time(theirHealer) + buffer
					local dist = _distance(theirHealer)
					local immune = immune_trap(theirHealer)

					if dr == 1 or (UnitDebuffID(theirHealer,3355) and dr >= .5) then
						if (cc and ccr <= tt) or (not cc and (dist < 2 or (UnitCastingInfo(theirHealer) and dist < 12 and not _isMoving(theirHealer)) or focus_trap_queued)) then
							if not immune then
								if buffer > 0 then
									if not _LoS(theirHealer) or dist  > 40 then
										_disengageToUnit(theirHealer,true)
									end
								end
								if cc then
									if _aeCastInMovingDirection(187650,theirHealer,perfectTravelDist(theirHealer)) then
										Squid_Alert("Trapping " .. UnitClass(theirHealer),"(" .. GetSpellInfo(cc) .. ")",2)
									end
								end
								if UnitCastingInfo(theirHealer) then
									if _aeCastInMovingDirection(187650,theirHealer,perfectTravelDist(theirHealer)) then
										Squid_Alert("Trapping " .. UnitClass(theirHealer),"(Casting)",2)
									end
								end
								if _isSlowed(theirHealer) or not _isMoving(theirHealer) then
									if focus_trap_queued then
										if _aeCastInMovingDirection(187650,theirHealer,perfectTravelDist(theirHealer)) then
											Squid_Alert("Trapping " .. UnitClass(theirHealer),"(Manual)",2)
										end
									else
										if _aeCastInMovingDirection(187650,theirHealer,perfectTravelDist(theirHealer)) then
											Squid_Alert("Trapping " .. UnitClass(theirHealer),"(Close)",2)
										end
									end
								elseif not _slowImmuneCheck(theirHealer) then
									_Cast(5116,theirHealer,nil,true)
								end
							end
						end

						if not cc and _movingTowards(theirHealer,.14,nil,true) and not _slowImmuneCheck(theirHealer) and not _immunePhysical(theirHealer) then
							_Cast(5116,theirHealer,nil,true)
						end

						if cc then
							if (dr == 1 or drrem < ccr) and ccr < 5 then
								if immune then
									Squid_Alert("|cffffff00Delaying Trap","("..GetSpellInfo(immune)..")",nil,5)
								else
									Squid_Alert("|cffADFF2FFollowing up with Trap |cff00ffff("..GetSpellInfo(cc)..")",nil,nil,4.8)
									if ccr <= tt+gcd then return end -- pause for followup
								end
							end
						end

					end

				end
			end

			local purges = {
				264265,
				264028,
				264266,
				264264,
				264263,
				264262,
				264056,
			}
			if _valid(current_target) then
				if _purgeAnything(current_target) then
					if _Cast(19801,current_target,nil,true) then
						Squid_Alert("Tranq Shot",nil,nil,nil,19801)
						return
					end
				end
			end

			local function cds()
				if _valid(t) then
					-- actions.cds=double_tap,if=cooldown.rapid_fire.remains<gcd|cooldown.rapid_fire.remains<cooldown.aimed_shot.remains|target.time_to_die<20
					if load_mode then
						if rapid_fire_cd < gcd or rapid_fire_cd < aimed_shot_cd or _HP(current_target) < 20 then
							if _Cast(260402) then
								Squid_Alert("Rapid Fire",nil,nil,nil,260402)
								return
							end
						end
					end
					-- actions.cds+=/berserking,if=buff.trueshot.remains>14&amp;(target.time_to_die>cooldown.berserking.duration+duration|(target.health.pct<20|!talent.careful_aim.enabled))|target.time_to_die<13
					-- actions.cds+=/blood_fury,if=buff.trueshot.remains>14&amp;(target.time_to_die>cooldown.blood_fury.duration+duration|(target.health.pct<20|!talent.careful_aim.enabled))|target.time_to_die<16
					-- actions.cds+=/ancestral_call,if=buff.trueshot.remains>14&amp;(target.time_to_die>cooldown.ancestral_call.duration+duration|(target.health.pct<20|!talent.careful_aim.enabled))|target.time_to_die<16
					-- actions.cds+=/fireblood,if=buff.trueshot.remains>14&amp;(target.time_to_die>cooldown.fireblood.duration+duration|(target.health.pct<20|!talent.careful_aim.enabled))|target.time_to_die<9
					-- actions.cds+=/lights_judgment,if=buff.trueshot.down
					-- actions.cds+=/bag_of_tricks,if=buff.trueshot.down
					-- actions.cds+=/reaping_flames,if=buff.trueshot.down&amp;(target.health.pct>80|target.health.pct<=20|target.time_to_pct_20>30)
					if _HP(t) > 80 or _HP(t) < 20 then
						if _Cast(310690,t,nil,true) then return end
					end
					-- actions.cds+=/worldvein_resonance,if=(trinket.azsharas_font_of_power.cooldown.remains>20|!equipped.azsharas_font_of_power|target.time_to_die<trinket.azsharas_font_of_power.cooldown.duration+34&amp;target.health.pct>20)&amp;(cooldown.trueshot.remains_guess<3|(essence.vision_of_perfection.minor&amp;target.time_to_die>cooldown+buff.worldvein_resonance.duration))|target.time_to_die<20

					-- actions.cds+=/guardian_of_azeroth,if=(ca_active|target.time_to_die>cooldown+30)&amp;(buff.trueshot.up|cooldown.trueshot.remains<16)|target.time_to_die<31
					-- actions.cds+=/ripple_in_space,if=cooldown.trueshot.remains<7
					-- actions.cds+=/memory_of_lucid_dreams,if=!buff.trueshot.up
					-- actions.cds+=/potion,if=buff.trueshot.react&amp;buff.bloodlust.react|buff.trueshot.remains>14&amp;target.health.pct<20|((consumable.potion_of_unbridled_fury|consumable.unbridled_fury)&amp;target.time_to_die<61|target.time_to_die<26)
					-- actions.cds+=/trueshot,if=buff.trueshot.down&amp;cooldown.rapid_fire.remains|target.time_to_die<15
					if load_mode or Squid_Burst then
						if rapid_fire_cd <= gcd or Squid_Burst then

							if _Cast(288613) then
								Squid_Alert("Trueshot",nil,nil,nil,288613)
								return
							end
							-- Use bike
							if not _immunePhysical(current_target) and _LoS(current_target) then
								if IsEquippedItem(169769) and GetItemCD(169769) <= 1 then
									if _HP(current_target) < 90 then
										UseItemByName(tostring(GetItemInfo(169769)));
									end
								end
							end
						end
					end
				end
			end

			local function st()
				if _valid(t) then
					-- actions.st=kill_shot
					if IsUsableSpell(53351) then
						if _Cast(53351,t,true) then
							Squid_Alert("Kill Shot",nil,nil,nil,53351)
							return
						end
					end
					-- actions.st+=/explosive_shot
					-- actions.st+=/barrage,if=active_enemies>1
					-- actions.st+=/a_murder_of_crows
					if load_mode then
						if _Cast(131894,t,true) then
							Squid_Alert("Crows",nil,nil,nil,131894)
							return
						end
					end
					-- actions.st+=/volley
					-- actions.st+=/serpent_sting,if=refreshable&amp;!action.serpent_sting.in_flight
					if _debuffRemains(t,271788,"player") <= 3 then
						if _Cast(271788,t,true) then return end
					end
					-- actions.st+=/rapid_fire,if=buff.trueshot.down|focus<35|focus<60&amp;!talent.lethal_shots.enabled|buff.in_the_rhythm.remains<execute_time
					if not trueshot or focus < 35 or focus < 60 and not lethal_shots_enabled then
						if _Cast(257044,t,true) then return end
					end
					-- actions.st+=/blood_of_the_enemy,if=buff.trueshot.up&amp;(buff.unerring_vision.stack>4|!azerite.unerring_vision.enabled)|target.time_to_die<11
					-- actions.st+=/focused_azerite_beam,if=!buff.trueshot.up|target.time_to_die<5
					-- actions.st+=/aimed_shot,if=buff.trueshot.up|(buff.double_tap.down|ca_active)&amp;buff.precise_shots.down|full_recharge_time<cast_time&amp;cooldown.trueshot.remains
					if trueshot or (not double_tap or ca_active) and not precise_shots or focus_time_to_max < aimed_shot_cast_time then
						if _Cast(19434,t,true) then return end
					end
					-- actions.st+=/purifying_blast,if=!buff.trueshot.up|target.time_to_die<8
					-- actions.st+=/concentrated_flame,if=focus+focus.regen*gcd<focus.max&amp;buff.trueshot.down&amp;(!dot.concentrated_flame_burn.remains&amp;!action.concentrated_flame.in_flight)|full_recharge_time<gcd|target.time_to_die<5
					-- actions.st+=/the_unbound_force,if=buff.reckless_force.up|buff.reckless_force_counter.stack<10|target.time_to_die<5
					-- actions.st+=/arcane_shot,if=buff.trueshot.down&amp;(buff.precise_shots.up&amp;(focus>55)|focus>75|target.time_to_die<5)
					if not trueshot and (precise_shots and focus > 55 or focus > 75 or _HP(t) < 10) then
						if _Cast(185358,t,nil,true) then return end
					end
					-- actions.st+=/chimaera_shot,if=buff.trueshot.down&amp;(buff.precise_shots.up&amp;(focus>55)|focus>75|target.time_to_die<5)
					if not trueshot and (precise_shots and focus > 55 or focus > 75 or _HP(t) < 10) then
						if _Cast(342049,t,nil,true) then return end
					end
					-- actions.st+=/steady_shot
					if focus_time_to_max > _castTime(56641) + .5 and _Cast(56641,t,true) then return end
				end
			end

			-- # Executed every time the actor is available.
			local function actions()
				if _valid(current_target) then
					if UnitBuffID("player",199483) then return end
					-- actions=auto_shot
					if not squid_aa or time - squid_aa > 1 then
						CastSpellByID(6603,t) -- Auto shot
						squid_aa = time
					end
					-- actions+=/use_item,name=lurkers_insidious_gift,if=cooldown.trueshot.remains_guess<15|target.time_to_die<30
					-- actions+=/use_item,name=azsharas_font_of_power,if=(target.time_to_die>cooldown+34|target.health.pct<20|target.time_to_pct_20<15)&amp;cooldown.trueshot.remains_guess<15|target.time_to_die<35
					-- actions+=/use_item,name=lustrous_golden_plumage,if=cooldown.trueshot.remains_guess<5|target.time_to_die<20
					-- actions+=/use_item,name=galecallers_boon,if=buff.trueshot.remains>14|!talent.calling_the_shots.enabled|target.time_to_die<10
					-- actions+=/use_item,name=ashvanes_razor_coral,if=buff.trueshot.remains>14&amp;(buff.guardian_of_azeroth.up|!essence.condensed_lifeforce.major&amp;ca_active)|debuff.razor_coral_debuff.down|target.time_to_die<20
					-- actions+=/use_item,name=pocketsized_computation_device,if=!buff.trueshot.up&amp;!essence.blood_of_the_enemy.major|debuff.blood_of_the_enemy.up|target.time_to_die<5
					-- # Try to line up activated trinkets with Trueshot
					-- actions+=/use_items,if=buff.trueshot.remains>14|!talent.calling_the_shots.enabled|target.time_to_die<20
					-- actions+=/call_action_list,name=cds
					cds()
					-- actions+=/call_action_list,name=st,if=active_enemies<3
					st()
					-- actions+=/call_action_list,name=trickshots,if=active_enemies>2
				end
			end

			actions()

			-- actions.trickshots=kill_shot
			-- actions.trickshots+=/volley
			-- actions.trickshots+=/barrage
			-- actions.trickshots+=/explosive_shot
			-- actions.trickshots+=/aimed_shot,if=buff.trick_shots.up&amp;ca_active&amp;buff.double_tap.up
			-- actions.trickshots+=/rapid_fire,if=buff.trick_shots.up&amp;(azerite.focused_fire.enabled|azerite.in_the_rhythm.rank>1|azerite.surging_shots.enabled|talent.streamline.enabled)
			-- actions.trickshots+=/aimed_shot,if=buff.trick_shots.up&amp;(buff.precise_shots.down|cooldown.aimed_shot.full_recharge_time<action.aimed_shot.cast_time|buff.trueshot.up)
			-- actions.trickshots+=/rapid_fire,if=buff.trick_shots.up
			-- actions.trickshots+=/multishot,if=buff.trick_shots.down|buff.precise_shots.up&amp;!buff.trueshot.up|focus>70
			-- actions.trickshots+=/focused_azerite_beam
			-- actions.trickshots+=/purifying_blast
			-- actions.trickshots+=/concentrated_flame
			-- actions.trickshots+=/blood_of_the_enemy
			-- actions.trickshots+=/the_unbound_force,if=buff.reckless_force.up|buff.reckless_force_counter.stack<10
			-- actions.trickshots+=/a_murder_of_crows
			-- actions.trickshots+=/serpent_sting,if=refreshable&amp;!action.serpent_sting.in_flight
			-- actions.trickshots+=/steady_shot


		--Beast Mastery
		elseif spec == 1 then

			local t=current_target

			local their_healer_cc
			if theirHealer and _CCcheck(theirHealer) then their_healer_cc = true end
			if not theirHealer then their_healer_cc = time_in_combat > 15 end

			local barbed_shot_frac_charges = _spellChargeFrac(217200)
			local bestial_wrath_cd = _spellCooldown(19574)
			local aspect_of_the_wild = UnitBuffID("player",193530)
			local aspect_of_the_wild_cd = _spellCooldown(193530)
			local kill_command_cd = _spellCooldown(34026)
			local barbed_shot_full_recharge_time = 20 - (barbed_shot_frac_charges*10)

			local primal_instincts = AzeritePowerTaken(366)
			local rapid_reload = AzeritePowerTaken(369)

			local stomp = IsPlayerSpell(199530)
			local aspect_of_the_beast = IsPlayerSpell(191384)
			local killer_instinct = IsPlayerSpell(273887)
			local one_with_the_pack = IsPlayerSpell(199528)
			local a_murder_of_crows = IsPlayerSpell(131894)
			local dire_beast_basilisk = IsPlayerSpell(205691)
			local dire_beast_basilisk_cd = _spellCooldown(205691)
			local pool_for_basilisk

			local frenzy_up
			local frenzy_stacks = 0
			local frenzy_remains = 0
			local beast_cleave_remains = 0

			if pet_exists then
				frenzy_up=UnitBuffID("pet",272790)
				frenzy_stacks=_buffStacks("pet",272790)
				frenzy_remains=_buffRemains("pet",272790)
				enemies_around_pet=Enemies_Around_Unit("pet",8)
				beast_cleave_remains=_buffRemains("pet",118455)
				petbcc=breakable_cc_around("pet",15)
				pet_in_cc=_CCcheck("pet")
				if _valid(current_target) then
					pet_in_range=_distance("pet",current_target) < 6.5
				end
				if IsPlayerSpell(53480) and _spellCooldown(53480) == 0 and not UnitIsDeadOrGhost("pet") and not _CCcheck("pet") then
					for i=1,#Friends do
						local hp = 50
						hp = hp + (EnemiesAttacking(Friends[i]) * 10)
						hp = hp + (EnemiesAttacking(Friends[i],nil,true) * 15)
						local current = math.floor(_HP(Friends[i]))
						if current < hp then
							if _distance("pet",Friends[i]) < 40 then
								CastSpellByID(53480,Friends[i])
								Squid_Alert("|cffff6060 Roar of Sac " .. UnitClass(Friends[i]),"|cffffff00" .. current .. "% (Danger)",2,nil,53480)
							end
						end
					end
				end
				if _spellCooldown(53271) == 0 then
					for i=1,#Friends do if not _CCcheck(Friends[i]) then
						if _isMeleeDps(Friends[i]) then
							if _distance("pet",Friends[i]) < 40 then
								if _rootCheck(Friends[i]) then
									if _Cast(53271,Friends[i]) then
										Squid_Alert("Freedom " .. UnitClass(Friends[i]),"(Rooted)",2)
									end
								end
								if (lowestEnemy < 45 or _rootCheck("pet")) and _isSlowed(Friends[i]) then
									if _Cast(53271,Friends[i]) then
										Squid_Alert("Freedom " .. UnitClass(Friends[i]),"(Slowed, Low Enemy)",2)
									end
								end
							end
						end
						if _isHealer(Friends[i]) then
							if UnitDebuffID(Friends[i],81261) then
								if _distance("pet",Friends[i]) < 40 then
									if _Cast(53271,Friends[i]) then
										Squid_Alert("Freedom " .. UnitClass(Friends[i]),"(Root Beam)",2)
									end
								end
							end
						end
					end end
				end
			end

			--Stomp
			local function Stomp(totem,name)
				if S then return false; end
				local hp = UnitHealth(totem)
				local maxhp = UnitHealthMax(totem)
				if hp <= 1 then return false; end
				if maxhp <= 10000 then
					--Cobra Shot
					if _Cast(193455,totem,true) then
						Squid_Alert(name .. " Stomped","(Cobra Shot)",1)
					end
				end
			end

			local totems = {
			"Psyfiend",
			"War Banner",
			"Ancestral Protection Totem",
			"Spirit Link Totem",
			"Counterstrike Totem",
			"Grounding Totem",
			"Skyfury Totem",
			"Windfury Totem",
			}

			if arena then
				for i=1,#Pets do
					local e = Pets[i]
					local name = UnitName(e);
					if tContains(totems,name) or (name == "Capacitor Totem" and UnitCastingInfo(e)) then
						Stomp(e,name)
					end
				end
			end

			if _spellCooldown(109304) <= gcd then
				local hp = 15
				hp = hp + EnemiesAttacking("player") * 10
				hp = hp + EnemiesAttacking("player",nil,true) * 5
				local current = math.floor(_HP("player"))
				if current < hp then
					if _Cast(109304) then
						Squid_Alert("|cffff6060Exhilharation Heal","|cffffff00" .. current.."% (Danger)",2)
					end
				end
			end

			-- if petbcc and stomp then
			-- 	Squid_Alert("|cffff6060Can't Barbed Shot","(Breakable CC)",nil,5)
			-- end

			local wait_for_intim
			-- local theirHealer="focus" -- testing purposes
			-- if not arena and UnitIsVisible(current_focus) then
			-- 	theirHealer=current_focus
			-- end
			if focus_trap_queued then
				theirHealer = current_focus
			end
			if healer_trap_queued then
				theirHealer = theirHealer
			end
			if theirHealer and _spellCooldown(187650) <= 5 then

				local dr = _incapacitateDR(theirHealer)
				local drrem = _drRemains(theirHealer,"incapacitate")

				local sdr = _stunDR(theirHealer)

				local ua = UnitEnemiesAttacking(theirHealer)

				--no friends attacking
				if ua == 0 then

					local los = _LoS(theirHealer)

					local buffer = (select(4,GetNetStats())/1000) + ((1/GetFramerate())*15)

					if _spellCooldown(781) == 0 and trap_cc(theirHealer) then
						if not _LoS(theirHealer) then
							buffer=buffer+.65
						end
					end

					local cc = trap_cc(theirHealer)
					local ccr = trap_cc_remains(theirHealer)
					local tt = trap_travel_time(theirHealer) + buffer
					local dist = _distance(theirHealer)
					local immune = immune_trap(theirHealer)

					if dr == 1 or (UnitDebuffID(theirHealer,3355) and dr >= .5) then
						if (cc and ccr <= tt) or (not cc and (dist < 2 or (UnitCastingInfo(theirHealer) and dist < 12 and not _isMoving(theirHealer)) or focus_trap_queued)) then
							if not immune then
								if buffer > 0 then
									if not _LoS(theirHealer) or dist  > 40 then
										_disengageToUnit(theirHealer,true)
									end
								end
								if cc then
									if _aeCastInMovingDirection(187650,theirHealer,perfectTravelDist(theirHealer)) then
										Squid_Alert("Trapping " .. UnitClass(theirHealer),"(" .. GetSpellInfo(cc) .. ")",2)
									end
								end
								if UnitCastingInfo(theirHealer) then
									if _aeCastInMovingDirection(187650,theirHealer,perfectTravelDist(theirHealer)) then
										Squid_Alert("Trapping " .. UnitClass(theirHealer),"(Casting)",2)
									end
								end
								if _isSlowed(theirHealer) or not _isMoving(theirHealer) then
									if focus_trap_queued then
										if _aeCastInMovingDirection(187650,theirHealer,perfectTravelDist(theirHealer)) then
											Squid_Alert("Trapping " .. UnitClass(theirHealer),"(Manual)",2)
										end
									else
										if _aeCastInMovingDirection(187650,theirHealer,perfectTravelDist(theirHealer)) then
											Squid_Alert("Trapping " .. UnitClass(theirHealer),"(Close)",2)
										end
									end
								elseif not _slowImmuneCheck(theirHealer) then
									_Cast(5116,theirHealer,nil,true)
								end
							end
						end

						if not cc and _movingTowards(theirHealer,.14,nil,true) and not _slowImmuneCheck(theirHealer) and not _immunePhysical(theirHealer) then
							_Cast(5116,theirHealer,nil,true)
						end

						if cc then
							if (dr == 1 or drrem < ccr) and ccr < 5 then
								if immune then
									Squid_Alert("|cffffff00Delaying Trap","("..GetSpellInfo(immune)..")",nil,5)
								else
									Squid_Alert("|cffADFF2FFollowing up with Trap |cff00ffff("..GetSpellInfo(cc)..")",nil,nil,4.8)
									if ccr <= tt+gcd then return end -- pause for followup
								end
							end
						elseif not focus_trap_queued and all_opponents_visible and not _CCcheck(theirHealer) then
							if dr == 1 or drrem < 5 then
								if _spellCooldown(19577) <= gcd and sdr == 1 then
									if not _immunePhysical(theirHealer) and not _immuneStuns(theirHealer) and dist < 42 then
										if _Cast(19577,theirHealer) then
											Squid_Alert("|cffffff00Stunning " .. UnitClass(theirHealer),"(Trap Ready)",3)
										end
										wait_for_intim = true
									end
								end
							end
						end

					end

				end
			end

			local purges = {
				264265,
				264028,
				264266,
				264264,
				264263,
				264262,
				264056,
			}
			if pet_exists then
				for i=1,#purges do
					local petPurge = purges[i]
					if IsUsableSpell(petPurge) then
						if _valid(current_target) and not waiting_for_intim then
							if _purgeAnything(current_target) then
								CastSpellByID(petPurge,current_target)
								CastSpellByID(petPurge,current_target)
							end
						end
					end
				end
			end

			--utils
			local function cds(t)
				if not t then return end
				if not their_healer_cc then return false end
				--bestial wrath
				if pet_exists and pet_in_range then
					_Cast(19574)
				end
				if dire_beast_basilisk and dire_beast_basilisk_cd < gcd then pool_for_basilisk=true end
				_Cast(205691)
				-- actions.cds=ancestral_call,if=cooldown.bestial_wrath.remains>30
				-- actions.cds+=/fireblood,if=cooldown.bestial_wrath.remains>30
				-- actions.cds+=/berserking,if=buff.aspect_of_the_wild.up&amp;(target.time_to_die>cooldown.berserking.duration+duration|(target.health.pct<35|!talent.killer_instinct.enabled))|target.time_to_die<13
				-- actions.cds+=/blood_fury,if=buff.aspect_of_the_wild.up&amp;(target.time_to_die>cooldown.blood_fury.duration+duration|(target.health.pct<35|!talent.killer_instinct.enabled))|target.time_to_die<16
				-- actions.cds+=/lights_judgment,if=pet.cat.buff.frenzy.up&amp;pet.cat.buff.frenzy.remains>gcd.max|!pet.cat.buff.frenzy.up
				-- actions.cds+=/potion,if=buff.bestial_wrath.up&amp;buff.aspect_of_the_wild.up&amp;(target.health.pct<35|!talent.killer_instinct.enabled)|target.time_to_die<25
				-- actions.cds+=/worldvein_resonance,if=buff.lifeblood.stack<4
				-- actions.cds+=/guardian_of_azeroth
				-- actions.cds+=/ripple_in_space
				-- actions.cds+=/memory_of_lucid_dreams
				_Cast(298357)
			end

			local function cleave(t,active_enemies)
				if not t then return end
				-- actions.cleave=barbed_shot,target_if=min:dot.barbed_shot.remains,if=pet.cat.buff.frenzy.up&amp;pet.cat.buff.frenzy.remains<=gcd.max
				if frenzy_up and frenzy_remains <= gcd then
					if _Cast(217200,t,true) then return end
				end
				-- actions.cleave+=/multishot,if=gcd.max-pet.cat.buff.beast_cleave.remains>0.25
				if gcd - beast_cleave_remains > 0.25 then
					if _Cast(2643,t,true) then return end
				end
				-- actions.cleave+=/barbed_shot,target_if=min:dot.barbed_shot.remains,if=full_recharge_time<gcd.max&amp;cooldown.bestial_wrath.remains
				if barbed_shot_full_recharge_time < gcd and _spellCooldown(19574) > 0 then
					if _Cast(217200,t,true) then return end
				end
				-- actions.cleave+=/aspect_of_the_wild
				if _Cast(193530) then return end
				-- actions.cleave+=/stampede,if=buff.aspect_of_the_wild.up&amp;buff.bestial_wrath.up|target.time_to_die<15
				-- actions.cleave+=/bestial_wrath,if=cooldown.aspect_of_the_wild.remains_guess>20|talent.one_with_the_pack.enabled|target.time_to_die<15
				if _spellCooldown(193530) > 20 or IsPlayerSpell(199528) or _HP(t) < 20 then
					if _Cast(19574) then return end
				end
				-- actions.cleave+=/chimaera_shot
				-- actions.cleave+=/a_murder_of_crows
				if not arena then
					if _Cast(131894,t,true) then return end
				end
				-- actions.cleave+=/barrage
				-- actions.cleave+=/kill_command,if=active_enemies<4|!azerite.rapid_reload.enabled
				if pet_exists and not pet_in_cc and (not rapid_reload or active_enemies < 4 or focus_deficit < 45) then
					if _spellCooldown(34026) < .5 then
						CastSpellByID(34026,t)
					end
				end
				-- actions.cleave+=/dire_beast
				-- actions.cleave+=/barbed_shot,target_if=min:dot.barbed_shot.remains,if=pet.cat.buff.frenzy.down&amp;(charges_fractional>1.8|buff.bestial_wrath.up)|cooldown.aspect_of_the_wild.remains<pet.cat.buff.frenzy.duration-gcd&amp;azerite.primal_instincts.enabled|charges_fractional>1.4|target.time_to_die<9
				if not frenzy_up and (barbed_shot_frac_charges > 1.8 or bestial_wrath) or aspect_of_the_wild_cd < frenzy_remains and barbed_shot_frac_charges > 1.4 then
					if _Cast(217200,t,true) then return end
				end
				-- actions.cleave+=/focused_azerite_beam
				-- if focused_azerite_beam_castable then
				-- 	_Cast(295258)
				-- end
				-- actions.cleave+=/purifying_blast
				-- actions.cleave+=/concentrated_flame
				-- actions.cleave+=/blood_of_the_enemy
				-- actions.cleave+=/the_unbound_force,if=buff.reckless_force.up|buff.reckless_force_counter.stack<10
				-- actions.cleave+=/multishot,if=azerite.rapid_reload.enabled&amp;active_enemies>2
				if rapid_reload and active_enemies > 2 then
					if _Cast(2643,t,true) then return end
				end
				-- actions.cleave+=/cobra_shot,if=cooldown.kill_command.remains>focus.time_to_max&amp;(active_enemies<3|!azerite.rapid_reload.enabled)
				if kill_command_cd > focus_time_to_max and (active_enemies < 3 or not rapid_reload) then
					if _Cast(193455,t,true) then return end
				end
				-- actions.cleave+=/spitting_cobra
			end

			local function st(t)
				if not t then return end
				--breath of the dying (reaping flames)
				if IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd_remains then
					local hp = (100 * (UnitHealth(t)-GetSpellEffect(310690)) / UnitHealthMax(t));
					if hp < 20 or (hp < 82 + (their_healer_cc and 18 or 0) and hp > 80) then
						if hp < 20 or _HP(t) > 80 then
							if _Cast(310690,t,true) then
								Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
							end
						end
					end
				end
				-- actions.st=barbed_shot,if=pet.cat.buff.frenzy.up&amp;pet.cat.buff.frenzy.remains<gcd|cooldown.bestial_wrath.remains&amp;(full_recharge_time<gcd|azerite.primal_instincts.enabled&amp;cooldown.aspect_of_the_wild.remains<gcd)
				if frenzy_up and frenzy_remains < gcd or bestial_wrath_cd > gcd and (barbed_shot_frac_charges >= 1.8 or primal_instincts and aspect_of_the_wild_cd < gcd) then
					if not petbcc or not stomp then
						if _Cast(217200,t,true) then return end
					end
				end
				-- actions.st+=/aspect_of_the_wild,if=cooldown.barbed_shot.charges<2|pet.cat.buff.frenzy.stack>2|!azerite.primal_instincts.enabled
				if GetSpellCharges(217200) < 2 or frenzy_stacks > 2 or not primal_instincts then
					if their_healer_cc then
						if _Cast(193530) then return end
					end
				end
				-- actions.st+=/stampede,if=buff.aspect_of_the_wild.up&amp;buff.bestial_wrath.up|target.time_to_die<15
				-- actions.st+=/a_murder_of_crows,if=cooldown.bestial_wrath.remains
				if bestial_wrath_cd > gcd and (not pool_for_basilisk or focus_deficit < 40) then
					if their_healer_cc then
						if _Cast(131894,t,true) then return end
					end
				end
				-- actions.st+=/focused_azerite_beam,if=buff.bestial_wrath.down
				if not bestial_wrath and focused_azerite_beam_castable then
					if _Cast(295258) then return end
				end
				-- actions.st+=/bestial_wrath
				-- actions.st+=/kill_command
				if pet_exists and not pet_in_cc and not wait_for_intim and (not pool_for_basilisk or focus_deficit < 40) and pet_exists then
					if _spellCooldown(34026) < .5 then
						CastSpellByID(34026,t)
					end
				end
				-- actions.st+=/chimaera_shot
				if _Cast(53209,t,true) then return end
				-- actions.st+=/dire_beast
				if _Cast(120679,t,true) then return end
				-- actions.st+=/barbed_shot,if=pet.cat.buff.frenzy.down&amp;(charges_fractional>1.8|buff.bestial_wrath.up)|cooldown.aspect_of_the_wild.remains<pet.cat.buff.frenzy.duration-gcd&amp;azerite.primal_instincts.enabled|azerite.dance_of_death.rank>1&amp;buff.dance_of_death.down&amp;crit_pct_current>40|target.time_to_die<9
				if not frenzy_up and (barbed_shot_frac_charges > 1.8 or bestial_wrath) or aspect_of_the_wild_cd < frenzy_remains - gcd and primal_instincts then
					if not petbcc or not stomp then
						if _Cast(217200,t,true) then return end
					end
				end
				-- actions.st+=/purifying_blast
				-- actions.st+=/concentrated_flame
				if _Cast(295373,t,true) then return end
				-- actions.st+=/blood_of_the_enemy
				-- actions.st+=/the_unbound_force,if=buff.reckless_force.up|buff.reckless_force_counter.stack<10
				-- actions.st+=/barrage
				if _Cast(120360,t,true) then return end
				-- actions.st+=/cobra_shot,if=(focus-cost+focus.regen*(cooldown.kill_command.remains-1)>action.kill_command.cost|cooldown.kill_command.remains>1+gcd|buff.memory_of_lucid_dreams.up)&amp;cooldown.kill_command.remains>1
				if (focus-35+GetPowerRegen()*(kill_command_cd-1) > 30 or kill_command_cd > 1+gcd or lucid_dreams_up) and kill_command_cd > 1 then
					if (not pool_for_basilisk or focus_deficit < 35) then
						if _Cast(193455,t,true) then return end
					end
				end
				-- actions.st+=/spitting_cobra

				-- actions.st+=/barbed_shot,if=charges_fractional>1.4
				if barbed_shot_frac_charges > 1.4 then
					if not petbcc or not stomp then
						if _Cast(217200,t,true) then return end
					end
				end
			end

			--lower prio than trap
			if pet_exists then
				if UnitIsDeadOrGhost("pet") then
					_Cast(982)
				elseif _HP("pet") < 70 then
					_Cast(136)
				end
			end

			if _valid(t) then

				local active_enemies = 1 + Enemies_Around_Unit(t,8)

				if not squid_aa or time - squid_aa > 1 then
					CastSpellByID(75,t)
					squid_aa = time
				end

				--pet bite
				if not pet_bite_time or time - pet_bite_time > 1 then
					CastSpellByName("Claw",t)
					CastSpellByName("Bite",t)
				end

				--tar
				for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) and _isMeleeDps(Enemies[i]) and _distance(Enemies[i]) <= 4 then
					_aeCastInMovingDirection(187698,Enemies[i],perfectTravelDist(Enemies[i]))
				end end

				--conc
				if UnitIsPlayer(t) and not _isSlowed(t) and not _slowImmuneCheck(t) then
					_Cast(5116,t,true)
				end

				if not wait_for_intim then
					if not petattacksent or time-petattacksent > 1.5 then
						PetAttack(t)
						petattacksent=time
					end
				end

				if not pet_exists and not UnitIsDeadOrGhost("pet") then
					if not petwarning or petwarning < 500 then
						petwarning=petwarning or 0
						Squid_Alert("Please summon pet",nil,2)
						petwarning=petwarning+1
					end
				end

				cds(t)

				if not arena and active_enemies > 1 then
					cleave(t,active_enemies)
				end

				if arena or active_enemies < 2 then
					st(t)
				end
			end

			--982 revive pet

			-- # Executed every time the actor is available.
			-- actions=auto_shot
			-- actions+=/use_items
			-- actions+=/ashvanes_razor_coral,if=debuff.razor_coral_debuff.up&amp;(prev_gcd.1.aspect_of_the_wild|!equipped.cyclotronic_blast&amp;buff.aspect_of_the_wild.up)|(debuff.razor_coral_debuff.down|target.time_to_die<26)&amp;target.time_to_die>(24*(cooldown.cyclotronic_blast.remains+4<target.time_to_die))
			-- actions+=/call_action_list,name=cds
			-- actions+=/call_action_list,name=st,if=active_enemies<2
			-- actions+=/call_action_list,name=cleave,if=active_enemies>1

			-- actions.cds=ancestral_call,if=cooldown.bestial_wrath.remains>30
			-- actions.cds+=/fireblood,if=cooldown.bestial_wrath.remains>30
			-- actions.cds+=/berserking,if=buff.aspect_of_the_wild.up&amp;(target.time_to_die>cooldown.berserking.duration+duration|(target.health.pct<35|!talent.killer_instinct.enabled))|target.time_to_die<13
			-- actions.cds+=/blood_fury,if=buff.aspect_of_the_wild.up&amp;(target.time_to_die>cooldown.blood_fury.duration+duration|(target.health.pct<35|!talent.killer_instinct.enabled))|target.time_to_die<16
			-- actions.cds+=/lights_judgment,if=pet.cat.buff.frenzy.up&amp;pet.cat.buff.frenzy.remains>gcd.max|!pet.cat.buff.frenzy.up
			-- actions.cds+=/potion,if=buff.bestial_wrath.up&amp;buff.aspect_of_the_wild.up&amp;(target.health.pct<35|!talent.killer_instinct.enabled)|target.time_to_die<25
			-- actions.cds+=/worldvein_resonance,if=buff.lifeblood.stack<4
			-- actions.cds+=/guardian_of_azeroth
			-- actions.cds+=/ripple_in_space
			-- actions.cds+=/memory_of_lucid_dreams



			-- actions.st=barbed_shot,if=pet.cat.buff.frenzy.up&amp;pet.cat.buff.frenzy.remains<gcd|cooldown.bestial_wrath.remains&amp;(full_recharge_time<gcd|azerite.primal_instincts.enabled&amp;cooldown.aspect_of_the_wild.remains<gcd)
			-- actions.st+=/aspect_of_the_wild,if=cooldown.barbed_shot.charges<2|pet.cat.buff.frenzy.stack>2|!azerite.primal_instincts.enabled
			-- actions.st+=/stampede,if=buff.aspect_of_the_wild.up&amp;buff.bestial_wrath.up|target.time_to_die<15
			-- actions.st+=/a_murder_of_crows,if=cooldown.bestial_wrath.remains
			-- actions.st+=/focused_azerite_beam,if=buff.bestial_wrath.down
			-- actions.st+=/bestial_wrath
			-- actions.st+=/kill_command
			-- actions.st+=/chimaera_shot
			-- actions.st+=/dire_beast
			-- actions.st+=/barbed_shot,if=pet.cat.buff.frenzy.down&amp;(charges_fractional>1.8|buff.bestial_wrath.up)|cooldown.aspect_of_the_wild.remains<pet.cat.buff.frenzy.duration-gcd&amp;azerite.primal_instincts.enabled|azerite.dance_of_death.rank>1&amp;buff.dance_of_death.down&amp;crit_pct_current>40|target.time_to_die<9
			-- actions.st+=/purifying_blast
			-- actions.st+=/concentrated_flame
			-- actions.st+=/blood_of_the_enemy
			-- actions.st+=/the_unbound_force,if=buff.reckless_force.up|buff.reckless_force_counter.stack<10
			-- actions.st+=/barrage
			-- actions.st+=/cobra_shot,if=(focus-cost+focus.regen*(cooldown.kill_command.remains-1)>action.kill_command.cost|cooldown.kill_command.remains>1+gcd|buff.memory_of_lucid_dreams.up)&amp;cooldown.kill_command.remains>1
			-- actions.st+=/spitting_cobra
			-- actions.st+=/barbed_shot,if=charges_fractional>1.4

		end -- End Beast Mastery

		--Begin Survival
		if spec == 3 then

			local spells = {
				abilities                       = {
					aspectOfTheEagle            = 186289,
					butchery                    = 212436,
					carve                       = 187708,
					chakrams                    = 259391,
					coordinatedAssault          = 266779,
					flankingStrike              = 269751,
					harpoon                     = 190925,
					intimidation                = 19577,
					killCommand                 = 259489,
					mongooseBite                = 259387,
					muzzle                      = 187707,
					pheromoneBomb               = 270323,
					raptorStrike                = 186270,
					serpentSting                = 259491,
					shrapnelBomb                = 270335,
					steelTrap                   = 162488,
					volatileBomb                = 271045,
					wildfireBomb                = 259495,
					wingClip                    = 195645,
				},
				artifacts                       = {

				},
				buffs                           = {
					aspectOfTheEagle            = 186289,
					blurOfTalons                = 277969,
					coordinatedAssault          = 266779,
					exposedFlank                = 252094, -- Tier 21
					mongooseFury                = 259388,
					tipOfTheSpear               = 260286,
					vipersVenom                 = 268552,
				},
				debuffs                         = {
					bloodseeker                 = 259277,
					internalBleeding            = 270343,
					latentPoison                = 273286,
					serpentSting                = 259491,
					shrapnelBomb                = 270339,
					wildfireBomb                = 269747,
				},
				glyphs                          = {

				},
				pvpTalents                      = {
					huntingPack					= 203235,
					mendingBandage				= 212640,
					stickyTar					= 203264,
					trackersNet					= 212638,
					diamondIce					= 203340,
					hiExplosiveTrap				= 236776,
					spiderSting					= 202914,
					scorpidSting				= 202900,
					dragonScaleArmor			= 202589,
					roarOfSacrifice				= 53480,
					survivalTactics				= 202746,
					viperSting					= 202797,
				},
				talents                         = {
					alphaPredator               = 269737,
					birdsOfPrey                 = 260331,
					bloodseeker                 = 260248,
					butchery                    = 212436,
					chakrams                    = 259391,
					flankingStrike              = 269751,
					guerrillaTactics            = 264332,
					hydrasBite                  = 260241,
					mongooseBite                = 259387,
					steelTrap                   = 162488,
					termsOfEngagement           = 265895,
					tipOfTheSpear               = 260285,
					vipersVenom                 = 268501,
					wildfireInfusion            = 271014,
				},
				traits                          = {
					blurOfTalons                = 277653,
					latentPoison                = 273283,
					primevalIntuition           = 288570,
					upCloseAndPersonal          = 278533,
					venomousFangs               = 274590,
					wildernessSurvival          = 279589,
				}
			}
			local function nextBomb(nextBomb)
				local _,_,currentBomb = GetSpellInfo(spells.abilities.wildfireBomb)
				local _,_,shrapnelBomb = GetSpellInfo(spells.abilities.shrapnelBomb)
				local _,_,volatileBomb = GetSpellInfo(spells.abilities.volatileBomb)
				local _,_,pheromoneBomb = GetSpellInfo(spells.abilities.pheromoneBomb)
				if nextBomb ~= nil then
					if currentBomb == shrapnelBomb then return nextBomb == spells.abilities.shrapnelBomb end -- spell.volatileBomb
					if currentBomb == volatileBomb then return nextBomb == spells.abilities.volatileBomb end -- spell.pheromoneBomb
					if currentBomb == pheromoneBomb then return nextBomb == spells.abilities.pheromoneBomb end -- spell.shrapnelBomb
				else
					return nextBomb == spells.abilities.wildfireBomb
				end
				return currentBomb == nextBomb
			end

			local t = current_target

			if not UnitIsVisible(t) or not UnitCanAttack("player",t) then
				t = nil
			end

			local their_healer_cc
			if theirHealer and _CCcheck(theirHealer) then their_healer_cc = true end
			if not theirHealer then their_healer_cc = time_in_combat > 15 end

			local focused_azerite_beam = IsPlayerSpell(295258)
			local focused_azerite_beam_castable

			if _valid(t) then
				local facing = am_i_facing_angle(t)
				if _distance(t) < 10 and facing and not facing_bcc(12) then
					focused_azerite_beam_castable=true
				end
			end

			if pet_exists then
				enemies_around_pet=Enemies_Around_Unit("pet",8)
				petbcc=breakable_cc_around("pet",15)
				pet_in_cc=_CCcheck("pet")
				if _valid(current_target) then
					pet_in_range=_distance("pet",current_target) < 6.5
				end
				if IsPlayerSpell(spells.pvpTalents.roarOfSacrifice) and _spellCooldown(spells.pvpTalents.roarOfSacrifice) == 0 and not UnitIsDeadOrGhost("pet") and not _CCcheck("pet") then
					for i=1,#Friends do
						local hp = 50
						hp = hp + (EnemiesAttacking(Friends[i]) * 10)
						hp = hp + (EnemiesAttacking(Friends[i],nil,true) * 15)
						local current = math.floor(_HP(Friends[i]))
						if current < hp then
							if _distance("pet",Friends[i]) < 40 then
								CastSpellByID(spells.pvpTalents.roarOfSacrifice,Friends[i])
								Squid_Alert("|cffff6060 Roar of Sac " .. UnitClass(Friends[i]),"|cffffff00" .. current .. "% (Danger)",2)
							end
						end
					end
				end
				if _spellCooldown(53271) == 0 then
					for i=1,#Friends do if not _CCcheck(Friends[i]) then
						if _isMeleeDps(Friends[i]) then
							if _distance("pet",Friends[i]) < 40 then
								if _rootCheck(Friends[i]) then
									if _Cast(53271,Friends[i]) then
										Squid_Alert("Freedom " .. UnitClass(Friends[i]),"(Rooted)",2)
									end
								end
								if (lowestEnemy < 45 or _rootCheck("pet")) and _isSlowed(Friends[i]) then
									if _Cast(53271,Friends[i]) then
										Squid_Alert("Freedom " .. UnitClass(Friends[i]),"(Slowed, Low Enemy)",2)
									end
								end
							end
						end
						if _isHealer(Friends[i]) then
							if UnitDebuffID(Friends[i],81261) then
								if _distance("pet",Friends[i]) < 40 then
									if _Cast(53271,Friends[i]) then
										Squid_Alert("Freedom " .. UnitClass(Friends[i]),"(Root Beam)",2)
									end
								end
							end
						end
					end end
				end
			end

			--Stomp
			local function Stomp(totem,name)
				if S then return false; end
				local hp = UnitHealth(totem)
				local maxhp = UnitHealthMax(totem)
				if hp <= 1 then return false; end
				if maxhp <= 10000 then
					--Cobra Shot
					if _Cast(193455,totem,true) then
						Squid_Alert(name .. " Stomped","(Cobra Shot)",1)
					end
				end
			end

			local totems = {
			101398,	--Psyfiend
			119052,	--War Banner
			104818,	--Ancestral Protection Totem
			53006,	--Spirit Link Totem
			2630,	--Earthbind Totem
			60561,	--Earthgrab Totem
			-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
			5925,	--Grounding Totem
			105425,	--Skyfury Totem
			5913,	--Tremor Totem
			105451,	--Counterstrike Totem
			}

			if arena then
				for i=1,#Pets do
					local e = Pets[i]
					local name = UnitName(e);
					local id = UnitCreatureID(e)
					--only kill cap totems when they're casting
					if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
						Stomp(e,name)
					end
				end
			end

			if _spellCooldown(109304) <= gcd then
				local hp = 15
				hp = hp + EnemiesAttacking("player") * 10
				hp = hp + EnemiesAttacking("player",nil,true) * 5
				local current = math.floor(_HP("player"))
				if current < hp then
					if _Cast(109304) then
						Squid_Alert("|cffff6060Exhilharation Heal","|cffffff00" .. current.."% (Danger)",2)
					end
				end
			end

			-- if petbcc and stomp then
			-- 	Squid_Alert("|cffff6060Can't Barbed Shot","(Breakable CC)",nil,5)
			-- end

			--pet purge if enemy has a debuff that is dispellable


			--tracker's net
			local our_healer = ourHealer
			local our_healer_cc
			local our_healer_cc_remains = 0
			if our_healer then
				our_healer_cc_remains = _CCremains(our_healer)
				our_healer_cc = our_healer_cc_remains > 0
			end
			local rogue_exists
			for i=1,#Enemies do if select(2,UnitClass(Enemies[i])) == "ROGUE" then
				rogue_exists=Enemies[i]
			end end

			--tracker's net taken and off cd
			if IsPlayerSpell(spells.pvpTalents.trackersNet) and _spellCooldown(spells.pvpTalents.trackersNet) <= gcd_remains then
				--when we have a healer
				if our_healer then
					--and no rogue exists
					if not rogue_exists then
						--and our lowest friend is below 90
						if lowestFriend < 90 then
							for i=1,#Enemies do if not _CCcheck(Enemies[i]) and not _slowImmuneCheck(Enemies[i]) and _rootDR(Enemies[i]) == 1 then
								--when cds are up, or lowest friend is below 70
								if _CDcheck(Enemies[i]) or lowestFriend < 70 then
									local e = Enemies[i]
									--and unit is melee, but not a feral druid
									if _isMeleeDps(e) and select(2,UnitClass(e)) ~= "DRUID" then
										local enemy_target = UnitTarget(e)
										--and unit is in range of his target, and no friends are attacking him
										if enemy_target and _meleeRange(e,enemy_target) and UnitEnemiesAttacking(e) == 0 then
											--throw the net
											if _Cast(spells.pvpTalents.trackersNet,e,true) then
												Squid_Alert("Tracker's Net",UnitClass(e),nil,3,spells.pvpTalents.trackersNet)
												return
											end
										end
									end
								end end
							end
						end
					--and rogue does exist
					else
						--and rogue is visible, out of cc, off root dr and not being attacked
						if UnitIsVisible(rogue_exists) and not _CCcheck(rogue_exists) and not _slowImmuneCheck(rogue_exists) and _rootDR(rogue_exists) == 1 and UnitEnemiesAttacking(rogue_exists) == 0 then
							local rogue_target = UnitTarget(rogue_exists)
							--and rogue stuns his target, or his target is below 60
							if rogue_target and _stunCheck(rogue_target) or _HP(rogue_target) < 60 then
								--throw the net
								if _Cast(spells.pvpTalents.trackersNet,rogue_exists,true) then
									Squid_Alert("Tracker's Net","(Rogue Stun)",nil,3,spells.pvpTalents.trackersNet)
									return
								end
							end
						end
					end
				--when we don't have a healer
				else
					if lowestFriend < 80 then
						for i=1,#Enemies do if not _CCcheck(Enemies[i]) and not _slowImmuneCheck(Enemies[i]) and _rootDR(Enemies[i]) == 1 then
							if _isMeleeDps(Enemies[i]) and select(2,UnitClass(Enemies[i])) ~= "DRUID" then
								local e = Enemies[i]
								local enemy_target = UnitTarget(e)
								--and enemy melee has pressure on his target
								if _HP(enemy_target) < 80 + (_CDcheck(e) and 20 or 0) and _meleeRange(e) and UnitEnemiesAttacking(e) == 0 then
									--throw the net
									if _Cast(spells.pvpTalents.trackersNet,e,true) then
										Squid_Alert("Tracker's Net",UnitClass(e),nil,3,spells.pvpTalents.trackersNet)
										return
									end
								end
							end
						end end
					end
				end
			end

			local mending_bandage_cd = _spellCooldown(spells.pvpTalents.mendingBandage)

			--worth mending
			local function worth_mending(unit)
				local bleeds = 0
				--1.5x value for rip, pain in the ass for feral to keep reapplying
				bleeds = bleeds + (_debuffRemains(unit,1079) * 1.5)
				--1/2 value for rake, weak ass dot
				bleeds = bleeds + (_debuffRemains(unit,155722) / 2)
				--4x value for internal bleeding, important and strong ass dot
				bleeds = bleeds + (_debuffRemains(unit,154953) * 4)
				--rupture
				bleeds = bleeds + _debuffRemains(unit,1943)
				--1/2 value for garrote
				bleeds = bleeds + (_debuffRemains(unit,703) / 2)
				--gushers
				bleeds = bleeds + (_debuffRemains(unit,318272) / 2)
				--add feral frenzy

				return bleeds > 30
			end

			--mending bandage
			if IsPlayerSpell(spells.pvpTalents.mendingBandage) and mending_bandage_cd <= gcd_remains then
				if not _isMoving("player") then
					for i=1,#Friends do if worth_mending(Friends[i]) then
						if _isMoving("player") then Squid_Alert("Stop Moving","Mending Bandage",nil,nil,spells.pvpTalents.mendingBandage) end
						if _Cast(spells.pvpTalents.mendingBandage,Friends[i]) then
							Squid_Alert("Mending Bandage",UnitClass(Friends[i]),nil,nil,spells.pvpTalents.mendingBandage)
							return
						end
					end end
				end
			end

			--spider sting
			local casters = {"MAGE","DRUID","WARLOCK","PRIEST"}

			if IsPlayerSpell(spells.pvpTalents.spiderSting) and _spellCooldown(spells.pvpTalents.spiderSting) < gcd_remains then
				for i=1,#Enemies do if _isRangedDps(Enemies[i]) then
					local e = Enemies[i]
					local class = select(2,UnitClass(Enemies[i]))
					if tContains(casters,class) then
						if Interrupt(e,nil,80) then
							if _Cast(spells.pvpTalents.spiderSting,e,nil,true) then
								Squid_Alert("Spider Sting",UnitClass(e),nil,nil,spells.pvpTalents.spiderSting)
							end
						end
					end
				end end
			end

			--scorpid sting
			if IsPlayerSpell(spells.pvpTalents.scorpidSting) and _spellCooldown(spells.pvpTalents.scorpidSting) < gcd_remains then
				for i=1,#Enemies do if _isMeleeDps(Enemies[i]) then
					local enemy_target = UnitTarget(Enemies[i])
					if enemy_target and _meleeRange(Enemies[i],enemy_target) then
						if _Cast(202900,Enemies[i],nil,true) then
							Squid_Alert("Scorpid Sting",UnitClass(Enemies[i]),nil,nil,spells.pvpTalents.scorpidSting)
						end
					end
				end end
			end

			--viper sting
			if theirHealer and IsPlayerSpell(spells.pvpTalents.viperSting) and _spellCooldown(spells.pvpTalents.viperSting) < gcd_remains then
				if lowestEnemy < 70 and not _CCcheck(theirHealer) then
					if _Cast(spells.pvpTalents.viperSting,theirHealer,nil,true) then
						Squid_Alert("Viper Sting",UnitClass(theirHealer),nil,nil,spells.pvpTalents.viperSting)
					end
				end
			end


			if not SQUID.i_am_xen then
				local wait_for_intim
				-- local theirHealer="focus" -- testing purposes
				-- if not arena and UnitIsVisible(current_focus) then
				-- 	theirHealer=current_focus
				-- end
				if focus_trap_queued then
					theirHealer = current_focus
				end
				if healer_trap_queued then
					theirHealer = theirHealer
				end
				if theirHealer and _spellCooldown(187650) <= 5 then

					local dr = _incapacitateDR(theirHealer)
					local drrem = _drRemains(theirHealer,"incapacitate")

					local sdr = _stunDR(theirHealer)

					local ua = UnitEnemiesAttacking(theirHealer)

					--no friends attacking
					if ua == 0 then

						local los = _LoS(theirHealer)

						local buffer = (select(4,GetNetStats())/1000) + ((1/GetFramerate())*15)

						if _spellCooldown(781) == 0 and trap_cc(theirHealer) then
							if not _LoS(theirHealer) then
								buffer=buffer+.65
							end
						end

						local cc = trap_cc(theirHealer)
						local ccr = trap_cc_remains(theirHealer)
						local tt = trap_travel_time(theirHealer) + buffer
						local dist = _distance(theirHealer)
						local immune = immune_trap(theirHealer)

						--if no dr or their healer is trapped and dr is not more than half duration
						if dr == 1 or (UnitDebuffID(theirHealer,3355) and dr >= .5) then
							if (cc and ccr <= tt) or (not cc and (dist < 2 or (UnitCastingInfo(theirHealer) and dist < 12 and not _isMoving(theirHealer)))) then
								if not immune then
									if buffer > 0 then
										if not _LoS(theirHealer) or dist  > 40 then
											_disengageToUnit(theirHealer,true)
										end
									end
									if cc then
										if _aeCastInMovingDirection(187650,theirHealer,perfectTravelDist(theirHealer)) then
											Squid_Alert("Trapping " .. UnitClass(theirHealer),"(" .. GetSpellInfo(cc) .. ")",2)
										end
									end
									if UnitCastingInfo(theirHealer) then
										if _aeCastInMovingDirection(187650,theirHealer,perfectTravelDist(theirHealer)) then
											Squid_Alert("Trapping " .. UnitClass(theirHealer),"(Casting)",2)
										end
									end
									if _isSlowed(theirHealer) or not _isMoving(theirHealer) then
										if _aeCastInMovingDirection(187650,theirHealer,perfectTravelDist(theirHealer)) then
											Squid_Alert("Trapping " .. UnitClass(theirHealer),"(Close)",2)
										end
									elseif not _slowImmuneCheck(theirHealer) then
										if _meleeRange(theirHealer) then
											_Cast(spells.abilities.wingClip,theirHealer,nil,true)
										end
									end
								end
							end

							-- if not cc and _movingTowards(theirHealer,.14,nil,true) and not _slowImmuneCheck(theirHealer) and not _immunePhysical(theirHealer) then
							-- 	_Cast(spells.abilities.wingClip,theirHealer,nil,true)
							-- end

							if cc then
								if (dr == 1 or drrem < ccr) and ccr < 5 then
									if immune then
										Squid_Alert("|cffffff00Delaying Trap","("..GetSpellInfo(immune)..")",nil,5)
									else
										Squid_Alert("|cffADFF2FFollowing up with Trap |cff00ffff("..GetSpellInfo(cc)..")",nil,nil,4.8)
										if ccr <= tt+gcd then return end -- pause for followup
									end
								end
							elseif all_opponents_visible and not _CCcheck(theirHealer) then
								if dr == 1 or drrem < 5 then
									if _spellCooldown(19577) <= gcd and sdr == 1 then
										if not _immunePhysical(theirHealer) and not _immuneStuns(theirHealer) and dist < 42 then
											if _Cast(19577,theirHealer) then
												Squid_Alert("|cffffff00Stunning " .. UnitClass(theirHealer),"(Trap Ready)",3)
											end
											wait_for_intim = true
										end
									end
								end
							end

						end

					end
				end
			end

			local purges = {
				264265,
				264028,
				264266,
				264264,
				264263,
				264262,
				264056,
			}

			if pet_exists then
				for i = 1, #purges do
					local petPurge = purges[i]
					if IsUsableSpell(petPurge) then
						if _valid(current_target) and not waiting_for_intim then
							if _purgeAnything(current_target) then
								CastSpellByID(petPurge,current_target)
								CastSpellByID(petPurge,current_target)
							end
						end
					end
				end
			end

			local function wfi(t) -- Wildfire Infusion Rotation
				if not t then return end
				--Default Action List
				--call_action_list,name=cds
				--racial,if=cooldown.coordinated_assault.remains>30
				-- if _spellCooldown(spells.abilities.coordinatedAssault) > 30 then
				-- 	if _Cast(sharedSpells.abilities.racial) then return end
				-- end
				--use_item,name=ashvanes_razor_coral,if=buff.memory_of_lucid_dreams.up|buff.guardian_of_azeroth.up|debuff.razor_coral_debuff.down|target.time_to_die<20
				-- if IsEquippedItem(169311) and select(2,GetItemCooldown(169311)) == 0 and (_buffRemains("player", 298357) > 1 or _debuffRemains(t, 303568) == 0) then
				-- 	if UseItemByName(GetItemInfo(169311)) then return end
				-- end
				--breath of the dying (reaping flames)
				if IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd_remains then
					local hp = (100 * (UnitHealth(t)-GetSpellEffect(310690)) / UnitHealthMax(t));
					if hp < 20 or (hp < 82 + (their_healer_cc and 18 or 0) and hp > 80) then
						if hp < 20 or _HP(t) > 80 then
							if _Cast(310690,t,true) then
								Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
							end
						end
					end
				end
				--concentrated_flame,if=full_recharge_time<1*gcd
				if _getFullRechargeTime(295373) < 1 * gcd then
					if _Cast(295373,t) then return end
				end
				--call_action_list,name=wfi,if=active_enemies<3&amp;!talent.alpha_predator.enabled&amp;talent.wildfire_infusion.enabled
				--serpent_sting,if=buff.vipers_venom.up&amp;buff.vipers_venom.remains<1.5*gcd|!dot.serpent_sting.ticking
				if UnitBuffID("player", spells.buffs.vipersVenom) and _buffRemains("player", spells.buffs.vipersVenom) < 1.5 * gcd or _debuffRemains(t, spells.debuffs.serpentSting, "player") < 2.5 then
					if _Cast(spells.abilities.serpentSting,t,true) then return end
				end
				--wildfire_bomb,if=full_recharge_time<1.5*gcd&amp;focus+cast_regen<focus.max|(next_wi_bomb.volatile&amp;dot.serpent_sting.ticking&amp;dot.serpent_sting.refreshable|next_wi_bomb.pheromone&amp;!buff.mongoose_fury.up&amp;focus+cast_regen<focus.max-action.kill_command.cast_regen*3)
				if (_getFullRechargeTime(spells.abilities.wildfireBomb) < (1.5 * gcd and focus + focus_regen)) or nextBomb(spells.abilities.volatileBomb) or nextBomb(spells.abilities.pheromoneBomb) and _buffRemains(spells.buffs.mongooseFury) == 0 and focus + focus_regen < focus_max - 15 * 3 then
					if _Cast(spells.abilities.wildfireBomb,t,true) then return end
				end
				--kill_command,if=focus+cast_regen<focus.max-focus.regen
				if focus + (focus_regen * gcd) < focus_max-focus_regen then
					if _Cast(spells.abilities.killCommand,t) then return end
				end
				--wildfire_bomb,if=full_recharge_time<1.5*gcd
				if _getFullRechargeTime(spells.abilities.wildfireBomb) < 1.5 * gcd then
					if _Cast(spells.abilities.wildfireBomb,t,true) then return end
				end
				--coordinated_assault
				if _Cast(spells.abilities.coordinatedAssault,t,true) then return end
				--serpent_sting,if=buff.vipers_venom.up&amp;dot.serpent_sting.remains<4*gcd
				if UnitBuffID("player", spells.buffs.vipersVenom) and _debuffRemains(t, spells.debuffs.serpentSting) < 4 * gcd then
					if _Cast(spells.abilities.serpentSting,t,true) then return end
				end
				--mongoose_bite,if=dot.shrapnel_bomb.ticking|buff.mongoose_fury.stack=5
				if _debuffRemains(t, spells.debuffs.shrapnelBomb) > 1 or _buffStacks("player", spells.buffs.mongooseFury) == 5 then
					if _Cast(spells.abilities.mongooseBite,t,true) then return end
				end
				--wildfire_bomb,if=next_wi_bomb.shrapnel&amp;dot.serpent_sting.remains>5*gcd
				if nextBomb(spells.abilities.shrapnelBomb) and _debuffRemains(t, spells.debuffs.serpentSting) > 5 * gcd then
					if _Cast(spells.abilities.wildfireBomb,t,true) then return end
				end
				--serpent_sting,if=refreshable
				if _debuffRemains(t, spells.debuffs.serpentSting) < 2.5 and _Cast(spells.abilities.serpentSting,t,true) then return end
				--mongoose_bite
				if _Cast(spells.abilities.mongooseBite,t,true) then  return end
				--serpent_sting,if=buff.vipers_venom.up
				if _buffRemains("player", spells.buffs.vipersVenom) > 1 then
					if _Cast(spells.abilities.serpentSting,t,true) then return end
				end
				--wildfire_bomb,if=next_wi_bomb.volatile&amp;dot.serpent_sting.ticking|next_wi_bomb.pheromone|next_wi_bomb.shrapnel
				if nextBomb(spells.abilities.volatileBomb) and _debuffRemains(t, spells.debuffs.serpentSting) > 1 or nextBomb(spells.abilities.pheromoneBomb) or nextBomb(spells.abilities.shrapnelBomb) then
					if _Cast(spells.abilities.wildfireBomb,t,true) then return end
				end
				--concentrated_flame
				if _Cast(295373,t) then return end
			end-- End Wfi Rotation List

			local target_hp = _HP(t)
			local target_absorbs = 0
			local target_effective_hp = 100

			if UnitIsVisible(t) then
				target_absorbs = UnitGetTotalAbsorbs(t)
				target_effective_hp = (100 * (UnitHealth(t)+target_absorbs) / UnitHealthMax(t))
			end

			local defensives = {
				-- Flat Walls
				{id = 212800, dr = 35}, -- Blur (35% DMG REDUC)
				{id = 209426, dr = 100}, -- Darkness (Just calling it 100%)
				{id = 498, dr = 20}, -- Divine Protection (20% wall)
				{id = 31821, dr = 20}, -- Aura Mastery (20% wall)
				{id = 243435, dr = 20}, -- Fort Brew (20% wall)
				{id = 125174, dr = 100}, -- Karma (100% absorb that doesn't show up in absorbs)
				{id = 122278, dr = 50}, -- Diffuse Magic (20-50% wall based on damage of incoming attack, calling it 50 for the sake of botd)
				{id = 61336, dr = 50}, -- Survival Instincts (50% wall)
				{id = 22812, dr = 20}, -- Barkskin (20% wall)
				{id = 102342, dr = 20}, -- Ironbark (20% wall)
				{id = 201633, dr = 10}, -- Earthen Wall (~10% max botd dmg absorbed)
				{id = 108271, dr = 40}, -- Astral Shift (40% wall)
				{id = 104773, dr = 40}, -- Unending Resolve (40% wall)
				{id = 1966, dr = 30}, -- Feint (30% wall)
				{id = 33206, dr = 40}, -- Pain Supp (40% wall)
				{id = 81782, dr = 40}, -- Barrier (25-50% wall depending on talent)
				{id = 47585, dr = 75}, -- Dispersion (75% wall)
				{id = 213602, dr = 100}, -- Greater Fade (100% wall)
				{id = 197690, dr = 20}, -- Defensive Stance (20% wall)
				{id = 118038, dr = 30}, -- Parry (30% wall)
				{id = 48792, dr = 30}, -- IBF (30% wall)
				{id = 287081, dr = 30}, -- Lichborne (30% wall)
				{id = 186265, dr = 100}, -- Turtle (hunter det)
				{id = 45438, dr = 100}, -- Ice Block

				-- Magic Walls (AMS shows up in UnitGetTotalAbsorbs so not putting here)
				{id = 122783, dr = 60}, -- Diffuse Magic (60% mwall)
				{id = 31224, dr = 100}, -- Cloak of Shadows (100% magic immune)
				{id = 198065, dr = 50}, -- Prismatic Cloak Mage Blink Shit
				{id = 204018, dr = 100}, -- Spell Warding
			}

			--reaping effective dmg
			local reaping_damage = GetSpellEffect(310690)
			--modifier for kb bonus
			reaping_damage = reaping_damage * ( UnitBuffID("player",311202) and 2 or 1 )

			local target_dmg_reduc = 0
			for i=1,#defensives do
				local id = defensives[i].id
				local dr = defensives[i].dr
				if UnitBuffID("target",id) then
					target_dmg_reduc = target_dmg_reduc + dr
				end
			end
			target_dmg_reduc = target_dmg_reduc / 100

			local reaping_mod = 1 - target_dmg_reduc

			-- flame
			if t and IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd_remains and not _immuneMagic(t) then
				local cur_hp = _HP(t)
				local est_hp = (100 * ( UnitHealth("target") - ( reaping_damage * reaping_mod ) + target_absorbs ) / UnitHealthMax("target") )
				if est_hp < 20 or cur_hp > 80 and ( cur_hp < 97 or their_healer_cc ) then
					if _Cast(310690,t,true) then
						Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
					end
				end
			end

			--lower prio than trap
			if pet_exists then
				if UnitIsDeadOrGhost("pet") then
					_Cast(982)
				elseif _HP("pet") < 70 then
					_Cast(136)
				end
			end

			--wing clip
			if UnitIsPlayer(t) and not _isSlowed(t) and not _slowImmuneCheck(t) then
				_Cast(spells.abilities.wingClip,t,true)
			end

			--tar
			for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) and _isMeleeDps(Enemies[i]) and _distance(Enemies[i]) <= 5 then
				_aeCastInMovingDirection(spells.abilities.tarTrap,Enemies[i],perfectTravelDist(Enemies[i]))
			end end

			if not SQUID.UtilitiesOnly and not SQUID.i_am_xen and _valid(t) then

				local active_enemies = Enemies_Around_Unit(t,8)

				if not squid_aa or time - squid_aa > 1 then
					CastSpellByID(6603,t) -- Auto shot
					squid_aa = time
				end

				--pet bite
				CastSpellByName("Claw",t)
				CastSpellByName("Bite",t)

				if not wait_for_intim then
					if not petattacksent or time-petattacksent > 1.5 then
						PetAttack(t)
						petattacksent=time
					end
				end

				if not pet_exists and not UnitIsDeadOrGhost("pet") then
					if not petwarning or petwarning < 500 then
						petwarning=petwarning or 0
						Squid_Alert("Please summon pet",nil,2)
						petwarning=petwarning+1
					end
				end

				--crows
				if (their_healer_cc or not arena) and IsPlayerSpell(131894) then
					if _Cast(131894,t,true) then return end
				end

				--crucible
				if IsPlayerSpell(295373) then
					if _Cast(295373,t,true) then return end
				end

				if not arena and active_enemies >= 1 then
					wfi(t)
				end

				if arena or active_enemies < 2 then
					wfi(t)
				end
			end
		end -- End Survival

	end

	-- fix swapping of sheep from healer who is already sheeped

	-- could_have_klepto - need to track enemy mage's alter heal effect and klept (+ cancel) at the approp times

	-- rotation feels really sluggish some games like it's using globals on something??

	-- Mage_Rotation_Override="PvP"
	-- door of shadows to disorients

	-- calculate bleed damage over duration of ring of frost with unit_has_dot and resheep just before it breaks

	-- [fixes implemented, need testing]:
	-- phoenix flames queued up while casting sheep breaks the sheep

	local cc_casts = {118,28272,277792,161354,277787,161355,161353,120140,61305,61721,61780,28271,113724}
	local crit_casts = {2948,133}

	local all_sheeps = {
		118,		-- Sheep
		28272,		-- Pig
		277792,		-- Bee
		161354,		-- Monkey
		277787,		-- Direhorn
		161355,		-- Penguin
		161353,		-- Polar Bear
		120140,		-- Porcupine
		61305,		-- Cat
		61721,		-- Rabbit
		61780,		-- Turkey
		28271,		-- Turtle
	}

	-- Covenant Data
	local covenants = {
		["None"] = 0,
		["Kyrian"] = 1,
		["Venthyr"] = 2,
		["NightFae"] = 3,
		["Necrolord"] = 4
	}

	local sheep_ids = {}

	local function check_sheep_ids()
		sheep_ids = {}
		for i=1,#all_sheeps do
			if IsPlayerSpell(all_sheeps[i]) then
				table.insert(sheep_ids,all_sheeps[i])
			end
		end
	end

	check_sheep_ids()

	local function sheep_remains(unit)
		local longest = 0
		for i=1,#all_sheeps do
			local remains = _debuffRemains(unit,all_sheeps[i],"player")
			if remains > longest then
				longest = remains
			end
		end
		return longest

		-- local debuffs = _debuffFromTable(unit,all_sheeps,true);
		-- table.sort(debuffs,function(x,y) return x>y end);
		-- if #debuffs > 0 then
		-- 	return debuffs[1];
		-- end

	end

	local function bin(arg)
		return arg and 1 or 0
	end

	local mage_frame
	-- fire mage frame
	if UnitClass("player") == "MAGE" and GetSpecialization() == 2 then

	end

	local function bleeds_around(unit,dist)

		if UnitDebuffID(unit,1079) and UnitEnemiesAttacking(unit) > 0 then return "this unit" end

		local rips_up = 0
		for i=1,#Enemies do
			if UnitDebuffID(Enemies[i],1079) and UnitEnemiesAttacking(Enemies[i]) > 0 then
				rips_up = rips_up + 1
			end
		end

		if rips_up >= 1 then
			return true
		end

	end

	function Squid_FireMagePvP()

		-- pause script (Eating, Soulshape)
		if UnitBuffID("player",167152) or UnitBuffID("player",310143) then return end

		local tanking = SQUID.tank_mmr

		local time = GetTime()
		local latency = squid_avg_latency
		local groupsize = GetNumGroupMembers()
		local msperframe = 2/GetFramerate()
		local buffer = latency + msperframe + .1
		local haste = UnitSpellHaste("player")
		local gcd = 1.5/(1+(haste/100))
		local gcd_remains = GetGCD()
		local combat = UnitAffectingCombat("player")
		local player_hp = _HP("player")
		local player_mana = (100 * UnitPower("player") / UnitPowerMax("player"));
		local player_immune = _immuneCheck("player",nil,true)

		local player_covenant = active_soulbinds[1] and active_soulbinds[1].covenantName

		local sheep = SQUID.poly_id or 118

		if SQUID.poly_id == "random" then
			sheep = sheep_ids [ math.random(1, #sheep_ids) ]
		end

		--barrier pre gate
		if UnitBuffID("player",32727) and arena_start_timer and arena_start_timer < 20 and not tanking then
			if _Cast(235313) then
				Squid_Alert("Blazing Barrier",nil,nil,nil,235313)
				return
			end
		end

		local auto_temp = SQUID.auto_temp

		local GetItemInfo_OG = GetItemInfo
		local GetItemInfo = function ( itemid ) local info = GetItemInfo_OG( itemid ) or ""; return info end

		local utilities_only = SQUID.utilities_only

		--equipped items
		local equipped_items = {}

		local trinkets = {
		174103,	--Manifesto of Madness
		167380,	--Notorious Gladiator's Badge
		172669,	--Corrupted Gladiator's Badge
		165058,	--Sinister Gladiator's Badge
		172666,	--Corrupted Gladiator's Medallion
		167377,	--Notorious Gladiator's Medallion
		165055,	--Sinister Gladiator's Medallion
		175884,	--Sinful Aspirant's Badge of Ferocity
		175921, --Sinful Glad's Badge
		159615,	--Ignition Mage's Fuse
		161411,	--Tzane's Barkspines
		161377,	--Azurethos' Singed Plumage
		166793,	--Ancient Knot of Wisdom (HORDE) (278267 SPELLID)
		161417,	--Ancient Knot of Wisdom (ALLIANCE) (278267 SPELLID)
		169318,	--Shockbiter's Fang
		168973,	--Neural Synapse Enhancer
		159630,	--Balefire Branch
		}

		for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then table.insert( equipped_items, trinkets[i] ) end end

		local extra_items = {
		159624,	--Rotcrusted Voodoo Doll
		169305,	--Aquipotent Nautilus
		168905,	--Shiver Venom Relic
		173944,	--Forbidden Obsidian Claw
		167677,	--Harmonic Dematerializer
		167835,	--Malformed Herald's Legwraps
		168989,	--Hyperthread Wristwraps (300142 SPELLID)
		167672,	--Cyclotronic Blast (293491 SPELLID)
		165576,	--Tidestorm Codex (289885 SPELLID)
		}

		for i=1,#extra_items do if IsEquippedItem ( extra_items[i] ) then table.insert( equipped_items, extra_items[i] ) end end

		local auto_cc = get_squid_var("Auto CC")
		local only_cc_healers = SQUID.only_cc_healers

		local fire_lockout = _spellCooldown(133) > gcd_remains and _spellCooldown(133) or 0
		local arcane_lockout = _spellCooldown(118) > gcd_remains and _spellCooldown(118) or 0
		local ring_cd = _spellCooldown(113724)
		local db_cd = _spellCooldown(31661)
		local meteor_cd = _spellCooldown(153561)
		local remove_curse_cd = _spellCooldown(475)
		local combustion_cd = _spellCooldown(190319)
		local blink_cd = _spellCooldown(212653)

		meteor_in_flight = meteor_cd > 42
		meteor_in_flight_remains = (3 - ( 45 - meteor_cd )) - buffer

		local rune_of_power_base_cd = 40
		local rune_of_power_charges = GetSpellCharges(116011)
		local rune_of_power_charges_frac = _spellChargeFrac(116011)
		local rune_of_power_next_charge_cd = (math.ceil(rune_of_power_charges_frac) - rune_of_power_charges_frac) * rune_of_power_base_cd

		local heating_up = UnitBuffID("player",48107)
		local heating_up_remains = _buffRemains("player",48107)
		local tinder_up = UnitBuffID("player",203277)
		local flamecannon_stacks = _buffStacks("player",203285)
		local rune_of_power_up = UnitBuffID("player",116014)

		local hot_streak = UnitBuffID("player",48108) or UnitBuffID("player",333100)
		local hot_streak_remains = _buffRemains("player",48108)
		local pyroclasm = UnitBuffID("player",269651)
		local pyroclasm_remains = _buffRemains("player",269651)
		local searing_touch_enabled = IsPlayerSpell(269644)
		local rune_of_power_enabled = IsPlayerSpell(116011)
		local ring_enabled = IsPlayerSpell(113724)
		local tinder_enabled = IsPlayerSpell(203275)
		local firestarter_enabled = IsPlayerSpell(203283)
		local flame_on = IsPlayerSpell(205029)
		local meteor_enabled = IsPlayerSpell(153561)
		local combustion_remains = _buffRemains("player",190319)
		local combustion = combustion_remains > 0

		local fire_blast_base_cd = flame_on and 10 or 12
		-- fire_blast_base_cd = fire_blast_base_cd * (1-(haste/100-.04))
		fire_blast_base_cd = fire_blast_base_cd - ( haste * 0.076954715597427 )

		local fire_blast_charges,fire_blast_max_charges = GetSpellCharges(108853)
		local fire_blast_total_cd = fire_blast_base_cd * fire_blast_max_charges
		local fire_blast_charges_frac = _spellChargeFrac(108853)
		local fire_blast_full_recharge_time = fire_blast_total_cd - (fire_blast_charges_frac*fire_blast_base_cd)
		local fire_blast_next_charge_cd = (math.ceil(fire_blast_charges_frac) - fire_blast_charges_frac) * fire_blast_base_cd

		function time_to_fb_charges(amt)
			return fire_blast_base_cd*amt - fire_blast_charges_frac*fire_blast_base_cd
		end

		local phoenix_flames_enabled = IsPlayerSpell(257541)
		local phoenix_flames_base_cd = 30
		local phoenix_flames_charges,phoenix_flames_max_charges = GetSpellCharges(257541)
		if not phoenix_flames_enabled then
			phoenix_flames_charges = 0
			phoenix_flames_max_charges = 0
		end
		local phoenix_flames_total_cd = phoenix_flames_base_cd * phoenix_flames_max_charges
		local phoenix_flames_charges_frac = _spellChargeFrac(257541)
		local phoenix_flames_full_recharge_time = phoenix_flames_total_cd - (phoenix_flames_charges_frac*phoenix_flames_base_cd)
		-- local phoenix_flames_next_charge_cd = (math.ceil(phoenix_flames_charges_frac) - phoenix_flames_charges_frac) * phoenix_flames_base_cd

		local enhanced_pyrotechnics_remains = _buffRemains("player",157644)
		-- local enhanced_pyrotechnics_up = enhanced_pyrotechnics_remains > 0
		-- local enhanced_pyrotechnics_stacks = _buffStacks("player",157644)

		local kyrian_fb_pool = player_covenant == "Kyrian" and time_to_fb_charges(2) >= (max(meteor_cd,_spellCooldown(307443)))

		local klepto_enabled = IsPlayerSpell(198100)

		flamecannon_value = (flamecannon_stacks * 3)

		gpy_range = 40
		sheep_range = 30
		ring_range = 30

		gpy_range = gpy_range + flamecannon_value
		sheep_range = sheep_range + flamecannon_value
		ring_range = ring_range + flamecannon_value

		local poly_cast_time = _castTime(118)
		local ring_cast_time = _castTime(113724)
		local greater_pyro_cast_time = _castTime(203286)
		local fireball_cast_time = _castTime(133)
		local scorch_cast_time = _castTime(2948)
		local rune_of_power_cast_time = _castTime(116011)

		local triune_ward = GetInventoryItemID("player",2) == 178927

		local thoughtsteal_remains = _debuffRemains("player",322464)

		meteor_in_flight = meteor_cd > 42
		meteor_in_flight_remains = (3 - ( 45 - meteor_cd )) - buffer

		local can_be_purged

		local enemies_on_player,enemy_melee_on_player,enemy_ranged_on_player,enemy_cds_on_player = EnemiesAttacking("player")

		player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")
		player_cast_target = UnitSpellTarget("player")
		player_cast_time_left = _castTimeLeft("player")
		player_cast_percent_complete = _castPctDone("player")
		player_interruptable = PlayerCanBeKicked()

		if tContains(sheep_ids,player_cast_id) then
			poly_cast_delay = time
			poly_cast_target = player_cast_target
		end

		if player_cast_id ~= 300728 then
			if door_of_shadows_pos then
				local _,_,_,_,startTime = unpack ( door_of_shadows_pos )
				if time - startTime > .15 then
					door_of_shadows_pos = nil
				end
			end
		elseif door_of_shadows_pos and player_cast_id == 300728 and player_cast_time_left <= buffer + .125 then

			local unit,x,y,z = unpack ( door_of_shadows_pos )

			if UnitIsVisible(unit) then
				local ux,uy,uz = ObjectPosition( unit )
				if GetDistanceBetweenPositions(x,y,z,ux,uy,uz) > 5 then
					Squid_Alert("Stop Casting","(Missed)",nil,nil,300728)
					SpellStopCasting()
				elseif _CCremains(unit) >= 2 then
					Squid_Alert("Stop Casting","(Overlap)",nil,nil,300728)
					SpellStopCasting()
				elseif _immuneMagic(unit) then
					Squid_Alert("Stop Casting","(Immune)",nil,nil,300728)
				end
			end

		end

		if player_cast_id == 113724 then
			ring_cast_delay = time
		end

		if player_cast_id == 203286 then
			gpy_cast_delay = time
		end

		--gui setting, disable movement stop for cc
		local move_setting = SQUID.stop_to_cc;

		local player_casting_non_cc = player_cast and not tContains(cc_casts,player_cast_id)
		local player_casting_cc = player_cast and tContains(cc_casts,player_cast_id)
		player_casting_sheep = player_cast and player_cast_id ~= 113724 and tContains(cc_casts,player_cast_id)

		local player_casting_crittable_damage = player_cast and tContains(crit_casts,player_cast_id)
		local player_casting_guaranteed_crit = player_cast and tContains(crit_casts,player_cast_id) and (combustion or (player_cast_id == 2948 and UnitIsVisible(player_cast_target) and _HP(player_cast_target) < 30 and IsPlayerSpell(269644)))

		--blazing barrier absorb
		local barrier,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID("player",235313)
		local barrier_remains = barrier and absorb or 0

		barrier,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID("player",11426)
		barrier_remains = barrier_remains + (barrier and absorb or 0)

		barrier,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID("player",235313)
		barrier_remains = barrier_remains + (barrier and absorb or 0)

		local player_effective_hp = (100 * (UnitHealth("player") + barrier_remains) / UnitHealthMax("player"));

		local sheeped_target
		local sheeped_target_duration = 0
		for i=1,#Enemies do
			local remains = sheep_remains(Enemies[i]) --, _debuffRemains(Enemies[i],82691,"player") )
			-- if _debuffRemains(Enemies[i],82691,"player") > remains then remains = _debuffRemains(Enemies[i],82691,"player") end
			if remains > 0 then
				sheeped_target = Enemies[i]
				sheeped_target_duration = remains
			end
		end

		if sheeped_target and SQUID.i_am_xen then
			-- Squid_Alert(UnitName(sheeped_target))
			-- print(sheeped_target_duration)
		end

		local their_healer = theirHealer
		local their_healer_cc
		local their_healer_cc_remains = 0
		local their_healer_incapacitate_dr
		local their_healer_incapacitate_dr_remains = 0
		local their_healer_disorient_dr
		local their_healer_disorient_dr_remains = 0
		local their_healer_important_lockout
		if their_healer then
			if not UnitIsDeadOrGhost(their_healer) then
				their_healer_cc_remains = _CCremains(their_healer)
				their_healer_cc = their_healer_cc_remains > 0
				their_healer_incapacitate_dr = _incapacitateDR(their_healer)
				their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
				their_healer_disorient_dr = _disorientDR(their_healer)
				their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

				local class = select(2,UnitClass(their_healer))

				local locked,remaining,school = UnitIsLocked(their_healer)

				if locked and remaining > .25 then
					if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
					or ( class == "SHAMAN" and school == "Nature" )
					or ( class == "PALADIN" and school == "Holy" )
					or ( class == "MONK" and school == "Nature" )
					or ( class == "DRUID" and school == "Nature" )  then
						their_healer_important_lockout = true
					end
				end
			else -- no healer if he dead
				their_healer = nil
			end
		end

		local function their_healer_can_dispel(unit,after)
			after = after or 0
			if not UnitIsVisible(their_healer) or not UnitIsVisible(unit) then return false end
			if unit_is_unit(unit,their_healer) then return false end
			local dispels = {
				["DRUID"] = 88423,	--Nature's Cure (Druid)
				["PALADIN"] = 4987,	--Cleanse (Paladin)
				["PRIEST"] = 527,	--Purify (Priest)
				["SHAMAN"] = 77130,	--Purify Spirit (Shaman)
				["MONK"] = 115450,	--Detox (Monk)
			}
			local class = select(2,UnitClass(their_healer))
			local cd = UnitCooldown(their_healer,dispels[class])
			if cd <= after and _distance(unit,their_healer) <= 48 and their_healer_cc_remains < poly_cast_time then
				return true
			end
		end

		if not their_healer then
			their_healer_cc = true
			their_healer_cc_remains = 100 - (lowestEnemy*1.5)
			their_healer_cc_remains = their_healer_cc_remains > 8 and 8 or their_healer_cc_remains
			their_healer_cc_remains = their_healer_cc_remains < 0 and 0 or their_healer_cc_remains
		end

		-- auto focus the best focus target
		if arena then
			if not UnitIsVisible(current_focus) or unit_is_unit(current_focus,current_target) then
				if their_healer and not unit_is_unit(their_healer,current_target) then
					FocusUnit(their_healer)
					Squid_Alert("Focusing Healer")
				elseif their_healer_hiding then
					-- do nothing
				else
					if UnitIsVisible(off_target) and not UnitIsDeadOrGhost(off_target) then
						FocusUnit(off_target)
						Squid_Alert("Focusing Off Target")
					end
				end
			end
		end

		-- for when the next cc defining max_cast_time is assigned to the healer
		local next_cc_is_healer
		local friendly_priest
		local friendly_feral
		local friendly_rogue

		for i=1,#Friends do
			local class = select(2,UnitClass(Friends[i]))
			--rog
			if class == "ROGUE" then
				friendly_rogue = Friends[i]
			--feral
			elseif class == "DRUID" and not _isHealer(Friends[i]) then
				friendly_feral = Friends[i]
			--priest
			elseif class == "PRIEST" then
				friendly_priest = Friends[i]
			end
		end

		local friendly_rogue_blind_cd
		if friendly_rogue then
			friendly_rogue_blind_cd = UnitCooldown(friendly_rogue,2094)
		end

		local our_healer
		local our_healer_cc
		local our_healer_cc_remains = 0
		if ourHealer then
			our_healer = ourHealer
			our_healer_cc_remains = _CCremains(ourHealer)
			our_healer_cc = our_healer_cc_remains > 0
		end

		-- enemy players count
		local enemy_players = 0
		for i=1,#Enemies do if unit_is_player(Enemies[i]) then
			enemy_players = enemy_players + 1
		end end

		-- team clone cast count
		local team_clone_cast = {}
		local team_hibernate_cast = {}
		for i=1,#Friends do
			local cast = UnitCastingInfo(Friends[i])

			if cast == "Cyclone" then
				local target = UnitSpellTarget(Friends[i])
				if target then
					team_clone_cast[target] = true
				end
			elseif cast == "Hibernate" then
				local target = UnitSpellTarget(Friends[i])
				if target then
					team_hibernate_cast[target] = true
				end
			end
		end

		-- print ( enemy_players )

		local not_moving_duration = 0

		if _isMoving("player") then
			not_moving_duration = 0
			last_move = time
		else
			if not last_move then last_move = time end
			not_moving_duration = time - last_move
		end

		local function meteor(unit,keypress)
			if meteor_cd > gcd then return false end
			local x,y,z = best_meteor_point(unit,keypress)
			if x and y and z then
				if player_casting_crittable_damage and meteor_cd == 0 and (not comubstion or player_cast_time_left > .5) then SpellStopCasting() end
				if _Cast(153561) then
					ClickPosition(x,y,z)
					_targetLastTarget()
					Squid_Alert("Meteor",nil,nil,nil,153561)
				end
				return true
			end
		end

		local function db(unit,alert)
			if poly_cast_delay and time - poly_cast_delay < .2 then return false end
			if ring_cast_delay and time - ring_cast_delay < .2 then return false end
			if _distance(unit) < 8.5 and _LoS(unit) and not breakable_cc_around(unit,8) then
				if db_cd == 0 then
					-- No db while casting
					if not UnitCastingInfo("player") then
						if player_has_control() then
							local f = ObjectFacing("player")
							local dir = GetAnglesBetweenObjects("player",unit)
							FaceDirection(dir,true)
							if Player_Facing(dir) then
								SQ_CastSpellByID(31661)
								FaceDirection(f,true)
								if alert == nil then
									Squid_Alert_Big("Dragon's Breath",UnitClass(unit),nil,nil,31661)
								end
								return true
							end
						end
					-- Stop cast to db
					elseif (player_cast_id == 2948 or player_cast_id == 133) then
						SpellStopCasting()
					end
				elseif db_cd <= gcd_remains + latency + .35 then
					return "wait"
				end
			end
		end

		function db_random()
			for i=1,#Enemies do if db(Enemies[i]) then Squid_Alert_Big("Dragon's Breath","(Pyroclasm!)",nil,nil,31661) return true end end
		end

		function Squid_DB(unit)
			return db(unit)
		end

		--Keybindz
		if blink_db_healer then
			if their_healer then
				if _CCremains(their_healer) < .75 then
					blink_db(their_healer)
					return
				else
					Squid_Alert("|cFFa665cdWaiting for Overlap","(Blink DB)",nil,nil,31661)
				end
			else
				local str = "|cFFa665cdHealer Not Found!"
				Squid_Alert(str,"(Blink DB)",nil,nil,31661)
			end
		end

		if blink_db_focus then
			if current_focus then
				if _CCremains(current_focus) < .75 then
					blink_db(current_focus)
					return
				else
					Squid_Alert("|cFFa665cdWaiting for Overlap","(Blink DB)",nil,nil,31661)
				end
			else
				local str = "|cFFa665cdFocus Not Found!"
				Squid_Alert(str,"(Blink DB)",nil,nil,31661)
			end
		end

		if blink_db_target then
			if current_target then
				if _CCremains(current_target) < .75 then
					blink_db(current_target)
					return
				else
					Squid_Alert("|cFFa665cdWaiting for Overlap","(Blink DB)",nil,nil,31661)
				end
			else
				local str = "|cFFa665cdTarget Not Found!"
				Squid_Alert(str,"(Blink DB)",nil,nil,31661)
			end
		end

		if meteor_key then
			if current_target then
				meteor(current_target,true)
			end
		end

		mage_next_cc_target = nil
		mage_next_cc_nooverride = nil
		mage_next_cc = nil
		mage_next_cc_dr = nil
		mage_next_cc_time = nil

		if _silenceCheck("player") then return end

		local bcc12 = _bccAM(12)

		local ttd = squid_ttd

		--db druid opener
		if _debuffRemains("player",50259) > 1.75 and  _debuffRemains("player",50259) < 1.955 then
			local source = select(7,UnitDebuffID("player",50259))
			if not UnitIsVisible(source) or _stealthCheck(source) or _disorientDR(source) == 1 then
				if not wildcharge_db or time - wildcharge_db > 5 then
					if player_has_control() then
						if _spellCooldown(31661) == 0 then
							local facing = ObjectFacing("player")
							FaceDirection(mod(facing + math.pi, math.pi * 2),true)
							CastSpellByID(31661)
							FaceDirection(facing)
							Squid_Alert("DB","(Druid Opener)",4,nil,31661)
							wildcharge_db = time
						end
					end
				end
			end
		end

		--nova cover imp
		if imp_exists then
			--sheep
			if player_casting_sheep then
				if _isHealer(player_cast_target) then
					if _spellCooldown(122) <= .3
					and _incapacitateDR(player_cast_target) == 1
					and not _rootImmuneCheck(player_cast_target)
					and _rootDR(player_cast_target) >= .5 then
						if _distance(player_cast_target) < 9 then
							if _Cast(122,nil,nil,nil,nil,true) then -- force queue
								Squid_Alert_Big("Nova " .. UnitClass(player_cast_target),"(Imp Cover)",1,nil,122)
							end
						elseif player_cast_time_left <= latency + .3 then
							--blink to them
							blink_to_unit(player_cast_target,8,true)
							Squid_Alert("Blink to " .. UnitClass(player_cast_target),"(Imp Cover)",nil,nil,212653)
						end
					end
				end
			end
			-- print("imp detected!!!")
		end

		--nova stealth
		if not bcc12 then
			for i=1,#Enemies do if _stealthCheck(Enemies[i]) and _distance(Enemies[i]) < 8 then
				if _Cast(122) then
					Squid_Alert_Big("Nova " .. UnitClass(Enemies[i]),"(Stealth)",1,nil,122)
				end
			end end
		end

		if self_reliance_stealth and not UnitBuffID("player",32727) then
			if _Cast(122) then
				Squid_Alert_Big("Nova","(Stealth Detected)",1,nil,122)
			end
		end

		--nova thing from beyond
		if not bcc12 and (not legendary_cloaked or time - legendary_cloaked > 4.5) and UnitDebuffID("player",319695) then
			for i=1,#things_from_beyond do
				local thing = things_from_beyond[i]
				if _realDistance(thing) < 11.25 then
					if _Cast(122) then
						Squid_Alert_Big("Frost Nova","(Thing From Beyond)",4,nil,122)
					end
				end
			end
		end

		if UnitAffectingCombat("player") and UnitCastingInfo("player") == "Pyroblast" and _castTimeLeft("player") > .75 and pyroclasm_remains < (player_cast_id == 11366 and player_cast_time_left or _castTime(11366)) then
			SpellStopCasting()
			Squid_Alert("Stopcasting","(Hardcasting Pyro)",nil,nil,11366)
		end

		local mage_stop_moving

		if IsMounted() or IsFlying() or UnitBuffID("player",66) or UnitBuffID("player",32612) or UnitBuffID("player",45438) or UnitBuffID("player",110960) or not player_has_control() then return end --32612

		local t=current_target

		-- local function _valid(unit,immune)
		-- 	if not unit or not UnitExists(unit) then return false end
		-- 	if UnitIsDead(unit) or UnitIsDeadOrGhost(unit) then return false end
		-- 	return UnitCanAttack("player",unit)
		-- 	and not UnitIsFriend("player",unit)
		-- 	and not _breakableCC(unit)
		-- 	and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
		-- 	and ((arena and unit_is_player(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or unit_is_player(unit))));
		-- end

		local m_i_r = t and magic_immunity_remains(t,true) or 0

		local target_dist = _distance(t)

		local function valid_magic(after,unit)

			if not unit then unit = t end
			if not unit then return false end
			if not UnitIsVisible(unit) then return false end

			if UnitIsDeadOrGhost(unit) then return false end

			if arena and not unit_is_player(unit) then return "pet" end

			if not arena and not UnitAffectingCombat(unit) and not _isDummy(unit) and not unit_is_player(unit) then return false end

			if UnitCanAttack("player",unit)
			and (not _breakableCC(unit) or not arena and not unit_is_player(unit))
			and (unit == t and m_i_r <= after or magic_immunity_remains(unit,true) <= after) then
				return true
			end

		end

		if t and UnitBuffID(t,53480) then
			Squid_Alert_Big("Target has RoS","(Switch Targets)",2,nil,53480)
		end

		local target_hp = _HP(t)
		local target_absorbs = 0
		local target_effective_hp = 100

		if UnitIsVisible(t) then
			target_absorbs = UnitGetTotalAbsorbs(t)
			target_effective_hp = (100 * (UnitHealth(t)+target_absorbs) / UnitHealthMax(t))
		end

		--magic defensive remains
		local MDR = valid_magic(0) and magic_defensive_remains(t) or 0

		local active_enemies = t and Enemies_Around_Unit(t,10) + 1 or 0

		local current_cast = UnitCastingInfo("player")

		--engage load mode when the enemy team is locked down
		local load_mode = valid_magic(0) and ( ( their_healer and ( their_healer_cc_remains > 0 or their_healer_important_lockout ) ) or combustion_remains > 0 or _stunRemains(t) > 0 or target_effective_hp < 30 * ((their_healer or not arena) and 1 or SQUID.cap_bot and 3 or 2.3) or unit_is_unit(their_healer,t) and target_effective_hp < 55 + ( ( _stunCheck(t) or _drRemains(t,"stun") > 15 ) and 35 or 0 ) + (SQUID.cap_bot and 25 or 0) )

		--engage load mode when burst mode is forced
		if Squid_Burst then load_mode = true end

		local load_target = valid_magic(0) and ( _stunCheck(t) or _HP(t) < 30 * ( their_healer_cc and 2.5 or 1 ) )

		--disable load mode when the enemy trades a defensive, unless already stunned or combusting
		if load_mode and _stunRemains(t) == 0 and combustion_remains == 0 then

			--not wasting this precious load on your magic defenses
			if MDR > 0 then
				load_mode = nil
			end

		end

		load_mode_active = load_mode

		--auto burst
		if SQUID.auto_mage_burst then
			if load_mode then
				--no healer
				if not their_healer then
					if valid_magic(0) and _LoS(t) and ( _stunRemains(t) > 2.5 or _HP(t) < 25 and select(2,GetUnitSpeed(t)) < 4 ) then
						SquidBurst()
					end
				--healer
				else
					if their_healer_cc_remains > 5.8 and valid_magic(0) and _LoS(t) and ( _stunRemains(t) > 1 or _HP(t) < 85 and select(2,GetUnitSpeed(t)) < 4.5 ) then
						SquidBurst()
					end
				end
			end
		end

		local function phoenix_flames(unit)
			if not phoenix_flames_enabled then return false end
			if phoenix_flames_charges == 0 then return false end
			if fire_lockout > gcd_remains then return false end
			if arena and not unit_is_player(unit) then return false end
			local total,bcc = Enemies_Around_Unit(unit,13.5)
			if bcc == 0 and not player_casting_cc then
				if _amIfacing(unit) and _LoS(unit) then
					SQ_CastSpellByID(257541,unit)
					return true
				end
			end
		end

		Squid_Meteor = meteor

		local function cc(unit,player_forced,offtarget)

			if not arena and not unit_is_player(unit) and not player_forced then return 69 end

			--stop if no unit
			if not unit or not UnitIsVisible(unit) then return 69 end

			--do not sheep? (ext. func)
			if DoNotSheep(unit) then return 69 end

			--dist to unit
			local dist = _distance(unit)

			local immunity_remains = max( magic_immunity_remains(unit), cc_immunity_remains(unit), _buffRemains(unit,48707) )

			--this function should not only cc, but also return the time until cc needs to happen
			--this is to keep it from starting casts that will get in the way of getting perfect cc on dr
			local time_to_cc = 0

			--druid?
			local is_druid = select(2,UnitClass(unit)) == "DRUID"

			--check root
			local root = ( not is_druid and _rootRemains(unit) or 0 )

			--check cc
			local ccr = _CCremains(unit)
			local cc = ccr > 0

			--incap drs
			local idr = _incapacitateDR(unit)
			local idr_remains = _drRemains(unit,"incapacitate")

			--disorient drs
			local ddr = _disorientDR(unit)
			local ddr_remains = _drRemains(unit,"disorient")

			--sheep immunities. beast or dummy is all i can think of right now. added in Moonkin Form for resto
			local immune_sheep = _isBeast(unit) or _isDummy(unit) or UnitBuffID(unit, 197625)

			--meteor?
			local standing_in_meteor = UnitDebuffID(unit,155158)

			--yea dont cc into it
			if standing_in_meteor then return 69 end

			--banner?
			local banner = UnitBuffID(unit,236321)

			--remaining shep
			local sheep_remains = sheep_remains(unit)

			--yea dont cc into it...unless
			if banner then return 69 end

			--incap on unit?
			local incap = _incapacitateCheck(unit)

			--healer?
			local is_healer = _isHealer(unit)

			--lockout? (only important lockout...)
			-- local lockout = IsLocked(unit,true)
			local locked,lockout_remaining,school = UnitIsLocked(unit)

			local important_lockout_remaining = 0
			if locked and lockout_remaining > 0 then
				if ( class == "PRIEST" and school == "Shadow" )
				or ( class == "SHAMAN" and school == "Nature" )
				or ( class == "PALADIN" and school == "Holy" )
				or ( class == "MONK" and school == "Nature" )
				or ( class == "DRUID" and school == "Nature" )
				or ( class == "MAGE" and school == "Arcane" )
				or ( class == "WARLOCK" and school == "Shadowflame" ) then
					important_lockout_remaining = lockout_remaining
				end
			end

			--los?
			local los = _LoS(unit)
			local time_los = time_in_los(unit)

			--charmed friend?
			local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

			if friendly then return 69 end

			local bleeds = bleeds_around(unit,9)

			--door of shadows disorient
			local time_til_dos_ready = 69
			-- if immunity_remains == 0 and conduit_taken(331576) and (not friendly_rogue or friendly_rogue_blind_cd > 16 - bin(lowestEnemy<40)*5) and (not friendly_priest or _distance(friendly_priest,unit) > 12) and (not _isMoving(unit) or ccr > 0) then
			-- 	local dos_cast_time = _castTime(300728)
			-- 	if not immune_sheep or ring_enabled and ring_cd < buffer+dos_cast_time then
			-- 		local sheep_dr_ready = idr == 1 or ( idr >= .5 and idr_remains > 17.25 - (cc and 6 * idr or 0) - ((100-lowestEnemy) * .038) ) or idr_remains < gcd + poly_cast_time
			-- 		local dos_ready = _spellCooldown(300728) == 0
			-- 		if (sheep_dr_ready or ccr > dos_cast_time and ccr < dos_cast_time + buffer*2) and (is_healer or not their_healer and not their_healer_hiding) and ccr < dos_cast_time + buffer*2 then
			-- 			if _spellCooldown(300728) == 0 then
			-- 				local ring_ready = ring_cd < gcd
			-- 				--delay dragon's breath when druid is in form, and no ring available
			-- 				if bleeds then
			-- 					Squid_Alert("Delaying DoS","(Bleeds)",nil,5,300728)
			-- 				elseif immune_sheep and not ring_ready and lowestEnemy > 65 then
			-- 					-- don't do it mane
			-- 				else
			-- 					if not team_clone_cast[unit] and (current_target and magic_immunity_remains(current_target) <= buffer + .25 + dos_cast_time) then
			-- 						door_of_shadows(unit)
			-- 					end
			-- 				end
			-- 				mage_next_cc = 300728
			-- 				mage_next_cc_time = 0
			-- 			end
			-- 		end
			-- 		time_til_dos_ready = dist < 32 and los and max((ccr < dos_cast_time or ccr > dos_cast_time + buffer*2) and idr_remains or 0,_spellCooldown(300728),ccr,ddr_remains) or 69 --may need fix vs druids
			-- 	end
			-- end

			--db druids out of form, and before drs in order to sheep. may need some
			--alternative in the future to hold casts while waiting for a druid to leave form.
			local time_til_db_ready = 69
			if immunity_remains == 0 and (not friendly_rogue or friendly_rogue_blind_cd > 18 - bin(lowestEnemy < 30)*6) and (not friendly_priest or _distance(friendly_priest,unit) > 13) then
				if not immune_sheep or ring_enabled and ring_cd < gcd+buffer then    --less restrictive dr checks when continuing cc chain / dr coming back up in the time it takes to db+sheep
					local sheep_dr_ready = idr == 1 or ( idr >= .25 and idr_remains > 17.25 - (cc and 6 * idr or 0) - ((100-lowestEnemy) * .038) ) or idr_remains < gcd + poly_cast_time
					local db_ready = db_cd <= gcd and dist < 6.5 and ccr < gcd and ddr == 1
					if sheep_dr_ready and db_ready and (is_healer or not their_healer and not their_healer_hiding) then
						local ring_ready = ring_cd < gcd
						--delay dragon's breath when druid is in form, and no ring available
						if immune_sheep and not ring_ready then
							Squid_Alert("Delaying DB","(Shapeshift)",nil,5,31661)
							--attempt to force druid out of form with a frost nova
							if not bcc12 and _Cast(122) then
								Squid_Alert_Big("Frost Nova","(Force Shift)",nil,nil,122)
							end
						else
							if not team_clone_cast[unit] and (current_target and magic_immunity_remains(current_target) <= buffer + .25) then
								--execute the db
								db(unit)
							end
						end
						mage_next_cc = 31661
						mage_next_cc_time = 0
					end
					time_til_db_ready = dist < 6.5 and max(idr_remains,db_cd,ccr,ddr_remains) or 69 --may need fix vs druids
				end
			end

			--ring to followup cc, if the unit is a beast, or we are locked on sheep
			local time_til_ring_ready = 69
			if immunity_remains <= ring_cast_time and (not ring_cast_delay or time - ring_cast_delay > .08) and (not poly_cast_delay or time - poly_cast_delay > .175 or arcane_lockout > 0) and (not UnitDebuffID(unit,33786) or (_debuffRemains(unit,33786) < ring_cast_time and _debuffRemains(33786) > ring_cast_time-(buffer*1.5))) then
				if ( idr >= .5 or lowestEnemy < 15 and idr >= .25 ) and ( idr == 1 or idr_remains > 16 or not incap and idr_remains > 8 and lowestEnemy < 55 ) then
					if arcane_lockout > 0 or immune_sheep or max( ccr, root ) > ring_cast_time - buffer or (sheeped_target and not unit_is_unit(unit,sheeped_target)) then
						local poly_cast_time_extra = poly_cast_time + buffer
						local max_overlap = ring_cast_time + ( buffer*2.65 ) + ( player_interruptable and ( not combustion or idr == 1 ) and idr >= .5 and poly_cast_time_extra + 1 or 0 ) + .1 + ( not incap and .25 or 0 ) --arcane_lockout < ring_cast_time and
						local ring_ready = ring_enabled and ring_cd <= gcd and max( ccr, root ) > ring_cast_time-buffer and ccr <= max_overlap and (idr == 1 or (not los or arcane_lockout > gcd_remains or player_interruptable) and idr >= .5)

						if ring_ready and dist < ring_range then
							--alert when moving, stop casting scorch when not
							local can_ring = ring_of_frost(unit)
							if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Ring)",nil,.5,113724)
							elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
							mage_stop_moving = {unit=unit, dist=ring_range}
							time_to_cc = 0
							if not mage_next_cc then
								mage_next_cc = 113724
							end
							mage_next_cc_time = 0
						end

						time_til_ring_ready = ccr > ring_cast_time + buffer and dist < ring_range and max(ring_cd,ccr,idr == 1 and 0 or idr == .5 and arcane_lockout > gcd_remains and 0 or idr_remains) or 69
					end
				end
			end

			local sheeped_and_dispellable = sheep_remains > 4 + poly_cast_time and their_healer_can_dispel(unit,poly_cast_time - buffer)

			--sheep, if drs are available, and the unit is not immune
			local time_til_poly_ready = 69
			local max_overlap = poly_cast_time + (buffer*2.55) + (player_interruptable and idr >= .5 and ( ring_cd <= gcd or SQUID.auto_juke ) and ring_cast_time + buffer + ( SQUID.auto_juke and buffer or 0 ) or 0) -- + (idr >= .5 and ring_cd < gcd and ccr > ring_cast_time and ring_cast_time or 0)
			if los and (not ring_cast_delay or time - ring_cast_delay > .3 or ring_cd > gcd_remains) and (not poly_cast_delay or time - poly_cast_delay > .125 or sheeped_and_dispellable ) then --no sheep into lockout, unless they're casting another school
				if (not immune_sheep or team_hibernate_cast[unit]) and (important_lockout_remaining <= poly_cast_time + 1.5 + (buffer*2.5) + (player_interruptable and poly_cast_time or 0) or UnitCastingInfo(unit)) then -- need better logic here to determine if the lockout is worth sheeping over, cause it often is.

					local sheep_dr_ready = idr == 1 or (idr >= .25 and idr_remains > 17.45 - (ccr >= poly_cast_time and 8 * idr or 0) - (incap and ccr >= poly_cast_time-.2 and 6 * idr or 0) - ((100-lowestEnemy) * .038) - (offtarget and idr >= .5 and 2 or 0) + (idr == .25 and 2 or 0) ) or ( idr_remains < poly_cast_time-(buffer/2) and ( idr_remains ~= 0 or idr == 1 ) )

					-- print(sheep_dr_ready, idr, idr_remains)
					-- local sheep_time_til_ready = idr == 1 and ccr or (idr >= .25 and idr_remains > 17 - (ccr > 1 and 6 * idr or 0)) and ccr or idr_remains
					local no_sheeps_out = not sheeped_target or unit_is_unit(unit,sheeped_target) or _incapacitateDR(sheeped_target) < .25 or (is_healer and idr == 1 and not _isHealer(sheeped_target)) --or (not _isHealer(sheeped_target) and _incapacitateDR(sheeped_target) <= .5 and _drRemains(sheeped_target,"incapacitate") > 3 and _drRemains(sheeped_target,"incapacitate") < 16.5)
					if sheep_dr_ready and no_sheeps_out then

						if dist < sheep_range and ( ccr < max_overlap or sheeped_and_dispellable ) then
							if thoughtsteal_remains == 0 then
								if arcane_lockout <= buffer then
									if immunity_remains <= poly_cast_time+latency+msperframe-.03 then -- extra 30 ms window
										--alert when moving, stop casting scorch when not
										if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Sheep)",nil,.5,sheep)
										elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
										if time_los >= 1 then
											mage_stop_moving = {unit=unit, dist=ring_range}
										end
										if (not poly_cast_delay or time-poly_cast_delay > .2) and _Cast(sheep,unit) then
											if team_hibernate_cast[unit] then
												Squid_Alert("Sheep + Hibernate",UnitClass(unit),nil,3,sheep)
											else
												Squid_Alert("Sheeping",UnitClass(unit),nil,3,sheep)
											end
										end
										time_to_cc = 0
										if not mage_next_cc then
											mage_next_cc = 118
										end
										mage_next_cc_time = 0
									end
								else
									time_to_cc = max(arcane_lockout,time_to_cc)
								end
							else
								time_to_cc = max(thoughtsteal_remains,time_to_cc)
							end
						else
							time_to_cc = max(ccr,time_to_cc)
						end

						local immune_val = 0
						if immunity_remains > 0 then
							immune_val = max ( immunity_remains - poly_cast_time - (buffer * .45), 0 )
						end

						time_til_poly_ready = dist < sheep_range and max(ccr-max_overlap,idr_remains < 17 and idr_remains or 0,arcane_lockout,immune_val,thoughtsteal_remains) or 69 -- "never" if out of range (applied to ring too)

						if immune_sheep and not is_healer then time_til_poly_ready = 69 end

					end
				end
			end

			local this_unit_dos
			if door_of_shadows_pos then
				local dosunit = unpack ( door_of_shadows_pos )
				if unit_is_unit(unit, dosunit) then this_unit_dos = true end
			end

			--db when drs are available, or to continue cc chain, and we are in range
			if (not friendly_priest or _distance(friendly_priest,unit) > 13) and not SQUID.i_am_xen and not this_unit_dos then
				if immunity_remains == 0 and (not friendly_rogue or friendly_rogue_blind_cd > 18) then
					if idr == 1 or idr_remains > 17 or lowestEnemy < 33 + (combust and 15 or 0) + (not is_druid and 30 or 0) then
						local db_ready = db_cd <= gcd and dist < 9.25 and ccr < gcd and ddr == 1 and (not poly_cast_delay or time-poly_cast_delay > .1 or not unit_is_unit(poly_cast_target,unit))
						if db_ready and is_healer and not immune_sheep and los then
							if ccr < gcd_remains + buffer + .1 then
								if not team_clone_cast[unit] then
									db(unit)
								end
							else
								time_to_cc = max(ccr,time_to_cc)
							end
							if not mage_next_cc then
								mage_next_cc = 31661
							end
						end
						time_til_db_ready = is_healer and dist < 8.5 and max(idr_remains,db_cd,ccr,ddr_remains) or 69
					end
				end
			end

			local val = math.min(time_til_db_ready,time_til_ring_ready,time_til_poly_ready,time_til_dos_ready)

			if val < greater_pyro_cast_time then

				if arcane_lockout > gcd and (ring_cd > greater_pyro_cast_time or max(root, ccr) < ring_cast_time-buffer) and (dist > 8.25 or db_cd > gcd_remains or ddr < 1 or idr <= .25 and lowestEnemy > 40) then

					val = greater_pyro_cast_time + .5

				end

			end

			--next cc unit used for drawings
			mage_next_cc_target = unit

			--default to sheep if no other cc defined above
			if not mage_next_cc then mage_next_cc = 118 end

			--display dr
			if mage_next_cc == 118 or mage_next_cc == 113724 then
				mage_next_cc_dr = idr
				mage_next_cc_time = val >= 69 and idr_remains or val
			else
				mage_next_cc_dr = ddr
				mage_next_cc_time = val >= 69 and ddr_remains or val
			end

			return val

		end

		local function only_ripped_target(unit)
			-- check if unit is the only enemy with rip applied, this means never sheep it because it is the kill target
			local unit_ripped = UnitDebuffID(unit,1079)
			if not unit_ripped then return false end
			local rips_up = 0
			for i=1,#Enemies do
				if UnitDebuffID(Enemies[i],1079) then
					rips_up = rips_up + 1
				end
			end
			if rips_up == 1 or SQUID.cap_bot then
				return true
			end
		end

		--designate highest prio to cc on healer (returning 69 will fall back to off dps cc)
		local function healer_cc()

			local healers = {}

			for i=1,#Enemies do if _isHealer(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) then
				local unit = Enemies[i]
				if _distance(unit) < sheep_range then
					local friends_attacking = UnitEnemiesAttacking(unit)
					local unit_hp = _HP(unit)
					if friends_attacking == 0 and not only_ripped_target(unit) then
						table.insert(healers,unit)
					end
				end
			end end

			local soonest = 69
			for i=1,#healers do
				local val = cc(healers[i])

				if val < soonest then
					soonest = val
				end

			end

			return soonest + .05

		end

		--cc off dps while waiting for dr on healer, or to secure cc on healer while they have interrupts available
		local function off_cc()

			if only_cc_healers then return 69 end

			local units = {}

			for i=1,#Enemies do
				local e = Enemies[i]
				if unit_is_player(e) then--or (UnitIsHunterPet(e) and combustion_cd <= 2) then
					if not unit_is_unit(e,current_target) and _distance(e) < sheep_range and _LoS(e) and not only_ripped_target(e) then
						local friends_attacking = UnitEnemiesAttacking(e)
						local unit_hp = _HP(e)
						if friends_attacking == 0 then
							local min_hp = 70
							min_hp = min_hp - (our_healer_cc and 20 or 0)
							min_hp = min_hp - (_CDcheck(e) and 20 or 0)
							min_hp = min_hp - (lowestFriend < 40 and 20 or 0)
							if unit_hp > min_hp then
								table.insert(units,e)
							end
						end
					end
				end
			end

			local soonest = 69
			for i=1,#units do
				local val = cc(units[i],nil,true) -- looser remaining incap dr on off targets

				if val < soonest then
					soonest = val
				end
			end

			return soonest

		end

		-- local function priority_cc()

		-- 	local player_exists

		-- 	for i=1,#Enemies do if unit_is_player(Enemies[i]) then player_exists = true end end

		-- 	if not arena and not player_exists then return 69 end

		-- 	--healer
		-- 	local unit = their_healer

		-- 	--focus target if there is no healer
		-- 	if not unit then unit = current_focus end

		-- 	if unit_is_unit(unit,current_target) then
		-- 		unit = current_focus
		-- 	end

		-- 	local idr
		-- 	local idr_r
		-- 	if unit then
		-- 		idr = _incapacitateDR(unit)
		-- 		idr_r = _drRemains(unit,"incapacitate")
		-- 	end

		-- 	if unit_is_unit(unit,current_target) then
		-- 		--off target
		-- 		for i=1,#Enemies do if unit_is_player(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) and _distance(Enemies[i]) <= 39 and _LoS(Enemies[i]) then
		-- 			unit=Enemies[i]
		-- 			break
		-- 		end end
		-- 	else
		-- 		if unit then
		-- 			if idr < .25 or ( idr_r > 3 and idr_r < 15 ) or _distance(unit) > 39 or (not _LoS(unit) and ring_cd > gcd) then
		-- 				--off target
		-- 				for i=1,#Enemies do if unit_is_player(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) and _distance(Enemies[i]) <= 39 and _LoS(Enemies[i]) then
		-- 					unit=Enemies[i]
		-- 					break
		-- 				end end
		-- 			end
		-- 		end
		-- 	end

		-- 	--someone on team is attacking?
		-- 	if unit then
		-- 		local friends_attacking = UnitEnemiesAttacking(unit)
		-- 		if friends_attacking > 0 then
		-- 			local temp_unit = unit
		-- 			unit = nil
		-- 			--off target
		-- 			for i=1,#Enemies do if unit_is_player(Enemies[i]) and not unit_is_unit(Enemies[i],temp_unit) and not unit_is_unit(Enemies[i],current_target) and _distance(Enemies[i]) <= 39 and _LoS(Enemies[i]) and (_incapacitateDR(Enemies[i]) >= .5 or _drRemains(Enemies[i],"incapacitate") <= 1) then
		-- 				unit=Enemies[i]
		-- 				break
		-- 			end end
		-- 		end
		-- 	end

		-- 	--stop function if no viable cc target
		-- 	if not unit then return 69 end

		-- 	if unit and UnitIsDeadOrGhost(unit) then return 69 end

		-- 	return cc(unit)

		-- end

		local function kill(unit)

			if not unit then return end

			local m_i_r = magic_immunity_remains(unit)
			local idr = _incapacitateDR(unit)
			local ddr = _disorientDR(unit)
			local ccr = _CCremains(unit)
			local hp = _HP(unit)
			local d = _distance(unit)
			local idr_remains = _drRemains(unit,"incapacitate")

			-- good incap dr
			if idr >= .5 and not gpy_flying then
				if hp > 60 and idr == 1 and m_i_r < poly_cast_time and ccr < poly_cast_time + buffer then
					-- sheep target if hp is higher than it would be after 1 gpy
					if (not poly_cast_delay or time - poly_cast_delay > .15) and (not ring_cast_delay or time - ring_cast_delay > .25) then
						_Cast(sheep,unit)
					end
				elseif ( db_cd <= gcd and ddr == 1 and ( d < 8.25 or blink_cd == 0 ) or ring_cd <= gcd_remains + ccr and ccr > ring_cast_time - buffer and ( ccr < greater_pyro_cast_time - ( buffer * 2 ) or gpy_flying ) ) then
					-- db > ring target if target hp is low
					if ccr <= buffer and (not ring_cast_delay or time - ring_cast_delay > .25) and ring_cd <= gcd then
						blink_db(unit)
					elseif ccr > ring_cast_time - buffer and ( ccr < ring_cast_time + buffer + (UnitDebuffID(unit,31661) and .25 or 0) ) then
						ring_of_frost(unit)
					end
				elseif idr == 1 then
					-- sheep target anyway if not close enough to db
					if (not poly_cast_delay or time - poly_cast_delay > .1) and (not ring_cast_delay or time - ring_cast_delay > .25) then
						_Cast(sheep,unit)
					end
				end
			end

			-- if casting gpy where target is in cc for the entire duration of the cast, blink to make distance ( 15-25 yd ) for a meteor that will hit simultaneously with gpy

			-- cast gpy into cc that remains > gpy cast time - a bit
			if ccr > greater_pyro_cast_time - ( buffer * 4 ) and (not gpy_flying and (not gpy_cast_delay or time - gpy_cast_delay > buffer) or ring_cd > ccr + ring_cast_time)  then--(not gpy_flying or _debuffRemains(unit,82691) > max ( greater_pyro_cast_time - ( buffer * 3 ), 0 ) and gpy_est_hit_time and gpy_est_hit_time - time < buffer)  then
				_Cast(203286,unit,nil,true)
			end

			-- ring if gpy is flying and target is in cc long enough
			if gpy_flying and ccr > ring_cast_time - buffer and ( gpy_est_hit_time and gpy_est_hit_time - time < ring_cast_time + buffer and gpy_est_hit_time - time > ring_cast_time - ( buffer * 1.5 ) ) then
				ring_of_frost(unit)
			end

			-- blink to target if gpy is flying, db is ready, and ring is not ready or cc remains not long enough for a ring
			if player_cast_id ~= 82691 and player_cast_id ~= 203286 and ( idr <= .5 or ring_cd <= gcd ) then
				if db_cd <= gcd and ( ring_cd > gcd or ccr < ring_cast_time - buffer and idr < 1 and not gpy_flying ) and ( not ring_cast_delay or time - ring_cast_delay > .2 ) then
					if not gpy_est_hit_time and ccr < gcd or gpy_est_hit_time and min ( _debuffRemains(unit,82691), gpy_est_hit_time - time ) < gcd then
						if not gpy_est_hit_time and ccr > buffer * 2 or gpy_est_hit_time and gpy_est_hit_time - time > buffer * 2 then
							blink_to_db(unit)
						else
							if not gpy_est_hit_time and ccr <= buffer or gpy_est_hit_time and max( ccr, gpy_est_hit_time - time ) <= buffer * 2 then
								blink_db(unit)
							end
						end
					end
				end
			end

			if not ring_cast_delay or time - ring_cast_delay > .45 then
				-- db as gpy hits / meteor falls on target out of ring, or if ring is avail
				if ( meteor_cd <= gcd or meteor_in_flight ) and idr <= .5 and idr_remains > 13.5 and (not gpy_est_hit_time and ccr < buffer or gpy_est_hit_time and max(gpy_est_hit_time - time, ccr) < buffer or meteor_in_flight) then
					blink_db(unit)
				end
				-- meteor on cc'd target
				if max(db_cd,blink_cd) > gcd_remains + buffer or d > 8.25 then
					if ( ( ccr > 0 or ( db_cd > gcd or idr <= .25 and gpy_flying ) and ring_cd > gcd ) and idr <= .25 + (UnitDebuffID(unit,82691) and .25 or 0) or ( ring_cd > gcd and _debuffRemains(unit,31661) > 0 and ( _debuffRemains(unit,82691) <= 1.25 or gpy_est_hit_time and gpy_est_hit_time - time < 2.5 ) ) ) and ( ccr < greater_pyro_cast_time - ( buffer * 2.5 ) or gpy_est_hit_time and gpy_est_hit_time - time < 2.5 ) then
						if not gpy_flying or gpy_est_hit_time and gpy_est_hit_time - time < buffer or idr <= .25 or db_cd > gcd then
							meteor(unit)
						end
					end
				end
			end

		end

		if killshot_key then--or ( SQUID.cap_bot and valid_magic(0) and _incapacitateDR(current_target) >= .5 + (db_cd > gcd and .5 or 0) and IsPlayerSpell(203286) and ring_cd <= gcd and enemy_players == 1 and UnitEnemiesAttacking(current_target) == 0 ) or killshot_engaged and time - killshot_engaged < 6 then
			kill(current_target)
			Squid_Alert("Killshot Enabled")
			if not killshot_key then
				if not killshot_engaged or time - killshot_engaged > 6 then
					killshot_engaged = time
				end
			end
			if not killshot_engaged or time - killshot_engaged < 6 then
				return
			end
		end

		if killshot_engaged and time - killshot_engaged > 6 then killshot_engaged = nil end
		if killshot_engaged and (ring_cd > gcd or db_cd > gcd) and ( current_target and not _CCcheck(current_target) ) then killshot_engaged = nil end

		local function priority_shit(max_cast_time)

			local target_stun = UnitExists(t) and _stunRemains(t) or 0

			if UnitExists(t) and _isDummy(t) then target_stun = 10 end

			--badge w/ combust
			if combustion or meteor_in_flight then

				local race = UnitRace("player")

				if race == "Orc" then
					SQ_CastSpellByName("Blood Fury")
				end

				if UnitBuffID("player",313948) then
					RunMacroText("/cancelaura Manifesto of Madness: Chapter One")
					Squid_Alert( "Manifesto of Madness", "(CANCEL)", nil, nil, 313948 )
				end

				if tContains( equipped_items, 161377 ) and GetItemCD ( ( 161377 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 161377 ) ) )
					Squid_Alert( "Azurethos' Singed Plumage", nil, nil, nil, 278383 )
				end

				if ( tContains( equipped_items, 167380 ) and GetItemCD ( ( 167380 ) ) == 0 )
				or ( tContains( equipped_items, 172669 ) and GetItemCD ( ( 172669 ) ) == 0 )
				or ( tContains( equipped_items, 165058 ) and GetItemCD ( ( 165058 ) ) == 0 )
				or ( tContains( equipped_items, 175884 ) and GetItemCD ( ( 175884 ) ) == 0 )
				or ( tContains( equipped_items, 175921 ) and GetItemCD ( ( 175921 ) ) == 0 ) then
					UseItemByName( tostring( GetItemInfo ( 167380 ) ) )
					UseItemByName( tostring( GetItemInfo ( 172669 ) ) )
					UseItemByName( tostring( GetItemInfo ( 165058 ) ) )
					UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
					UseItemByName( tostring( GetItemInfo ( 175921 ) ) )
					Squid_Alert( "Gladiator's Badge", nil, nil, nil, 277185 )
				end

				if ( tContains( equipped_items, 172666 ) and GetItemCD ( ( 172666 ) ) == 0 )
				or ( tContains( equipped_items, 167377 ) and GetItemCD ( ( 167377 ) ) == 0 )
				or ( tContains( equipped_items, 165055 ) and GetItemCD ( ( 165055 ) ) == 0 ) then
					UseItemByName( tostring( GetItemInfo ( 172666 ) ) )
					UseItemByName( tostring( GetItemInfo ( 167377 ) ) )
					UseItemByName( tostring( GetItemInfo ( 165055 ) ) )
					Squid_Alert( "Gladiator's Medallion", nil, nil, nil, 277179 )
				end

				if tContains( equipped_items, 159630 ) and GetItemCD ( ( 159630 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 159630 ) ) )
					Squid_Alert( "Balefire Branch", nil, nil, nil, 268999 )
				end

				if tContains( equipped_items, 169318 ) and GetItemCD ( ( 169318 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 169318 ) ) )
					Squid_Alert( "Shockbiter's Fang", nil, nil, nil, 303953 )
				end

				if tContains( equipped_items, 161411 ) and GetItemCD ( ( 161411 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 161411 ) ) )
					Squid_Alert( "T'zane's Barkspines", nil, nil, nil, 278227 )
				end

				if ( tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 )
				or ( tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 ) then
					UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
					UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
					Squid_Alert( "Knot of Wisdom", nil, nil, nil, 278267 )
				end

				if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
					Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
				end

				if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
					Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
				end

				if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
					Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
				end

			end

			--even healers on your team (if you're playing a caster comp) should be stunning your kill target on goes, securing a clean 50k meteor.
			local stun_classes = {
			"ROGUE",
			"DRUID",
			"PALADIN",
			"WARRIOR",
			"DEATHKNIGHT",
			"DEMONHUNTER",
			"MONK",
			}

			local stuns_on_team
			for i=1,#Friends do
				if tContains(stun_classes,select(2,UnitClass(Friends[i]))) then
					stuns_on_team = true
				end
			end

			if not _stealthCheck("player") then

				--klepto
				-- if klepto_enabled and valid_magic(0) and should_klepto(t) and max_cast_time >= gcd then
				-- 	if _Cast(30449,t,nil,true) then
				-- 		Squid_Alert_Big("Klepto",UnitClass(t),1,nil,30449)
				-- 	end
				-- end

				--blink feral frenzy
				if _debuffRemains("player",274838) > 5.5 then
					if not player_blink or time - player_blink > 2.5 then
						if _Cast(212653) then
							Squid_Alert("Blink","(Feral Frenzy)",4,nil,212653)
						end
					end
				end

				--db fists
				for i=1,#Enemies do
					local e = Enemies[i]
					local channel,_,_,_,endtime,_,_,spellID = UnitChannelInfo(e)
					if channel then
						if spellID == 113656 and _disorientDR(e) >= .25 then
							if endtime and endtime/1000 >= time + 1.25 then
								if not breakable_cc_around(e,10) then
									if db(e,false) then
										Squid_Alert("Dragon's Breath","(Fists of Fury)",4,nil,31661)
									end
								end
							end
						end
						if spellID == 323764 and _disorientDR(e) >= .25 then
							if endtime and endtime/1000 >= time + 1 then
								if not breakable_cc_around(e,10) then
									if db(e,false) then
										Squid_Alert("Dragon's Breath","(Convoke the Spirits)",4,nil,31661)
									end
								end
							end
						end
					end
				end

				--pve rune of power &amp; combust
				-- actions+=/rune_of_power,if=talent.firestarter.enabled&amp;firestarter.remains>full_recharge_time|cooldown.combustion.remains>variable.combustion_rop_cutoff&amp;buff.combustion.down|target.time_to_die<cooldown.combustion.remains&amp;buff.combustion.down
				-- actions+=/call_action_list,name=combustion_phase,if=(talent.rune_of_power.enabled&amp;cooldown.combustion.remains<=action.rune_of_power.cast_time|cooldown.combustion.ready)&amp;!firestarter.active|buff.combustion.up
				-- actions.bm_combustion_phase+=/combustion,use_off_gcd=1,use_while_casting=1,if=azerite.blaster_master.enabled&amp;((action.meteor.in_flight&amp;action.meteor.in_flight_remains<0.2)|!talent.meteor.enabled|prev_gcd.1.meteor)&amp;(buff.rune_of_power.up|!talent.rune_of_power.enabled)
				-- actions.bm_combustion_phase+=/rune_of_power,if=buff.combustion.down
				if rune_of_power_enabled then
					if valid_magic(0) and not unit_is_player(t) and ttd(t) > 9.5 then
						if combustion_cd > rune_of_power_next_charge_cd + rune_of_power_cast_time and not combustion or ttd(t) < combustion_cd and not combustion then
							_Cast(116011)
						end
						if combustion_cd <= rune_of_power_cast_time then
							-- --lucid dreams
							-- if IsPlayerSpell(298357) and _spellCooldown(298357) <= gcd then
							-- 	SQ_CastSpellByID(298357)
							-- 	return
							-- end
							-- if not combustion and not rune_of_power_up then
							-- 	_Cast(116011)
							-- end
							-- --combustion
							-- if meteor_cd > 42.5 and meteor_cd < 43.85 and rune_of_power_up then
							-- 	SQ_CastSpellByID(190319)
							-- end
						end
					end
				end

				if not utilities_only then

					local valid_meteor = valid_magic(1.25)

					if valid_meteor and valid_meteor ~= "pet" and (max_cast_time >= gcd or target_stun > 0 and target_stun <= gcd*2.5) then

						local kyrian_meteor = player_covenant == "Kyrian" and (_debuffRemains(t, 307443, "player") >= 3.5 or _spellCooldown(307443) > 15)

						-- target stun
						if unit_is_player(t) or _isDummy(t) then
							if kyrian_meteor or player_covenant ~= "Kyrian" and target_stun >= .75 + buffer then
								if meteor_enabled and meteor_cd <= gcd_remains + (buffer*3) then
									if meteor(t, kyrian_meteor) then return end
								end
							end
						end

						-- 2s meteor on any cc?
						if unit_is_player(t) and load_mode then
							if groupsize == 2 and GetNumArenaOpponents() <= 2 then
								if kyrian_meteor or player_covenant ~= "Kyrian" and _CCremains(t) >= .75 + buffer then
									if meteor_enabled and meteor_cd < gcd_remains + (buffer*3) then
										if meteor(t, kyrian_meteor) then return end
									end
								end
							end
						end

						-- mirror image
						if load_mode and max_cast_time > gcd and not combustion and lowestFriend < 60 and lowestEnemy > 40 then
							if _Cast(55342) then
								Squid_Alert("Mirror Images",nil,nil,nil,55342)
							end
						end

					end

				end

				local defensives = {
					-- Flat Walls
					{id = 212800, dr = 35}, -- Blur (35% DMG REDUC)
					{id = 209426, dr = 100}, -- Darkness (Just calling it 100%)
					{id = 498, dr = 20}, -- Divine Protection (20% wall)
					{id = 31821, dr = 20}, -- Aura Mastery (20% wall)
					{id = 243435, dr = 20}, -- Fort Brew (20% wall)
					{id = 125174, dr = 100}, -- Karma (100% absorb that doesn't show up in absorbs)
					{id = 122278, dr = 50}, -- Diffuse Magic (20-50% wall based on damage of incoming attack, calling it 50 for the sake of botd)
					{id = 61336, dr = 50}, -- Survival Instincts (50% wall)
					{id = 22812, dr = 20}, -- Barkskin (20% wall)
					{id = 102342, dr = 20}, -- Ironbark (20% wall)
					{id = 201633, dr = 7}, -- Earthen Wall (~7% of botd dmg absorbed)
					{id = 108271, dr = 40}, -- Astral Shift (40% wall)
					{id = 104773, dr = 40}, -- Unending Resolve (40% wall)
					{id = 1966, dr = 30}, -- Feint (30% wall)
					{id = 33206, dr = 40}, -- Pain Supp (40% wall)
					{id = 81782, dr = 40}, -- Barrier (25-50% wall depending on talent)
					{id = 47585, dr = 75}, -- Dispersion (75% wall)
					{id = 213602, dr = 100}, -- Greater Fade (100% wall)
					{id = 197690, dr = 20}, -- Defensive Stance (20% wall)
					{id = 118038, dr = 30}, -- Parry (30% wall)
					{id = 48792, dr = 30}, -- IBF (30% wall)
					{id = 287081, dr = 30}, -- Lichborne (30% wall)
					{id = 186265, dr = 100}, -- Turtle (hunter det)
					{id = 45438, dr = 100}, -- Ice Block

					-- Magic Walls (AMS shows up in UnitGetTotalAbsorbs so not putting here)
					{id = 122783, dr = 60}, -- Diffuse Magic (60% mwall)
					{id = 31224, dr = 100}, -- Cloak of Shadows (100% magic immune)
					{id = 198065, dr = 50}, -- Prismatic Cloak Mage Blink Shit
					{id = 204018, dr = 100}, -- Spell Warding
				}

				-- --reaping effective dmg
				-- local reaping_damage = GetSpellEffect(310690)
				-- --modifier for kb bonus
				-- reaping_damage = reaping_damage * ( UnitBuffID("player",311202) and 2 or 1 )

				-- local target_dmg_reduc = 0
				-- for i=1,#defensives do
				-- 	local id = defensives[i].id
				-- 	local dr = defensives[i].dr
				-- 	if UnitBuffID("target",id) then
				-- 		target_dmg_reduc = target_dmg_reduc + dr
				-- 	end
				-- end
				-- target_dmg_reduc = target_dmg_reduc / 100

				-- local reaping_mod = 1 - target_dmg_reduc

				-- --essences
				-- if max_cast_time >= gcd and (combustion_remains == 0 or (fire_blast_charges == 0 and phoenix_flames_charges == 0 and not hot_streak and combustion_remains < scorch_cast_time)) then
				-- 	--breath of the dying
				-- 	if IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd_remains and valid_magic(0) then
				-- 		local cur_hp = _HP(t)
				-- 		local est_hp = (100 * ( UnitHealth("target") - ( reaping_damage * reaping_mod ) + target_absorbs ) / UnitHealthMax("target") )
				-- 		if not combustion or est_hp < 20 then
				-- 			if est_hp < 20 or cur_hp > 80 and ( cur_hp < 98 or load_mode ) then
				-- 				if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) then
				-- 					if _LoS(t) and _distance(t) < 40 and _amIfacing(t) then
				-- 						CastSpellByID(310690,t)
				-- 					end
				-- 					if _Cast(310690,t,true) then
				-- 						Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
				-- 					end
				-- 				end
				-- 			end
				-- 		end
				-- 	end
				-- 	if IsPlayerSpell(295373) then
				-- 		local stacks = _buffStacks("player",295378)
				-- 		if valid_magic(0) and (load_mode or (GetSpellCharges(295373) == 2 and stacks < 2) or stacks == 0 or _HP(t) < 8*stacks) then
				-- 			if combustion_remains == 0 or (fire_blast_charges < 1 and not hot_streak and stacks >= 1) or stacks == 2 then
				-- 				local str = stacks == 1 and "1 Stack" or stacks .. " Stacks"
				-- 				if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) then
				-- 					if _Cast(295373,t,true) then
				-- 						Squid_Alert("Crucible of Flame",str,nil,nil,295373)
				-- 					end
				-- 				end
				-- 			end
				-- 		end
				-- 	end
				-- end

				-- use the radiant spark
				-- if max_cast_time >= _castTime(307443) and (combustion_remains == 0 or (fire_blast_charges == 0 and phoenix_flames_charges == 0 and not hot_streak and combustion_remains < scorch_cast_time)) then
				-- 	if valid_magic(_castTime(307443)) and _Cast(307443,t,true) then
				-- 		Squid_Alert("Radiant Spark", nil, nil, nil, 307443)
				-- 		return true
				-- 	end
				-- end

				-- rune of power on go
				if not player_interruptable and IsPlayerSpell(116011) and max_cast_time > _castTime(116011) and not combustion and time_in_los(t) > 2 then
					if their_healer_cc_remains >= 6 and combustion_cd > 8 then
						if _Cast(116011) then
							Squid_Alert("Rune of Power", nil, nil, nil, 116011)
							return true
						end
					end
				end

				-- Radiant Spark
				if player_covenant == "Kyrian" then
					if max_cast_time > _castTime(307443) and (meteor_cd <= 2 + fire_blast_charges or meteor_cd > 30 + _castTime(307443)) and load_mode then
						if valid_magic(_castTime(307443)) and _Cast(307443, t, true) then
							Squid_Alert("Radiant Spark", nil, nil, nil, 307443)
							return true
						end
					end
				end

				-- Mirrors of Torment
				if C_Covenants.GetActiveCovenantID() == covenants["Venthyr"] then
					if max_cast_time < 15 - poly_cast_time - buffer and max_cast_time > _castTime(314793) and player_interruptable and (not their_healer or next_cc_is_healer) then
						if valid_magic(_castTime(314793)) and _Cast(314793,t,true) then
							Squid_Alert("Mirrors of Torment", nil, nil, nil, 314793)
							return true
						end
					end
				end
			end
		end

		local function standard_rotation(max_cast_time)

			local target_stun = UnitExists(t) and _stunRemains(t) or 0

			--cast gpy if target will LoS before cast is off, and shimmer available???

			-- hardcast pyro with pyroclasm
			if pyroclasm_remains > 4 then
				if valid_magic(_castTime(11366)) and (not load_mode or lowestEnemy > 45 or fire_blast_charges == 0 and not (_HP(t) < 30 and searing_touch_enabled)) and max_cast_time > _castTime(11366) - buffer - (player_interruptable and 2 or 0) then
					if combustion_remains == 0 and t then
						if IsPlayerSpell(235870) and pyroclasm_remains >= 4.5 + gcd then
							if db_random() then return end
						end
						if not hot_streak then
							if _Cast(11366,t,nil,true) then return end
						elseif pyroclasm_remains > 4.5 + gcd and (UnitBuffID("player", 334277) or pyroclasm_remains < 6) then
							RunMacroText("/cancelaura hot streak!")
							Squid_Alert("Cancel Hot Streak","(Pyroclasm)",nil,nil,48108)
							SquidFrame = 2
							return
						end
					end
				end
			end

			-- q fireball before hot streak pyro / phoenix flames if pveing
			if valid_magic(fireball_cast_time) and (hot_streak and hot_streak_remains > fireball_cast_time + buffer and not UnitBuffID("player",333100)) and (not combustion or fireball_cast_time < scorch_cast_time and fire_blast_charges == 0 and not player_interruptable) and (not load_mode or tinder_up) then
				if max_cast_time > fireball_cast_time and not player_interruptable and fire_blast_full_recharge_time > gcd+buffer then
					if not meteor_in_flight or not UnitDebuffID(t, 307454, "player") then
						if _Cast(133,t,true) then return end
					end
				end
			end

			--consume hot streak (combust prio)
			if combustion and (player_hp > 15 or player_immune) then
				if valid_magic(0) and (hot_streak or player_casting_guaranteed_crit and heating_up) then
					if max_cast_time >= gcd / 2 then
						if _LoS(t) and _distance(t) < gpy_range then
							if ( not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) ) and ( not ring_cast_delay or time - ring_cast_delay > .2 ) then
								if _Cast(11366,t,true) then return end
							end
						end
					end
				end
			end

			--blazing barrier high prio
			local blazing_hp = 25
			blazing_hp = blazing_hp + (enemies_on_player * 50)
			blazing_hp = blazing_hp + (not our_healer and enemies_on_player * 25 or our_healer_cc and 75 or 0)
			blazing_hp = blazing_hp + (enemy_cds_on_player * 100)
			blazing_hp = blazing_hp + (triune_ward and 25 or 0)
			blazing_hp = blazing_hp - (load_target and 35 or 0)
			blazing_hp = blazing_hp - (combustion and 25 or 0)
			-- blazing_hp = blazing_hp - (UnitBuffID("player",310143) and 45 or 0)

			--why die before using blazing barrier?
			if blazing_hp < 5 then
				blazing_hp = 5
			end

			--why use blazing barrier when invincible?
			if player_immune then blazing_hp = 0 end

			if max_cast_time > gcd and player_hp < blazing_hp and barrier_remains < 1400 and (not temp_up or _HP("player") < 25) then
				if not UnitChannelInfo("player") and _Cast(235313) then
					Squid_Alert("Blazing Barrier",nil,nil,nil,235313)
					return
				end
			end

			--consume hot streak
			if valid_magic(0) and (hot_streak or player_casting_guaranteed_crit and heating_up) then
				if max_cast_time >= gcd + (player_cast_id ~= nil and player_cast_time_left or 0) then
					if _LoS(t) and _distance(t) < gpy_range then
						if ( not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) ) and ( not ring_cast_delay or time - ring_cast_delay > .2 ) then
							if not (pyroclasm_remains >= 5 and UnitBuffID("player", 334277)) or max_cast_time < 4 then
								if _Cast(11366,t,true) then return end
							else
								Squid_Alert_Big("Stand Still","(KILL SHOT)",nil,nil,11366)
							end
						end
					end
				end
			end

			if SQUID.auto_temp then

				local temp_hp = 5
				temp_hp = temp_hp + (enemies_on_player * 10.5)
				temp_hp = temp_hp * (1 + (enemy_cds_on_player * 2))
				temp_hp = temp_hp * (our_healer_cc_remains >= 3 and our_healer_cc_remains * 1.25 or 1)

				-- go in
				if player_effective_hp < temp_hp and (not our_healer or our_healer_cc or enemy_cds_on_player >= 1 and barrier_remains <= 1000) and not player_immune then
					if not UnitBuffID("player",110909) then
						if _spellCooldown(108978) == 0 then SpellStopCasting() end
						if _Cast(108978) then
							Squid_Alert_Big("Alter Time",nil,5,nil,110909)
							return
						end
					end
				end

				-- go back
				-- note: needs to consider enemy mage having klepto when we don't
				if squid_alter then
					local start_hp = squid_alter.start_hp
					local alter_effect = start_hp - player_hp
					if alter_effect >= 50 - bin(can_be_purged)*20 or player_effective_hp <= 5 + bin(enemy_melee_on_player > 0 and _stunDR("player") == 1)*16 + enemies_on_player*7 and alter_effect >= player_effective_hp - 8 then
						if _Cast(127140) then
							Squid_Alert_Big("Alter Return","+" .. alter_effect .. "%",6,3,127140)
							return
						end
					elseif alter_effect < 0 and _buffRemains("player",110909) <= buffer then
						RunMacroText("/cancelaura alter time")
						Squid_Alert_Big("|cFFc31d39Alter Cancelled", nil, nil, nil, 110909)
					end
				end

			end

			--temp shield
			if SQUID.cap_bot then
				local temp_hp = 12
				temp_hp = temp_hp + ( (enemies_on_player * 25) * (not our_healer and 2 or our_healer_cc and 2 or 1) )
				temp_hp = temp_hp + (enemy_cds_on_player * 60)
				temp_hp = temp_hp * (not our_healer and 2.25 or our_healer_cc and 2.25 or 1)

				if auto_temp and player_hp < temp_hp and barrier_remains < 1200 then
					if not UnitBuffID("player",110909) and _Cast(108978) then
						Squid_Alert_Big("Temp Shield",nil,nil,nil,108978)
						return
					end
				end

				if alter_effect and UnitBuffID("player",110909) and (alter_effect > 45 or player_hp < 20) then
					if _Cast(108978) then
						Squid_Alert_Big("Alter Return",alter_effect .. "%",nil,nil,108978)
					end
				end
			end

			--pre blaze or temp doesnt matter
			if gpy_on_player then
				if not temp_up and _Cast(235313) then
					Squid_Alert_Big("Blazing Barrier","Greater Pyro",nil,nil,235313)
					return
				-- elseif barrier_remains < 35000 and _Cast(198111) then
				-- 	Squid_Alert_Big("Temp Shield","Greater Pyro",nil,nil,198111)
				-- 	return
				end
			end

			--pre blaze or temp doesnt matter
			if big_dmg_inc and (our_healer_cc or not our_healer or rly_big_dmg_inc or _HP("player") < 50) then
				local spell = GetSpellInfo(big_dmg_inc)
				if barrier_remains < 9000 and _Cast(198111) then
					Squid_Alert_Big("Temp Shield",spell,nil,nil,198111)
					return
				elseif not temp_up and _Cast(235313) then
					Squid_Alert_Big("Blazing Barrier",spell,nil,nil,235313)
					return
				end
			end

			--pre blaze or temp doesnt matter
			if _debuffRemains("player",274838) > 5.5 then
				if not temp_up and _Cast(235313) then
					Squid_Alert_Big("Blazing Barrier","Feral Frenzy",nil,nil,235313)
					return
				elseif barrier_remains < 5000 and _Cast(198111) then
					Squid_Alert_Big("Temp Shield","Feral Frenzy",nil,nil,198111)
					return
				end
			end

			--pre blaze cc
			if cc_flying_towards_player then
				local spell = GetSpellInfo(cc_flying_towards_player)
				if barrier_remains < 18000 and _Cast(235313) then
					Squid_Alert_Big("Blazing Barrier",spell,nil,nil,235313)
					return
				end
			end

			--phoenix flames
			if phoenix_flames_enabled and max_cast_time > gcd and (not fb_used or time - fb_used > .25 + buffer) then
				if valid_magic(0) and not hot_streak and not UnitBuffID(t,53480) and (not fb_flying and not pyro_flying and not pf_flying or not heating_up) then
					-- --use to keep stacks from capping
					if phoenix_flames_full_recharge_time <= gcd * 2 + gcd_remains and not heating_up and not player_casting_crittable_damage and lowestEnemy < 85 then
						if phoenix_flames(t) then return end
					end
					--use after fireball casts
					-- if player_cast_id == 133 and not heating_up and (phoenix_flames_charges_frac >= 1.85 or lowestEnemy < 60 or load_mode) and fire_blast_charges_frac >= .85 then
					-- 	if phoenix_flames(t) then return end
					-- end
					--dump during load mode
					if not player_casting_crittable_damage and load_mode and (not heating_up or combustion) and (phoenix_flames_charges_frac >= 1.85 or combustion) then
						if phoenix_flames(t) then return end
					end
				end
			end

			--consume tinder buff with fireball
			if fireball_cast_time < max_cast_time and valid_magic(fireball_cast_time) and tinder_up then
				local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
				if not unsafe_cast and _Cast(133,t,true) then
					return
				end
			end

			--fire blast
			if (not fb_used or time - fb_used > .2 + buffer) and fire_blast_charges >= bin(kyrian_fb_pool)*2 then
				-- print("FB  NO US " .. math.random(1,9999999))
				--valid target, and not hot streaking already (Never FB into RoS)
				if valid_magic(0) and not hot_streak and not UnitBuffID(t,53480) and (not fb_flying and not pyro_flying and not pf_flying or combustion and combustion_remains < 9.85 and not heating_up) then
					--use to protect heating up procs from casts that may non-crit, and from falling off
					if heating_up and load_mode and (player_cast_id == 133 and player_cast_time_left < (buffer*2) or heating_up_remains <= buffer or player_cast_id == 2948 and not player_casting_guaranteed_crit and fire_blast_full_recharge_time < 3 + (load_mode and 6 or 0) ) and (fire_blast_full_recharge_time <= 14 or load_mode) and not player_casting_guaranteed_crit then
						if _Cast(108853,t,true) then
							-- print("used to protect")
							fb_used = time
							SquidFrame = 2
							return
						end
					end
					--use to keep from stacks capping (with heating up, or while casting guaranteed crit / gpy)
					local kyrian_setup = meteor_in_flight and UnitDebuffID(t,307443,"player") and _debuffStacks(t,307454,"player") < 3 + bin(meteor_in_flight_remains < buffer+1)
					if (fire_blast_full_recharge_time < gcd + ( heating_up and heating_up_remains <= buffer and gcd * 1.5 or 0 ) or kyrian_setup) and (heating_up and not player_casting_guaranteed_crit or not heating_up and player_casting_guaranteed_crit or player_cast_id == 203286 or kyrian_setup) then
						if _Cast(108853,t,true) then
							-- print("used to not cap")
							fb_used = time
							SquidFrame = 2
							return
						end
					end
					--dump all charges for hot streak w/ load mode
					if load_mode and ( heating_up and not player_casting_guaranteed_crit or fire_blast_charges_frac >= 1.85 or combustion_remains > max(scorch_cast_time, fire_blast_next_charge_cd) or player_casting_guaranteed_crit and not heating_up ) then
						if _Cast(108853,t,true) then
							-- print("used to dump")
							fb_used = time
							SquidFrame = 2
							return
						end
					end
				end
			end

			--phoenix flames
			if phoenix_flames_enabled and max_cast_time > gcd and (not fb_used or time - fb_used > .25 + buffer) and (combustion or load_mode or phoenix_flames_charges >= 3) then
				if valid_magic(0) and not hot_streak and not UnitBuffID(t,53480) and (not fb_flying and not pyro_flying and not pf_flying or not heating_up) then
					-- --use to keep stacks from capping
					if phoenix_flames_full_recharge_time <= gcd * 2 + gcd_remains and not heating_up and not player_casting_crittable_damage and lowestEnemy < 90 then
						if phoenix_flames(t) then return end
					end
					--use after fireball casts
					-- if player_cast_id == 133 and not heating_up and (phoenix_flames_charges_frac >= 1.85 or lowestEnemy < 60 or load_mode) and fire_blast_charges_frac >= .85 then
					-- 	if phoenix_flames(t) then return end
					-- end
					--dump during load mode
					if not player_casting_crittable_damage and load_mode and (not heating_up or combustion) and (phoenix_flames_charges_frac >= 1.85 or combustion) then
						if phoenix_flames(t) then return end
					end
				end
			end

			--spellsteals
			if not combustion and valid_magic(0) and max_cast_time > gcd and player_mana > 70 then
				local ss = Basic_Spellsteal(t)
				if ss and _Cast(30449,t,nil,true) then
					Squid_Alert("Spellsteal " .. UnitClass(t),"("..GetSpellInfo(ss)..")",nil,nil,30449)
				end
			end

			--maintain flames of alacrity with fireball
			-- if flames_of_alacrity_enabled and flames_of_alacrity_count == 3 and enhanced_pyrotechnics_remains < fireball_cast_time * 2.5 and (not fireball_cast_delay or time - fireball_cast_delay > .25) and not fb_flying then
			-- 	if valid_magic(fireball_cast_time) and max_cast_time > fireball_cast_time then
			-- 		-- local unsafe_cast = combustion --player_interruptable and fire_blast_charges >= ((heating_up or fire_blast_next_charge_cd < 1) and 1 or 2)
			-- 		if not combustion and _Cast(133,t,true) then
			-- 			return
			-- 		end
			-- 	end
			-- end

			--scorch execute off targets if main target is higher hp
			if max_cast_time > scorch_cast_time and not (valid_magic(0) and _HP(t) < 30) and not hot_streak and ( not pyro_flying or not hot_streak and fire_blast_charges == 0 and fire_blast_next_charge_cd > scorch_cast_time ) then
				if searing_touch_enabled and not arena and UnitAffectingCombat("player") then
					local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
					if not unsafe_cast then
						for i=1,#Enemies do if not _breakableCC(Enemies[i]) then
							if _HP(Enemies[i]) < 30 and ttd(Enemies[i]) > scorch_cast_time then
								_Cast(2948,Enemies[i],true)
							end
						end end
					end
				end
			end

			--gpy only if followup cc is not needed before a finished cast, or if full lockout on arcane and no ring available or healer out of cc
			if IsPlayerSpell(203286) and valid_magic(greater_pyro_cast_time) and (not load_mode or fire_blast_charges == 0 and not hot_streak and not (_HP(t) < 30 and searing_touch_enabled)) and max_cast_time > greater_pyro_cast_time - buffer - ( player_interruptable and 2.5 or 0 ) then
				if combustion_remains == 0 and t then
					--stop casting dummy scorch after planting (causes issues with scorch totem stomp and not really necessary)
					-- if player_cast_id == 2948 and not_moving_duration > .3 and player_cast_time_left > .45 and (not searing_touch_enabled or _HP(t) > 30) and (not combustion or combustion_remains < player_cast_time_left) then
					-- 	SpellStopCasting()
					-- end
					if not killshot_engaged and _Cast(203286,t,nil,true) then
						return
					end
				end
			end

			--scorch w/ combust or execute
			if valid_magic(scorch_cast_time) and max_cast_time > scorch_cast_time and ( not pyro_flying or not hot_streak and fire_blast_charges == 0 and fire_blast_next_charge_cd > scorch_cast_time ) then
				if combustion_remains > scorch_cast_time or (_HP(t) <= 30 and searing_touch_enabled) then
					local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
					if not unsafe_cast and _Cast(2948,t,true) then
						return
					end
				end
			end

			--firestarter fireballs
			if firestarter_enabled then
				if valid_magic(fireball_cast_time) and fireball_cast_time < max_cast_time and (not combustion or fireball_cast_time < scorch_cast_time and fire_blast_charges == 0) then
					local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
					if not unsafe_cast and _Cast(133,t,true) then
						return
					end
				end
			end

			--rebuff intellect
			local someone_missing_int
			for i=1,#Friends do if not UnitBuffID(Friends[i],1459) and _distance(Friends[i]) < 40 and not UnitCanAttack("player",Friends[i]) and (not combat or not _isMeleeDps(Friends[i])) then
				someone_missing_int = true
			end end
			-- dont rebuff while casting
			if max_cast_time > gcd and someone_missing_int and not UnitCastingInfo("player") and not tanking then
				if _Cast(1459,"player") then
					Squid_Alert("Rebuff",nil,nil,nil,1459)
					return
				end
			end

			--conjure food
			if GetItemCount(80610) == 0 and GetItemCount(113509) == 0 and not tanking and get_squid_var("Auto Food") then
				if UnitBuffID("player",32727) and GetNumGroupMembers() > 1 then
					_Cast(190336)
				end
				if Free_Bag_Slots() > 0 and (not food_already_clicked or time - food_already_clicked > 2 or (GetItemCount(80610) >= 20 and GetItemCount(80610) <= 40) or (GetItemCount(113509) >= 20 and GetItemCount(113509) <= 40)) then
					InteractUnit("Refreshment Table")
					InteractUnit("Lavish Refreshment Table")
					food_already_clicked = time
				end
			end

			-- Call Kyrian Steward
			if C_Covenants.GetActiveCovenantID() == covenants["Kyrian"] then
				if GetItemCount(177278) < 3 and not tanking and Free_Bag_Slots() > 0 then
					if UnitBuffID("player", 32727) and GetNumGroupMembers() > 1 then
						_Cast(324739)
					end
				end
			end

			--fireball (only with tinder if playing gpy)
			if fireball_cast_time < max_cast_time and valid_magic(fireball_cast_time) and (not tinder_enabled or tinder_up or firestarter_enabled) and (not combustion or fireball_cast_time < scorch_cast_time and fire_blast_charges == 0) then
				local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
				if not unsafe_cast and _Cast(133,t,true) then
					return
				end
			end

			--dispel dots
			local function low_prio_dispel(unit)
				local agony_stacks = _debuffStacks(unit,980)
				if agony_stacks >= 9 then
					return 980
				end
			end

			if remove_curse_cd <= gcd_remains and max_cast_time > gcd*2 then
				for i=1,#Friends do
					local dispel = low_prio_dispel(Friends[i])
					if dispel and _LoS(Friends[i]) then
						if _Cast(475,Friends[i]) then
							Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,475)
						end
					end
				end
			end

			--scorch fallthrough for movement
			if SQUID.scorch_filler then
				if max_cast_time > scorch_cast_time and valid_magic(scorch_cast_time) and (not combustion or fire_blast_charges == 0) and ( not pyro_flying or not hot_streak and fire_blast_charges == 0 and fire_blast_next_charge_cd > scorch_cast_time ) then
					local unsafe_cast = combustion and fire_blast_charges >= 1 - ( ((heating_up and (pyro_flying or fb_flying or pf_flying)) or hot_streak) and 1 or 0)
					if not unsafe_cast and _Cast(2948,t,true) then
						return
					end
				end
			end

		end

		--stop bad fire casts
		if combustion and fire_blast_charges > 1 - ((heating_up or hot_streak or pyro_flying or fb_flying) and 1 or 0) and (player_casting_crittable_damage or player_cast_id == 203286) and player_interruptable then
			SpellStopCasting()
			Squid_Alert("Stop Casting Fire","(Combustion/Interruptable)",nil,nil,nil,190319)
		end

		--burst mode
		if Squid_Burst and (valid_magic(0) or meteor_in_flight and UnitIsVisible(current_target) and UnitCanAttack("player",current_target) and not _immuneMagic(current_target)) then
			--lucid dreams
			if IsPlayerSpell(298357) then
				if _Cast( 298357 ) then
					Squid_Alert( "Memory of Lucid Dreams", nil, nil, nil, 298357 )
					return
				end
			end

			--combust
			if _spellCooldown(190319) <= .5 and (not IsPlayerSpell(298357) or _spellCooldown(298357) > gcd_remains + 2 and gcd_remains <= .2) then--  _spellCooldown(190319) < .2 and _spellCooldown(11366) <= buffer and then
				SQ_CastSpellByID ( 190319 )
				Squid_Alert_Big( "Combustion", nil, nil, nil, 190319 )
			end

			--racials
			local race = UnitRace("player")
			if race == "Orc" then
				SQ_CastSpellByName("Blood Fury")
			end

			--items
			if UnitBuffID("player",313948) then
				RunMacroText("/cancelaura Manifesto of Madness: Chapter One")
				Squid_Alert( "Manifesto of Madness", "(CANCEL)", nil, nil, 313948 )
			end

			if tContains( equipped_items, 161377 ) and GetItemCD ( ( 161377 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 161377 ) ) )
				Squid_Alert( "Azurethos' Singed Plumage", nil, nil, nil, 278383 )
			end

			if ( tContains( equipped_items, 167380 ) and GetItemCD ( ( 167380 ) ) == 0 )
			or ( tContains( equipped_items, 172669 ) and GetItemCD ( ( 172669 ) ) == 0 )
			or ( tContains( equipped_items, 165058 ) and GetItemCD ( ( 165058 ) ) == 0 )
			or ( tContains( equipped_items, 175884 ) and GetItemCD ( ( 175884 ) ) == 0 )
			or ( tContains( equipped_items, 175921 ) and GetItemCD ( ( 175921 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 167380 ) ) )
				UseItemByName( tostring( GetItemInfo ( 172669 ) ) )
				UseItemByName( tostring( GetItemInfo ( 165058 ) ) )
				UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
				UseItemByName( tostring( GetItemInfo ( 175921 ) ) )
				Squid_Alert( "Gladiator's Badge", nil, nil, nil, 277185 )
			end

			if ( tContains( equipped_items, 172666 ) and GetItemCD ( ( 172666 ) ) == 0 )
			or ( tContains( equipped_items, 167377 ) and GetItemCD ( ( 167377 ) ) == 0 )
			or ( tContains( equipped_items, 165055 ) and GetItemCD ( ( 165055 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 172666 ) ) )
				UseItemByName( tostring( GetItemInfo ( 167377 ) ) )
				UseItemByName( tostring( GetItemInfo ( 165055 ) ) )
				Squid_Alert( "Gladiator's Medallion", nil, nil, nil, 277179 )
			end

			if tContains( equipped_items, 159630 ) and GetItemCD ( ( 159630 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 159630 ) ) )
				Squid_Alert( "Balefire Branch", nil, nil, nil, 268999 )
			end

			if tContains( equipped_items, 169318 ) and GetItemCD ( ( 169318 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 169318 ) ) )
				Squid_Alert( "Shockbiter's Fang", nil, nil, nil, 303953 )
			end

			if tContains( equipped_items, 161411 ) and GetItemCD ( ( 161411 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 161411 ) ) )
				Squid_Alert( "T'zane's Barkspines", nil, nil, nil, 278227 )
			end

			if ( tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 )
			or ( tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
				UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
				Squid_Alert( "Knot of Wisdom", nil, nil, nil, 278267 )
			end

			if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
				Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
			end

			if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
				Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
			end

			if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
				Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
			end

		end

		local dispellable ={
		51514,	--hex
		199954,	--curse of frag
		199890,	--curse of tongues
		80240,	--havoc
		51514,	--hex
		211015,	--hex cockroach
		210873,	--hex compy
		211010,	--hex snake
		211004,	--hex spider
		277784,	--hex wicker mongrel
		277778,	--hex zandalari tendonripper
		309328,	--hex living honey
		269352,	--hex skeletal raptor
		};

		local function remove_curse(unit)
			local lessDelay = minDelayTime/1.1;
			if SQUID.max_mindelay > 200 then
				lessDelay = .35
			end
			for i=1,#dispellable do
				local debuff,_,_,five,six,seven,source = UnitDebuffID(unit,dispellable[i]);
				if debuff and seven-time < six-lessDelay then
					return dispellable[i], source;
				end
			end
		end

		--dispel
		if remove_curse_cd <= gcd_remains then
			for i=1,#Friends do
				local dispel,source = remove_curse(Friends[i])
				if dispel and _LoS(Friends[i]) then
					if _Cast(475,Friends[i]) then
						Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,475)
					end
					if (player_casting_crittable_damage or (player_cast_id == 203286 and player_cast_time_left > 1)) and player_cast_time_left > gcd_remains then
						if dispel == 80240 then
							-- check source coil cd is up
							-- if source then
							-- 	source = ObjectPointer(source)
							-- 	if UnitIsVisible(source) and UnitCooldown(source,6789) <= 1 then
							-- 		SpellStopCasting()
							-- 	end
							-- end
							-- check that coil hasn't been used (this will not work well vs double warlock)
							if not enemy_coil or time - enemy_coil >= 42 then
								SpellStopCasting()
							end
						else
							SpellStopCasting()
						end
					end
				end
			end
		end

		-- keep rogu
		local keep_rogue
		for i=1,#Enemies do if select(2,UnitClass(Enemies[i])) == "ROGUE" and _CCremains(Enemies[i]) <= buffer and not UnitAffectingCombat(Enemies[i]) and (not player_cast_id or not unit_is_unit(player_cast_target,Enemies[i])) and not _immuneMagic(Enemies[i]) then
			keep_rogue = Enemies[i]
		end end

		if keep_rogue and UnitIsVisible(keep_rogue) then
			-- flamestrike with hotstreak -- FIXME ADD BREAKABLE CC CHECK
			if hot_streak and ( not _LoS(keep_rogue) or not _isSlowed(keep_rogue) ) and breakable_cc_around(keep_rogue,14) == 0 then
				if _AeCast(2120,keep_rogue,40,8) then
					Squid_Alert("Flamestrike","(Keep Rogue)",4,nil,2120)
					return
				end
			end
			-- keep rogue with fb
			if not hot_streak and (not fb_flying and not pyro_flying and not pf_flying or combustion and combustion_remains < 9.85 and not heating_up) then
				if not fb_used or time - fb_used > .25 + buffer then
					if _Cast(108853,keep_rogue,nil,true) then
						Squid_Alert("Fire Blast","(Keep Rogue)",4,nil,108853)
						fb_used = time
						SquidFrame = 2
						return
					end
				end
			else
			-- keep rogue with pyro
				-- if _Cast(11366,keep_rogue,nil,true) then
				-- 	Squid_Alert("Pyroblast","(Keep Rogue)",4,nil,11366)
				-- 	return
				-- end
			end
		end

		--stop drink
		local drinkbuffs = {
			274914, -- (rockskip mineral water / seafoam coconut water?)
			167152, -- (mage food)
		}

		local stop_drink
		for i=1,#Enemies do if _buffFromTable(Enemies[i],drinkbuffs) then
			stop_drink = Enemies[i]
		end end

		if stop_drink and UnitIsVisible(stop_drink) then
			-- flamestrike with hotstreak -- FIXME ADD BREAKABLE CC CHECK
			if hot_streak and breakable_cc_around(stop_drink,14) == 0 then
				if _AeCast(2120,stop_drink,40,8) then
					Squid_Alert("Flamestrike","(Stop Drink)",4,nil,2120)
					return
				end
			end
			-- keep rogue with fb
			if not hot_streak and (not fb_flying and not pyro_flying and not pf_flying or combustion and combustion_remains < 9.85 and not heating_up) then
				if not fb_used or time - fb_used > .25 + buffer then
					if _Cast(108853,stop_drink,nil,true) then
						Squid_Alert("Fire Blast","(Stop Drink)",4,nil,108853)
						fb_used = time
						SquidFrame = 2
						return
					end
				end
			else
			-- keep rogue with pyro
				if _Cast(11366,stop_drink,nil,true) then
					Squid_Alert("Pyroblast","(Stop Drink)",4,nil,11366)
					return
				end
			end
		end

		local function should_klepto(unit)

			if UnitDebuffID(unit,33786) then return false end

			local value = 0

			local stun = _stunRemains(unit)

			--fixme add big value for recent overgrowth
			if unit_is_unit(unit,current_target) then
				value = value + _buffRemains(unit,774)*min(max(stun*1.5,1.8),4.5) -- rejuv duration
				value = value + _buffRemains(unit,155777)*min(max(stun*1.5,1.8),4.5) -- rejuv germination duration
				value = value + (_buffRemains(unit,33763) * (.65 + (_buffStacks(unit,203554) / 4))) -- lifebloom duration * stacks
				--safegaurd
				local buff,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID(unit,286342)
				if buff and absorb > 20000 then
					value = value + 20 + (15 * (absorb / 20000))
				end
				value = value + _buffRemains(unit,198111)*3 -- some value for temp based on duration
				value = value + _buffRemains(unit,305497)*.35 -- half value for thorns duration
				--high value for ghost wolf / es / riptide when stunned
				if stun >= 1 then
					value = value + (UnitBuffID(unit,2645) and _isHealer(unit) and 45 or 0)
					value = value + (UnitBuffID(unit,974) and _isHealer(unit) and 20 or 0)
					value = value + (UnitBuffID(unit,61295) and _isHealer(unit) and 10 or 0)
				elseif _HP(unit) < 30 then
					--es and riptide still have value when they rly low
					value = value + (UnitBuffID(unit,974) and _isHealer(unit) and 15 or 0)
					value = value + (UnitBuffID(unit,61295) and _isHealer(unit) and 10 or 0)
				end
				value = value * (load_mode and 1.35 or 1)
				value = value * (_HP(unit) < 50 and 1.35 or 1)
				value = value * (_stunCheck(unit) and 1.5 or 1)
			end

			-- only if spellsteal has been used in last 30 seconds
			if not unit_has_klepto(unit) then
				value = value + _buffRemains(unit,190319)*11 -- high value for combust
			end

			--big value for bop when being targeted by melee
			value = value + (_buffRemains(unit,1022) > 0 and enemy_melee_on_player > 0 and _buffRemains(unit,1022)*10 or 0)

			if _buffUptime(unit,210294) > minDelayTime * 2 or UnitCastingInfo(unit) then
				value = value + (UnitBuffID(unit,210294) and 69 or 0) -- always klept divine favor
			end

			value = value * ( (not theirHealer or their_healer_cc) and 1.5 or 1 )

			return value >= 60

		end

		-- klepto
		if klepto_enabled and not SQUID.dont_klept then
			for i=1,#Enemies do
				local e = Enemies[i]
				if not _immuneCheck(e) and should_klepto(e) then
					if _Cast(30449,e,nil,true) then
						Squid_Alert_Big("Klepto",UnitClass(e),1,nil,30449)
						return
					end
				end
			end
		end

		--priority cc, and define max cast time here
		local max_cast_time = 69
		if auto_cc then
			max_cast_time = healer_cc()

			--is the next cc for the healer?
			next_cc_is_healer = max_cast_time ~= 69

			if max_cast_time > poly_cast_time * 2 then
				max_cast_time = min ( max_cast_time, off_cc() )
			end
		end

		-- if max_cast_time < 69 then max_cast_time = max_cast_time - buffer end
		if max_cast_time < 0 then max_cast_time = 0 end

		-- print(max_cast_time)

		--stop moving!
		-- if not _isMoving("player") and not UnitCastingInfo("player") and #movement_lock_commands == 0 then
		-- 	SetMovementLocked(false)
		-- end
		if mage_stop_moving and move_setting and not _silenceCheck("player") then
			StopMovingAndLock()
			C_Timer.After(.15 + buffer,function() if not player_cast_id then SetMovementLocked(false) else unlock_after = player_cast_time_left end end)
		end

		if mage_stop_moving then
			if not UnitIsVisible(mage_stop_moving.unit) then
				SetMovementLocked(false)
				mage_stop_moving = nil
			elseif _distance(mage_stop_moving.unit) > mage_stop_moving.dist then
				SetMovementLocked(false)
				mage_stop_moving = nil
			end
		end

		if not arena and IsMovementLocked() then
			SetMovementLocked(false)
		end

		if unlock_after and unlock_after > 0 then
			C_Timer.After(unlock_after, function() SetMovementLocked(false) end)
			unlock_after = nil
		end

		--still use gcds and scorch while moving
		if _isMoving("player") then max_cast_time = gcd+.5 end

		if cc_healer_key then
			if UnitExists(theirHealer) then
				cc(theirHealer,true)
				return
			else
				Squid_Alert("|cFFc31d39No Healers Found",nil,nil,nil,sheep)
			end
		end
		if cc_focus_key then
			if UnitExists(current_focus) then
				cc(current_focus,true)
				return
			else
				Squid_Alert("|cFFc31d39No Focus Target",nil,nil,nil,sheep)
			end
		end
		if cc_offtarget_key then
			if UnitExists(off_target) then
				cc(off_target,true)
				return
			else
				Squid_Alert("|cFFc31d39No off target found",nil,nil,nil,sheep)
			end
		end

		--nova healer out of game
		if not poly_cast_delay or time - poly_cast_delay > .1 or not unit_is_unit(their_healer,poly_cast_target) then
			if not bcc12 and their_healer and valid_magic(69) then
				if not unit_is_unit(their_healer,t) and _realDistance(their_healer) < 11 and _LoS(their_healer) and not _CCcheck(their_healer) and (_distance(their_healer,t) > 42 or not _LoS(their_healer,t)) then
					if _Cast(122) then
						Squid_Alert_Big("Frost Nova Healer","(Bad Position)",4,3.5,122)
						return
					end
				end
			end
		end

		--nova subterfuge
		if not bcc12 then
			for i=1,#Enemies do
				if UnitBuffID(Enemies[i],115192) and not _immuneMagic(Enemies[i]) and not _slowImmuneCheck(Enemies[i]) and _LoS(Enemies[i]) then
					if _realDistance(Enemies[i]) < 11.15 then
						if _Cast(122) then
							Squid_Alert_Big("Frost Nova","(Subterfuge)",nil,3.5,122)
						end
					end
				end
			end
		end

		--nova melee
		if not combustion and not bcc12 then
			local p_slowed = _isSlowed("player")
			for i=1,#Enemies do
				local e = Enemies[i]
				if _isMeleeDps(e) and not _immuneMagic(e) and (select(2,UnitClass(e)) ~= "DRUID" or lowestFriend < 45) and not _slowImmuneCheck(e) then
					local d = _realDistance(e)
					if lowestFriend < 50 + ((not our_healer or our_healer_cc) and 30 or 0) + (_CDcheck(e) and 30 or 0) - (UnitEnemiesAttacking(e) * 40) - (unit_is_unit(e,current_target) and _amIfacing(e) and 40 or 0) then
						if d < 11 and _LoS(e) and (d > 8 or d > 2 and moving_away_from(e,max(7-d-(p_slowed and 1.5 or 0),2))) and (_isMoving("player") or _isMoving(e)) then
							if _Cast(122) then
								Squid_Alert_Big("Frost Nova","(Melee, Kiting)",nil,3.5,122)
							end
						end
					end
				end
			end
		end

		object_first_detected = object_first_detected or {}
		auto_totem_target = auto_totem_target or {}

		for k,v in pairs(object_first_detected) do
			if time - v > 5 then
				object_first_detected[k] = nil
			end
		end

		--totem stomp
		local function Stomp(totem,name)
			local hp = UnitHealth(totem)
			local maxhp = UnitHealthMax(totem)
			if hp <= 1 then return false; end
			if not object_first_detected[totem] then
				object_first_detected[totem] = time
			else
				if time - object_first_detected[totem] > max(.35,minDelayTime*2) or player_cast_id and player_cast_time_left < .165 + latency or SQUID.max_mindelay < 50 then
					if _LoS(totem) and _distance(totem) < 40 and fire_lockout == 0 then
						--Fire Blast
						if hp <= 17000 and (not fb_used or time-fb_used > .18) then
							if not auto_totem_target[name] or time - auto_totem_target[name] > 1 then
								TargetUnit(totem)
								auto_totem_target[name] = time
							end
							if _Cast(108853,totem,nil,true) then
								Squid_Alert_Big("Stomp " .. name,"(Fire Blast)",4,nil,108853)
								fb_used=time
								SquidFrame = 2
								return
							end
						end

						--Pyroblast
						if hot_streak then
							if not auto_totem_target[name] or time - auto_totem_target[name] > 1 then
								TargetUnit(totem)
								auto_totem_target[name] = time
							end
							if _Cast(11366,totem,nil,true) then
								Squid_Alert_Big("Stomp " .. name,"(Pyroblast)",4,nil,11366)
								return
							end
						end
						-- if _isMoving("player") then
							if _Cast(2948,totem,true) then
								if not auto_totem_target[name] or time - auto_totem_target[name] > 1 then
									TargetUnit(totem)
									auto_totem_target[name] = time
								end
								Squid_Alert_Big("Stomp " .. name,"(Scorch)",4,nil,2948)
								return
							end
						-- else
						-- 	if _Cast(133,totem,true) then
						-- 		Squid_Alert_Big("Stomp " .. name,"(Fireball)",4,nil,133)
						-- 		return
						-- 	end
						-- end
					end
				end
			end
		end

		local totems = {
		101398,	--Psyfiend
		119052,	--War Banner
		104818,	--Ancestral Protection Totem
		53006,	--Spirit Link Totem
		-- 2630,	--Earthbind Totem
		-- 60561,	--Earthgrab Totem
		-- 61245,	--Capacitor Totem
		5925,	--Grounding Totem
		-- 105425,	--Skyfury Totem
		105427,	--Skyfury Totem
		-- 5913,	--Tremor Totem
		105451,	--Counterstrike Totem
		6112,	--Windfury Totem
		}

		local function target_last_non_totem_target()
			if last_non_totem_target and UnitIsVisible(last_non_totem_target) then
				TargetUnit(last_non_totem_target)
			end
		end

		local target_id = ObjectID(t)
		if tContains(totems,target_id) then
			if UnitHealth(t) <= 1 then
				if not totem_tlt_queued then
					C_Timer.After((max(.25,minDelayTime*1.5)),function() target_last_non_totem_target() totem_tlt_queued = nil end)
					totem_tlt_queued = true
				end
			end
		else
			if t and target_id ~= 61245 then
				last_non_totem_target = t
			end
		end

		-- if arena then
			for i=1,#Pets do
				local e = Pets[i]
				local name = UnitName(e);
				local id = ObjectID(e)
				--only kill cap totems when they're casting
				if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e) and _castTimeLeft(e) < latency + 1.15) or (name == "Twisted Appendage" and lowestFriend < 75 + (not our_healer and 25 or our_healer_cc and 25 or 0) and lowestEnemy > 15) then
					Stomp(e,name)
				end
				--root abomination
				if id == 149555 and _rootDR(e) >= .5 and _CCremains(e) + _rootRemains(e) < gcd and _distance(e) < 8 and not bcc12 and _LoS(e) then
					if _Cast(122) then
						Squid_Alert("Nova","Abomination",nil,nil,122)
						return
					end
				end
			end
		-- end

		--Prio Spellsteal
		if player_mana > 22 then
			for i=1,#Enemies do
				local ss = Prio_Spellsteal(Enemies[i])
				if ss and valid_magic(0,Enemies[i]) and _Cast(30449,Enemies[i],nil,true) then
					Squid_Alert("Spellsteal " .. UnitClass(Enemies[i]),"("..GetSpellInfo(ss)..")",nil,nil,30449)
					return true
				end
			end
		end

		-- ? ? ? ?
		-- if auto_cc then

		-- 	local off_target
		-- 	for i=1,#Enemies do if not unit_is_unit(current_target,Enemies[i]) and _distance(Enemies[i]) < 40 and not UnitIsDead(Enemies[i]) then
		-- 		off_target=Enemies[i]
		-- 		break
		-- 	end end

		-- 	if off_target then
		-- 		cc(off_target)
		-- 	end

		-- end

		-- print(mage_next_cc_target,mage_next_cc,mage_next_cc_dr,mage_next_cc_time)

		-- print(max_cast_time)

		priority_shit(max_cast_time)

		if not utilities_only then
			standard_rotation(max_cast_time)
		end

	end

	function Squid_FrostMagePvP()

		-- FLOW --


		--		Queue      --

		-- 		Work in Progress / Up Next    --



		-- 		Added Recently  --

		local time = GetTime()
		local latency = squid_avg_latency
		local groupsize = GetNumGroupMembers()
		local msperframe = 2/GetFramerate()
		local buffer = latency + msperframe + .1
		local haste = UnitSpellHaste("player")
		local gcd = 1.5/(1+(haste/100))
		local gcd_remains = GetGCD()
		local combat = UnitAffectingCombat("player")
		local player_hp = _HP("player")
		local player_immune = _immuneCheck("player",nil,true)
		local corruption = GetNetCorruption()

		-- barrier pre gate
		if UnitBuffID("player",32727) and arena_start_timer and arena_start_timer < 20 then
			if _Cast(11426) then
				Squid_Alert("Ice Barrier",nil,nil,nil,11426)
				return
			end
		end

		local auto_temp = SQUID.auto_temp

		local GetItemInfo_OG = GetItemInfo
		local GetItemInfo = function ( itemid ) local info = GetItemInfo_OG( itemid ) or ""; return info end

		--Auto Targeting
		local function dynamicTargeting(range)
			--Target enemies above 75% or below 35% preferably
			local bestUnit = bestUnit or nil
			if bestUnit == nil then
				if #Enemies > 0 then
					for i = 1, #Enemies do
						local thisUnit = Enemies[i]
						if _distance('player', thisUnit) <= range and _LoS('player', Enemies[i]) and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
							bestUnit = thisUnit
						end
					end
				end
			end
			if not UnitExists("target") and UnitAffectingCombat('player') then
				TargetUnit(bestUnit)
			end
		end
		local auto_target = SQUID.auto_target
		if auto_target then
			dynamicTargeting(40)
		end

		local utilities_only = SQUID.utilities_only

		--equipped items
		local equipped_items = {}

		local trinkets = {
		174103,	--Manifesto of Madness
		167380,	--Notorious Gladiator's Badge
		172669,	--Corrupted Gladiator's Badge
		165058,	--Sinister Gladiator's Badge
		172666,	--Corrupted Gladiator's Medallion
		167377,	--Notorious Gladiator's Medallion
		165055,	--Sinister Gladiator's Medallion
		159615,	--Ignition Mage's Fuse
		161411,	--Tzane's Barkspines
		161377,	--Azurethos' Singed Plumage
		166793,	--Ancient Knot of Wisdom (HORDE) (278267 SPELLID)
		161417,	--Ancient Knot of Wisdom (ALLIANCE) (278267 SPELLID)
		169318,	--Shockbiter's Fang
		168973,	--Neural Synapse Enhancer
		159630,	--Balefire Branch
		}

		for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then table.insert( equipped_items, trinkets[i] ) end end

		local extra_items = {
		159624,	--Rotcrusted Voodoo Doll
		169305,	--Aquipotent Nautilus
		168905,	--Shiver Venom Relic
		173944,	--Forbidden Obsidian Claw
		167677,	--Harmonic Dematerializer
		167835,	--Malformed Herald's Legwraps
		168989,	--Hyperthread Wristwraps (300142 SPELLID)
		167672,	--Cyclotronic Blast (293491 SPELLID)
		165576,	--Tidestorm Codex (289885 SPELLID)
		}

		for i=1,#extra_items do if IsEquippedItem ( extra_items[i] ) then table.insert( equipped_items, extra_items[i] ) end end

		local auto_cc = SQUID.auto_cc
		local only_cc_healers = SQUID.only_cc_healers

		local icicles = _buffStacks("player",205473)

		local pet
		local pet_hp = 100
		local pet_cast_id,pet_cast_target
		local pet_exists = UnitIsVisible("pet")
		if pet_exists then
			pet = ObjectPointer("pet")
			pet_hp = _HP(pet)
			pet_status = squid_pet_status
			pet_cast_id,_,pet_cast_target = UnitCastID(pet)
		end
		local pet_position = {ObjectPosition("pet")}

		if pet_cast_id == 0 then pet_cast_id = nil pet_cast_target = nil end

		local frost_lockout = _spellCooldown(116) > gcd_remains and _spellCooldown(116) or 0
		local arcane_lockout = _spellCooldown(118) > gcd_remains and _spellCooldown(118) or 0
		local ring_cd = _spellCooldown(113724)
		local comet_cd = _spellCooldown(153595)
		local ice_nova_cd = _spellCooldown(157997)
		local remove_curse_cd = _spellCooldown(475)
		local veins_cd = _spellCooldown(12472)
		local blink_cd = _spellCooldown(212653)
		local ray_of_frost_cd = _spellCooldown(205021)
		local coc_cd = _spellCooldown(120)
		local freeze_cd = pet_exists and _spellCooldown(33395) or 99
		local orb_cd = _spellCooldown(198149)

		local fof_remains = _buffRemains("player",44544)
		local fof_stacks = fof_remains > 0 and _buffStacks("player",44544) or 0
		local fof = fof_stacks > 0
		local brain_freeze_remains = _buffRemains("player",190446)
		local brain_freeze = brain_freeze_remains > 0
		local temp_up = UnitBuffID("player",198111)
		local rune_of_power_up = UnitBuffID("player",116014)

		local ice_lance_effect_raw = GetSpellEffect(30455)
		local ice_lance_effect = ice_lance_effect_raw * (fof and 3 or 1)

		local freezing_rain = UnitBuffID("player",270232)
		local ice_nova_enabled = IsPlayerSpell(157997)
		local lonely_winter_enabled = IsPlayerSpell(205024)
		local ebonbolt_enabled = IsPlayerSpell(257537)
		local spike_enabled = IsPlayerSpell(199786)
		local ring_enabled = IsPlayerSpell(113724)
		local comet_enabled = IsPlayerSpell(153595)
		local ebonbolt_enabled = IsPlayerSpell(257537)
		local veins_remains = _buffRemains("player",12472)
		local veins = veins_remains > 0

		local klepto_enabled = IsPlayerSpell(198100)

		local spike_range = 40

		local sheep_range = 30

		local ring_range = 30

		local frostbolt_cast_time = _castTime(116)
		local ebonbolt_cast_time = _castTime(257537)
		local poly_cast_time = _castTime(118)
		local ring_cast_time = _castTime(113724)
		local spike_cast_time = _castTime(199786)
		local fireball_cast_time = _castTime(133)
		local scorch_cast_time = _castTime(2948)
		local rune_of_power_cast_time = _castTime(116011)

		local comet_in_flight = comet_cd > 27
		local comet_in_flight_remains = (3 - ( 30 - comet_cd )) - buffer

		local orb_out = orb_cd > 50

		local enemies_on_player,enemy_melee_on_player,enemy_ranged_on_player,enemy_cds_on_player = EnemiesAttacking("player")

		local player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")
		local player_cast_target = UnitSpellTarget("player")
		local player_cast_time_left = _castTimeLeft("player")
		local player_cast_percent_complete = _castPctDone("player")
		local player_interruptable = PlayerCanBeKicked()

		if player_cast_id == 118 then
			poly_cast_delay = time
			poly_cast_target = player_cast_target
		end

		if player_cast_id == 113724 then
			ring_cast_delay = time
		end

		--gui setting, disable movement stop for cc
		local move_setting = SQUID.stop_to_cc

		local cc_casts = {118,113724}
		local player_casting_non_cc = player_cast and not tContains(cc_casts,player_cast_id)
		local player_casting_cc = player_cast and tContains(cc_casts,player_cast_id)

		local shatter_casts = {116,257537,199786}
		local player_casting_shatterable_damage = player_cast and tContains(shatter_casts,player_cast_id)
		local player_casting_guaranteed_shatter = player_cast and tContains(shatter_casts,player_cast_id) -- and ??? fixme

		--ice barrier absorb
		local ice_barrier_up,_,_,_,_,_,_,_,_,_,_,_,_,_,_,ice_barrier_absorb = UnitBuffID("player",11426)
		local barrier_remains = ice_barrier_up and ice_barrier_absorb or 0

		local sheeped_target
		local sheeped_target_duration = 0
		for i=1,#Enemies do
			local remains = _debuffRemains(Enemies[i],118,"player")
			-- if _debuffRemains(Enemies[i],82691,"player") > remains then remains = _debuffRemains(Enemies[i],82691,"player") end
			if remains > 0 then
				sheeped_target = Enemies[i]
				sheeped_target_duration = remains
			end
		end

		local their_healer = theirHealer
		local their_healer_cc
		local their_healer_cc_remains = 0
		local their_healer_incapacitate_dr
		local their_healer_incapacitate_dr_remains = 0
		local their_healer_disorient_dr
		local their_healer_disorient_dr_remains = 0
		local their_healer_important_lockout
		if their_healer then
			if not UnitIsDeadOrGhost(their_healer) then
				their_healer_cc_remains = _CCremains(their_healer)
				their_healer_cc = their_healer_cc_remains > 0
				their_healer_incapacitate_dr = _incapacitateDR(their_healer)
				their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
				their_healer_disorient_dr = _disorientDR(their_healer)
				their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

				local class = select(2,UnitClass(their_healer))

				local locked,remaining,school = UnitIsLocked(their_healer)

				if locked and remaining > .25 then
					if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
					or ( class == "SHAMAN" and school == "Nature" )
					or ( class == "PALADIN" and school == "Holy" )
					or ( class == "MONK" and school == "Nature" )
					or ( class == "DRUID" and school == "Nature" )  then
						their_healer_important_lockout = true
					end
				end
			else -- no healer if he dead
				their_healer = nil
			end
		end

		if not their_healer then
			their_healer_cc = true
			their_healer_cc_remains = 100 - (lowestEnemy*1.5)
			their_healer_cc_remains = their_healer_cc_remains > 8 and 8 or their_healer_cc_remains
			their_healer_cc_remains = their_healer_cc_remains < 0 and 0 or their_healer_cc_remains
		end

		local friendly_rogue
		for i=1,#Friends do if select(2,UnitClass(Friends[i])) == "ROGUE" then
			friendly_rogue = Friends[i]
		end end

		local friendly_rogue_blind_cd
		if friendly_rogue then
			friendly_rogue_blind_cd = UnitCooldown(friendly_rogue,2094)
		end

		local our_healer
		local our_healer_cc
		if ourHealer then
			our_healer = ourHealer
			if _CCcheck(ourHealer) then our_healer_cc = true end
		end

		-- enemy players count
		local enemy_players = 0
		for i=1,#Enemies do if unit_is_player(Enemies[i]) then
			enemy_players = enemy_players + 1
		end end

		-- team clone cast count
		local team_clone_cast = {}
		for i=1,#Friends do if UnitCastingInfo(Friends[i]) == "Cyclone" then
			local ut = UnitSpellTarget(Friends[i])
			if ut then
				team_clone_cast[ut] = true
			end
		end end

		local not_moving_duration = 0

		if _isMoving("player") then
			not_moving_duration = 0
			last_move = time
		else
			if not last_move then last_move = time end
			not_moving_duration = time - last_move
		end

		local function comet_storm(unit)
			if comet_cd > gcd then return false end
			if breakable_cc_around(unit,8.5) then return false end
			-- if player_casting_shatterable_damage and comet_cd == 0 and player_cast_time_left > .5 then SpellStopCasting() end
			if _Cast(153595,unit) then
				return true
			end
		end

		local function ice_nova(unit)
			if ice_nova_cd > gcd then return false end
			if breakable_cc_around(unit,8.25) then return false end
			if _Cast(157997,unit) then
				return true
			end
		end

		local function pet_freeze(unit)
			if freeze_cd > 0 then return false end
			if not pet_exists then return false end
			if not _immuneMagic(unit) and not _rootImmuneCheck(unit) and _rootDR(unit) > .25 then
				local x,y,z = ObjectPosition(unit)
				local px,py,pz = unpack(pet_position)
				local freeze_x,freeze_y,freeze_z
				if GetDistanceBetweenPositions(x,y,z,px,py,pz) < 49 then
					local step = (math.pi*2) / 8
					for dist=.5, 4, .5 do
						if freeze_x and freeze_y and freeze_z then break end
						for i=0, math.pi*2, step do
							local fx, fy, fz = GroundZ (x + dist * math.cos(i), y + dist * math.sin(i), z)
							if fx and fy and fz and not TraceLine(fx, fy, fz+1.7, px, py, pz+1.7, 0x100111) and not TraceLine(fx, fy, fz+1.7, x, y, z+1.7, 0x100111) and GetDistanceBetweenPositions(fx,fy,fz,px,py,pz) < 45 then--TraceLine(x + 7.25 * math.cos(i), y + 7.25 * math.sin(i), z+2, px, py, pz+2, 0x100111) then
								freeze_x, freeze_y, freeze_z = fx, fy, fz
								break
							end
						end
					end
				end
				if freeze_x and freeze_y and freeze_z then
					CastSpellByID(33395)
					ClickPosition(freeze_x,freeze_y,freeze_z)
					_targetLastTarget()
					return true
				end
			end
		end

		local function frozen_orb(unit)
			if orb_cd > gcd then return false end
			if breakable_cc_around(unit,12) then return false end
			if _aeCastInMovingDirection(198149,unit,GetUnitSpeed(unit)/3,40,3) then return true end
		end

		local function cone_of_cold(unit)
			if coc_cd > gcd then return false end
			if bcc_facing(unit,10,45) then return false end
			if UnitIsFacing("player",unit,45) and _distance(unit) < 8 then
				if _Cast(120) then return true end
			end
		end

		local function unit_freeze_remains(unit)
											--petfreeze				--flurry                      --nova               --glacial spike
			return max( _debuffRemains(unit,33395), _debuffRemains(unit,228358), _debuffRemains(unit,122), _debuffRemains(unit,228600) )

		end

		local function unit_frozen(unit)

			return unit_freeze_remains(unit) > buffer + .1

		end

		local t = current_target

		local m_i_r = t and magic_immunity_remains(t,true) or 0

		local target_dist = _distance(t)

		local function valid_magic(after,unit)

			if not unit then unit = t end
			if not unit then return false end
			if not UnitIsVisible(unit) then return false end

			if UnitIsDeadOrGhost(unit) then return false end

			if arena and not unit_is_player(unit) then return false end

			if not arena and not UnitAffectingCombat(unit) and not _isDummy(unit) and not unit_is_player(unit) then return false end

			if UnitCanAttack("player",unit)
			and (not _breakableCC(unit) or not arena and not unit_is_player(unit))
			and (unit == t and m_i_r <= after or magic_immunity_remains(unit,true) <= after) then
				return true
			end

		end

		--Keybindz
		if freeze_healer then
			if their_healer then
				if pet_freeze(their_healer) then
					Squid_Alert("Pet Freeze","(Healer)",nil,nil,33395)
					return
				end
			else
				local str = "|cFFa665cdHealer Not Found!"
				Squid_Alert(str,"(Freeze)",nil,nil,33395)
			end
		end

		if freeze_focus then
			if current_focus then
				if pet_freeze(current_focus) then
					Squid_Alert("Pet Freeze","(Focus)",nil,nil,33395)
					return
				end
			else
				local str = "|cFFa665cdFocus Not Found!"
				Squid_Alert(str,"(Freeze)",nil,nil,33395)
			end
		end

		if freeze_target then
			if current_target then
				if pet_freeze(current_target) then
					Squid_Alert("Pet Freeze","(Target)",nil,nil,33395)
					return
				end
			else
				local str = "|cFFa665cdTarget Not Found!"
				Squid_Alert(str,"(Freeze)",nil,nil,33395)
			end
		end

		if meteor_key then
			if valid_magic(0) then
				frozen_orb(current_target)
			end
		end

		mage_next_cc_target = nil
		mage_next_cc_nooverride = nil
		mage_next_cc = nil
		mage_next_cc_dr = nil
		mage_next_cc_time = nil

		if _silenceCheck("player") then return end

		local bcc12 = _bccAM(12)

		local ttd = squid_ttd

		--nova stealth
		if not bcc12 then
			for i=1,#Enemies do if _stealthCheck(Enemies[i]) and _distance(Enemies[i]) < 8 then
				if _Cast(122) then
					Squid_Alert_Big("Nova " .. UnitClass(Enemies[i]),"(Stealth)",1,nil,122)
				end
			end end
		end

		--nova thing from beyond
		if not bcc12 and (not legendary_cloaked or time - legendary_cloaked > 4.5) and UnitDebuffID("player",319695) then
			for i=1,#things_from_beyond do
				local thing = things_from_beyond[i]
				if _realDistance(thing) < 11.25 then
					if _Cast(122) then
						Squid_Alert_Big("Frost Nova","(Thing From Beyond)",4,nil,122)
					end
				end
			end
		end

		local mage_stop_moving = false

		if IsMounted() or IsFlying() or UnitBuffID("player",66) or UnitBuffID("player",32612) or UnitBuffID("player",45438) or UnitBuffID("player",110960) or not player_has_control() then return end --32612

		local thp = _HP(t)

		--magic defensive remains
		local MDR = valid_magic(0) and magic_defensive_remains(t) or 0

		local active_enemies = t and Enemies_Around_Unit(t,10) + 1 or 0

		local current_cast = UnitCastingInfo("player")

		--engage load mode when the enemy team is locked down
		local load_mode = valid_magic(0) and ( ( their_healer and ( their_healer_cc_remains >= 1.5 or their_healer_important_lockout ) ) or veins_remains > 0 or orb_out or _stunRemains(t) > 0 or _HP(t) < 30 * ((their_healer or not arena) and 1 or 2.3) or unit_is_unit(their_healer,t) and _HP(t) < 60 + ( ( _stunCheck(t) or _drRemains(t,"stun") > 14 ) and 35 or 0 ) )

		--engage load mode when burst mode is forced
		if Squid_Burst then load_mode = true end

		local load_target = valid_magic(0) and ( _stunCheck(t) or _HP(t) < 30 * ( their_healer_cc and 2 or 1 ) )

		--disable load mode when the enemy trades a defensive, unless already stunned or combusting
		if load_mode and _stunRemains(t) == 0 and combustion_remains == 0 then

			--not wasting this precious load on your magic defenses
			if MDR > 0 then
				load_mode = nil
			end

		end

		load_mode_active = load_mode

		local fcast_hp = 15
		fcast_hp = fcast_hp + (our_healer_cc and 25 or 0)

		if _spellCooldown(45438) > 6 then fcast_hp = 0 end

		if not our_healer then fcast_hp = 5 end

		local dont_cast_frost = player_interruptable and player_hp < fcast_hp

		-- comet_target (target comet storm was recently used on)

		local function cc(unit)

			local player_forced

			if cc_focus_key and unit_is_unit(unit,current_focus) then player_forced = true end
			if cc_offtarget_key or cc_healer_key then player_forced = true end

			if not arena and not unit_is_player(unit) and not player_forced then return 69 end

			--stop if no unit
			if not unit or not UnitIsVisible(unit) then return 69 end

			--do not sheep? (ext. func)
			if DoNotSheep(unit) then return 69 end

			--dist to unit
			local dist = _distance(unit)

			local immunity_remains = max( magic_immunity_remains(unit), cc_immunity_remains(unit) )

			--this function should not only cc, but also return the time until cc needs to happen
			--this is to keep it from starting casts that will get in the way of getting perfect cc on dr
			local time_to_cc = 0

			--check cc
			local ccr = _CCremains(unit)
			local cc = ccr > 0

			--incap drs
			local idr = _incapacitateDR(unit)
			local idr_remains = _drRemains(unit,"incapacitate")

			--sheep immunities. beast or dummy is all i can think of right now. added in Moonkin Form for resto
			local immune_sheep = _isBeast(unit) or _isDummy(unit) or UnitBuffID(unit, 197625)

			--meteor?
			local standing_in_meteor = UnitDebuffID(unit,155158)

			--yea dont cc into it
			if standing_in_meteor then return 69 end

			--orb?
			local standing_in_orb = UnitDebuffID(unit,289308)

			--nope
			if standing_in_orb then return 69 end

			--banner?
			local banner = UnitBuffID(unit,236321)

			--yea dont cc into it...unless
			if banner then return 69 end

			--incap on unit?
			local incap = _incapacitateCheck(unit)

			--healer?
			local is_healer = _isHealer(unit)

			--lockout?
			local lockout = IsLocked(unit,true)

			--los?
			local los = _LoS(unit)

			--druid?
			local is_druid = select(2,UnitClass(unit)) == "DRUID"

			--charmed friend?
			local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

			if friendly then return 69 end

			--ring to followup cc, if the unit is a beast, or we are locked on sheep
			local time_til_ring_ready = 69
			if immunity_remains < ring_cast_time and (not ring_cast_delay or time - ring_cast_delay > .25) and (not poly_cast_delay or time - poly_cast_delay > .25 or arcane_lockout > 0) and (not UnitDebuffID(unit,33786) or (_debuffRemains(unit,33786) < ring_cast_time and _debuffRemains(33786) > ring_cast_time-(buffer*1.5))) then
				if idr >= .5 or lowestEnemy < 35 and idr >= .25 then
					if arcane_lockout > 0 or immune_sheep or ccr > ring_cast_time - buffer or (sheeped_target and not unit_is_unit(unit,sheeped_target)) then
						local poly_cast_time_extra = poly_cast_time + buffer
						local max_overlap = ring_cast_time + (buffer*2.65) + (player_interruptable and idr >= .5 and poly_cast_time_extra or 0) --arcane_lockout < ring_cast_time and
						local ring_ready = ring_enabled and ring_cd <= gcd and ccr > ring_cast_time-buffer and ccr <= max_overlap and (idr == 1 or (not los or arcane_lockout > gcd_remains or player_interruptable) and idr >= .5)

						if ring_ready and dist < ring_range then
							--alert when moving, stop casting scorch when not
							local can_ring = ring_of_frost(unit)
							if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Ring)",nil,nil,113724)
							elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
							mage_stop_moving = can_ring
							time_to_cc = 0
							if not mage_next_cc then
								mage_next_cc = 113724
							end
							mage_next_cc_time = 0
						end

						time_til_ring_ready = ccr > ring_cast_time + buffer and math.max(ring_cd,ccr,idr == 1 and 0 or idr == .5 and arcane_lockout > gcd_remains and 0 or idr_remains) or 69
					end
				end
			end

			--sheep, if drs are available, and the unit is not immune
			local time_til_poly_ready = 69
			local max_overlap = poly_cast_time + (buffer*2.55) + (player_interruptable and idr >= .5 and ( ring_cd <= gcd or SQUID.auto_juke ) and ring_cast_time + buffer + ( SQUID.auto_juke and buffer or 0 ) or 0) -- + (idr >= .5 and ring_cd < gcd and ccr > ring_cast_time and ring_cast_time or 0)
			if los and (not ring_cast_delay or time - ring_cast_delay > .3 or ring_cd > gcd_remains) and (not poly_cast_delay or time - poly_cast_delay > .15) then --no sheep into lockout, unless they're casting another school
				if not immune_sheep and (lockout <= poly_cast_time + (buffer*2.5) + (player_interruptable and poly_cast_time or 0) or UnitCastingInfo(unit)) then

					local sheep_dr_ready = idr == 1 or (idr >= .25 and idr_remains > 17.25 - (ccr >= poly_cast_time and 8 * idr or 0) - (incap and ccr >= poly_cast_time-.2 and 6 * idr or 0) - ((100-lowestEnemy) * .038) + (idr == .25 and 1 or 0) ) or ( idr_remains < poly_cast_time-(buffer/2) and ( idr_remains ~= 0 or idr == 1 ) )

					-- print(sheep_dr_ready, idr, idr_remains)
					-- local sheep_time_til_ready = idr == 1 and ccr or (idr >= .25 and idr_remains > 17 - (ccr > 1 and 6 * idr or 0)) and ccr or idr_remains
					local no_sheeps_out = not sheeped_target or unit_is_unit(unit,sheeped_target) or _incapacitateDR(sheeped_target) < .25 or (is_healer and idr == 1) or (not _isHealer(sheeped_target) and _incapacitateDR(sheeped_target) <= .5 and _drRemains(sheeped_target,"incapacitate") > 3 and _drRemains(sheeped_target,"incapacitate") < 16.5)
					if sheep_dr_ready and no_sheeps_out then

						if ccr < max_overlap and dist < sheep_range then
							if arcane_lockout <= buffer then
								if immunity_remains <= poly_cast_time+(buffer*.45) then
									--alert when moving, stop casting scorch when not
									if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Sheep)",nil,nil,118) mage_stop_moving = true
									elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
									mage_stop_moving = true
									if (not poly_cast_delay or time-poly_cast_delay > .2) and _Cast(118,unit) then
										Squid_Alert("Sheeping",UnitClass(unit),nil,3,118)
									end
									time_to_cc = 0
									if not mage_next_cc then
										mage_next_cc = 118
									end
									mage_next_cc_time = 0
								end
							else
								time_to_cc = math.max(arcane_lockout,time_to_cc)
							end
						else
							time_to_cc = math.max(ccr,time_to_cc)
						end

						local immune_val = 0
						if immunity_remains > 0 then
							immune_val = max ( immunity_remains - poly_cast_time - (buffer * .45), 0 )
						end

						time_til_poly_ready = math.max(ccr-max_overlap,idr_remains < 17 and idr_remains or 0,arcane_lockout,immune_val)

						if immune_sheep and not is_healer then time_til_poly_ready = 69 end

					end
				end
			end

			local val = math.min(time_til_ring_ready,time_til_poly_ready)

			--next cc unit used for drawings
			mage_next_cc_target = unit

			--default to sheep if no other cc defined above
			if not mage_next_cc then mage_next_cc = 118 end

			--display dr
			if mage_next_cc == 118 or mage_next_cc == 113724 then
				mage_next_cc_dr = idr
				mage_next_cc_time = val >= 69 and idr_remains or val
			end

			return val

		end

		--designate highest prio to cc on healer (returning 69 will fall back to off dps cc)
		local function healer_cc()

			local healers = {}

			for i=1,#Enemies do if _isHealer(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) then
				local unit = Enemies[i]
				if _distance(unit) < sheep_range then
					local friends_attacking = UnitEnemiesAttacking(unit)
					local unit_hp = _HP(unit)
					if friends_attacking == 0 then
						table.insert(healers,unit)
					end
				end
			end end

			local soonest = 69
			for i=1,#healers do
				local val = cc(healers[i])

				if val < soonest then
					soonest = val
				end

			end

			return soonest

		end

		--cc off dps while waiting for dr on healer, or to secure cc on healer while they have interrupts available
		local function off_cc()

			if only_cc_healers then return 69 end

			local units = {}

			for i=1,#Enemies do
				local e = Enemies[i]
				if unit_is_player(e) then--or (UnitIsHunterPet(e) and combustion_cd <= 2) then
					if not unit_is_unit(e,current_target) and _distance(e) < sheep_range and _LoS(e) then
						local friends_attacking = UnitEnemiesAttacking(e)
						local unit_hp = _HP(e)
						if friends_attacking == 0 then
							local min_hp = 70
							min_hp = min_hp - (our_healer_cc and 20 or 0)
							min_hp = min_hp - (_CDcheck(e) and 20 or 0)
							min_hp = min_hp - (lowestFriend < 40 and 20 or 0)
							if unit_hp > min_hp then
								table.insert(units,e)
							end
						end
					end
				end
			end

			local soonest = 69
			for i=1,#units do
				local val = cc(units[i])

				if val < soonest then
					soonest = val
				end
			end

			return soonest

		end

		local function pet_control()

			if not lonely_winter_enabled and not pet_exists then
				if _Cast(31687) then
					Squid_Alert("Summon Pet",nil,nil,nil,31687)
				end
			end

			if not pet_exists then return end

			local pull_back

			if pet_cast_id and UnitIsVisible(pet_cast_target) then
				if _breakableCC(pet_cast_target) then
					pull_back = true
				end
			end

			if pull_back then
				if not pet_follow_sent or time - pet_follow_sent > 1 then
					PetFollow()
					pet_follow_sent = time
				end
			elseif valid_magic(2) then
				if not pet_attack_sent or time - pet_attack_sent > 1 then
					PetAttack(t)
					pet_attack_sent = time
				end
			else
				if not pet_follow_sent or time - pet_follow_sent > 1.5 then
					PetFollow()
					pet_follow_sent = time
				end
			end

		end

		local function priority_shit(max_cast_time)

			local target_stun = UnitExists(t) and _stunRemains(t) or 0

			if UnitExists(t) and _isDummy(t) then target_stun = 10 end

			--on use with veins
			if veins then

				local race = UnitRace("player")

				if race == "Orc" then
					SQ_CastSpellByName("Blood Fury")
				end

				if UnitBuffID("player",313948) then
					RunMacroText("/cancelaura Manifesto of Madness: Chapter One")
					Squid_Alert( "Manifesto of Madness", "(CANCEL)", nil, nil, 313948 )
				end

				if tContains( equipped_items, 161377 ) and GetItemCD ( ( 161377 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 161377 ) ) )
					Squid_Alert( "Azurethos' Singed Plumage", nil, nil, nil, 278383 )
				end

				if ( tContains( equipped_items, 167380 ) and GetItemCD ( ( 167380 ) ) == 0 )
				or ( tContains( equipped_items, 172669 ) and GetItemCD ( ( 172669 ) ) == 0 )
				or ( tContains( equipped_items, 165058 ) and GetItemCD ( ( 165058 ) ) == 0 ) then
					UseItemByName( tostring( GetItemInfo ( 167380 ) ) )
					UseItemByName( tostring( GetItemInfo ( 172669 ) ) )
					UseItemByName( tostring( GetItemInfo ( 165058 ) ) )
					Squid_Alert( "Gladiator's Badge", nil, nil, nil, 277185 )
				end

				if ( tContains( equipped_items, 172666 ) and GetItemCD ( ( 172666 ) ) == 0 )
				or ( tContains( equipped_items, 167377 ) and GetItemCD ( ( 167377 ) ) == 0 )
				or ( tContains( equipped_items, 165055 ) and GetItemCD ( ( 165055 ) ) == 0 ) then
					UseItemByName( tostring( GetItemInfo ( 172666 ) ) )
					UseItemByName( tostring( GetItemInfo ( 167377 ) ) )
					UseItemByName( tostring( GetItemInfo ( 165055 ) ) )
					Squid_Alert( "Gladiator's Medallion", nil, nil, nil, 277179 )
				end

				if tContains( equipped_items, 159630 ) and GetItemCD ( ( 159630 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 159630 ) ) )
					Squid_Alert( "Balefire Branch", nil, nil, nil, 268999 )
				end

				if tContains( equipped_items, 169318 ) and GetItemCD ( ( 169318 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 169318 ) ) )
					Squid_Alert( "Shockbiter's Fang", nil, nil, nil, 303953 )
				end

				if tContains( equipped_items, 161411 ) and GetItemCD ( ( 161411 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 161411 ) ) )
					Squid_Alert( "T'zane's Barkspines", nil, nil, nil, 278227 )
				end

				if ( tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 )
				or ( tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 ) then
					UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
					UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
					Squid_Alert( "Knot of Wisdom", nil, nil, nil, 278267 )
				end

				if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
					Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
				end

				if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
					Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
				end

				if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
					Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
				end

			end

			if not _stealthCheck("player") then

				if not utilities_only then

					--shatter comet storm damage (ice nova / pet freeze / flurry)
					if comet_in_flight and comet_in_flight_remains > 1.3 then
						local ct = comet_target
						if UnitIsVisible(ct) then
							if not unit_frozen(ct) then
								--flurry if immune to roots
								if _rootImmuneCheck(ct) and brain_freeze then
									if _Cast(44614,ct,nil,true) then
										Squid_Alert("Flurry","(Comet Shatter)",nil,nil,44614)
										return
									end
								--ice nova
								elseif ice_nova(ct) or ice_nova_cd <= gcd_remains or ice_nova_cd > 24 then return true
								--pet freeze
								elseif not _rootImmuneCheck(ct) and comet_in_flight_remains <= 1.5 + buffer then
									if pet_freeze(ct) then
										Squid_Alert("Pet Freeze","(Comet Shatter)",nil,nil,33395)
										return
									end
								end
							end
						end
					end

					--orb it up
					if (their_healer_cc or not their_healer) and load_mode and valid_magic(0) and (unit_is_player(t) or _isDummy(t)) and (not _slowImmuneCheck(t) or target_stun > 0) then
						frozen_orb(t)
					end

					--comet storm at the appropriate time
					if load_mode and valid_magic(0.3) and (unit_is_player(t) or _isDummy(t)) then
						if target_stun > 0 or _isSlowed(t) then
							if ice_nova_cd <= gcd or freeze_cd <= gcd then
								comet_storm(t)
							end
						end
					end

				end

				--essences
				if max_cast_time >= gcd then
					--breath of the dying
					if IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd_remains and valid_magic(0) then
						local hp = (100 * (UnitHealth(t)-GetSpellEffect(310690)) / UnitHealthMax(t));
						if hp < 20 or (hp < 90 and _HP(t) > 80) or load_mode then
							if hp < 20 or _HP(t) > 80 or load_mode then
								if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) then
									if _Cast(310690,t,true) then
										Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
									end
								end
							end
						end
					end
					if IsPlayerSpell(295373) then
						local stacks = _buffStacks("player",295378)
						if valid_magic(0) and (load_mode or (GetSpellCharges(295373) == 2 and stacks < 2) or stacks == 0 or _HP(t) < 8*stacks) then
							local str = stacks == 1 and "1 Stack" or stacks .. " Stacks"
							if not poly_cast_delay or time - poly_cast_delay > .3 or not unit_is_unit(poly_cast_target,t) then
								if _Cast(295373,t,true) then
									Squid_Alert("Crucible of Flame",str,nil,nil,295373)
								end
							end
						end
					end
				end
			end
		end

		local function standard_rotation(max_cast_time)

			local target_stun = UnitExists(t) and _stunRemains(t) or 0

			--ice barrier high prio
			local barrier_hp = 25
			barrier_hp = barrier_hp + (enemies_on_player * 50)
			barrier_hp = barrier_hp + (not our_healer and 75 or our_healer_cc and 75 or 0)
			barrier_hp = barrier_hp + (enemy_cds_on_player * 100)
			barrier_hp = barrier_hp - (load_target and 40 or 0)

			--why die before using ice barrier?
			if barrier_hp < 5 then
				barrier_hp = 5
			end

			--why use ice barrier when invincible?
			if player_immune then barrier_hp = 0 end

			if max_cast_time > gcd and player_hp < barrier_hp and barrier_remains < 12000 and (not temp_up or _HP("player") < 30) then
				if _Cast(11426) then
					Squid_Alert("Ice Barrier",nil,nil,nil,11426)
					return
				end
			end

			local shattering_target

			--flurry to shatter
			if valid_magic(0) and not shattering_target and max_cast_time > gcd then
				if ( brain_freeze or player_cast_id == 257537 ) and ( player_casting_shatterable_damage or load_mode and not fof and ( dont_cast_frost or _isMoving("player") ) and not unit_frozen(t) ) then
					SQ_CastSpellByID(44614,t)
					shattering_target = true
				end
			end

			--pet freeze to shatter
			if valid_magic(0) and load_mode and not shattering_target then
				if player_casting_shatterable_damage and player_cast_time_left < buffer * 2 then
					if pet_freeze(t) then
						Squid_Alert("Pet Freeze","(Shatter " .. player_cast .. ")",nil,nil,33395)
						shattering_target = true
					end
				end
			end

			--prio ice lance
			if valid_magic(0) then
				if fof_stacks >= 2 - (load_mode and 1 or 0) or unit_frozen(t) then
					if _Cast(30455,t) then return end
				end
			end

			--temp shield
			local temp_hp = 5
			temp_hp = temp_hp + ( (enemies_on_player * 15) * (not our_healer and 1.85 or our_healer_cc and 2 or 1) )
			temp_hp = temp_hp + (not our_healer and 15 or our_healer_cc and 30 or 0)
			temp_hp = temp_hp + (enemy_cds_on_player * 40)

			if auto_temp and player_hp < temp_hp and barrier_remains < 5500 then
				if _Cast(198111) then
					Squid_Alert_Big("Temp Shield",nil,nil,nil,198111)
					return
				end
			end

			--pre barrier or temp doesnt matter
			if gpy_on_player then
				if not temp_up and _Cast(11426) then
					Squid_Alert_Big("Ice Barrier","Greater Pyro",nil,nil,11426)
					return
				elseif barrier_remains < 35000 and _Cast(198111) then
					Squid_Alert_Big("Temp Shield","Greater Pyro",nil,nil,198111)
					return
				end
			end

			--pre barr or temp doesnt matter
			if big_dmg_inc and (our_healer_cc or not our_healer or rly_big_dmg_inc or _HP("player") < 50) then
				local spell = GetSpellInfo(big_dmg_inc)
				if barrier_remains < 9000 and _Cast(198111) then
					Squid_Alert_Big("Temp Shield",spell,nil,nil,198111)
					return
				elseif not temp_up and _Cast(11426) then
					Squid_Alert_Big("Ice Barrier",spell,nil,nil,11426)
					return
				end
			end

			--pre barr or temp doesnt matter
			if _debuffRemains("player",274838) > 5.5 then
				if not temp_up and _Cast(11426) then
					Squid_Alert_Big("Ice Barrier","Feral Frenzy",nil,nil,11426)
					return
				elseif barrier_remains < 11000 and _Cast(198111) then
					Squid_Alert_Big("Temp Shield","Feral Frenzy",nil,nil,198111)
					return
				end
			end

			--pre barr cc
			if cc_flying_towards_player then
				local spell = GetSpellInfo(cc_flying_towards_player)
				if barrier_remains < 18000 and _Cast(11426) then
					Squid_Alert_Big("Ice Barrier",spell,nil,nil,11426)
					return
				end
			end

			--ray
			if load_mode and max_cast_time > 3.25 and valid_magic(0) and not _slowImmuneCheck(t) then
				if not dont_cast_frost then
					if _Cast(205021,t) then
						Squid_Alert("Ray of Frost",nil,nil,nil,205021)
					end
				end
			end

			--ebonbolt
			if max_cast_time > ebonbolt_cast_time and ebonbolt_enabled and load_mode and not fof and valid_magic(ebonbolt_cast_time) then
				if _Cast(257537,t) then return end
			end

			--cone
			for i=1,#Enemies do if not _slowImmuneCheck(Enemies[i]) and not _immuneMagic(Enemies[i]) and not _CCcheck(Enemies[i]) and not _rootCheck(Enemies[i]) then
				if cone_of_cold(Enemies[i]) then
					Squid_Alert("Cone of Cold",UnitClass(Enemies[i]),nil,nil,120)
					return
				end
			end end

			--spellsteals
			if not combustion and valid_magic(0) and max_cast_time > gcd then
				local ss = Basic_Spellsteal(t)
				if ss and _Cast(30449,t,nil,true) then
					Squid_Alert("Spellsteal " .. UnitClass(t),"("..GetSpellInfo(ss)..")",nil,nil,30449)
				end
			end

			--frostbolt fallthru
			if max_cast_time > frostbolt_cast_time and not dont_cast_frost and valid_magic(frostbolt_cast_time) then
				_Cast(116,t)
			end

			--rebuff intellect
			local someone_missing_int
			for i=1,#Friends do if not UnitBuffID(Friends[i],1459) and _distance(Friends[i]) < 40 and not UnitCanAttack("player",Friends[i]) and (not combat or not _isMeleeDps(Friends[i])) then
				someone_missing_int = true
			end end
			-- dont rebuff while casting
			if max_cast_time > gcd and someone_missing_int and not UnitCastingInfo("player") then
				if _Cast(1459,"player") then
					Squid_Alert("Rebuff",nil,nil,nil,1459)
					return
				end
			end

			--conjure food
			if GetItemCount(113509) == 0 then
				if UnitBuffID("player",32727) and GetNumGroupMembers() > 1 then
					_Cast(190336)
				end
				if Free_Bag_Slots() > 0 and (not food_already_clicked or time - food_already_clicked > 2 or (GetItemCount(113509) >= 20 and GetItemCount(113509) <= 40)) then
					InteractUnit("Refreshment Table")
					food_already_clicked = time
				end
			end

			--dispel dots
			local function low_prio_dispel(unit)
				local agony_stacks = _debuffStacks(unit,980)
				if agony_stacks >= 6 then
					return 980
				end
			end

			if remove_curse_cd <= gcd_remains and max_cast_time > gcd then
				for i=1,#Friends do
					local dispel = low_prio_dispel(Friends[i])
					if dispel and _LoS(Friends[i]) then
						if _Cast(475,Friends[i]) then
							Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,475)
						end
					end
				end
			end

		end

		--burst mode
		if valid_magic(0) and Squid_Burst then

			--lucid dreams
			if IsPlayerSpell(298357) then
				if _Cast( 298357 ) then
					Squid_Alert( "Memory of Lucid Dreams", nil, nil, nil, 298357 )
					return
				end
			end

			--combust
			if veins_cd <= .5 then
				SQ_CastSpellByID ( 12472 )
				Squid_Alert_Big( "Icy Veins", nil, nil, nil, 12472 )
			end

			--racials
			local race = UnitRace("player")
			if race == "Orc" then
				SQ_CastSpellByName("Blood Fury")
			end

			--items
			if UnitBuffID("player",313948) then
				RunMacroText("/cancelaura Manifesto of Madness: Chapter One")
				Squid_Alert( "Manifesto of Madness", "(CANCEL)", nil, nil, 313948 )
			end

			if tContains( equipped_items, 161377 ) and GetItemCD ( ( 161377 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 161377 ) ) )
				Squid_Alert( "Azurethos' Singed Plumage", nil, nil, nil, 278383 )
			end

			if ( tContains( equipped_items, 167380 ) and GetItemCD ( ( 167380 ) ) == 0 )
			or ( tContains( equipped_items, 172669 ) and GetItemCD ( ( 172669 ) ) == 0 )
			or ( tContains( equipped_items, 165058 ) and GetItemCD ( ( 165058 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 167380 ) ) )
				UseItemByName( tostring( GetItemInfo ( 172669 ) ) )
				UseItemByName( tostring( GetItemInfo ( 165058 ) ) )
				Squid_Alert( "Gladiator's Badge", nil, nil, nil, 277185 )
			end

			if ( tContains( equipped_items, 172666 ) and GetItemCD ( ( 172666 ) ) == 0 )
			or ( tContains( equipped_items, 167377 ) and GetItemCD ( ( 167377 ) ) == 0 )
			or ( tContains( equipped_items, 165055 ) and GetItemCD ( ( 165055 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 172666 ) ) )
				UseItemByName( tostring( GetItemInfo ( 167377 ) ) )
				UseItemByName( tostring( GetItemInfo ( 165055 ) ) )
				Squid_Alert( "Gladiator's Medallion", nil, nil, nil, 277179 )
			end

			if tContains( equipped_items, 159630 ) and GetItemCD ( ( 159630 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 159630 ) ) )
				Squid_Alert( "Balefire Branch", nil, nil, nil, 268999 )
			end

			if tContains( equipped_items, 169318 ) and GetItemCD ( ( 169318 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 169318 ) ) )
				Squid_Alert( "Shockbiter's Fang", nil, nil, nil, 303953 )
			end

			if tContains( equipped_items, 161411 ) and GetItemCD ( ( 161411 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 161411 ) ) )
				Squid_Alert( "T'zane's Barkspines", nil, nil, nil, 278227 )
			end

			if ( tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 )
			or ( tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 ) then
				UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
				UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
				Squid_Alert( "Knot of Wisdom", nil, nil, nil, 278267 )
			end

			if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
				Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
			end

			if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
				Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
			end

			if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
				Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
			end

		end

		local dispellable ={
		51514,	--hex
		199954,	--curse of frag
		80240,	--havoc
		51514,	--hex
		211015,	--hex cockroach
		210873,	--hex compy
		211010,	--hex snake
		211004,	--hex spider
		277784,	--hex wicker mongrel
		277778,	--hex zandalari tendonripper
		309328,	--hex living honey
		};

		local function remove_curse(unit)
			local lessDelay = minDelayTime/1.3;
			for i=1,#dispellable do
				local debuff,_,_,five,six,seven = UnitDebuffID(unit,dispellable[i]);
				if debuff and seven-time < six-lessDelay then
					return dispellable[i];
				end
			end
		end

		--dispel
		if remove_curse_cd <= gcd_remains then
			for i=1,#Friends do
				local dispel = remove_curse(Friends[i])
				if dispel and _LoS(Friends[i]) then
					if _Cast(475,Friends[i]) then
						Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,475)
					end
					if (player_casting_crittable_damage or (player_cast_id == 203286 and player_cast_time_left > 1)) and player_cast_time_left > gcd_remains then
						SpellStopCasting()
					end
				end
			end
		end

		local function should_klepto(unit)

			local value = 0

			local stun = _stunRemains(unit)

			if unit_is_unit(unit,current_target) then
				value = value + _buffRemains(unit,774)*min(max(stun,1.5),2) -- rejuv duration
				value = value + _buffRemains(unit,155777)*min(max(stun,1.5),2) -- rejuv germination duration
				value = value + (_buffRemains(unit,33763) * (.65 + (_buffStacks(unit,203554) / 4))) -- lifebloom duration * stacks
				--safegaurd
				local buff,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID(unit,286342)
				if buff and absorb > 20000 then
					value = value + 20 + (15 * (absorb / 20000))
				end
				value = value + _buffRemains(unit,198111)*3 -- some value for temp based on duration
				value = value + _buffRemains(unit,305497)*.35 -- half value for thorns duration
				--high value for ghost wolf / es / riptide when stunned
				if stun >= 1 then
					value = value + (UnitBuffID(unit,2645) and _isHealer(unit) and 45 or 0)
					value = value + (UnitBuffID(unit,974) and _isHealer(unit) and 30 or 0)
					value = value + (UnitBuffID(unit,61295) and _isHealer(unit) and 15 or 0)
				elseif _HP(unit) < 30 then
					--es and riptide still have value when they rly low
					value = value + (UnitBuffID(unit,974) and _isHealer(unit) and 15 or 0)
					value = value + (UnitBuffID(unit,61295) and _isHealer(unit) and 10 or 0)
				end
				value = value * (load_mode and 1.35 or 1)
				value = value * (_HP(unit) < 50 and 1.35 or 1)
				value = value * (_stunCheck(unit) and 1.5 or 1)
			end

			value = value + _buffRemains(unit,190319)*11 -- high value for combust

			--big value for bop when being targeted by melee
			value = value + (_buffRemains(unit,1022) > 0 and enemy_melee_on_player > 0 and _buffRemains(unit,1022)*10 or 0)

			value = value + (UnitBuffID(unit,210294) and 69 or 0) -- always klept divine favor

			value = value * ( (not theirHealer or their_healer_cc) and 1.5 or 1 )

			return value >= 42

		end

		--klepto
		if klepto_enabled then
			for i=1,#Enemies do
				local e = Enemies[i]
				if not _immuneCheck(e) and should_klepto(e) then
					if _Cast(30449,e,nil,true) then
						Squid_Alert_Big("Klepto",UnitClass(e),1,nil,30449)
					end
				end
			end
		end

		--priority cc, and define max cast time here
		local max_cast_time = 69
		if auto_cc then
			max_cast_time = healer_cc()
			if max_cast_time > poly_cast_time then
				max_cast_time = min ( max_cast_time, off_cc() )
			end
		end

		if max_cast_time < 69 then max_cast_time = max_cast_time - buffer end
		if max_cast_time < 0 then max_cast_time = 0 end

		-- print(max_cast_time)

		--stop moving!
		if mage_stop_moving and move_setting and not _silenceCheck("player") then
			StopMovingAndLock()
		else
			SetMovementLocked(false)
		end

		--still use gcds and scorch while moving
		if _isMoving("player") then max_cast_time = gcd+.1 end

		if cc_healer_key then
			if UnitExists(theirHealer) then
				cc(theirHealer)
				return
			else
				Squid_Alert("|cFFc31d39No Healers Found",nil,nil,nil,118)
			end
		end
		if cc_focus_key then
			if UnitExists(current_focus) then
				cc(current_focus)
				return
			else
				Squid_Alert("|cFFc31d39No Focus Target",nil,nil,nil,118)
			end
		end
		if cc_offtarget_key then
			local off_target
			for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) and not unit_is_unit(Enemies[i],current_focus) then
				off_target = Enemies[i]
				break
			end end
			if UnitExists(off_target) then
				cc(off_target)
				return
			else
				Squid_Alert("|cFFc31d39No off target found",nil,nil,nil,118)
			end
		end

		--nova healer out of game
		if not poly_cast_delay or time - poly_cast_delay > .1 or not unit_is_unit(their_healer,poly_cast_target) then
			if not bcc12 and their_healer and valid_magic(69) then
				if not unit_is_unit(their_healer,t) and _realDistance(their_healer) < 11 and _LoS(their_healer) and not _CCcheck(their_healer) and (_distance(their_healer,t) > 42 or not _LoS(their_healer,t)) then
					if _Cast(122) then
						Squid_Alert_Big("Frost Nova Healer","(Bad Position)",4,3.5,122)
						return
					end
				end
			end
		end

		--nova subterfuge
		if not bcc12 then
			for i=1,#Enemies do
				if UnitBuffID(Enemies[i],115192) and not _immuneMagic(Enemies[i]) and not _rootImmuneCheck(Enemies[i]) and _LoS(Enemies[i]) then
					if _realDistance(Enemies[i]) < 11.15 then
						if _Cast(122) then
							Squid_Alert_Big("Frost Nova","(Subterfuge)",nil,3.5,122)
						end
					end
				end
			end
		end

		--nova melee
		if not combustion and not bcc12 then
			local p_slowed = _isSlowed("player")
			for i=1,#Enemies do
				local e = Enemies[i]
				if _isMeleeDps(e) and not _immuneMagic(e) and (select(2,UnitClass(e)) ~= "DRUID" or lowestFriend < 45) and not _rootImmuneCheck(e) then
					local d = _realDistance(e)
					if lowestFriend < 50 + ((not our_healer or our_healer_cc) and 30 or 0) + (_CDcheck(e) and 30 or 0) - (UnitEnemiesAttacking(e) * 40) - (unit_is_unit(e,current_target) and _amIfacing(e) and 40 or 0) then
						if d < 11 and _LoS(e) and (d > 8 or d > 2 and moving_away_from(e,max(7-d-(p_slowed and 1.5 or 0),2))) and (_isMoving("player") or _isMoving(e)) then
							if _Cast(122) then
								Squid_Alert_Big("Frost Nova","(Melee, Kiting)",nil,3.5,122)
							end
						end
					end
				end
			end
		end

		object_first_detected = object_first_detected or {}

		for k,v in pairs(object_first_detected) do
			if time - v > 8 then
				object_first_detected[k] = nil
			end
		end

		--totem stomp
		function Stomp(totem,name)
			local hp = UnitHealth(totem)
			local maxhp = UnitHealthMax(totem)
			if hp <= 1 then return false; end
			if not object_first_detected[totem] then
				object_first_detected[totem] = time
			else
				if time - object_first_detected[totem] > minDelayTime / 1.5 then
					--Lance
					if hp <= ice_lance_effect then
						if _Cast(30455,totem,nil,true) then
							Squid_Alert_Big("Stomp " .. name,"(Ice Lance)",4,nil,30455)
							fb_used=time
							return
						end
					end
				end
			end
		end

		local totems = {
		101398,	--Psyfiend
		119052,	--War Banner
		104818,	--Ancestral Protection Totem
		53006,	--Spirit Link Totem
		-- 2630,	--Earthbind Totem
		-- 60561,	--Earthgrab Totem
		-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
		5925,	--Grounding Totem
		-- 105425,	--Skyfury Totem
		105427,	--Skyfury Totem
		-- 5913,	--Tremor Totem
		105451,	--Counterstrike Totem
		}

		-- if arena then
			for i=1,#Pets do
				local e = Pets[i]
				local name = UnitName(e);
				local id = ObjectID(e)
				--only kill cap totems when they're casting
				if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) or (name == "Twisted Appendage" and lowestFriend < 50 + (not our_healer and 40 or our_healer_cc and 40 or 0) and lowestEnemy > 30) then
					Stomp(e,name)
				end
				--root abomination
				if id == 149555 and _rootDR(e) >= .5 and _CCremains(e) + _rootRemains(e) < gcd and _distance(e) < 8 and not bcc12 and _LoS(e) then
					if _Cast(122) then
						Squid_Alert("Nova","Abomination",nil,nil,122)
						return
					end
				end
			end
		-- end

		--Prio Spellsteal
		for i=1,#Enemies do if not _immuneMagic(Enemies[i]) then
			local ss = Prio_Spellsteal(Enemies[i])
			if ss and _Cast(30449,Enemies[i],nil,true) then
				Squid_Alert("Spellsteal " .. UnitClass(Enemies[i]),"("..GetSpellInfo(ss)..")",nil,nil,30449)
			end
		end end

		pet_control()

		priority_shit(max_cast_time)

		if not utilities_only then
			standard_rotation(max_cast_time)
		end

		--testing
		-- if UnitExists("focus") then pet_freeze("focus") end

	end

	function Squid_ArcaneMagePvP()

		local time = GetTime()
		local latency = squid_avg_latency
		local groupsize = GetNumGroupMembers()
		local msperframe = 2/GetFramerate()
		local buffer = latency + msperframe + .1
		local haste = UnitSpellHaste("player")
		local gcd = 1.5/(1+(haste/100))
		local gcd_remains = GetGCD()
		local combat = UnitAffectingCombat("player")
		local player_hp = _HP("player")
		local player_immune = _immuneCheck("player",nil,true)
		local corruption = GetNetCorruption()

		local GetItemInfo_OG = GetItemInfo
		local GetItemInfo = function ( itemid ) local info = GetItemInfo_OG( itemid ) or ""; return info end

		--Auto Targeting
		local function dynamicTargeting(range)
			--Target enemies above 75% or below 35% preferably
			local bestUnit = bestUnit or nil
			if bestUnit == nil then
				if #Enemies > 0 then
					for i = 1, #Enemies do
						local thisUnit = Enemies[i]
						if _distance('player', thisUnit) <= range and _LoS('player', Enemies[i]) and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
							bestUnit = thisUnit
						end
					end
				end
			end
			if not UnitExists("target") and UnitAffectingCombat('player') then
				TargetUnit(bestUnit)
			end
		end
		local auto_target = SQUID.auto_target
		if auto_target then
			dynamicTargeting(40)
		end

		-- local tContains = tContains
		-- local IsPlayerSpell = IsPlayerSpell
		-- local UnitClass = UnitClass --this breaks shit???
		-- local UnitIsVisible = UnitIsVisible
		-- local UnitCastingInfo = UnitCastingInfo
		-- local UnitChannelInfo = UnitChannelInfo
		-- local GetSpellInfo = GetSpellInfo
		-- local UnitName = UnitName
		-- local UnitIsPlayer = UnitIsPlayer
		-- local UnitCastingInfo = UnitCastingInfo

		-- local _LoS = _LoS
		-- local _isHealer = _isHealer
		-- local GetItemInfo = GetItemInfo
		-- local GetItemCount = GetItemCount
		-- local UnitIsFriend = UnitIsFriend
		-- local UnitInParty = UnitInParty
		-- local unit_is_unit = unit_is_unit
		-- local _HP = _HP
		-- local _CCremains = _CCremains
		-- local _breakableCC = _breakableCC
		-- local unit_is_unit = unit_is_unit
		-- local IsSpellOnGCD = IsSpellOnGCD
		-- local UnitEnemiesAttacking = UnitEnemiesAttacking
		-- local Interrupt = Interrupt
		-- local PhysicalInterrupt = PhysicalInterrupt
		-- local _Cast = _Cast
		-- local _distance = _distance
		-- local GetGCD = GetGCD
		-- local _castTimeLeft = _castTimeLeft
		-- local _isHealer = _isHealer
		-- local PVE_Interrupt = PVE_Interrupt
		-- local _immuneMagic = _immuneMagic
		-- local UnitBuffID = UnitBuffID
		-- local UnitDebuffID = UnitDebuffID
		-- local _meleeRange = _meleeRange
		-- local _stealthCheck = _stealthCheck
		-- local _debuffRemains = _debuffRemains

		-- local _isMeleeDps = _isMeleeDps
		-- local _slowImmuneCheck = _slowImmuneCheck
		-- local moving_away_from = moving_away_from
		-- local ObjectID = ObjectID
		-- local _rootDR = _rootDR
		-- local _incapacitateDR = _incapacitateDR
		-- local _drRemains = _drRemains

		mage_next_cc_target = nil
		mage_next_cc_nooverride = nil
		mage_next_cc = nil
		mage_next_cc_dr = nil
		mage_next_cc_time = nil

		if _silenceCheck("player") then return end

		local bcc12 = _bccAM(12)

		local ttd = squid_ttd

		--nova stealth
		if not bcc12 then
			for i=1,#Enemies do if _stealthCheck(Enemies[i]) and _distance(Enemies[i]) < 8 then
				if _Cast(122) then
					Squid_Alert_Big("Nova " .. UnitClass(Enemies[i]),"(Stealth)",1,nil,122)
				end
			end end
		end

		--nova thing from beyond
		if not bcc12 and (not legendary_cloaked or time - legendary_cloaked > 4.5) then
			for i=1,#things_from_beyond do
				local thing = things_from_beyond[i]
				if _realDistance(thing) < 11.5 then
					if _Cast(122) then
						Squid_Alert_Big("Frost Nova","(Thing From Beyond)",4,nil,122)
					end
				end
			end
		end

		if UnitAffectingCombat("player") and UnitCastingInfo("player") == "Pyroblast" and _castTimeLeft("player") > .75 then
			SpellStopCasting()
			Squid_Alert("Stopcasting","(Hardcasting Pyro)",nil,nil,11366)
		end

		local mage_stop_moving = false

		if IsMounted() or IsFlying() or UnitBuffID("player",66) or UnitBuffID("player",32612) or UnitBuffID("player",45438) or UnitBuffID("player",110960) or not player_has_control() then return end --32612

		--equipped items
		local equipped_items = {}

		local trinkets = {
		174103,	--Manifesto of Madness
		167380,	--Notorious Gladiator's Badge
		172669,	--Corrupted Gladiator's Badge
		165058,	--Sinister Gladiator's Badge
		172666,	--Corrupted Gladiator's Medallion
		167377,	--Notorious Gladiator's Medallion
		165055,	--Sinister Gladiator's Medallion
		159615,	--Ignition Mage's Fuse
		161411,	--Tzane's Barkspines
		161377,	--Azurethos' Singed Plumage
		166793,	--Ancient Knot of Wisdom (HORDE) (278267 SPELLID)
		161417,	--Ancient Knot of Wisdom (ALLIANCE) (278267 SPELLID)
		169318,	--Shockbiter's Fang
		168973,	--Neural Synapse Enhancer
		159630,	--Balefire Branch
		}

		for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then table.insert( equipped_items, trinkets[i] ) end end

		local extra_items = {
		159624,	--Rotcrusted Voodoo Doll
		169305,	--Aquipotent Nautilus
		168905,	--Shiver Venom Relic
		173944,	--Forbidden Obsidian Claw
		167677,	--Harmonic Dematerializer
		167835,	--Malformed Herald's Legwraps
		168989,	--Hyperthread Wristwraps (300142 SPELLID)
		167672,	--Cyclotronic Blast (293491 SPELLID)
		165576,	--Tidestorm Codex (289885 SPELLID)
		}

		for i=1,#extra_items do if IsEquippedItem ( extra_items[i] ) then table.insert( equipped_items, extra_items[i] ) end end

		--begin arcane

		local arcane_lockout = _spellCooldown(118) > gcd_remains and _spellCooldown(118) or 0

		local ring_enabled = IsPlayerSpell(113724)

		local ring_cd = _spellCooldown(113724)

		local auto_cc = SQUID.auto_cc

		if UnitBuffID("player",190319) then
			CancelSpellByName("Combustion")
			Squid_Alert("Cancel Aura","(Combustion)",nil,nil,190319)
		end

		local presence_of_mind = UnitBuffID("player",205025)

		local remove_curse_cd = _spellCooldown(475)

		local arcane_charges = UnitPower("player",16)

		local mana = (100 * UnitPower("player") / UnitPowerMax("player"));

		local clearcasting = UnitBuffID("player",276743)

		local temp_up = UnitBuffID("player",198111)

		local chrono_shift_enabled = IsPlayerSpell(235711)

		local arcane_power_up = UnitBuffID("player",12042)

		local arcane_orb_enabled = IsPlayerSpell(153626)
		local arcane_orb_cd = _spellCooldown(153626)

		local sheep_range = 30

		local ring_range = 30

		mage_next_cc_target = nil
		mage_next_cc_nooverride = nil
		mage_next_cc = nil
		mage_next_cc_dr = nil
		mage_next_cc_time = nil

		local poly_cast_time = _castTime(118)
		local ring_cast_time = _castTime(113724)
		local arcane_blast_cast_time = _castTime(30451)
		local arcane_missiles_cast_time = 2
		local rune_of_power_cast_time = _castTime(116011)

		-- local fb_flying
		-- if fireball_target_dist and fireball_thrown and time - fireball_thrown < .075 + (.0485 * fireball_target_dist) then
		-- 	fb_flying = true
		-- end

		-- local pyro_flying
		-- if pyro_target_dist and pyro_thrown and time - pyro_thrown < .075 + (.04 * pyro_target_dist) then
		-- 	pyro_flying = true
		-- end

		-- local pf_flying
		-- if pf_target_dist and pf_thrown and time - pf_thrown < .135 + (.0465 * pf_target_dist) then
		-- 	pf_flying = true
		-- end

		-- if pf_flying then
		-- 	print(math.random(1,10))
		-- end
		-- if pyro_flying then
		-- 	print(math.random(1,10))
		-- end
		-- if fb_flying then
		-- 	print( math.random(1,10))
		-- end

		-- if phoenix_flames_enabled then return end

		local enemies_on_player,enemy_melee_on_player,enemy_ranged_on_player,enemy_cds_on_player = EnemiesAttacking("player")

		local player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")
		local player_cast_target = UnitSpellTarget("player")
		local player_cast_time_left = _castTimeLeft("player")
		local player_cast_percent_complete = _castPctDone("player")
		local player_interruptable = PlayerCanBeKicked()

		if player_cast_id == 118 then
			poly_cast_delay = time
			poly_cast_target = player_cast_target
		end

		if player_cast_id == 113724 then
			ring_cast_delay = time
		end

		if player_cast_id == 133 then
			fireball_cast_delay = time
		end

		--gui setting, disable movement stop for cc
		local move_setting = SQUID.stop_to_cc

		-- This pretty much negates one of the main selling points of my mage script, blinking to secure a greater pyro.
		-- Same code in core .lua file would have done the same with a flat return in the wrong place.
		-- Bandaid fix won't work - yet I don't see anywhere in the code that it would stopcasting a Greater Pyro at this point.
		-- Solution I've considered is determining a whitelist of spells to stop current cast for, such as:
		-- CC on you that will interrupt it anyways, CC on someone on your team that is more important than the damage you're putting out,
		-- damage from the enemy team that is more important than what you're casting, etc. This logic needs thought put into it.
		-- if (player_cast_id == 203286 and cast_percent > 80) then return; end

		local cc_casts = {118,113724}
		local player_casting_non_cc = player_cast and not tContains(cc_casts,player_cast_id)
		local player_casting_cc = player_cast and tContains(cc_casts,player_cast_id)

		--prismatic barrier absorb
		local prismatic_barrier_up,_,_,_,_,_,_,_,_,_,_,_,_,_,_,prismatic_barrier_absorb = UnitBuffID("player",235450)
		barrier_remains = prismatic_barrier_up and prismatic_barrier_absorb or 0

		local sheeped_target
		local sheeped_target_duration = 0
		for i=1,#Enemies do
			local remains = _debuffRemains(Enemies[i],118,"player")
			if remains > 0 then
				sheeped_target = Enemies[i]
				sheeped_target_duration = remains
			end
		end

		local their_healer = theirHealer
		local their_healer_cc
		local their_healer_cc_remains = 0
		local their_healer_incapacitate_dr
		local their_healer_incapacitate_dr_remains = 0
		local their_healer_important_lockout
		if their_healer then
			their_healer_cc_remains = _CCremains(their_healer)
			their_healer_cc = their_healer_cc_remains > 0
			their_healer_incapacitate_dr = _incapacitateDR(their_healer)
			their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")

			local class = select(2,UnitClass(their_healer))

			local locked,remaining,school = UnitIsLocked(their_healer)

			if locked and remaining > .15 then
				if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
				or ( class == "SHAMAN" and school == "Nature" )
				or ( class == "PALADIN" and school == "Holy" )
				or ( class == "MONK" and school == "Nature" )
				or ( class == "DRUID" and school == "Nature" )  then
					their_healer_important_lockout = true
				end
			end

		end

		if not their_healer then
			their_healer_cc = true
			their_healer_cc_remains = 100 - (lowestEnemy*1.5)
			their_healer_cc_remains = their_healer_cc_remains > 8 and 8 or their_healer_cc_remains
			their_healer_cc_remains = their_healer_cc_remains < 0 and 0 or their_healer_cc_remains
		end

		local our_healer
		local our_healer_cc
		if ourHealer then
			our_healer = ourHealer
			if _CCcheck(ourHealer) then our_healer_cc = true end
		end

		if not our_healer then our_healer_cc = true end

		local not_moving_duration = 0

		if _isMoving("player") then
			not_moving_duration = 0
			last_move = time
		else
			if not last_move then last_move = time end
			not_moving_duration = time - last_move
		end

		local t = current_target

		-- local function _valid(unit,immune)
		-- 	if not unit or not UnitExists(unit) then return false end
		-- 	if UnitIsDead(unit) or UnitIsDeadOrGhost(unit) then return false end
		-- 	return UnitCanAttack("player",unit)
		-- 	and not UnitIsFriend("player",unit)
		-- 	and not _breakableCC(unit)
		-- 	and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
		-- 	and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))));
		-- end

		local m_i_r = t and magic_immunity_remains(t) or 0

		local target_dist = _distance(t)

		local valid_magic = function(after,unit)

			if not unit then unit = t end
			if not unit then return false end
			if not UnitIsVisible(unit) then return false end

			if UnitIsDeadOrGhost(unit) then return false end

			if arena and not UnitIsPlayer(unit) then return false end

			if not arena and not UnitAffectingCombat(unit) and not _isDummy(unit) and not UnitIsPlayer(unit) then return false end

			if UnitCanAttack("player",unit)
			and (not _breakableCC(unit) or not arena and not UnitIsPlayer(unit))
			and (unit == t and m_i_r <= after or magic_immunity_remains(unit) <= after) then
				return true
			end

		end

		local thp = _HP(t)

		--magic defensive remains
		local MDR = valid_magic(0) and magic_defensive_remains(t) or 0

		local active_enemies = t and Enemies_Around_Unit(t,10) + 1 or 0

		local current_cast = UnitCastingInfo("player")

		--engage load mode when the enemy team is locked down
		local load_mode = valid_magic(0) and ( ( their_healer and ( their_healer_cc_remains >= 3 or their_healer_important_lockout ) ) or arcane_power_up or UnitDebuffID(t,210824,"player") or _stunRemains(t) > 0 or _HP(t) < 25 * (their_healer and 1 or 3.2) )

		--disable load mode when the enemy trades a defensive, unless already stunned or combusting
		if load_mode and _stunRemains(t) == 0 and combustion_remains == 0 then

			--not wasting this precious load on your magic defenses
			if MDR > 0 then
				load_mode = nil
			end

		end

		load_mode_active = load_mode

		local function arcane_orb(unit)
			if arena and not UnitIsPlayer(unit) then return false end
			if arcane_lockout > 0 then return false end
			if arcane_orb_enabled then
				if arcane_orb_cd <= gcd_remains then
					local d = _distance(unit)
					local total,bcc = Enemies_Around_Unit(unit,12)
					if d < 26 and bcc == 0 then
						if _LoS(unit) then
							if arcane_orb_cd == 0 then
								local f = ObjectFacing("player")
								FaceDirection(GetAnglesBetweenObjects("player",unit),true)
								CastSpellByID(153626)
								FaceDirection(f,true)
								Squid_Alert("Arcane Orb",UnitClass(unit),nil,nil,153626)
							end
							return "wait"
						end
					end
				end
			end
		end

		local function cc(unit)

			local player_exists

			for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then player_exists = true end end

			local player_forced

			if cc_focus_key and unit_is_unit(unit,current_focus) then player_forced = true end
			if cc_offtarget_key or cc_healer_key then player_forced = true end

			if not arena and not UnitIsPlayer(unit) and not player_forced then return 69 end

			--stop if no unit
			if not UnitIsVisible(unit) then return 69 end

			--dist to unit
			local dist = _distance(unit)

			--stop function if unit can't be cc'd
			-- if _immuneMagic(unit,true) or not _LoS(unit) or dist > 39.25 then return 69 end

			local immunity_remains = magic_immunity_remains(unit,true)

			--this function should not only cc, but also return the time until cc needs to happen
			--this is to keep it from starting casts that will get in the way of getting perfect cc on dr
			local time_to_cc = 0

			--check cc
			local ccr = _CCremains(unit)
			local cc = ccr > 0

			--incap drs
			local idr = _incapacitateDR(unit)
			local idr_remains = _drRemains(unit,"incapacitate")

			--sheep immunities. beast or dummy is all i can think of right now. added in Moonkin Form for resto
			local immune_sheep = _isBeast(unit) or _isDummy(unit) or UnitBuffID(unit, 197625)

			--meteor?
			local standing_in_meteor = UnitDebuffID(unit,155158)

			--yea dont cc into it
			if standing_in_meteor then return 69 end

			--banner?
			local banner = UnitBuffID(unit,236321)

			--yea dont cc into it...unless
			if banner then return 69 end

			--incap on unit?
			local incap = _incapacitateCheck(unit)

			--healer?
			local is_healer = _isHealer(unit)

			--lockout?
			local lockout = IsLocked(unit,true)

			--los?
			local los = _LoS(unit)

			--ring to followup cc, if the unit is a beast, or we are locked on sheep
			local time_til_ring_ready = 69
			if immunity_remains == 0 and (not UnitDebuffID(unit,33786) or (_debuffRemains(unit,33786) < ring_cast_time and _debuffRemains(33786) > ring_cast_time-(buffer*3.5))) then
				if idr >= .5 or lowestEnemy < 30 and idr >= .25 then
					if arcane_lockout > 0 or immune_sheep or ccr > ring_cast_time or (sheeped_target and not unit_is_unit(unit,sheeped_target)) then
						local poly_cast_time_extra = poly_cast_time + .5
						local max_overlap = ring_cast_time + (buffer*3.5) + (idr >= .5 and poly_cast_time_extra or 0) --arcane_lockout < ring_cast_time and
						local ring_ready = ring_enabled and ring_cd < gcd and ring_cd <= gcd_remains and ccr > ring_cast_time-.05 and ccr < max_overlap and (idr == 1 or not los and idr >= .5 or arcane_lockout > gcd_remains and idr >= .5)

						if ring_ready and dist < ring_range and (not _isMoving(unit) or UnitDebuffID(unit,31661)) then
							--alert when moving, stop casting scorch when not
							if not poly_cast_delay or time-poly_cast_delay > .2 then
								local can_ring = ring_of_frost(unit)
								if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Ring)",nil,nil,113724)
								elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
								mage_stop_moving = can_ring
								if not mage_next_cc then
									mage_next_cc = 113724
								end
								mage_next_cc_time = 0
							end
							time_to_cc = 0
						end

						time_til_ring_ready = ccr > ring_cast_time + buffer and math.max(ring_cd,ccr,idr == 1 and 0 or idr == .5 and arcane_lockout > gcd_remains and 0 or idr_remains) or 69
					end
				end
			end

			--sheep, if drs are available, and the unit is not immune
			local time_til_poly_ready = 69
			if immunity_remains <= poly_cast_time+(buffer*.45) and los then --no sheep into lockout, unless they're casting another school
				if not immune_sheep and (lockout <= poly_cast_time + (buffer*2) or UnitCastingInfo(unit)) then

					local sheep_dr_ready = idr == 1 or (idr >= .25 and idr_remains > 17.25 - (ccr >= poly_cast_time and 6 * idr or 0) - (incap and ccr >= poly_cast_time-.2 and 6 * idr or 0) - ((100-lowestEnemy) * .038) + (idr == .25 and 1 or 0) ) or idr_remains < poly_cast_time-(buffer/2)

					-- print(sheep_dr_ready, idr, idr_remains)
					-- local sheep_time_til_ready = idr == 1 and ccr or (idr >= .25 and idr_remains > 17 - (ccr > 1 and 6 * idr or 0)) and ccr or idr_remains
					local no_sheeps_out = not sheeped_target or unit_is_unit(unit,sheeped_target) or _incapacitateDR(sheeped_target) <= .25 or (is_healer and idr == 1 and not _isHealer(sheeped_target)) or (_incapacitateDR(sheeped_target) <= .5 and _drRemains(sheeped_target,"incapacitate") > 3 and _drRemains(sheeped_target,"incapacitate") < 16.5)
					if sheep_dr_ready and no_sheeps_out then
						local max_overlap = poly_cast_time + (buffer*2.85) + .145 -- + (idr >= .5 and ring_cd < gcd and ccr > ring_cast_time and ring_cast_time or 0)
						if ccr < max_overlap and dist < sheep_range then
							if arcane_lockout <= buffer then
								--alert when moving, stop casting scorch when not
								if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Sheep)",nil,nil,118) mage_stop_moving = true
								elseif player_cast_id == 2948 and player_cast_time_left > gcd_remains then SpellStopCasting() end
								mage_stop_moving = true
								if (not poly_cast_delay or time-poly_cast_delay > .2) and _Cast(118,unit) then
									Squid_Alert("Sheeping",UnitClass(unit),nil,3,118)
								end
								time_to_cc = 0
								if not mage_next_cc then
									mage_next_cc = 118
								end
								mage_next_cc_time = 0
							else
								time_to_cc = math.max(arcane_lockout,time_to_cc)
							end
						else
							time_to_cc = math.max(ccr,time_to_cc)
						end

						time_til_poly_ready = math.max(ccr-max_overlap,idr_remains < 17 and idr_remains or 0,arcane_lockout)

						if immune_sheep and not is_healer then time_til_poly_ready = 69 end

					end
				end
			end

			local val = math.min(time_til_ring_ready,time_til_poly_ready)

			--next cc unit used for drawings
			mage_next_cc_target = unit

			--default to sheep if no other cc defined above
			if not mage_next_cc then mage_next_cc = 118 end

			--display incap dr for sheeps
			if mage_next_cc == 118 or mage_next_cc == 113724 then
				mage_next_cc_dr = idr
				mage_next_cc_time = val >= 69 and idr_remains or val
			end

			return val

		end

		local function priority_cc()

			local player_exists

			for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then player_exists = true end end

			if not arena and not player_exists then return 69 end

			--healer
			local unit = their_healer

			--focus target if there is no healer
			if not unit then unit = current_focus end

			if unit_is_unit(unit,current_target) then
				unit = current_focus
			end

			local idr
			local idr_r
			if unit then
				idr = _incapacitateDR(unit)
				idr_r = _drRemains(unit,"incapacitate")
			end

			if unit_is_unit(unit,current_target) then
				--off target
				for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) and _distance(Enemies[i]) <= 39 and _LoS(Enemies[i]) then
					unit=Enemies[i]
					break
				end end
			else
				if unit then
					if idr < .25 or ( idr_r > 3 and idr_r < 15 ) or _distance(unit) > 39 or (not _LoS(unit) and ring_cd > gcd) then
						--off target
						for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) and not unit_is_unit(Enemies[i],current_target) and _distance(Enemies[i]) <= 39 and _LoS(Enemies[i]) then
							unit=Enemies[i]
							break
						end end
					end
				end
			end

			if unit_is_unit(unit,current_target) then
				unit=nil
			end

			--stop function if no healer and no fuckus
			if not unit then return 69 end

			if unit and UnitIsDeadOrGhost(unit) then return 69 end

			return cc(unit)

		end

		local function priority_shit(max_cast_time)

			local target_stun = UnitExists(t) and _stunRemains(t) or 0

			if UnitExists(t) and _isDummy(t) then target_stun = 10 end

			local stuns_on_team

			--badge w/ ap
			if arcane_power_up then
				UseItemByName("Notorious Gladiator's Badge")
				UseItemByName("Sinister Gladiator's Badge")
				UseItemByName("Corrupted Gladiator's Badge")
			end

			--klepto
			-- if klepto_enabled and valid_magic(0) and should_klepto(t) and max_cast_time >= gcd then
			-- 	if _Cast(30449,t,nil,true) then
			-- 		Squid_Alert_Big("Klepto",UnitClass(t),1,nil,30449)
			-- 	end
			-- end

			--arcane orb
			if valid_magic(0) then
				if arcane_orb(t) == "wait" then return end
			end

			--charged up in load mode
			if load_mode and arcane_charges <= 1 then
				if _Cast(205032) then
					Squid_Alert("Charged Up",nil,nil,nil,205032)
				end
			end

			--pump w/ pom
			if presence_of_mind then
				if valid_magic(0) then
					_Cast(30451,t,true)
				end
			end

			--essences
			if max_cast_time >= gcd then
				--breath of the undying
				if valid_magic(0) then
					_Cast(310690,t,true)
				end
				--crucible of flame
				if valid_magic(0) and (load_mode or GetSpellCharges(295373) == 2 or _buffStacks("player",295378) == 0 or _HP(t) < 8*_buffStacks("player",295378)) then
					_Cast(295373,t,true)
				end
			end

		end

		local function standard_rotation(max_cast_time)

			local target_stun = UnitExists(t) and _stunRemains(t) or 0

			--pris barrier
			local prismatic_hp = 40
			prismatic_hp = prismatic_hp + (enemies_on_player * 25)
			prismatic_hp = prismatic_hp + (not our_healer and 15 or our_healer_cc and 50 or 0)
			prismatic_hp = prismatic_hp + (enemy_cds_on_player * 50)
			prismatic_hp = prismatic_hp - (load_mode and 45 or 0)

			if max_cast_time >= gcd and player_hp < prismatic_hp and barrier_remains < 5000 and (not temp_up or _HP("player") < 25) then
				if _Cast(235450) then
					Squid_Alert("Prismatic Barrier",nil,nil,nil,235450)
				end
			end

			if _buffRemains("player",235450) < 10 then
				if _Cast(235450) then
					Squid_Alert("Prismatic Barrier",nil,nil,nil,235450)
				end
			end

			--temp shield
			local temp_hp = 25
			temp_hp = temp_hp + (enemies_on_player * 20)
			temp_hp = temp_hp + ((our_healer_cc and 40 or 0) or (not our_healer and 40 or 0))
			temp_hp = temp_hp + (enemy_cds_on_player * 40)

			if player_hp < temp_hp then
				if _Cast(198111) then
					Squid_Alert_Big("Temp Shield",nil,nil,nil,198111)
				end
			end

			if gpy_on_player then
				if _Cast(198111) then
					Squid_Alert_Big("Temp Shield","Greater Pyro",nil,nil,198111)
				end
			end

			--maintain slow with barrage
			if max_cast_time >= gcd and chrono_shift_enabled and valid_magic(0) and not _slowImmuneCheck(t) and _debuffRemains(t,236299,"player") < 1.8 then
				_Cast(44425,t,true)
			end

			--slow off dps to peel
			if lowestFriend < 70 then
				if chrono_shift_enabled then
					for i=1,#Enemies do if _isMeleeDps(Enemies[i]) and not _breakableCC(Enemies[i]) and not _isSlowed(Enemies[i]) and not _slowImmuneCheck(Enemies[i]) then
						if _Cast(44425,Enemies[i],true) then
							Squid_Alert("Chrono Shift "..UnitClass(Enemies[i]),"(Peel)",nil,nil,44425)
						end
					end end
				else
					for i=1,#Enemies do if _isMeleeDps(Enemies[i]) and not _isSlowed(Enemies[i]) and not _slowImmuneCheck(Enemies[i]) then
						if _Cast(31589,Enemies[i]) then
							Squid_Alert("Slow "..UnitClass(Enemies[i]),"(Peel)",nil,nil,31589)
						end
					end end
				end
			end

			--arcane orb
			if valid_magic(0) then
				if arcane_orb(t) == "wait" then return end
			end

			--missiles with clearcasting
			if max_cast_time >= gcd and valid_magic(0) and (load_mode or mana > 80 or clearcasting) then
				_Cast(5143,t,true)
			end

			--touch of the magi blasts
			if max_cast_time > arcane_blast_cast_time and IsPlayerSpell(210725) and valid_magic(arcane_blast_cast_time) then
				_Cast(30451,t,true)
			end

			--Arcane Spellsteal
			if max_cast_time >= gcd then
				for i=1,#Enemies do if not _immuneMagic(Enemies[i]) then
					local ss = Arcane_Spellsteal(Enemies[i])
					if ss and _Cast(30449,Enemies[i],nil,true) then
						Squid_Alert("Spellsteal " .. UnitClass(Enemies[i]),"("..GetSpellInfo(ss)..")",nil,nil,30449)
					end
				end end
			end

			--barrage
			if max_cast_time >= gcd and valid_magic(0) then
				_Cast(44425,t,true)
			end

			--rebuff intellect
			if max_cast_time >= gcd then
				local someone_missing_int
				for i=1,#Friends do if not UnitBuffID(Friends[i],1459) and _distance(Friends[i]) < 40 and not UnitCanAttack("player",Friends[i]) then
					someone_missing_int = true
				end end
				-- dont rebuff while casting
				if someone_missing_int and not UnitCastingInfo("player") then
					if _Cast(1459,"player") then
						Squid_Alert("Rebuff",nil,nil,nil,1459)
						return
					end
				end
			end

			--blast
			if max_cast_time >= arcane_blast_cast_time and valid_magic(0) and arcane_charges <= 3 then
				_Cast(30451,t,true)
			end

			--arcane explosion filler
			if not bcc12 and mana > 65 and Enemies_Around_Unit("player",10) > 0 then
				_Cast(1449)
			end

			--conjure food
			if GetItemCount(113509) == 0 then
				if UnitBuffID("player",32727) and GetNumGroupMembers() > 1 then
					_Cast(190336)
				end
				if Free_Bag_Slots() > 0 then
					InteractUnit("Refreshment Table")
				end
			end

			--dispel agony etc

		end

		--priority cc, and define max cast time here
		local max_cast_time = 69
		if auto_cc then
			max_cast_time = priority_cc()
		end

		--stop moving!
		if mage_stop_moving and move_setting and not _silenceCheck("player") then
			StopMovingAndLock()
		else
			SetMovementLocked(false)
		end

		--still use gcds and scorch while moving
		if _isMoving("player") then max_cast_time = math.max(_castTime(2948) + .01,gcd + .01) end

		if cc_healer_key then
			if UnitExists(theirHealer) then
				cc(theirHealer)
				return
			else
				Squid_Alert("|cFFc31d39No Healers Found",nil,nil,nil,118)
			end
		end
		if cc_focus_key then
			if UnitExists(current_focus) then
				cc(current_focus)
				return
			else
				Squid_Alert("|cFFc31d39No Focus Target",nil,nil,nil,118)
			end
		end
		if cc_offtarget_key then
			local off_target
			for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) and not unit_is_unit(Enemies[i],current_focus) then
				off_target = Enemies[i]
				break
			end end
			if UnitExists(off_target) then
				cc(off_target)
				return
			else
				Squid_Alert("|cFFc31d39No off target found",nil,nil,nil,118)
			end
		end

		--priority nova
		if not poly_cast_delay or time - poly_cast_delay > .1 or not unit_is_unit(their_healer,poly_cast_target) then
			if their_healer and valid_magic(69) and not bcc12 then
				if not unit_is_unit(their_healer,t) and _distance(their_healer) < 8 and _LoS(their_healer) and not _CCcheck(their_healer) and (not _LoS(their_healer,t) or _distance(their_healer,t) > 42) then
					if _Cast(122) then
						Squid_Alert_Big("Frost Nova Healer","(Bad Position)",4,3.5,122)
					end
				end
			end
		end

		--nova melee
		if not combustion and not bcc12 and lowestFriend < 75 then
			for i=1,#Enemies do if _isMeleeDps(Enemies[i]) and not _immuneMagic(Enemies[i]) and _distance(Enemies[i]) < 8 and (select(2,UnitClass(Enemies[i])) ~= "DRUID" or lowestFriend < 45) then
				if _CDcheck(Enemies[i]) or lowestFriend < 40 then
					_Cast(122)
				end
			end end
		end

		--totem stomp
		function Stomp(totem,name)
			local hp = UnitHealth(totem)
			local maxhp = UnitHealthMax(totem)
			if hp <= 1 then return false; end
			--Barrage
			if hp <= 17000 then
				if _Cast(44425,totem,nil,true) then
					Squid_Alert_Big("Stomp " .. name,"(Barrage)",4,3.3,44425)
					return
				end
			end
		end

		local totems = {
		101398,	--Psyfiend
		119052,	--War Banner
		104818,	--Ancestral Protection Totem
		53006,	--Spirit Link Totem
		-- 2630,	--Earthbind Totem
		-- 60561,	--Earthgrab Totem
		-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
		5925,	--Grounding Totem
		105425,	--Skyfury Totem
		-- 5913,	--Tremor Totem
		105451,	--Counterstrike Totem
		}

		if arena then
			for i=1,#Pets do
				local e = Pets[i]
				local name = UnitName(e);
				local id = UnitCreatureID(e)
				--only kill cap totems when they're casting
				if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
					Stomp(e,name)
				end
				--root abomination
				if id == 149555 and _rootDR(e) >= .5 and _CCremains(e) + _rootRemains(e) < gcd and _distance(e) < 8 and not bcc12 then
					if _Cast(122) then
						Squid_Alert("Nova","Abomination",nil,nil,122)
						return
					end
				end
			end
		end

		local dispellable ={
		51514,	--hex
		199954,	--curse of frag
		80240,	--havoc
		211015,	--hex cockroach
		210873,	--hex compy
		211010,	--hex snake
		211004,	--hex spider
		277784,	--hex wicker mongrel
		277778,	--hex zandalari tendonripper
		309328,	--hex living honey
		};

		local function remove_curse(unit)
			local lessDelay = minDelayTime/1.3;
			for i=1,#dispellable do
				local debuff,_,_,five,six,seven = UnitDebuffID(unit,dispellable[i]);
				if debuff and seven-time < six-lessDelay then
					return dispellable[i];
				end
			end
			if _buffStacks(unit,980) >= 6 then
				return 980
			end
		end

		--dispel
		if remove_curse_cd <= gcd_remains then
			for i=1,#Friends do
				local dispel = remove_curse(Friends[i])
				if dispel and _LoS(Friends[i]) and _Cast(475,Friends[i]) then
					Squid_Alert_Big("Dispel "..UnitClass(Friends[i]),"("..GetSpellInfo(dispel)..")",4,nil,475)
				end
			end
		end

		if auto_cc then

			local off_target
			for i=1,#Enemies do if not unit_is_unit(current_target,Enemies[i]) and _distance(Enemies[i]) < 40 and not UnitIsDead(Enemies[i]) then
				off_target=Enemies[i]
				break
			end end

			if off_target then
				cc(off_target)
			end

		end

		-- print(mage_next_cc_target,mage_next_cc,mage_next_cc_dr,mage_next_cc_time)

		-- print(max_cast_time)

		priority_shit(max_cast_time)

		standard_rotation(max_cast_time)

	end

	function Squid_FireMagePvE()

		local eating = UnitBuffID("player",167152)
		if eating then return end

		--todo

		local time = GetTime()
		local latency = squid_avg_latency
		local groupsize = GetNumGroupMembers()
		local msperframe = 2/GetFramerate()
		local buffer = latency + msperframe + .11
		local haste = UnitSpellHaste("player")
		local gcd = 1.5/(1+(haste/100))
		local gcd_remains = GetGCD()
		local combat = player_combat
		local player_hp = _HP("player")

		local player_combat = UnitAffectingCombat("player")

		local GetItemInfo_OG = GetItemInfo
		local GetItemInfo = function ( itemid ) local info = GetItemInfo_OG( itemid ) or ""; return info end

		local UnitAffectingCombat = UnitAffectingCombat
		local _HP = _HP
		local squid_ttd = squid_ttd
		local _distance = _distance
		local _realDistance = _realDistance
		local UnitBuffID = UnitBuffID
		local UnitDebuffID = UnitDebuffID
		local UnitCanAttack = UnitCanAttack
		local _isMeleeDps = _isMeleeDps

		local auto_combust = SQUID.auto_combust

		if UnitBuffID("player",296510) then
			CancelSpellByName(GetSpellInfo(296510))
		end

		--dbm pull timer
		local dbm_countdown = 1000
		if DBM then
			local numBars = DBM.Bars.numBars
			if numBars and numBars ~= 0 then dbm_countdown = 1001 end
			local bars = DBM.Bars.hugeBars
			if bars then
				local last = bars.last
				if last then
					local timer = last.timer
					dbm_countdown = timer
				end
			end
			if dbm_countdown == 1000 or dbm_countdown == 1001 then
				bars = DBM.Bars.smallBars
			end
			if bars then
				local last = bars.last
				if last then
					local timer = last.timer
					dbm_countdown = timer
				end
			end
		end

		--min combust hp
		local min_combust_health = SQUID.min_combust_hp

		--traits info
		local blaster_master_enabled = AzeritePowerTaken(215)

		--solomode
		local solo_mode = SQUID.solo_mode_enabled

		--reset cc draws when switching to pve rotation
		mage_next_cc_target = nil
		mage_next_cc_nooverride = nil
		mage_next_cc = nil
		mage_next_cc_dr = nil
		mage_next_cc_time = nil

		if IsMounted() or IsFlying() or UnitBuffID("player",66) or UnitBuffID("player",32612) or UnitBuffID("player",45438) or UnitBuffID("player",110960) or not player_has_control() then return end

		local function debug_print(str) if squid_debug then print(str) end end
		local function dynamicTargeting(range)
			--Target enemies above 75% or below 35% preferably
			local bestUnit = bestUnit or nil
			if bestUnit == nil then
				if #Enemies > 0 then
					for i = 1, #Enemies do
						local thisUnit = Enemies[i]
						if _distance('player', thisUnit) <= range and _LoS('player', Enemies[i]) and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
							bestUnit = thisUnit
						end
					end
				end
			end
			if not UnitExists("target") and UnitAffectingCombat('player') then
				TargetUnit(bestUnit)
			end
		end
		local auto_target = SQUID.auto_target
		if auto_target then
			dynamicTargeting(40)
		end

		local fire_lockout = _spellCooldown(133) > gcd_remains and _spellCooldown(133) or 0
		local arcane_lockout = _spellCooldown(118) > gcd_remains and _spellCooldown(118) or 0
		local ring_cd = _spellCooldown(113724)
		local db_cd = _spellCooldown(31661)
		local meteor_cd = _spellCooldown(153561)
		local remove_curse_cd = _spellCooldown(475)
		local combustion_cd = _spellCooldown(190319)
		local shifting_power_cd = _spellCooldown(314791)

		local rune_of_power_base_cd = 40
		local rune_of_power_max_charges = 2
		local rune_of_power_total_cd = rune_of_power_base_cd * rune_of_power_max_charges
		local rune_of_power_charges = GetSpellCharges(116011)
		local rune_of_power_charges_frac = _spellChargeFrac(116011)
		local rune_of_power_next_charge_cd = (math.ceil(rune_of_power_charges_frac) - rune_of_power_charges_frac) * rune_of_power_base_cd
		local rune_of_power_full_recharge_time = rune_of_power_total_cd - (rune_of_power_charges_frac*rune_of_power_base_cd)
		local rune_of_power_cd = gcd_remains
		if rune_of_power_charges == 0 then rune_of_power_cd = rune_of_power_next_charge_cd end

		local heating_up = UnitBuffID("player",48107)
		local heating_up_remains = _buffRemains("player",48107)
		local tinder_up = UnitBuffID("player",203277)
		local flamecannon_stacks = _buffStacks("player",203285)
		local temp_up = UnitBuffID("player",198111)
		local rune_of_power_up = UnitBuffID("player",116014)
		local rune_of_power_remains = ( rune_of_power_up and player_rop and 10 - ( time - player_rop ) or 0 )
		local blaster_master_remains = _buffRemains("player",274598) - (buffer/2)
		local blaster_master_up = UnitBuffID("player",274598)
		local blaster_master_stacks = _buffStacks("player",274598)

		local hot_streak = UnitBuffID("player",48108) or UnitBuffID("player",333100)
		local hot_streak_remains = _buffRemains("player",48108)
		local pyroclasm_remains = _buffRemains("player",269651)
		local pyroclasm = pyroclasm_remains > 0
		local searing_touch_enabled = IsPlayerSpell(269644)
		local rune_of_power_enabled = IsPlayerSpell(116011)
		local ring_enabled = IsPlayerSpell(113724)
		local tinder_enabled = IsPlayerSpell(203275)
		local firestarter_enabled = IsPlayerSpell(205026)
		local flame_on = IsPlayerSpell(205029)
		local meteor_enabled = IsPlayerSpell(153561)
		local shifting_power_enabled = IsPlayerSpell(314791)
		local combustion_remains = _buffRemains("player",190319)
		local combustion = combustion_remains > 0
		local infernal_cascade_remains = _buffRemains('player', 336821)
		local infernal_cascade = infernal_cascade_remains > 0

		local fire_blast_base_cd = flame_on and 10 or 12
		-- fire_blast_base_cd = fire_blast_base_cd * (1-(haste/100-.04))
		fire_blast_base_cd = fire_blast_base_cd - ( haste * 0.076954715597427 )

		local fire_blast_charges,fire_blast_max_charges = GetSpellCharges(108853)
		local fire_blast_total_cd = fire_blast_base_cd * fire_blast_max_charges
		local fire_blast_charges_frac = _spellChargeFrac(108853)
		local fire_blast_full_recharge_time = fire_blast_total_cd - (fire_blast_charges_frac*fire_blast_base_cd)
		local fire_blast_next_charge_cd = (math.ceil(fire_blast_charges_frac) - fire_blast_charges_frac) * fire_blast_base_cd

		-- print(fire_blast_full_recharge_time)
		-- if not cd_printed or time - cd_printed > 1 then
		-- 	print( fire_blast_next_charge_cd )
		-- 	print( fire_blast_full_recharge_time )
		-- 	cd_printed = time
		-- end

		-- print(pyro_flying)

		local alexstraszas_fury_enabled = IsPlayerSpell(235870)
		local flame_patch_enabled = IsPlayerSpell(205037)
		local kindling_enabled = IsPlayerSpell(155148)

		local phoenix_flames_enabled = IsPlayerSpell(257541)
		local phoenix_flames_base_cd = 30
		local phoenix_flames_charges,phoenix_flames_max_charges = GetSpellCharges(257541)
		if not phoenix_flames_enabled then
			phoenix_flames_charges = 0
			phoenix_flames_max_charges = 0
		end
		local phoenix_flames_total_cd = phoenix_flames_base_cd * phoenix_flames_max_charges
		local phoenix_flames_charges_frac = _spellChargeFrac(257541)
		local phoenix_flames_full_recharge_time = phoenix_flames_total_cd - (phoenix_flames_charges_frac*phoenix_flames_base_cd)
		local phoenix_flames_next_charge_cd = (math.ceil(phoenix_flames_charges_frac) - phoenix_flames_charges_frac) * phoenix_flames_base_cd

		local meteor_in_flight = meteor_cd > 42
		local meteor_in_flight_remains = (3 - ( 45 - meteor_cd )) - buffer

		local combustion_learned = IsPlayerSpell(190319)

		-- print(meteor_in_flight_remains,meteor_in_flight)

		local flamecannon_value = (flamecannon_stacks * 3)

		local gpy_range = 40

		local sheep_range = 30

		local ring_range = 30

		gpy_range = gpy_range + flamecannon_value

		sheep_range = sheep_range + flamecannon_value

		ring_range = ring_range + flamecannon_value

		local poly_cast_time = _castTime(118)
		local ring_cast_time = _castTime(113724)
		local greater_pyro_cast_time = _castTime(203286)
		local fireball_cast_time = _castTime(133)
		local scorch_cast_time = _castTime(2948)
		local rune_of_power_cast_time = _castTime(116011)
		local pyro_cast_time = _castTime(11366)
		local flamestrike_cast_time = _castTime(2120)

		local player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")
		local player_cast_target = UnitSpellTarget("player")
		local player_cast_time_left = _castTimeLeft("player")
		local player_cast_percent_complete = _castPctDone("player")

		local crit_casts = {2948,133}
		local player_casting_crittable_damage = player_cast and tContains(crit_casts,player_cast_id)
		local player_casting_guaranteed_crit = player_cast and tContains(crit_casts,player_cast_id) and (combustion or (player_cast_id == 2948 and UnitIsVisible(player_cast_target) and _HP(player_cast_target) < 30 and IsPlayerSpell(269644)))

		local single_target = SQUID.single_target

		--blazing barrier absorb
		local blazing_barrier_up,_,_,_,_,_,_,_,_,_,_,_,_,_,_,blazing_barrier_absorb = UnitBuffID("player",235313)
		barrier_remains = blazing_barrier_up and blazing_barrier_absorb or 0

		local crit_inc = fb_flying or pf_flying or pyro_flying

		--stopcasting hardcast pyro
		if not pyroclasm and player_combat and UnitCastingInfo("player") == "Pyroblast" and _castTimeLeft("player") > 1.25 then
			SpellStopCasting()
			Squid_Alert("Stopcasting","(Hardcasting Pyro)",nil,nil,11366)
		end

		local scorch_execute_ready
		if searing_touch_enabled then
			for i=1,#Enemies do
				if _HP(Enemies[i]) < 30 and valid_attackable(Enemies[i]) and _distance(Enemies[i]) < 40 and _LoS(Enemies[i]) and _amIfacing(Enemies[i]) and squid_ttd(Enemies[i]) > scorch_cast_time then
					scorch_execute_ready = true
					break
				end
			end
		end

		if _isMoving("player") then
			not_moving_duration = 0
			last_move = time
		else
			if not last_move then last_move = time end
			not_moving_duration = time - last_move
		end

		local function ready_to_attack(unit)
			-- local whitelist = {
			-- "Spirit of Gold",
			-- "Reanimation Totem",
			-- "Soulspawn",
			-- "Crackling Shard",
			-- "Horrific Hemorrhage",
			-- "Synthesis Growth",
			-- "Corrupted Neuron",
			-- }
			-- if tContains(whitelist,ObjectName(unit)) then
			-- 	return true
			-- else
			-- 	return UnitAffectingCombat(unit)
			-- end
			return valid_attackable(unit)
		end

		local t = current_target

		if UnitIsVisible(t) then
			if not UnitCanAttack("player",t) or (dbm_countdown == 1000 and not _isDummy(t) and not ready_to_attack(t)) then
				t = nil
			end
		end

		local all_explosives = {}
		for i=1,#Enemies do
			if ObjectID(Enemies[i]) == 120651 and UnitCastingInfo(Enemies[i]) and _LoS(Enemies[i]) and _distance(Enemies[i]) < 35 and _amIfacing(Enemies[i]) then
				table.insert(all_explosives,{pointer=Enemies[i],hp=_HP(Enemies[i]),cast_left=_castTimeLeft(Enemies[i])})
			end
		end

		table.sort(all_explosives,function(x,y) return x.cast_left < y.cast_left end)

		local explosive = #all_explosives >= 4 and all_explosives[1].pointer or nil

		local important_explosive
		for i=1,#all_explosives do
			if all_explosives[i].cast_left < buffer then
				if not fb_used or time - fb_used > .2 then
					if _Cast(108853,all_explosives[i].pointer,nil,true) then
						Squid_Alert("Fire Blast","(Explosive)",nil,nil,108853)
						fb_used = time
						debug_print("returning on fire_blast (explosive, 1)")
						return
					end
				end
			end
			if all_explosives[i].hp > ( all_explosives[i].cast_left * 25 ) - ( #all_explosives * 13 ) then
				important_explosive = all_explosives[i].pointer
				break
			end
		end

		if important_explosive then
			explosive = important_explosive
		end

		explosive_draw = explosive

		--use fire blast when on full stacks
		if combustion and ready_to_attack(t) then
			if fire_blast_charges_frac >= fire_blast_max_charges-.5 and not hot_streak and not heating_up and not pf_flying and not fb_flying and not pyro_flying then
				if not fb_used or time - fb_used > .35 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						--print("Combust Fireblast 1")
						fb_used = time
						debug_print("returning on fire_blast (combust, 1)")
						return true
					end
				end
			end
		end

		--target time to die
		local t_ttd = ( t and squid_ttd(t) or 0 )

		--target hp
		local t_hp = ( t and _HP( t ) or 100 )

		--target actual hp
		local t_ahp = ( t and UnitHealth(t) or UnitHealth("player") )

		--target is boss
		local t_is_boss = ( t and UnitClassification( t ) == "worldboss" )

		--enemies around t
		local enemies_around_target = Enemies_Around_Unit(t,12,true)

		--target is dummy
		local t_is_dummy = ( t and _isDummy( t ) )

		--facing target
		local facing_target = t and _amIfacing(t)

		--distance to targ
		local t_dist = t and _distance( t ) or 99

		--active enemies
		local active_enemies = #Enemies

		--min flamestrike units
		local fs_count

		--not combusting
		local not_combusting_target

		-- # Default consumables
		-- potion=potion_of_unbridled_fury
		-- flask=greater_flask_of_endless_fathoms
		-- food=biltong
		-- augmentation=battle_scarred

		--potions, sorted by best to worst
		--pots need update
		local potions = {
		169299,	--potion of unbridled fury
		168498,	--superior int pot
		163222,	--int pot
		}
		local best_pot = nil
		for i=1,#potions do if GetItemCount( potions[i] ) > 0 then
			best_pot = potions[i]
			break
		end end

		--FIX ME
		-- SQUID.pre_pot_enabled = true

		--simc vars
		local disable_combustion = not combustion_learned
		local combustion_rop_cutoff
		local combustion_on_use
		local font_double_on_use
		local font_of_power_precombat_channel
		local on_use_cutoff
		local hold_combustion_threshold = 20
		local time_to_combustion
		local fire_blast_pooling
		local phoenix_pooling
		local combustion_shifting_power = 2
		local combustion_flamestrike = 0
		local full_reduction = 10

		--more
		local firestarter_active = firestarter_enabled and t and t_hp >= 90
		local firestarter_remains = firestarter_enabled and t and squid_ttp( t, 90 ) or 0

		--equipped items
		local equipped_items = {}

		local trinkets = {
		174103,	--Manifesto of Madness
		167380,	--Notorious Gladiator's Badge
		172669,	--Corrupted Gladiator's Badge
		165058,	--Sinister Gladiator's Badge
		175884,	--Sinful Aspirant's Weed
		172666,	--Corrupted Gladiator's Medallion
		167377,	--Notorious Gladiator's Medallion
		165055,	--Sinister Gladiator's Medallion
		159615,	--Ignition Mage's Fuse
		161411,	--Tzane's Barkspines
		161377,	--Azurethos' Singed Plumage
		166793,	--Ancient Knot of Wisdom (HORDE) (278267 SPELLID)
		161417,	--Ancient Knot of Wisdom (ALLIANCE) (278267 SPELLID)
		169318,	--Shockbiter's Fang
		168973,	--Neural Synapse Enhancer
		159630,	--Balefire Branch
		}
		local combustion_trinket_equipped

		for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then combustion_trinket_equipped = true table.insert( equipped_items, trinkets[i] ) end end

		local extra_items = {
		159624,	--Rotcrusted Voodoo Doll
		169305,	--Aquipotent Nautilus
		168905,	--Shiver Venom Relic
		173944,	--Forbidden Obsidian Claw
		167677,	--Harmonic Dematerializer
		167835,	--Malformed Herald's Legwraps
		168989,	--Hyperthread Wristwraps (300142 SPELLID)
		167672,	--Cyclotronic Blast (293491 SPELLID)
		165576,	--Tidestorm Codex (289885 SPELLID)
		}

		for i=1,#extra_items do if IsEquippedItem ( extra_items[i] ) then table.insert( equipped_items, extra_items[i] ) end end


		-- actions.precombat+=/variable,name=disable_combustion,op=reset
		-- disable_combustion = nil (FIXME)
		-- # This variable sets the time at which Rune of Power should start being saved for the next Combustion phase
		-- actions.precombat+=/variable,name=combustion_rop_cutoff,op=set,value=60
		combustion_rop_cutoff = 60

		combustion_on_use = combustion_trinket_equipped
		-- actions.precombat+=/variable,name=font_double_on_use,op=set,value=equipped.azsharas_font_of_power&amp;variable.combustion_on_use
		font_double_on_use = font_equipped and combustion_on_use == 1
		-- # This variable determines when Azshara's Font of Power is used before the pull if bfa.font_of_power_precombat_channel is not specified.
		-- actions.precombat+=/variable,name=font_of_power_precombat_channel,op=set,value=18,if=variable.font_double_on_use&amp;variable.font_of_power_precombat_channel=0
		font_of_power_precombat_channel = font_double_on_use and 18 or nil
		-- # Items that are used outside of Combustion are not used after this time if they would put a trinket used with Combustion on a sharded cooldown.
		-- actions.precombat+=/variable,name=on_use_cutoff,op=set,value=20*variable.combustion_on_use&amp;!variable.font_double_on_use+40*variable.font_double_on_use+25*equipped.azsharas_font_of_power&amp;!variable.font_double_on_use+8*equipped.manifesto_of_madness&amp;!variable.font_double_on_use
		on_use_cutoff = ( 20 * ( combustion_on_use and not font_double_on_use and 1 or 0 ) + 40 * ( font_double_on_use and 1 or 0 ) + 25 * ( font_equipped and not font_double_on_use and 1 or 0 ) + 8 * ( IsEquippedItem(174103) and not font_double_on_use and 1 or 0 ) )
		-- # Combustion is only used without Worldvein Resonance or Memory of Lucid Dreams if it will be available at least this many seconds before the essence's cooldown is ready.
		-- actions.precombat+=/variable,name=hold_combustion_threshold,op=reset,default=20
		-- hold_combustion_threshold = 20

		-- actions+=/variable,name=time_to_combustion,op=set,value=cooldown.combustion.remains
		time_to_combustion = combustion_cd

		-- actions+=/variable,name=fire_blast_pooling,value=talent.rune_of_power.enabled&amp;cooldown.rune_of_power.remains<cooldown.fire_blast.full_recharge_time&amp;(variable.time_to_combustion>variable.combustion_rop_cutoff|variable.disable_combustion|firestarter.active)&amp;(cooldown.rune_of_power.remains<target.time_to_die|action.rune_of_power.charges>0)|!variable.disable_combustion&amp;variable.time_to_combustion<action.fire_blast.full_recharge_time+cooldown.fire_blast.duration*azerite.blaster_master.enabled&amp;!firestarter.active&amp;variable.time_to_combustion<target.time_to_die|talent.firestarter.enabled&amp;firestarter.active&amp;firestarter.remains<cooldown.fire_blast.full_recharge_time+cooldown.fire_blast.duration*azerite.blaster_master.enabled
		fire_blast_pooling = rune_of_power_enabled and rune_of_power_cd < fire_blast_full_recharge_time and ( time_to_combustion > combustion_rop_cutoff or disable_combustion or firestarter_active ) and ( rune_of_power_cd < t_ttd or rune_of_power_charges > 0 ) or not disable_combustion and time_to_combustion < fire_blast_full_recharge_time + fire_blast_base_cd * ( blaster_master_enabled and 1 or 0 ) and not firestarter_active and time_to_combustion < t_ttd or firestarter_enabled and firestarter_active and firestarter_remains < fire_blast_full_recharge_time + fire_blast_next_charge_cd * ( blaster_master_enabled and 1 or 0 )
		-- actions+=/variable,name=phoenix_pooling,value=talent.rune_of_power.enabled&amp;cooldown.rune_of_power.remains<cooldown.phoenix_flames.full_recharge_time&amp;(variable.time_to_combustion>variable.combustion_rop_cutoff|variable.disable_combustion)&amp;(cooldown.rune_of_power.remains<target.time_to_die|action.rune_of_power.charges>0)|!variable.disable_combustion&amp;variable.time_to_combustion<action.phoenix_flames.full_recharge_time&amp;variable.time_to_combustion<target.time_to_die
		phoenix_pooling = rune_of_power_enabled and rune_of_power_cd < phoenix_flames_full_recharge_time and ( time_to_combustion > combustion_rop_cutoff or disable_combustion ) and ( rune_of_power_cd < t_ttd or rune_of_power_charges > 0 ) or not disable_combustion and time_to_combustion < phoenix_flames_full_recharge_time and time_to_combustion < t_ttd

		--variable,name=phoenix_pooling,value=!variable.disable_combustion&amp;variable.time_to_combustion<action.phoenix_flames.full_recharge_time-action.shifting_power.full_reduction*
		--(cooldown.shifting_power.remains<variable.time_to_combustion)&amp;variable.time_to_combustion<fight_remains|runeforge.sun_kings_blessing|time<5
		--phoenix_pooling = not disable_combustion and time_to_combustion < phoenix_flames_full_recharge_time - full_reduction * ((_spellCooldown(314791) < time_to_combustion) and 1 or 0) and time_to_combustion < t_ttd

		--	variable,name=combustion_flamestrike,op=set,if=variable.combustion_flamestrike=0,value=3*talent.flame_patch+6*!talent.flame_patch
		-- This variable specifies the number of targets at which Hot Streak Flamestrikes are used during Combustion.
		if combustion_flamestrike == 0 then
			combustion_flamestrike = 3 * (flame_patch_enabled and 1 or 0) + 6 * (not flame_patch_enabled and 1 or 0)
		end

		if pool_them_fbs then
			fire_blast_pooling = true
		end

		if not combustion_learned then
			fire_blast_pooling,phoenix_pooling = nil,nil
		end

		if not auto_combust then
			time_to_combustion = max( time_to_combustion, 40 )
		end

		if solo_mode and not Squid_Burst then
			time_to_combustion = 400
			disable_combustion = true
		end

		local flamestrike_ready

		-- # Executed before combat begins. Accepts non-harmful actions only.
		local function precombat()

			if not combat then
				-- actions.precombat+=/arcane_intellect
				local someone_missing_int
				for i=1,#Friends do if not UnitBuffID( Friends[i], 1459 ) and _distance( Friends[i] ) < 40 and not UnitIsCharmed( Friends[i] ) then
					someone_missing_int = true
				end end
				-- dont rebuff while casting
				if someone_missing_int and not UnitCastingInfo( "player" ) then
					if not recent_buff or time - recent_buff > 6 then
						if _Cast( 1459, "player" ) then
							recent_buff = time
							Squid_Alert( "Rebuff", nil, nil, nil, 1459 )

							return true
						end
					end
				end
			end

			if not t then return end
			-- actions.precombat=flask
			-- actions.precombat+=/food
			-- actions.precombat+=/augmentation


			-- actions.precombat+=/snapshot_stats
			if not player_combat then
				-- actions.precombat+=/use_item,name=azsharas_font_of_power,if=!variable.disable_combustion
				-- if font_equipped and not disable_combustion then
				-- 	if GetItemCD (( 169314 ) ) == 0 then
				-- 		UseItemByName( tostring( GetItemInfo( 169314 ) ) )
				-- 		Squid_Alert( "Font of Power", nil, nil, nil, 296962 )
				-- 	end
				-- end
				-- actions.precombat+=/mirror_image
				if dbm_countdown <= 6 and _Cast( 55342 ) then
					Squid_Alert( "Mirror Image", nil, nil, nil, 55342 )
					return true
				end
				-- actions.precombat+=/potion
				if dbm_countdown <= 6 and t and UnitClassification(t) == "worldboss" and combustion_cd < 5 and best_pot and SQUID.pre_pot_enabled then
					if GetItemCD ( ( best_pot ) ) == 0 then
						UseItemByName( tostring( GetItemInfo ( best_pot ) ) )
						Squid_Alert( "Pre Pot", nil, nil, nil, 300714 )
					end
				end
				-- actions.precombat+=/pyroblast
				if dbm_countdown <= pyro_cast_time + latency + ( t_dist * .015 ) then
					_Cast( 11366, t, true )
				end
			end
		end

		local function items_combustion()

			if UnitCastingInfo("player") or UnitChannelInfo("player") then return end

			-- actions.items_combustion=use_item,name=ignition_mages_fuse
			--[[
			if tContains( equipped_items, 159615 ) and GetItemCD ( ( 159615 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 159615 ) ) )
				Squid_Alert( "Ignition Mage's Fuse", nil, nil, nil, 271117 )
			end
			--]]
			-- actions.items_combustion+=/cancel_buff,use_off_gcd=1,name=manifesto_of_madness_chapter_one,if=buff.combustion.up|action.meteor.in_flight&amp;action.meteor.in_flight_remains<=0.5
			-- actions.items_combustion+=/use_item,use_off_gcd=1,name=azurethos_singed_plumage,if=buff.combustion.up|action.meteor.in_flight&amp;action.meteor.in_flight_remains<=0.5
			-- actions.items_combustion+=/use_item,use_off_gcd=1,effect_name=gladiators_badge,if=buff.combustion.up|action.meteor.in_flight&amp;action.meteor.in_flight_remains<=0.5
			-- actions.items_combustion+=/use_item,use_off_gcd=1,effect_name=gladiators_medallion,if=buff.combustion.up|action.meteor.in_flight&amp;action.meteor.in_flight_remains<=0.5
			-- actions.items_combustion+=/use_item,use_off_gcd=1,name=balefire_branch,if=buff.combustion.up|action.meteor.in_flight&amp;action.meteor.in_flight_remains<=0.5
			-- actions.items_combustion+=/use_item,use_off_gcd=1,name=shockbiters_fang,if=buff.combustion.up|action.meteor.in_flight&amp;action.meteor.in_flight_remains<=0.5
			-- actions.items_combustion+=/use_item,use_off_gcd=1,name=tzanes_barkspines,if=buff.combustion.up|action.meteor.in_flight&amp;action.meteor.in_flight_remains<=0.5
			-- actions.items_combustion+=/use_item,use_off_gcd=1,name=ancient_knot_of_wisdom,if=buff.combustion.up|action.meteor.in_flight&amp;action.meteor.in_flight_remains<=0.5
			-- actions.items_combustion+=/use_item,use_off_gcd=1,name=neural_synapse_enhancer,if=buff.combustion.up|action.meteor.in_flight&amp;action.meteor.in_flight_remains<=0.5
			-- actions.items_combustion+=/use_item,use_off_gcd=1,name=malformed_heralds_legwraps,if=buff.combustion.up|action.meteor.in_flight&amp;action.meteor.in_flight_remains<=0.5
			if combustion or meteor_in_flight and ( meteor_in_flight_remains <= .85 or hot_streak and fire_blast_charges_frac >= fire_blast_max_charges - .3 ) or lucid_dreams_up and meteor_cd > gcd and not meteor_in_flight or worldvein_major and worldvein_cd >= 48 then

				if UnitBuffID("player",313948) then
					RunMacroText("/cancelaura Manifesto of Madness: Chapter One")
					Squid_Alert( "Manifesto of Madness", "(CANCEL)", nil, nil, 313948 )
				end

				if tContains( equipped_items, 161377 ) and GetItemCD ( ( 161377 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 161377 ) ) )
					Squid_Alert( "Azurethos' Singed Plumage", nil, nil, nil, 278383 )
				end

				if ( tContains( equipped_items, 167380 ) and GetItemCD ( ( 167380 ) ) == 0 )
				or ( tContains( equipped_items, 172669 ) and GetItemCD ( ( 172669 ) ) == 0 )
				or ( tContains( equipped_items, 165058 ) and GetItemCD ( ( 165058 ) ) == 0 )
				or ( tContains( equipped_items, 175884 ) and GetItemCD ( ( 175884 ) ) == 0 ) then
					UseItemByName( tostring( GetItemInfo ( 167380 ) ) )
					UseItemByName( tostring( GetItemInfo ( 172669 ) ) )
					UseItemByName( tostring( GetItemInfo ( 165058 ) ) )
					UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
					Squid_Alert( "Gladiator's Badge", nil, nil, nil, 277185 )
				end

				if ( tContains( equipped_items, 172666 ) and GetItemCD ( ( 172666 ) ) == 0 )
				or ( tContains( equipped_items, 167377 ) and GetItemCD ( ( 167377 ) ) == 0 )
				or ( tContains( equipped_items, 165055 ) and GetItemCD ( ( 165055 ) ) == 0 ) then
					UseItemByName( tostring( GetItemInfo ( 172666 ) ) )
					UseItemByName( tostring( GetItemInfo ( 167377 ) ) )
					UseItemByName( tostring( GetItemInfo ( 165055 ) ) )
					Squid_Alert( "Gladiator's Medallion", nil, nil, nil, 277179 )
				end

				if tContains( equipped_items, 159630 ) and GetItemCD ( ( 159630 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 159630 ) ) )
					Squid_Alert( "Balefire Branch", nil, nil, nil, 268999 )
				end

				if tContains( equipped_items, 169318 ) and GetItemCD ( ( 169318 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 169318 ) ) )
					Squid_Alert( "Shockbiter's Fang", nil, nil, nil, 303953 )
				end

				if tContains( equipped_items, 161411 ) and GetItemCD ( ( 161411 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 161411 ) ) )
					Squid_Alert( "T'zane's Barkspines", nil, nil, nil, 278227 )
				end

				if ( tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 )
				or ( tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 ) then
					UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
					UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
					Squid_Alert( "Knot of Wisdom", nil, nil, nil, 278267 )
				end

				if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
					Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
				end

				if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
					Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
				end

				if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
					Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
				end

			end

		end

		local function items_high_priority()
			if UnitCastingInfo("player") or UnitChannelInfo("player") then return end

			-- want an accurate time to combust here so we don't use alt on use right before combust
			-- actions+=/variable,name=time_to_combustion,op=set,value=cooldown.combustion.remains
			local time_to_combustion = combustion_cd
			if solo_mode and not Squid_Burst then
				time_to_combustion = 400
			end

			-- actions.items_high_priority=call_action_list,name=items_combustion,if=!variable.disable_combustion&amp;(talent.rune_of_power.enabled&amp;variable.time_to_combustion<=action.rune_of_power.cast_time|variable.time_to_combustion<=0)&amp;!firestarter.active|buff.combustion.up
			if not disable_combustion and ( rune_of_power_enabled and time_to_combustion <= rune_of_power_cast_time or time_to_combustion <= 0 ) and not firestarter_active or combustion then
				items_combustion()
			end
			if Squid_Burst and ( tContains( equipped_items, 172669 ) or tContains( equipped_items, 167380 ) or tContains( equipped_items, 165058 ) ) then
				if GetItemCD(172669) <= 6 or GetItemCD(167380) <= 6 or GetItemCD(165058) <= 6 then
					return
				end
			end
			-- actions.items_high_priority+=/use_items
			-- actions.items_high_priority+=/use_item,name=manifesto_of_madness,if=!equipped.azsharas_font_of_power&amp;variable.time_to_combustion<8
			if not font_equipped and time_to_combustion < 8 then
				if tContains( equipped_items, 174103 ) and GetItemCD ( ( 174103 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 174103 ) ) )
					Squid_Alert( "Manifesto of Madness", nil, nil, nil, 313948 )
					return true
				end
			end
			-- actions.items_high_priority+=/use_item,name=azsharas_font_of_power,if=variable.time_to_combustion<=5+15*variable.font_double_on_use&amp;!variable.disable_combustion
			if font_equipped then
				-- if time_to_combustion <= 5 + 15 * (font_double_on_use and not disable_combustion and 1 or 0) then
				-- 	if GetItemCD ( ( 169314 ) ) == 0 then
				-- 		UseItemByName( tostring( GetItemInfo ( 169314 ) ) )
				-- 		Squid_Alert( "Font of Power", nil, nil, nil, 296962 )
				-- 		return true
				-- 	end
				-- end
			end
			-- actions.items_high_priority+=/use_item,name=rotcrusted_voodoo_doll,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
			-- actions.items_high_priority+=/use_item,name=aquipotent_nautilus,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
			-- actions.items_high_priority+=/use_item,name=shiver_venom_relic,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
			-- actions.items_high_priority+=/use_item,name=forbidden_obsidian_claw,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
			if t_ttd > 7.5 and ( time_to_combustion > on_use_cutoff or disable_combustion ) and ( not Squid_Burst or combustion_cd > 20 ) then
				if tContains( equipped_items, 159624 ) and GetItemCD ( ( 159624 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 159624 ) ) )
					Squid_Alert( "Voodoo Doll", nil, nil, nil, 271462 )
					return true
				end
				if tContains( equipped_items, 169305 ) and GetItemCD ( ( 169305 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 169305 ) ) )
					Squid_Alert( "Aquipotent Nautilus", nil, nil, nil, 306146 )
					return true
				end
				if tContains( equipped_items, 168905 ) and GetItemCD ( ( 168905 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 168905 ) ) )
					Squid_Alert( "Shiver Venom Relic", nil, nil, nil, 301834 )
					return true
				end
				if tContains( equipped_items, 173944 ) and GetItemCD ( ( 173944 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 173944 ) ) )
					Squid_Alert( "Obsidian Claw", nil, nil, nil, 313148 )
					return true
				end
			end

			-- actions.items_high_priority+=/use_item,effect_name=harmonic_dematerializer
			if tContains( equipped_items, 167677 ) and GetItemCD ( ( 167677 ) ) == 0 then
				UseItemByName( tostring( GetItemInfo ( 167677 ) ) )
				Squid_Alert( "Harmonic Dematerializer", nil, nil, nil, 293512 )
				return true
			end

			-- actions.items_high_priority+=/use_item,name=malformed_heralds_legwraps,if=variable.time_to_combustion>=55&amp;buff.combustion.down&amp;variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
			-- actions.items_high_priority+=/use_item,name=ancient_knot_of_wisdom,if=variable.time_to_combustion>=55&amp;buff.combustion.down&amp;variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
			if time_to_combustion >= 55 and not combustion and time_to_combustion > on_use_cutoff or disable_combustion then
				if tContains( equipped_items, 167835 ) and GetItemCD ( ( 167835 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 167835 ) ) )
					Squid_Alert( "Malformed Herald's Legwraps", nil, nil, nil, 295174 )
					return true
				end
				if tContains( equipped_items, 166793 ) and GetItemCD ( ( 166793 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 166793 ) ) )
					Squid_Alert( "Ancient Knot of Wisdom", nil, nil, nil, 278267 )
					return true
				end
				if tContains( equipped_items, 161417 ) and GetItemCD ( ( 161417 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 161417 ) ) )
					Squid_Alert( "Ancient Knot of Wisdom", nil, nil, nil, 278267 )
					return true
				end
			end

			-- actions.items_high_priority+=/use_item,name=neural_synapse_enhancer,if=variable.time_to_combustion>=45&amp;buff.combustion.down&amp;variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion
			if time_to_combustion >= 45 and not combustion and time_to_combustion > on_use_cutoff or disable_combustion then
				if _HP("player") > 10 then
					if tContains( equipped_items, 168973 ) and GetItemCD ( ( 168973 ) ) == 0 then
						UseItemByName( tostring( GetItemInfo ( 168973 ) ) )
						Squid_Alert( "Neural Synapse Enhancer", nil, nil, nil, 300612 )
						return true
					end
				end
			end

		end

		local function active_talents()
			if not t then debug_print("returning on fire_blast (combust, 1)") return end
			-- actions.active_talents=living_bomb,if=active_enemies>1&amp;buff.combustion.down&amp;(variable.time_to_combustion>cooldown.living_bomb.duration|variable.time_to_combustion<=0|variable.disable_combustion)
			if (not single_target or not t_is_boss) and enemies_around_target > 1 and not combustion and ( time_to_combustion > 9.9 or time_to_combustion <= 0 or disable_combustion ) and (not hot_streak or hot_streak_remains > gcd + buffer) then
				if _Cast( 44457, t ) then return true end
			end
			-- actions.active_talents+=/meteor,if=buff.rune_of_power.up&amp;(firestarter.remains>cooldown.meteor.duration|!firestarter.active)|cooldown.rune_of_power.remains>target.time_to_die&amp;action.rune_of_power.charges<1|(cooldown.meteor.duration<variable.time_to_combustion|variable.time_to_combustion<=0|variable.disable_combustion)&amp;!talent.rune_of_power.enabled&amp;(cooldown.meteor.duration<firestarter.remains|!talent.firestarter.enabled|!firestarter.active)
			if meteor_enabled then
				if ( 45 < time_to_combustion or time_to_combustion <= 0 or disable_combustion ) or max(rune_of_power_cd,combustion_cd) > t_ttd and t_is_boss and rune_of_power_charges < 1 or ( 45 < time_to_combustion or time_to_combustion <= 0 or disable_combustion ) and not rune_of_power_enabled and ( 45 < firestarter_remains or not firestarter_enabled or not firestarter_active ) then
					if t_ttd > 3 or combustion or rune_of_power_up then
						if not _isMoving(t) and _AeCast( 153561, t, 40, 8 ) then
							Squid_Alert( "Meteor", nil, nil, nil, 153561 )
							return true
						elseif _isMoving(t) and _aeCastInMovingDirection( 153561, t, GetUnitSpeed(t)/1.15, 40 ) then
							Squid_Alert( "Meteor", nil, nil, nil, 153561 )
							return true
						end
					end
				end
			end
		end

		if meteor_key then
			if current_target then
				if _AeCast( 153561, current_target, 38.5, 8 ) then
					Squid_Alert( "Meteor", nil, nil, nil, 153561 )
					return true
				end
			end
		end

		-- had to split combustion phase into 2 parts, too many upvalues. this is 2nd part
		local function combustion_phase_2()

			-- actions.combustion_phase+=/flamestrike,if=((talent.flame_patch.enabled&amp;active_enemies>2)|active_enemies>6)&amp;buff.hot_streak.react&amp;!azerite.blaster_master.enabled
			fs_count = ( flame_patch_enabled and 3 or 8 + ( ( t_ahp > min_combust_health or t_is_boss ) and 6 or 0 ) )
			if not single_target and hot_streak and not blaster_master_enabled then
				-- if active_enemies >= fs_count then flamestrike_ready = true end
				if aoe_cast_best_position( 2120, 7 + ( hot_streak and 1 or 0 ), fs_count, 40, nil, flamestrike_cast_time, not hot_streak ) then
					return true
				end
			end

			-- actions.combustion_phase+=/pyroblast,if=buff.pyroclasm.react&amp;buff.combustion.remains>cast_time
			if pyroclasm and combustion_remains > pyro_cast_time and pyroclasm_remains > pyro_cast_time + .25 and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyro (combust 2, 1)") return true end
			end

			if facing_target then
				-- actions.combustion_phase+=/pyroblast,if=buff.hot_streak.react
				if hot_streak and ( not flame_strike_ready or gcd_remains <= .025 ) then
					local t = important_explosive or t
					if _Cast( 11366, t, true ) then debug_print("returning on pyro (combust 2, 2)") return true end
				end
				-- actions.combustion_phase+=/pyroblast,if=prev_gcd.1.scorch&amp;buff.heating_up.up
				if not meteor_in_flight and heating_up and player_casting_guaranteed_crit and ( not flamestrike_ready or gcd_remains <= 0 ) then
					local t = important_explosive or t
					if _Cast( 11366, t, true ) then debug_print("returning on pyro (combust 2, 3)") return true end
				end
			end

			-- actions.combustion_phase+=/phoenix_flames
			if (fire_blast_charges <= 1 or combustion_remains <= gcd+buffer) and (not fb_used or time - fb_used > .2 + latency) then
				if _Cast( 257541, t, true ) then pf_flying = time debug_print("returning on pf (combust 2, 1)") return true end
			end

			if phoenix_flames_charges == phoenix_flames_max_charges and (not fb_used or time - fb_used > .2 + latency) and not hot_streak and not heating_up then
				if _Cast( 257541, t, true ) then pf_flying = time debug_print("returning on pf (combust 2, 2)") return true end
			end

			-- actions.combustion_phase+=/scorch,if=buff.combustion.remains>cast_time&amp;buff.combustion.up|buff.combustion.down
			if combustion_remains > scorch_cast_time and fire_blast_charges == 0 then
				-- local t = explosive or t -- no scorch explosive?
				if _Cast( 2948, t, true ) then --[[print("Combust Scorch 1")]] return true end
			end

			-- actions.combustion_phase+=/living_bomb,if=buff.combustion.remains<gcd.max&amp;active_enemies>1
			if (not single_target or not t_is_boss) and combustion_remains < gcd and enemies_around_target > 1 then
				if _Cast( 44457, t ) then return true end
			end

			-- actions.combustion_phase+=/dragons_breath,if=buff.combustion.remains<gcd.max&amp;buff.combustion.up
			if combustion_remains < gcd and combustion then
				if t_dist < 6.5 and facing_target then
					if _Cast( 31661 ) then return true end
				end
			end

			-- actions.combustion_phase+=/scorch,if=target.health.pct<=30&amp;talent.searing_touch.enabled
			if ( scorch_execute_ready or combustion_remains > scorch_cast_time ) and searing_touch_enabled then
				if fire_blast_charges == 0 and fire_blast_next_charge_cd > .5 or not combustion then
					--other enemies
					for i=1,#Enemies do
						if ready_to_attack(Enemies[i]) and _HP(Enemies[i]) < 30 and squid_ttd(Enemies[i]) > scorch_cast_time then
							if _Cast( 2948, Enemies[i], true ) then --[[print("Combustion Scorch Execute")]] return true end
						end
					end
					--target
					if _Cast( 2948, t, true ) then --[[print("Combust Scorch 2")]] return true end
				end
			end

		end

		local function combustion_phase()
			-- print("doing it!")
			-- if t and t_ttd < 3 and not combustion and not lucid_dreams_up and not Squid_Burst then return end
			--counterspell for lucid dreams proc
			-- if not SQUID.i_am_kane then
			-- 	if lucid_minor or lucid_major then
			-- 		if not wristwraps_used or time - wristwraps_used > .5 then
			-- 			if fire_blast_full_recharge_time > fire_blast_base_cd + gcd_remains + ( ( hot_streak or combustion and ( pyro_flying or fb_flying ) and heating_up ) and gcd or 0) + (not rune_of_power_up and rune_of_power_cast_time or 0) + (meteor_enabled and meteor_cd < gcd and gcd or 0) and ( not combustion or not ( tContains( equipped_items, 168989 ) and GetItemCD ( ( 168989 ) ) == 0 ) ) then
			-- 				if t_is_boss or groupsize ~= 5 then
			-- 					if _spellCooldown(2139) == 0 then
			-- 						local e
			-- 						for i=1,#Enemies do
			-- 							e = Enemies[i]
			-- 							if not UnitCastingInfo(e) and not UnitChannelInfo(e) then
			-- 								if _Cast( 2139, e, true ) then return end
			-- 							end
			-- 						end
			-- 					end
			-- 				end
			-- 			end
			-- 		end
			-- 	end
			-- end
			--use fire blast when sitting on full stacks
			if fire_blast_charges == fire_blast_max_charges and phoenix_flames_charges == phoenix_flames_max_charges and not hot_streak and not heating_up then
				if not fb_used or time - fb_used > .2 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						--print("Combust Fireblast 1")
						fb_used = time
						debug_print("returning on fire_blast (combust, 1)")
						return true
					end
				end
			end
			-- # Combustion phase prepares abilities with a delay, then launches into the Combustion sequence
			-- actions.combustion_phase=lights_judgment,if=buff.combustion.down
			-- actions.combustion_phase+=/bag_of_tricks,if=buff.combustion.down
			-- actions.combustion_phase+=/living_bomb,if=active_enemies>1&amp;buff.combustion.down
			if not combustion then
				local player_race = UnitRace("player")
				if player_race == "Lightforged Draenei" and _Cast( 255647, t, true ) then
					Squid_Alert( "Light's Judgment", nil, nil, nil, 255647 )
				end
				if player_race == "Vulpera" and _Cast( 312411, t, true ) then
					Squid_Alert( "Bag of Tricks", nil, nil, nil, 312411 )
				end
				if enemies_around_target > 1 and (not lucid_dreams_up or lucid_dreams_remains > 10) then
					if _Cast( 44457, t ) then return true end
				end
			end
			-- # During Combustion, Fire Blasts are used to generate Hot Streaks and minimize the amount of time spent executing other spells. For standard Fire, Fire Blasts are only used when Heating Up is active or when a Scorch cast is in progress and Heating Up and Hot Streak are not active. With Blaster Master and Flame On, Fire Blasts can additionally be used while Hot Streak and Heating Up are not active and a Pyroblast is in the air and also while casting Scorch even if Heating Up is already active. The latter allows two Hot Streak Pyroblasts to be cast in succession after the Scorch. Additionally with Blaster Master and Flame On, Fire Blasts should not be used unless Blaster Master is about to expire or there are more than enough Fire Blasts to extend Blaster Master to the end of Combustion.
			-- actions.combustion_phase+=/fire_blast,use_while_casting=1,use_off_gcd=1,if=charges>=1&amp;((action.fire_blast.charges_fractional+(buff.combustion.remains-buff.blaster_master.duration)%cooldown.fire_blast.duration-(buff.combustion.remains)%(buff.blaster_master.duration-0.5))>=0|!azerite.blaster_master.enabled|!talent.flame_on.enabled|buff.combustion.remains<=buff.blaster_master.duration|buff.blaster_master.remains<0.5|equipped.hyperthread_wristwraps&amp;cooldown.hyperthread_wristwraps_300142.remains<5)&amp;buff.combustion.up&amp;(!action.scorch.executing&amp;!action.pyroblast.in_flight&amp;buff.heating_up.up|action.scorch.executing&amp;buff.hot_streak.down&amp;(buff.heating_up.down|azerite.blaster_master.enabled)|azerite.blaster_master.enabled&amp;talent.flame_on.enabled&amp;action.pyroblast.in_flight&amp;buff.heating_up.down&amp;buff.hot_streak.down)
			if fire_blast_charges >= 1 and ( ( fire_blast_charges_frac + ( combustion_remains - 3 ) % fire_blast_base_cd - ( combustion_remains ) % ( 3 - 0.5 ) ) >= 0 or not blaster_master_enabled or not flame_on or combustion_remains <= blaster_master_remains or blaster_master_remains < 0.5 or tContains( equipped_items, 168989 ) and GetItemCD( 168989 ) < 5 ) and combustion and ( player_cast_id ~= 2948 and not pyro_flying and heating_up or player_cast_id == 2948 and not hot_streak and ( not heating_up or blaster_master_enabled ) or blaster_blaster_enabled and flame_on and pyro_flying and not hot_streak ) then
				if not hot_streak and (player_cast_id ~= 2948 or not heating_up) then
					if not fb_used or time - fb_used > .2 + latency then
						local t = explosive or t
						if _Cast( 108853, t, true ) then
							fb_used = time
							debug_print("returning on fire_blast (combust, 2)")
							return true
						end
					end
				end
			end
			--use fire blast if capped on charges when not using meteor or rop
			if fire_blast_charges == fire_blast_max_charges and not meteor_enabled and not rune_of_power_enabled and not hot_streak then
				if not fb_used or time - fb_used > .25 + latency then
					if _Cast( 108853, t, true ) then
						--print("Combust Fireblast 2")
						fb_used = time
						debug_print("returning on fire_blast (combust, 3)")
						return true
					end
				end
			end
			-- actions.combustion_phase+=/rune_of_power,if=buff.combustion.down
			-- if not combustion then
			-- 	if not _isMoving("player") and _Cast( 116011 ) then
			-- 		Squid_Alert( "Rune of Power", nil, nil, nil, 116011 )
			-- 		return true
			-- 	end
			-- end
			-- # A Fire Blast should be used to apply Blaster Master while casting Rune of Power when using Blaster Master, Flame On, and Meteor. If only Memory of Lucid Dreams Minor is equipped, this line is ignored because it will sometimes result in going into Combustion with few Fire Blast charges.
			-- actions.combustion_phase+=/fire_blast,use_while_casting=1,if=azerite.blaster_master.enabled&amp;(essence.memory_of_lucid_dreams.major|!essence.memory_of_lucid_dreams.minor)&amp;talent.meteor.enabled&amp;talent.flame_on.enabled&amp;buff.blaster_master.down&amp;(talent.rune_of_power.enabled&amp;action.rune_of_power.executing&amp;action.rune_of_power.execute_remains<0.6|(variable.time_to_combustion<=0|buff.combustion.up)&amp;!talent.rune_of_power.enabled&amp;!action.pyroblast.in_flight&amp;!action.fireball.in_flight)
			if fire_blast_charges_frac >= 1.9 then
				if blaster_master_enabled and meteor_enabled and flame_on and blaster_master_remains < .25 and ( rune_of_power_enabled and player_cast_id == 116011 and player_cast_time_left < 0.6 or ( time_to_combustion <= 0 or combustion ) and not rune_of_power_enabled and not pyro_flying and not fb_flying ) and (not hot_streak or blaster_master_stacks >= 2) then
					if not fb_used or time - fb_used > .25 + latency then
						local t = explosive or t
						if _Cast( 108853, t, true ) then
							--print("Combust Fireblast 5")
							fb_used = time
							debug_print("returning on fire_blast (combust, 4)")
							return true
						end
					end
				end
			end
			-- actions.combustion_phase+=/call_action_list,name=active_talents
			if active_talents() then return true end
			-- actions.combustion_phase+=/combustion,use_off_gcd=1,use_while_casting=1,if=((action.meteor.in_flight&amp;action.meteor.in_flight_remains<=0.5)|!talent.meteor.enabled)&amp;(buff.rune_of_power.up|!talent.rune_of_power.enabled)
			-- removing the delay on combusting while meteor is in flight
			if ( meteor_in_flight and ( meteor_in_flight_remains <= 1.5 + latency or hot_streak and fire_blast_charges_frac >= fire_blast_max_charges - 1 or SQUID.wildi_mode ) ) or not meteor_enabled or Squid_Burst then
				if _spellCooldown( 190319 ) <= .2 and player_cast_time_left <= buffer + .3 then
					CastSpellByID( 190319 )
					Squid_Alert_Big( "Combustion", nil, nil, nil, 190319 )
					debug_print("returning on combustion (combust, 44)")
					return true
				end
			end
			-- actions.combustion_phase+=/potion
			if best_pot and SQUID.pre_pot_enabled then
				if GetItemCD ( ( best_pot ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( best_pot ) ) )
					Squid_Alert( tostring( GetItemInfo ( best_pot ) ), nil, nil, nil, 300714 )
					-- return true
				end
			end
			-- actions.combustion_phase+=/blood_fury
			-- actions.combustion_phase+=/berserking
			-- actions.combustion_phase+=/fireblood
			-- actions.combustion_phase+=/ancestral_call
			_Cast( 33697 )
			_Cast( 26297 )
			_Cast( 265221 )
			_Cast( 274738 )

			-- if meteor_in_flight and meteor_in_flight_remains < scorch_cast_time and time_to_combustion <= scorch_cast_time then
			-- 	if _Cast( 2948, t, true ) then return true end
			-- end

			--maintain blaster master during meteor drop > combust gap
			-- if not hot_streak and blaster_master_enabled and ( meteor_in_flight or not meteor_enabled ) and ( rune_of_power_up or not rune_of_power_enabled ) and blaster_master_up and blaster_master_remains < .25 then
			-- 	if not fb_used or time - fb_used > .15 then
			-- 		if _Cast( 108853, t, true ) then
			-- 			fb_used = time
			-- 			return true
			-- 		end
			-- 	end
			-- end

			combustion_phase_2() -- combustion pt 2!

			if time_to_combustion <= gcd then debug_print("returning on tiem to combust (combust, 44)") return end

		end

		local function rop_phase()
			-- actions.rop_phase=rune_of_power
			if not rune_of_power_up and _Cast( 116011 ) then debug_print("returning on rop (rop_phase, 1)") return true end
			-- actions.rop_phase+=/flamestrike,if=(talent.flame_patch.enabled&amp;active_enemies>1|active_enemies>4)&amp;buff.hot_streak.react
			fs_count = ( flame_patch_enabled and 2 or 6 + ( ( t_ahp > min_combust_health or t_is_boss ) and 6 or 0 ) )
			if not single_target and hot_streak then
				-- if active_enemies >= fs_count then flamestrike_ready = true end
				if aoe_cast_best_position( 2120, 7 + ( hot_streak and 1 or 0 ), fs_count, 40, nil, flamestrike_cast_time, not hot_streak ) then
					debug_print("returning on fs (rop, 1)")
					return true
				end
			end
			if rune_of_power_remains > fireball_cast_time + buffer and (not scorch_execute_ready or worldvein_major and combustion_cd < worldvein_cd) then
				-- alert that we are holding a hot streak so the player stands still for fireball
				if hot_streak and fire_blast_charges_frac < 2.75 and not pyro_flying and not firestarter_active and player_cast_id ~= 133 and _isMoving("player") and t_ttd > fireball_cast_time + gcd and t_hp > 30 then
					Squid_Alert_Big("Stand Still","(Fireball > Pyro)",nil,.35,133)
				end
				-- hot streak < fireball cast
				if hot_streak and hot_streak_remains <= fireball_cast_time + buffer and ( not flamestrike_ready or gcd_remains <= 0 ) then
					local t = important_explosive or t
					if _Cast( 11366, t, true ) then debug_print("returning on pyro (rop, 1)") return true end
				end
				-- fireball with hot streak proc
				if not fireball_cast_delay or time - fireball_cast_delay > .2 then
					if hot_streak and not _isMoving("player") and not UnitCastingInfo("player") and facing_target and t_ttd > fireball_cast_time + gcd then
						if _Cast( 133, t) then debug_print("returning on fb (rop, 1)") return true end
					end
				end
				-- actions.standard_rotation+=/pyroblast,if=buff.hot_streak.react&amp;(prev_gcd.1.fireball|firestarter.active|action.pyroblast.in_flight)
				if facing_target and hot_streak and ( player_cast_id == 133 or firestarter_active or pyro_flying or fire_blast_charges_frac >= 2.75 or scorch_execute_ready ) and ( not flamestrike_ready or gcd_remains <= 0 ) then
					local t = important_explosive or t
					if _Cast( 11366, t, true ) then debug_print("returning on pyro (rop, 2)") return true end
				end
			else
				-- actions.rop_phase+=/pyroblast,if=buff.hot_streak.react
				if hot_streak and facing_target and ( not flamestrike_ready or gcd_remains <= 0 ) then
					local t = important_explosive or t
					if _Cast( 11366, t, true ) then debug_print("returning on pyro (rop, 3)") return true end
				end
			end
			-- actions.rop_phase+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=!(talent.flame_patch.enabled&amp;active_enemies>2|active_enemies>5)&amp;(!firestarter.active&amp;(variable.time_to_combustion>0|variable.disable_combustion))&amp;(!buff.heating_up.react&amp;!buff.hot_streak.react&amp;!prev_off_gcd.fire_blast&amp;(action.fire_blast.charges>=2|(action.phoenix_flames.charges>=1&amp;talent.phoenix_flames.enabled)|(talent.alexstraszas_fury.enabled&amp;cooldown.dragons_breath.ready)|(talent.searing_touch.enabled&amp;target.health.pct<=30)))
			if not ( flame_patch_enabled and active_enemies > 2 or active_enemies > 5 ) and ( not firestarter_active and ( time_to_combustion > 0 or disable_combustion ) ) and ( not heating_up and not hot_streak and PlayerSpellCasts[1] ~= 108853 and ( fire_blast_charges >= 2 or ( phoenix_flames_charges >= 1 and phoenix_flames_enabled ) or ( alexstraszas_fury_enabled and db_cd <= gcd_remains ) or ( scorch_execute_ready ) ) ) then
				if not fb_used or time - fb_used > .2 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						-- print("RoP Fireblast 1")
						fb_used = time
						debug_print("returning on fire_blast (rop, 1)")
						return true
					end
				end
			end
			-- actions.rop_phase+=/call_action_list,name=active_talents
			active_talents()
			-- actions.rop_phase+=/pyroblast,if=buff.pyroclasm.react&amp;cast_time<buff.pyroclasm.remains&amp;buff.rune_of_power.remains>cast_time
			if pyroclasm and pyro_cast_time < pyroclasm_remains and rune_of_power_remains > pyro_cast_time and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyro (rop, 4)") return true end
			end
			-- actions.rop_phase+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=!(talent.flame_patch.enabled&amp;active_enemies>2|active_enemies>5)&amp;(!firestarter.active&amp;(variable.time_to_combustion>0|variable.disable_combustion))&amp;(buff.heating_up.react&amp;(target.health.pct>=30|!talent.searing_touch.enabled))
			if not ( flame_patch_enabled and active_enemies > 2 or active_enemies > 5 ) and ( not firestarter_active and ( time_to_combustion > 0 or disable_combustion ) ) and ( heating_up and ( not scorch_execute_ready ) ) then
				if not fb_used or time - fb_used > .2 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						-- print("RoP Fireblast 2")
						fb_used = time
						debug_print("returning on fire_blast (rop, 2)")
						return true
					end
				end
			end
			-- actions.rop_phase+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=!(talent.flame_patch.enabled&amp;active_enemies>2|active_enemies>5)&amp;(!firestarter.active&amp;(variable.time_to_combustion>0|variable.disable_combustion))&amp;talent.searing_touch.enabled&amp;target.health.pct<=30&amp;(buff.heating_up.react&amp;!action.scorch.executing|!buff.heating_up.react&amp;!buff.hot_streak.react)
			if not ( flame_patch_enabled and active_enemies > 2 or active_enemies > 5 ) and ( not firestarter_active and ( time_to_combustion > 0 or disable_combustion ) ) and scorch_execute_ready and ( heating_up and player_cast_id ~= 2948 or heating_up and not hot_streak ) then
				if not fb_used or time - fb_used > .2 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						-- print("RoP Fireblast 3")
						fb_used = time
						debug_print("returning on fire_blast (rop, 3)")
						return true
					end
				end
			end
			-- actions.rop_phase+=/pyroblast,if=prev_gcd.1.scorch&amp;buff.heating_up.up&amp;talent.searing_touch.enabled&amp;target.health.pct<=30&amp;(!talent.flame_patch.enabled|active_enemies=1)
			if player_casting_guaranteed_crit and ( not flame_patch_enabled or active_enemies == 1 ) and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, nil, true ) then debug_print("returning on pyro (rop, 4)") return true end
				debug_print("returning on pyro weird return (rop, 123)")
				return true
			end
			-- actions.rop_phase+=/phoenix_flames,if=!prev_gcd.1.phoenix_flames&amp;buff.heating_up.react
			if Prev_GCD( 1 ) ~= 257541 and heating_up and combustion and (not fb_used or time - fb_used > .2 + latency) then
				if _Cast( 257541, t, true ) then pf_flying = time debug_print("returning on PF (rop, 1)") return true end
			end
			-- actions.rop_phase+=/scorch,if=target.health.pct<=30&amp;talent.searing_touch.enabled
			if searing_touch_enabled and not hot_streak then
				for i=1,#Enemies do if ready_to_attack(Enemies[i]) and _HP(Enemies[i]) < 30 and squid_ttd(Enemies[i]) > scorch_cast_time then
					if _Cast( 2948, Enemies[i], true ) then debug_print("returning on scorch (rop, 1)") return true end
				end end
			end
			if t_hp <= 30 and searing_touch_enabled and not hot_streak then
				if _Cast( 2948, t, true ) then debug_print("returning on scorch (rop, 2)") return true end
			end
			-- actions.rop_phase+=/dragons_breath,if=active_enemies>2
			-- if active_enemies > 2 and facing_target and t_dist < 6.5 then
			-- 	if _Cast( 31661 ) then return true end
			-- end
			-- # When Hardcasting Flame Strike, Fire Blasts should be used to generate Hot Streaks and to extend Blaster Master.
			-- actions.rop_phase+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=(talent.flame_patch.enabled&amp;active_enemies>2|active_enemies>5)&amp;((variable.time_to_combustion>0|variable.disable_combustion)&amp;!firestarter.active)&amp;buff.hot_streak.down&amp;(!azerite.blaster_master.enabled|buff.blaster_master.remains<0.5)
			if ( flame_patch_enabled and active_enemies >= 4 or active_enemies > 6 ) and not hot_streak and ( not blaster_master_enabled or blaster_master_remains <= buffer ) then
				if not fb_used or time - fb_used > .2 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						--print("RoP Fireblast 4")
						fb_used = time
						debug_print("returning on fire_blast (rop, 4)")
						return true
					end
				end
			end
			-- actions.rop_phase+=/flamestrike,if=talent.flame_patch.enabled&amp;active_enemies>2|active_enemies>5
			if not single_target and flame_patch_enabled then
				fs_count = 4
				if aoe_cast_best_position( 2120, 7 + ( hot_streak and 1 or 0 ), fs_count, 40, nil, flamestrike_cast_time, not hot_streak ) then
					debug_print("returning on flamestrike (rop, 1)")
					return true
				end
			end
			-- actions.rop_phase+=/fireball
			if _Cast( 133, t) then debug_print("returning on fireball (rop, 1)") return true end
			-- alert that we are not scorching because it would waste a heating up proc
			if not scorch_execute_ready then
				if heating_up and not hot_streak and fire_blast_charges == 0 and fire_blast_next_charge_cd >= scorch_cast_time - buffer then
					Squid_Alert_Big("Stand Still","(Fireball)",nil,.35,133)
				end
			end
			-- scorch while moving if it's a viable option
			if not heating_up or fire_blast_charges > 0 or fire_blast_next_charge_cd < scorch_cast_time - buffer then
				if _Cast( 2948, t, true ) then debug_print("returning on scorch (rop, 44)") return true end
			end
		end

		local function items_low_priority()
			if UnitCastingInfo("player") or UnitChannelInfo("player") then return end
			-- actions.items_low_priority=use_item,name=tidestorm_codex,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion|talent.firestarter.enabled&amp;firestarter.remains>variable.on_use_cutoff
			-- actions.items_low_priority+=/use_item,effect_name=cyclotronic_blast,if=variable.time_to_combustion>variable.on_use_cutoff|variable.disable_combustion|talent.firestarter.enabled&amp;firestarter.remains>variable.on_use_cutoff
			if time_to_combustion > on_use_cutoff or disable_combustion or firestarter_enabled and firestarter_remains > on_use_cutoff then
				if tContains( equipped_items, 165576 ) and GetItemCD ( ( 165576 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 165576 ) ) )
					Squid_Alert( "Tidestorm Codex", nil, nil, nil, 289885 )
					return true
				end
				if tContains( equipped_items, 167672 ) and GetItemCD ( ( 167672 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 167672 ) ) )
					Squid_Alert( "Cyclotronic Blast", nil, nil, nil, 293491 )
					return true
				end
			end
		end

		local function standard_rotation_2()
			-- actions.standard_rotation+=/call_action_list,name=active_talents
			active_talents()
			-- actions.standard_rotation+=/dragons_breath,if=active_enemies>1
			-- if facing_target and t_dist < 6.5 and active_enemies > 1 then
			-- 	if _Cast( 31661 ) then return true end
			-- end
			-- actions.standard_rotation+=/call_action_list,name=items_low_priority
			items_low_priority()
			-- fireball prio with worldvein combust
			if t_ttd > fireball_cast_time and not heating_up and worldvein_major and combustion_cd > worldvein_cd then
				if _Cast(133,t,true) then debug_print("returning on fireball (standard_rotation 2 , 1)") return true end
			end
			-- actions.standard_rotation+=/scorch,if=target.health.pct<=30&amp;talent.searing_touch.enabled
			if searing_touch_enabled and not hot_streak then
				for i=1,#Enemies do if ready_to_attack(Enemies[i]) and _HP(Enemies[i]) < 30 and squid_ttd(Enemies[i]) > scorch_cast_time then
					if _Cast( 2948, Enemies[i], true ) then debug_print("returning on scorch (standard_rotation 2 , 1)") return true end
				end end
			end
			if t_hp <= 30 and searing_touch_enabled and not hot_streak then
				if _Cast( 2948, t, true ) then debug_print("returning on scorch (standard_rotation 2 , 2)") return true end
			end
			-- -- # When Hardcasting Flame Strike, Fire Blasts should be used to generate Hot Streaks and to extend Blaster Master.
			-- -- actions.standard_rotation+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=!variable.fire_blast_pooling&amp;(talent.flame_patch.enabled&amp;active_enemies>2|active_enemies>9)&amp;((variable.time_to_combustion>0|variable.disable_combustion)&amp;!firestarter.active)&amp;buff.hot_streak.down&amp;(!azerite.blaster_master.enabled|buff.blaster_master.remains<0.5)
			-- if ( flame_patch_enabled and active_enemies > 2 or active_enemies > 9 ) and not hot_streak and ( not blaster_master_enabled or blaster_master_remains <= buffer * 1.08 ) and ( not fire_blast_pooling or fire_blast_charges_frac >= 3 - blaster_master_stacks - (heating_up and heating_up_remains <= buffer and 1 or 0) - .1 and ( rune_of_power_next_charge_cd > fire_blast_next_charge_cd or combustion_cd <= 10 and not auto_combust or auto_combust and not_combusting_target and t_ttd > 3 )  ) then
			-- 	if not fb_used or time - fb_used > .25 + latency then
			-- 		local t = explosive or t
			-- 		if _Cast( 108853, t, true ) then
			-- 			--print("Standard Fireblast 3")
			-- 			fb_used = time
			-- 			debug_print("returning on fireblast (standard_rotation 2 , 1)")
			-- 			return true
			-- 		end
			-- 	end
			-- end
			-- # With enough targets, it is a gain to cast Flamestrike as filler instead of Fireball.
			-- actions.standard_rotation+=/flamestrike,if=talent.flame_patch.enabled&amp;active_enemies>2|active_enemies>9
			fs_count = ( flame_patch_enabled and 4 or 11 + ( ( t_ahp > min_combust_health or t_is_boss ) and 6 or 0 ) )
			if not single_target and aoe_cast_best_position( 2120, 7 + ( hot_streak and 1 or 0 ) , fs_count, 40, nil, flamestrike_cast_time, not hot_streak ) then
				debug_print("returning on flamestrike (standard_rotation 2 , 1)")
				return true
			end
			-- actions.standard_rotation+=/fireball
			if _Cast( 133, t) then debug_print("returning on fireball (standard_rotation 2 , 22)") return true end
			-- actions.standard_rotation+=/scorch
			if _Cast( 2948, t, true ) then debug_print("returning on scorch (standard_rotation 2 , 22)") return true end
		end

		local function standard_rotation()
			-- actions.standard_rotation=flamestrike,if=((talent.flame_patch.enabled&amp;active_enemies>1&amp;!firestarter.active)|active_enemies>4)&amp;buff.hot_streak.react
			fs_count = ( flame_patch_enabled and not firestarter_active and 4 or 6 + ( ( t_ahp > min_combust_health or t_is_boss ) and 6 or 0 ) )
			if not single_target and hot_streak then
				-- if active_enemies >= fs_count then flamestrike_ready = true end
				if aoe_cast_best_position( 2120, 7 + ( hot_streak and 1 or 0 ), fs_count, 40, nil, flamestrike_cast_time, not hot_streak ) then
					debug_print("returning on flamestrike (standard_rotation, 1)")
					return true
				end
			end
			-- alert that we are holding a hot streak so the player stands still for fireball
			if not scorch_execute_ready then
				if hot_streak and fire_blast_charges_frac < 2.75 and not pyro_flying and not firestarter_active and player_cast_id ~= 133 and _isMoving("player") and t_ttd > fireball_cast_time + gcd and t_hp > 30 then
					Squid_Alert_Big("Stand Still","(Fireball > Pyro)",nil,.35,133)
				end
			end
			-- actions.standard_rotation+=/pyroblast,if=buff.hot_streak.react&amp;buff.hot_streak.remains<action.fireball.execute_time
			if hot_streak and hot_streak_remains <= fireball_cast_time + buffer and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyroblast (standard_rotation, 1)") return true end
			end
			-- queue up fireball with pyro
			if not scorch_execute_ready then
				if not fireball_cast_delay or time - fireball_cast_delay > .2 then
					if hot_streak and not _isMoving("player") and not UnitCastingInfo("player") and facing_target and t_ttd > fireball_cast_time + gcd + (solo_mode and 6 or 0) and not UnitBuffID("player",333100) then
						if _Cast( 133, t) then debug_print("returning on fireball (standard_rotation, 1)") return true end
					end
				end
			end
			-- actions.standard_rotation+=/pyroblast,if=buff.hot_streak.react&amp;(prev_gcd.1.fireball|firestarter.active|action.pyroblast.in_flight)
			if facing_target and hot_streak and ( player_cast_id == 133 or UnitBuffID("player",333100) or firestarter_active or pyro_flying or fire_blast_charges_frac >= 2.75 or scorch_execute_ready or (solo_mode and _isMoving("player"))) and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyroblast (standard_rotation, 2)") return true end
			end
			-- actions.standard_rotation+=/phoenix_flames,if=charges>=3&amp;active_enemies>2&amp;!variable.phoenix_pooling
			if phoenix_flames_enabled and phoenix_flames_charges >= 3 and active_enemies > 3 and not phoenix_pooling and (not heating_up or combustion) and (not fb_used or time - fb_used > .2 + latency) and (not fb_used or time - fb_used > .2 + latency) then
				if _Cast( 257541, t, true ) then pf_flying = time debug_print("returning on phoenix_flames (standard_rotation, 1)") return true end
			end
			-- actions.standard_rotation+=/pyroblast,if=buff.hot_streak.react&amp;target.health.pct<=30&amp;talent.searing_touch.enabled
			if facing_target and hot_streak and scorch_execute_ready and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyroblast (standard_rotation, 3)") return true end
			end
			-- actions.standard_rotation+=/pyroblast,if=buff.pyroclasm.react&amp;cast_time<buff.pyroclasm.remains
			if pyroclasm and pyro_cast_time < pyroclasm_remains and ( not flamestrike_ready or gcd_remains <= 0 ) then
				local t = important_explosive or t
				if _Cast( 11366, t, true ) then debug_print("returning on pyroblast (standard_rotation, 4)") return true end
			end
			-- actions.standard_rotation+=/fire_blast,use_off_gcd=1,use_while_casting=1,if=((variable.time_to_combustion>0|variable.disable_combustion)&amp;buff.rune_of_power.down&amp;!firestarter.active)&amp;!talent.kindling.enabled&amp;!variable.fire_blast_pooling&amp;(((action.fireball.executing|action.pyroblast.executing)&amp;(buff.heating_up.react))|(talent.searing_touch.enabled&amp;target.health.pct<=30&amp;(buff.heating_up.react&amp;!action.scorch.executing|!buff.hot_streak.react&amp;!buff.heating_up.react&amp;action.scorch.executing&amp;!action.pyroblast.in_flight&amp;!action.fireball.in_flight)))
			if ( ( time_to_combustion > 0 or disable_combustion ) and not rune_of_power_up and not firestarter_active ) and not kindling_enabled and not fire_blast_pooling and ( ( ( player_cast_id == 133 or player_cast_id == 11366 ) and ( heating_up ) ) or ( scorch_execute_ready and ( heating_up and player_cast_id ~= 2948 or not hot_streak and not heating_up and player_cast_id == 2948 and not pyro_flying and not fb_flying ) ) ) then
				if not fb_used or time - fb_used > .2 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						--print("Standard Fireblast 1")
						fb_used = time
						debug_print("returning on fire_blast (standard_rotation, 1)")
						return true
					end
				end
			end
			-- actions.standard_rotation+=/fire_blast,if=talent.kindling.enabled&amp;buff.heating_up.react&amp;!firestarter.active&amp;(variable.time_to_combustion>full_recharge_time+2+talent.kindling.enabled|variable.disable_combustion|(!talent.rune_of_power.enabled|cooldown.rune_of_power.remains>target.time_to_die&amp;action.rune_of_power.charges<1)&amp;variable.time_to_combustion>target.time_to_die)
			if kindling_enabled and heating_up and not firestarter_active and ( time_to_combustion > fire_blast_full_recharge_time + 2 + ( kindling_enabled and 1 or 0 ) or disable_combustion or ( not rune_of_power_enabled or rune_of_power_next_charge_cd > t_ttd and rune_of_power_charges < 1 ) and time_to_combustion > t_ttd ) then
				if not fb_used or time - fb_used > .2 + latency then
					local t = explosive or t
					if _Cast( 108853, t, true ) then
						fb_used = time
						debug_print("returning on fire_blast (standard_rotation, 2)")
						return true
					end
				end
			end
			-- actions.standard_rotation+=/fire_blast,if=talent.kindling.enabled&amp;buff.heating_up.react&amp;!firestarter.active&amp;(variable.time_to_combustion>full_recharge_time+2+talent.kindling.enabled|variable.disable_combustion|(!talent.rune_of_power.enabled|cooldown.rune_of_power.remains>target.time_to_die&amp;action.rune_of_power.charges<1)&amp;variable.time_to_combustion>target.time_to_die)
			if solo_mode and not hot_streak then
				if not firestarter_active and fire_blast_charges >= 2 - (heating_up and 1 or 0) and not UnitBuffID("player",203277) and (not player_casting_crittable_damage or player_cast_time_left > .5 or heating_up) then
					if not fb_used or time - fb_used > .2 + latency then
						local t = explosive or t
						if _Cast( 108853, t, true ) then
							fb_used = time
							debug_print("returning on fire_blast (standard_rotation, 3)")
							return true
						end
					end
				end
			end
			-- actions.standard_rotation+=/pyroblast,if=prev_gcd.1.scorch&amp;buff.heating_up.up&amp;talent.searing_touch.enabled&amp;target.health.pct<=30&amp;((talent.flame_patch.enabled&amp;active_enemies=1&amp;!firestarter.active)|(active_enemies<4&amp;!talent.flame_patch.enabled))
			if player_cast_id == 2948 and heating_up and player_casting_guaranteed_crit and ( ( flame_patch_enabled and active_enemies == 1 and not firestarter_active ) or ( active_enemies < 4 and not flame_patch_enabled ) ) then
				if facing_target and ( not flamestrike_ready or gcd_remains <= 0 ) then
					local t = important_explosive or t
					if _Cast( 11366, t, true ) then debug_print("returning on pyroblast (standard_rotation, 6)") return true end
				end
			end
			-- actions.standard_rotation+=/phoenix_flames,if=(buff.heating_up.react|(!buff.hot_streak.react&amp;(action.fire_blast.charges>0|talent.searing_touch.enabled&amp;target.health.pct<=30)))&amp;!variable.phoenix_pooling
			if not hot_streak then
				if ( heating_up or ( not hot_streak and ( fire_blast_charges > 0 or scorch_execute_ready ) ) ) and not phoenix_pooling and (combustion or active_enemies > 4 and not heating_up or phoenix_flames_charges == phoenix_flames_max_charges and not heating_up) and (not fb_used or time - fb_used > .2 + latency) then
					if _Cast( 257541, t, true ) then pf_flying = time debug_print("returning on phoenix_flames (standard_rotation, 69)") return true end
				end
			end
			standard_rotation_2()
		end

		local function actions()

			--blazing barrier high prio
			local blazing_hp = 70
			blazing_hp = blazing_hp - (combustion and 40 or 0)
			blazing_hp = blazing_hp - (rune_of_power_up and 20 or 0)

			if (not player_afk or player_combat) and player_hp < blazing_hp and barrier_remains < 5000 then
				if _Cast(235313) then
					Squid_Alert("Blazing Barrier",nil,nil,nil,235313)
					debug_print("returning on blazing_barrier (actions , 1)")
					return
				end
			end

			if not t then debug_print("returning on no valid target (actions , 1)") return end

			-- use the radiant spark
			-- if UnitHealth(t) >= UnitHealth("player")/3.5 then
			-- 	if _Cast(307443,t,true) then
			-- 		Squid_Alert("Radiant Spark", nil, nil, nil, 307443)
			-- 		return true
			-- 	end
			-- end

			-- actions+=/call_action_list,name=items_high_priority
			if items_high_priority() then debug_print("returning on items_high_priority") return true end

			--shifting_power,if=buff.combustion.down&amp;variable.time_to_combustion>full_reduction&amp;(cooldown.rune_of_power.remains>full_reduction|!talent.rune_of_power)&amp;!(buff.infernal_cascade.up&amp;
			--buff.hot_streak.react)&amp;(active_enemies<variable.combustion_shifting_power|active_enemies<variable.combustion_flamestrike|variable.time_to_combustion-full_reduction>cooldown)
			if IsPlayerSpell(314791) and not combustion and time_to_combustion > full_reduction and (rune_of_power_cd > full_reduction or not rune_of_power_enabled) and not (infernal_cascade and hot_streak) and
				(Enemies_Around_Unit('player', 18) < combustion_shifting_power or Enemies_Around_Unit('player', 18) < combustion_flamestrike or time_to_combustion - full_reduction > _spellCooldown(314791)) then
					if fire_blast_charges_frac <= 1.2 then
						_Cast(314791)
					end
			end

			-- actions+=/mirror_image,if=buff.combustion.down
			if not combustion and _HP("player") < 40 and t and _distance(t) < 40 then
				if _Cast( 55342 ) then
					Squid_Alert( "Mirror Image", nil, nil, nil, 55342 )
					debug_print("returning on mirror img (actions , 1)")
					return true
				end
			end
			-- actions+=/rune_of_power,if=talent.firestarter.enabled&amp;firestarter.remains>full_recharge_time|variable.time_to_combustion>variable.combustion_rop_cutoff&amp;buff.combustion.down|target.time_to_die<variable.time_to_combustion&amp;buff.combustion.down|variable.disable_combustion
			if firestarter_enabled and firestarter_remains > rune_of_power_full_recharge_time or time_to_combustion > combustion_rop_cutoff and not combustion or t_ttd < time_to_combustion and t_is_boss and not combustion then
				if t_ttd > 8.5 - (time_to_combustion > 45 + gcd_remains and meteor_enabled and meteor_cd <= 3 and 3 or 0) or t_is_boss and instance_type ~= "party" then
					if not _isMoving("player") and _Cast( 116011 ) then
						Squid_Alert( "Rune of Power", nil, nil, nil, 116011 )
						debug_print("returning on rune_of_power~1459")
						return true
					end
				end
			end
			-- actions+=/call_action_list,name=combustion_phase,if=!variable.disable_combustion&amp;(talent.rune_of_power.enabled&amp;variable.time_to_combustion<=action.rune_of_power.cast_time|variable.time_to_combustion<=0)&amp;!firestarter.active|buff.combustion.up
			if combustion_learned and ( time_to_combustion <= 2.5 or combustion ) then
				if (not disable_combustion or combustion or Squid_Burst) and ( rune_of_power_enabled and time_to_combustion <= rune_of_power_cast_time or time_to_combustion <= 0 ) and not firestarter_enabled or combustion or Squid_Burst then
					if ( ( t and t_ttd < 9 and not t_is_dummy ) or not auto_combust or UnitHealth(t) < min_combust_health ) and not Squid_Burst and not combustion then
						--do nothing
						not_combusting_target = true
						debug_print("returning on not combusting target? (actions , 1)")
					else
						combustion_phase()
						return
					end
				end
			end
			-- # During Firestarter, Fire Blasts are used similarly to during Combustion. Generally, they are used to generate Hot Streaks when crits will not be wasted and with Blaster Master, they should be spread out to maintain the Blaster Master buff.
			-- actions+=/fire_blast,use_while_casting=1,use_off_gcd=1,if=firestarter.active&amp;charges>=1&amp;(!variable.fire_blast_pooling|buff.rune_of_power.up)&amp;(!azerite.blaster_master.enabled|buff.blaster_master.remains<0.5)&amp;(!action.fireball.executing&amp;!action.pyroblast.in_flight&amp;buff.heating_up.up|action.fireball.executing&amp;buff.hot_streak.down|action.pyroblast.in_flight&amp;buff.heating_up.down&amp;buff.hot_streak.down)
			if firestarter_enabled and not hot_streak and not crit_inc then
				if firestarter_active and fire_blast_charges >= 1 and ( not fire_blast_pooling or rune_of_power_up ) and ( not blaster_master_enabled or blaster_master_remains < 0.5 ) and ( player_cast_id ~= 133 and not pyro_flying and heating_up or player_cast_id == 133 and not hot_streak or pyro_flying and not heating_up and not hot_streak ) then
					if not fb_used or time - fb_used > .2 + latency then
						local t = explosive or t
						if _Cast( 108853, t, true ) then
							--print("Actions Fireblast 2")
							fb_used = time
							debug_print("returning on fire_blast (actions, 1)")
							return true
						end
					end
				end
			end
			-- actions+=/call_action_list,name=rop_phase,if=buff.rune_of_power.up&amp;buff.combustion.down
			if rune_of_power_up and not combustion then
				rop_phase()
				debug_print("returning on rop_phase (actions, 1)")
				return
			end

			-- actions+=/call_action_list,name=standard_rotation
			standard_rotation()

		end

		precombat()

		if UnitIsVisible( t ) then
			if ( ready_to_attack( t ) or t_is_dummy and dbm_countdown == 1000 and player_combat ) then
				actions()
			end
		end

		--low prio blazing bar
		if not player_afk and barrier_remains < 5000 and not combustion and (not player_combat or player_hp < 15) then
			if _Cast(235313) then
				Squid_Alert("Blazing Barrier",nil,nil,nil,235313)
				return
			end
		end

		-- head=grasping_crown_of_the_deep,id=159252,bonus_id=1617/4820/4775,azerite_powers=168/215/30/13
		-- neck=heart_of_azeroth,id=158075,bonus_id=4929/5814/4936/1600,azerite_level=65
		-- shoulders=amice_of_the_reef_witch,id=168338,bonus_id=4824/1517/4775,azerite_powers=215/168/30/13
		-- back=cloak_of_blessed_depths,id=168602,bonus_id=4800/1517
		-- chest=vestments_of_creeping_terror,id=168337,bonus_id=4824/1517/4775,azerite_powers=378/215/30/13
		-- wrists=hyperthread_wristwraps,id=168989,bonus_id=4779/1472
		-- hands=poens_deepsea_gloves,id=170333,bonus_id=1512
		-- waist=vims_scalecrusher_belt,id=170367,bonus_id=1512
		-- legs=malformed_heralds_legwraps,id=167835,bonus_id=4800/1547
		-- feet=akanas_reefstrider_soles,id=170140,bonus_id=1512
		-- finger1=overclocking_bit_band,id=169159,bonus_id=4779/1472,enchant=accord_of_versatility
		-- finger2=logic_loop_of_division,id=169157,bonus_id=4779/1472,enchant=accord_of_versatility
		-- trinket1=azsharas_font_of_power,id=169314,bonus_id=4800/1517
		-- trinket2=leviathans_lure,id=169304,bonus_id=4800/1517
		-- main_hand=fang_of_the_behemoth,id=168397,bonus_id=4800/1517,enchant=torrent_of_elements
		-- off_hand=stormtamers_orb,id=168896,bonus_id=4800/1517

		-- # Gear Summary
		-- # gear_ilvl=436.44
		-- # gear_stamina=12616
		-- # gear_intellect=8749
		-- # gear_crit_rating=1362
		-- # gear_haste_rating=1235
		-- # gear_mastery_rating=422
		-- # gear_versatility_rating=552
		-- # gear_armor=1672


	end

	function Squid_Monk()

		if IsMounted() or IsAoEPending() then return end

		local spec = GetSpecialization()
		local time = GetTime()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
		local gcd_remains = GetGCD()

		--Windwalker
		if spec == 3 then

			local energy = UnitPower("player")
			local energy_max = UnitPowerMax("player")
			local energy_deficit = energy_max-energy
			local energy_regen = GetPowerRegen()
			local energy_time_to_max = energy_deficit / energy_regen
			local chi = UnitPower("player",12)
			local chi_max = UnitPowerMax("player",12)
			local chi_deficit = chi_max-chi

			local rising_sun_kick = 107428
			local fists_of_fury = 113656
			local whirling_dragon_punch = 152175
			local tiger_palm = 100780
			local spinning_crane_kick = 101546
			local tigers_last = 116841
			local blackout_kick = 100784
			local detox = 218164
			local chi_wave = 115098
			local fist_of_the_white_tiger = 261947
			local disable = 116095
			local provoke = 115546
			local diffuse_magic = 122783
			local leg_sweep = 119381
			local touch_of_death = 115080
			local touch_of_karma = 122470
			local roll = 109132
			local storm_earth_and_fire = 137639
			local transcendence = 101643
			local transcendence_transfer = 119996
			local ring_of_peace = 175697
			local vivify = 116670
			local reverse_harm = 287771

			local alpha_tiger_up = UnitBuffID("player",287504)
			local storm_earth_and_fire_up = UnitBuffID("player",137639)
			local swift_roundhouse_stacks = _buffStacks("player",277669)
			local port_up = UnitBuffID("player",101643)

			function port_in_los(unit)
				local x,y,z
				if port_up then
					x=portcoords.x
					y=portcoords.y
					z=portcoords.z
					local X,Y,Z = ObjectPosition(unit)
					return los_coords(x,y,z,X,Y,Z)
				end
			end

			function port_distance(unit)
				local x,y,z
				if port_up then
					x=portcoords.x
					y=portcoords.y
					z=portcoords.z
					local X,Y,Z = ObjectPosition(unit)
					return GetDistanceBetweenPositions(x,y,z,X,Y,Z)
				end
			end

			function port_distance_deficit(unit)
				local port = port_distance(unit)
				local player = _realDistance(unit)
				return player-port
			end

			local alpha_tiger_enabled = IsPlayerSpell(287503)
			local tigers_lust_enabled = IsPlayerSpell(116841)

			local spear_hand_strike_cd = _spellCooldown(116705)
			local roll_cd = _spellCooldown(109132)
			local touch_of_death_cd = _spellCooldown(115080)

			local storm_earth_and_fire_charges = GetSpellCharges(storm_earth_and_fire)
			local storm_earth_and_fire_charges_frac = _spellChargeFrac(storm_earth_and_fire)
			local fists_of_fury_cd = _spellCooldown(fists_of_fury)
			local rising_sun_kick_cd = _spellCooldown(rising_sun_kick)
			local time_to_next_sef = 180-(_spellChargeFrac(137639)*90)
			local player_hp = _HP("player")

			local function _valid(unit,immune)
				if not unit or not UnitIsVisible(unit) then return false end
				return unit
				and UnitCanAttack("player",unit)
				and not UnitIsDeadOrGhost(unit)
				and not _breakableCC(unit)
				and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
				and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))));
			end

			local function can_i_kick(unit)
				local dist = _realDistance(unit)
				local time_left_to_kick = _castTimeLeft(unit) - (dist * .1)
				if spear_hand_strike_cd > 0 then return false end
				if dist < 6 then
					return true
				end
				if dist < 20 and dist > 15 and _spellCooldown(109132) < time_left_to_kick then
					return true
				end
			end

			if _rootCheck("player") or _isSlowed("player") then
				_Cast(116841,"player")
			end

			local t = current_target
			if t and not UnitCanAttack("player",t) then t=nil end

			local validtar = _valid(t,1)
			local validmagic = _valid(t,2)
			local target_hp = _HP(t)
			local melee_range = _meleeRange(t)
			local dist = _distance(t)
			local bcc9 = _bccAM(9)

			local active_enemies = EnemiesAroundMe(6)

			local not_dmg = {
			"Roll",
			"Flying Serpent Kick",
			"Leg Sweep",
			"Storm, Earth, and Fire",
			"Storm, Earth, and Fire: Fixate",
			"Paralysis",
			"Ring of Peace",
			"Tiger's Lust",
			"Touch of Death",
			"Touch of Karma",
			"Transcendence",
			"Transcendence: Transfer",
			"Disable",
			"Crackling Jade Lightning",
			"Fortifying Brew",
			"Vivify",
			}

			prev_gcd = nil

			for i=1,#PlayerSpellCasts do
				if not tContains(not_dmg,PlayerSpellCasts[i].name) and IsSpellOnGCD(PlayerSpellCasts[i].name) and time-PlayerSpellCasts[i].time < 5 then
					prev_gcd = PlayerSpellCasts[i].name
					break;
				end
			end

			local function monk_cast(spell,unit,requiresfacing,forcefacing)
				local spellName=GetSpellInfo(spell)
				if prev_gcd ~= spellName then
					if spell == 152175 and current_target and UnitDebuffID(current_target,115080,"player") and _debuffRemains(current_target,115080,"player") < 1.5 then
						SpellStopCasting()
						CastSpellByID(spell,unit)
					end
					_Cast(spell,unit,requiresfacing,forcefacing)
				end
			end

			local function currentlyrolling()
				local crackling,check = IsUsableSpell(117952)
				return not crackling and not check
			end

			local function currentlyflying()
				return IsUsableSpell(115057) and _spellCooldown(101545) >= 23.5
			end

			if forced_fsk and time-forced_fsk <= 1.5 and currentlyflying() then
				if t then
					if _distance(t) < 4 and not bcc9 then
						_Cast(115057)
					end
				end
			end

			-- if currentlyrolling() then
			-- 	currently_rolling_lock = true
			-- 	SetMovementLocked(true)
			-- elseif not currentlyrolling() and currently_rolling_lock == true then
			-- 	SetMovementLocked(false)
			-- 	currently_rolling_lock=nil
			-- end

			if validtar and (dist > 11 or (dist > 8 and GetUnitSpeed(t) >= GetUnitSpeed("player") and not _slowImmuneCheck(t))) then
				if _movingTowards(t,.102,nil,nil,true) and moving_towards_unit_duration(t,.102) > .05 then
					if roll_cd >= 2 or dist > 18 then
						if fsk_to_unit(t) then
							Squid_Alert("Flying Serpent Kick","(Gapclose)",nil,nil,101545)
							return
						end
					end
					if dist <= 18 and roll_to_unit(t) then
						Squid_Alert("Roll","(Gapclose)",nil,nil,109132)
					end
				end
			end

			-- if UnitExists("focus") then roll_to_unit("focus",true) end
			if validtar then
				if UnitIsPlayer(t) then
					if (select(4,GetUnitSpeed(t)) >= select(4,GetUnitSpeed("player")) or not _slowCheck(t)) and not _slowImmuneCheck(t) then
						_Cast(116095,t,true)
					end
				end
			end

			-- 	# Executed every time the actor is available.
			-- actions=auto_attack
			if validtar and (not auto_attack or time-auto_attack > 1) then
				StartAttack()
				if storm_earth_and_fire_up then
					_Cast(221771,t)
				end
				auto_attack=time
			end
			-- # Touch of Karma on cooldown, if Good Karma is enabled equal to 100% of maximum health
			-- actions+=/touch_of_karma,interval=90,pct_health=0.5
			-- if player_hp < 7 then
			-- 	if validtar and not UnitBuffID(t,1022) then
			--  		if _Cast(touch_of_karma,t,nil,true) then
			--  			Squid_Alert("Karma " .. UnitClass(t),"(DANGER)",2,4,122470)
			--  		end
			--  	end
			-- 	for i=1,#Enemies do
			-- 		if not _immuneCheck(Enemies[i]) and not UnitBuffID(Enemies[i],1022) then
			-- 			if _Cast(touch_of_karma,Enemies[i],nil,true) then
			-- 				Squid_Alert("Karma " .. UnitClass(Enemies[i]),"(DANGER)",2,4,122470)
			-- 			end
			-- 		end
			-- 	end
			-- end
			-- # Potion if Serenity or Storm, Earth, and Fire are up or you are running serenity and a main stat trinket procs, or you are under the effect of bloodlust, or target time to die is greater or equal to 60
			-- actions+=/potion,if=buff.serenity.up|buff.storm_earth_and_fire.up|(!talent.serenity.enabled&amp;trinket.proc.agility.react)|buff.bloodlust.react|target.time_to_die<=60
			-- actions+=/call_action_list,name=serenity,if=buff.serenity.up
			-- actions+=/fist_of_the_white_tiger,if=(energy.time_to_max<1|(talent.serenity.enabled&amp;cooldown.serenity.remains<2))&amp;chi.max-chi>=3
			if validtar then
				if energy_time_to_max < 1 and chi_deficit >= 3 then
					_Cast(fist_of_the_white_tiger,t,true)
				end
			end
			-- actions+=/tiger_palm,target_if=min:debuff.mark_of_the_crane.remains,if=(energy.time_to_max<1|(talent.serenity.enabled&amp;cooldown.serenity.remains<2))&amp;chi.max-chi>=2&amp;!prev_gcd.1.tiger_palm
			if validtar and energy_time_to_max < 1 and chi_deficit >= 2 then
				monk_cast(100780,t,true)
			end

			local focused_azerite_beam = IsPlayerSpell(295258)
			local focused_azerite_beam_castable

			if validmagic and active_enemies > 2 and focused_azerite_beam then
				local facing = am_i_facing_angle(t)
				if _distance(t) < 10 and facing and not facing_bcc(t) then
					focused_azerite_beam_castable=true
				end
			end

			local function essences()
				-- actions.cleave+=/focused_azerite_beam
				if focused_azerite_beam_castable then
					_Cast(295258)
				end
			end

			local function cd()
				-- # Cooldowns
				-- actions.cd=invoke_xuen_the_white_tiger
				if validtar and (target_hp < 80 or their_healer_cc or not arena) then
					_Cast(123904)
				end
				-- actions.cd+=/use_item,name=variable_intensity_gigavolt_oscillating_reactor
				-- actions.cd+=/blood_fury
				-- actions.cd+=/berserking
				-- # Use Arcane Torrent if you are missing at least 1 Chi and won't cap energy within 0.5 seconds
				-- actions.cd+=/arcane_torrent,if=chi.max-chi>=1&amp;energy.time_to_max>=0.5
				-- actions.cd+=/lights_judgment
				-- actions.cd+=/fireblood
				-- actions.cd+=/ancestral_call
				-- actions.cd+=/touch_of_death,if=target.time_to_die>9
				if arena then
					if validtar then
						--touch of death in arena
						if fists_of_fury_cd <= 3 and chi >= 3 and rising_sun_kick_cd <= gcd then
							_Cast(115080,t,true)
						end
					end
				else
					if fists_of_fury_cd <= gcd*2 and chi >= 2 and rising_sun_kick_cd <= gcd*3 then
						if touch_of_death_cd <= gcd then
							CastSpellByID(201318)
							_Cast(115080,t,true)
						end
					end
				end
				-- actions.cd+=/storm_earth_and_fire,if=cooldown.storm_earth_and_fire.charges=2|(cooldown.fists_of_fury.remains<=6&amp;chi>=3&amp;cooldown.rising_sun_kick.remains<=1)|target.time_to_die<=15
				if validtar then
					if storm_earth_and_fire_charges == 2 or (fists_of_fury_cd <= 6 and chi >= 3 and rising_sun_kick_cd <= gcd and time_to_next_sef < _spellCooldown(115080)) or (_HP(t) < 35 and their_healer_cc) or UnitDebuffID(t,115080,"player") then
						_Cast(137639,t,true)
					end
				end
				-- actions.cd+=/serenity,if=cooldown.rising_sun_kick.remains<=2|target.time_to_die<=12
				-- actions.cd+=/call_action_list,name=essences
				essences()
			end

			local function st()
				-- actions.st=whirling_dragon_punch
				if validtar and dist < 4.5 and fists_of_fury_cd > 0 and rising_sun_kick_cd > 0 and not bcc9 then
					monk_cast(whirling_dragon_punch)
				end
				-- actions.st+=/rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains,if=chi>=5
				if validtar and chi >= 5 then
					monk_cast(107428,t,true)
				end
				--maintain alpha tiger
				if alpha_tiger_enabled and not alpha_tiger_up then
					if arena then
						for i=1,#Pets do if not UnitDebuffID(Pets[i],290512,"player") and not _breakableCC(Pets[i]) then
							monk_cast(100780,Pets[i],nil,true)
						end end
					else
						for i=1,#Enemies do if not UnitDebuffID(Enemies[i],290512,"player") and not _breakableCC(Enemies[i]) then
							monk_cast(100780,Enemies[i],nil,true)
						end end
					end
				end
				-- actions.st+=/fists_of_fury,if=energy.time_to_max>3
				if validtar and dist < 4.8 and not _slowImmuneCheck(t) and (energy_time_to_max > 1.5 or chi >= 4 or UnitDebuffID(t,115080,"player") or storm_earth_and_fire_up) and fists_of_fury_cd < 2 then
					monk_cast(fists_of_fury,t,true)
				end
				-- actions.st+=/rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains
				if validtar then
					monk_cast(rising_sun_kick,t,true)
				end
				-- actions.st+=/spinning_crane_kick,if=!prev_gcd.1.spinning_crane_kick&amp;buff.dance_of_chiji.up
				if validtar and dist <= 6 and not bcc9 and UnitBuffID("player",286587) then
					monk_cast(spinning_crane_kick)
				end
				-- actions.st+=/rushing_jade_wind,if=buff.rushing_jade_wind.down&amp;active_enemies>1
				-- actions.st+=/reverse_harm,if=chi.max-chi>=2
				if t then
					if chi_deficit >= 2 and (melee_range or dist > 6) then
						monk_cast(reverse_harm)
					end
				end
				-- actions.st+=/fist_of_the_white_tiger,if=chi<=2
				if validtar and chi <= 2 then
					monk_cast(fist_of_the_white_tiger,t,true)
				end
				-- actions.st+=/energizing_elixir,if=chi<=3&amp;energy<50
				if chi <= 3 and energy < 50 then
					_Cast(115288)
				end
				-- actions.st+=/blackout_kick,target_if=min:debuff.mark_of_the_crane.remains,if=!prev_gcd.1.blackout_kick&amp;(cooldown.rising_sun_kick.remains>3|chi>=3)&amp;(cooldown.fists_of_fury.remains>4|chi>=4|(chi=2&amp;prev_gcd.1.tiger_palm))&amp;buff.swift_roundhouse.stack<2
				if validtar and (rising_sun_kick_cd > 3 or chi >= 3) and (fists_of_fury_cd > 4 or chi >= 4 or (chi == 2 and prev_gcd == "Tiger Palm")) and swift_roundhouse_stacks < 2 then
					monk_cast(blackout_kick,t,true)
				end
				-- actions.st+=/chi_wave
				monk_cast(chi_wave,t,true)
				-- actions.st+=/chi_burst,if=chi.max-chi>=1&amp;active_enemies=1|chi.max-chi>=2
				if chi_deficit >= 1 and active_enemies == 1 or chi_deficit >= 2 then
					if validmagic and not bcc9 then
						monk_cast(123986)
					end
				end
				-- actions.st+=/tiger_palm,target_if=min:debuff.mark_of_the_crane.remains,if=!prev_gcd.1.tiger_palm&amp;chi.max-chi>=2
				if validtar and chi_deficit >= 2 then
					monk_cast(tiger_palm,t,true)
				end
				-- actions.st+=/flying_serpent_kick,if=prev_gcd.1.blackout_kick&amp;chi>3&amp;buff.swift_roundhouse.stack<2,interrupt=1
			end

			local function aoe()

			end

			-- actions+=/call_action_list,name=cd
			cd()
			-- # Call the ST action list if there are 2 or less enemies
			-- actions+=/call_action_list,name=st,if=active_enemies<3
			-- if arena or active_enemies < 2 or _isDummy(t) then
			st()
			-- else
			-- 	aoe()
			-- end
			-- -- # Call the AoE action list if there are 3 or more enemies
			-- actions+=/call_action_list,name=aoe,if=active_enemies>=3

			-- # Actions.AoE is intended for use with Hectic_Add_Cleave and currently needs to be optimized
			-- actions.aoe=rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains,if=(talent.whirling_dragon_punch.enabled&amp;cooldown.whirling_dragon_punch.remains<5)&amp;cooldown.fists_of_fury.remains>3
			-- actions.aoe+=/whirling_dragon_punch
			-- actions.aoe+=/energizing_elixir,if=!prev_gcd.1.tiger_palm&amp;chi<=1&amp;energy<50
			-- actions.aoe+=/fists_of_fury,if=energy.time_to_max>3
			-- actions.aoe+=/rushing_jade_wind,if=buff.rushing_jade_wind.down
			-- actions.aoe+=/spinning_crane_kick,if=!prev_gcd.1.spinning_crane_kick&amp;(((chi>3|cooldown.fists_of_fury.remains>6)&amp;(chi>=5|cooldown.fists_of_fury.remains>2))|energy.time_to_max<=3)
			-- actions.aoe+=/reverse_harm,if=chi.max-chi>=2
			-- actions.aoe+=/chi_burst,if=chi<=3
			-- actions.aoe+=/fist_of_the_white_tiger,if=chi.max-chi>=3
			-- actions.aoe+=/tiger_palm,target_if=min:debuff.mark_of_the_crane.remains,if=chi.max-chi>=2&amp;(!talent.hit_combo.enabled|!prev_gcd.1.tiger_palm)
			-- actions.aoe+=/chi_wave
			-- actions.aoe+=/flying_serpent_kick,if=buff.bok_proc.down,interrupt=1
			-- actions.aoe+=/blackout_kick,target_if=min:debuff.mark_of_the_crane.remains,if=!prev_gcd.1.blackout_kick&amp;(buff.bok_proc.up|(talent.hit_combo.enabled&amp;prev_gcd.1.tiger_palm&amp;chi<4))

			-- # Cooldowns
			-- actions.cd=invoke_xuen_the_white_tiger
			-- actions.cd+=/use_item,name=variable_intensity_gigavolt_oscillating_reactor
			-- actions.cd+=/blood_fury
			-- actions.cd+=/berserking
			-- # Use Arcane Torrent if you are missing at least 1 Chi and won't cap energy within 0.5 seconds
			-- actions.cd+=/arcane_torrent,if=chi.max-chi>=1&amp;energy.time_to_max>=0.5
			-- actions.cd+=/lights_judgment
			-- actions.cd+=/fireblood
			-- actions.cd+=/ancestral_call
			-- actions.cd+=/touch_of_death,if=target.time_to_die>9
			-- actions.cd+=/storm_earth_and_fire,if=cooldown.storm_earth_and_fire.charges=2|(cooldown.fists_of_fury.remains<=6&amp;chi>=3&amp;cooldown.rising_sun_kick.remains<=1)|target.time_to_die<=15
			-- actions.cd+=/serenity,if=cooldown.rising_sun_kick.remains<=2|target.time_to_die<=12
			-- actions.cd+=/call_action_list,name=essences

			-- actions.essences=concentrated_flame
			-- actions.essences+=/blood_of_the_enemy
			-- actions.essences+=/guardian_of_azeroth
			-- actions.essences+=/focused_azerite_beam
			-- actions.essences+=/purifying_blast
			-- actions.essences+=/the_unbound_force
			-- actions.essences+=/ripple_in_space
			-- actions.essences+=/worldvein_resonance
			-- actions.essences+=/memory_of_lucid_dreams,if=energy<40&amp;buff.storm_earth_and_fire.up

			-- # Serenity priority
			-- actions.serenity=rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains,if=active_enemies<3|prev_gcd.1.spinning_crane_kick
			-- actions.serenity+=/fists_of_fury,if=(buff.bloodlust.up&amp;prev_gcd.1.rising_sun_kick)|buff.serenity.remains<1|(active_enemies>1&amp;active_enemies<5)
			-- actions.serenity+=/spinning_crane_kick,if=!prev_gcd.1.spinning_crane_kick&amp;(active_enemies>=3|(active_enemies=2&amp;prev_gcd.1.blackout_kick))
			-- actions.serenity+=/blackout_kick,target_if=min:debuff.mark_of_the_crane.remains

			-- actions.st=whirling_dragon_punch
			-- actions.st+=/rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains,if=chi>=5
			-- actions.st+=/fists_of_fury,if=energy.time_to_max>3
			-- actions.st+=/rising_sun_kick,target_if=min:debuff.mark_of_the_crane.remains
			-- actions.st+=/spinning_crane_kick,if=!prev_gcd.1.spinning_crane_kick&amp;buff.dance_of_chiji.up
			-- actions.st+=/rushing_jade_wind,if=buff.rushing_jade_wind.down&amp;active_enemies>1
			-- actions.st+=/reverse_harm,if=chi.max-chi>=2
			-- actions.st+=/fist_of_the_white_tiger,if=chi<=2
			-- actions.st+=/energizing_elixir,if=chi<=3&amp;energy<50
			-- actions.st+=/blackout_kick,target_if=min:debuff.mark_of_the_crane.remains,if=!prev_gcd.1.blackout_kick&amp;(cooldown.rising_sun_kick.remains>3|chi>=3)&amp;(cooldown.fists_of_fury.remains>4|chi>=4|(chi=2&amp;prev_gcd.1.tiger_palm))&amp;buff.swift_roundhouse.stack<2
			-- actions.st+=/chi_wave
			-- actions.st+=/chi_burst,if=chi.max-chi>=1&amp;active_enemies=1|chi.max-chi>=2
			-- actions.st+=/tiger_palm,target_if=min:debuff.mark_of_the_crane.remains,if=!prev_gcd.1.tiger_palm&amp;chi.max-chi>=2
			-- actions.st+=/flying_serpent_kick,if=prev_gcd.1.blackout_kick&amp;chi>3&amp;buff.swift_roundhouse.stack<2,interrupt=1

		end

	end

	function Squid_Paladin()

		if IsMounted() or IsFlying() or UnitBuffID("player",32727) then return false end
		local spec = GetSpecialization()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		local gcd_remains = GetGCD()
		local time = GetTime()

		--Ret
		if spec == 3 then

			local combat = UnitAffectingCombat("player")
			local power = UnitPower("player",9)

			local hammer_of_wrath_enabled = IsPlayerSpell(24275)
			local inquisition_enabled = IsPlayerSpell(84963)
			local crusade_enabled = IsPlayerSpell(231895)
			local rv_enabled = IsPlayerSpell(267610)

			local inquisition_remains = _buffRemains("player",84963)

			local sh_stacks = _buffStacks("player",114250)

			local wings_up = UnitBuffID("player",31884)
			local inquisition_up = inquisition_remains > 0
			local empyrean_power_up = UnitBuffID("player",286393)
			local wings_auto_crit = UnitBuffID("player",294027)

			local consecration_cd = IsPlayerSpell(205228) and _spellCooldown(205228) or 69

			local how_cd = _spellCooldown(24275)
			local wings_cd = not crusade_enabled and _spellCooldown(31884) or _spellCooldown(231895)
			local boj_cd = _spellCooldown(184575)
			local judgment_cd = _spellCooldown(20271)

			local cs_charges_frac = _spellChargeFrac(35395)

			local active_enemies = 0
			for i=1,#Enemies do if UnitAffectingCombat(Enemies[i]) then
				active_enemies = active_enemies + 1
			end end

			local t = current_target
			local t_hp = 100
			local t_ttd = 0
			local t_judgment
			if t then
				t_judgment = UnitDebuffID(t,197277,"player")
				t_ttd = squid_ttd(t)
				t_hp = _HP(t)
				if not valid_attackable(t) then
					t = nil
				end
			end

			if sh_stacks >= 4 then
				for i=1,#Friends do if _HP(Friends[i]) < 60 then
					_Cast(19750,Friends[i])
				end end
			end

			local function cooldowns()
				if not t then return end
				-- actions.cooldowns=potion,if=(cooldown.guardian_of_azeroth.remains>90|!essence.condensed_lifeforce.major)&amp;(buff.bloodlust.react|buff.avenging_wrath.up&amp;buff.avenging_wrath.remains>18|buff.crusade.up&amp;buff.crusade.remains<25)
				-- actions.cooldowns+=/lights_judgment,if=spell_targets.lights_judgment>=2|(!raid_event.adds.exists|raid_event.adds.in>75)
				-- actions.cooldowns+=/fireblood,if=buff.avenging_wrath.up|buff.crusade.up&amp;buff.crusade.stack=10
				-- actions.cooldowns+=/shield_of_vengeance,if=buff.seething_rage.down&amp;buff.memory_of_lucid_dreams.down
				if combat then
					_Cast(184662)
				end
				-- actions.cooldowns+=/use_item,name=ashvanes_razor_coral,if=debuff.razor_coral_debuff.down|(buff.avenging_wrath.remains>=20|buff.crusade.stack=10&amp;buff.crusade.remains>15)&amp;(cooldown.guardian_of_azeroth.remains>90|target.time_to_die<30|!essence.condensed_lifeforce.major)
				-- actions.cooldowns+=/the_unbound_force,if=time<=2|buff.reckless_force.up
				-- actions.cooldowns+=/blood_of_the_enemy,if=buff.avenging_wrath.up|buff.crusade.up&amp;buff.crusade.stack=10
				-- actions.cooldowns+=/guardian_of_azeroth,if=!talent.crusade.enabled&amp;(cooldown.avenging_wrath.remains<5&amp;holy_power>=3&amp;(buff.inquisition.up|!talent.inquisition.enabled)|cooldown.avenging_wrath.remains>=45)|(talent.crusade.enabled&amp;cooldown.crusade.remains<gcd&amp;holy_power>=4|holy_power>=3&amp;time<10&amp;talent.wake_of_ashes.enabled|cooldown.crusade.remains>=45)
				-- actions.cooldowns+=/worldvein_resonance,if=cooldown.avenging_wrath.remains<gcd&amp;holy_power>=3|talent.crusade.enabled&amp;cooldown.crusade.remains<gcd&amp;holy_power>=4|cooldown.avenging_wrath.remains>=45|cooldown.crusade.remains>=45
				-- actions.cooldowns+=/focused_azerite_beam,if=(!raid_event.adds.exists|raid_event.adds.in>30|spell_targets.divine_storm>=2)&amp;!(buff.avenging_wrath.up|buff.crusade.up)&amp;(cooldown.blade_of_justice.remains>gcd*3&amp;cooldown.judgment.remains>gcd*3)
				-- actions.cooldowns+=/memory_of_lucid_dreams,if=(buff.avenging_wrath.up|buff.crusade.up&amp;buff.crusade.stack=10)&amp;holy_power<=3
				-- actions.cooldowns+=/purifying_blast,if=(!raid_event.adds.exists|raid_event.adds.in>30|spell_targets.divine_storm>=2)
				-- actions.cooldowns+=/use_item,effect_name=cyclotronic_blast,if=!(buff.avenging_wrath.up|buff.crusade.up)&amp;(cooldown.blade_of_justice.remains>gcd*3&amp;cooldown.judgment.remains>gcd*3)
				-- actions.cooldowns+=/avenging_wrath,if=(!talent.inquisition.enabled|buff.inquisition.up)&amp;holy_power>=3
				if t_ttd > 10 and (not inquisition_enabled or inquisition_up) and power >= 3 then
					_Cast(31884)
				end
				-- actions.cooldowns+=/crusade,if=holy_power>=4|holy_power>=3&amp;time<10&amp;talent.wake_of_ashes.enabled
			end

			local wings_pool
			local ds_castable
			local function finishers()
				if not t then return end
				-- actions.finishers=variable,name=wings_pool,value=!equipped.169314&amp;(!talent.crusade.enabled&amp;cooldown.avenging_wrath.remains>gcd*3|cooldown.crusade.remains>gcd*3)|equipped.169314&amp;(!talent.crusade.enabled&amp;cooldown.avenging_wrath.remains>gcd*6|cooldown.crusade.remains>gcd*6)
				wings_pool = not IsEquippedItem(169314) and (not crusade_enabled or wings_cd > gcd * 3) or IsEquippedItem(169314) and (not crusade_enabled and wings_cd > gcd * 6)
				-- actions.finishers+=/variable,name=ds_castable,value=spell_targets.divine_storm>=2&amp;!talent.righteous_verdict.enabled|spell_targets.divine_storm>=3&amp;talent.righteous_verdict.enabled|buff.empyrean_power.up&amp;debuff.judgment.down&amp;buff.divine_purpose.down&amp;buff.avenging_wrath_autocrit.down
				local ds_targets = Enemies_Around_Unit("player",8)
				ds_castable = ds_targets >= 2 and not rv_enabled or ds_targets >= 3 and rv_enabled or empyrean_power_up and not t_judgment and not divine_purpose_up and not wings_auto_crit
				-- actions.finishers+=/inquisition,if=buff.avenging_wrath.down&amp;(buff.inquisition.down|buff.inquisition.remains<8&amp;holy_power>=3|talent.execution_sentence.enabled&amp;cooldown.execution_sentence.remains<10&amp;buff.inquisition.remains<15|cooldown.avenging_wrath.remains<15&amp;buff.inquisition.remains<20&amp;holy_power>=3)
				if not wings_up and (not inquisition_up or inquisition_remains < 8 and power >= 3 or es_enabled and es_cd < 10 and inquisition_remains < 15 or wings_cd < 15 and inquisition_remains < 20 and power >= 3) then
					_Cast(84963)
				end
				-- actions.finishers+=/execution_sentence,if=spell_targets.divine_storm<=2&amp;(!talent.crusade.enabled&amp;cooldown.avenging_wrath.remains>10|talent.crusade.enabled&amp;buff.crusade.down&amp;cooldown.crusade.remains>10|buff.crusade.stack>=7)
				if ds_targets <= 2 then
					_Cast(267798,t,true)
				end
				-- actions.finishers+=/divine_storm,if=variable.ds_castable&amp;variable.wings_pool&amp;((!talent.execution_sentence.enabled|(spell_targets.divine_storm>=2|cooldown.execution_sentence.remains>gcd*2))|(cooldown.avenging_wrath.remains>gcd*3&amp;cooldown.avenging_wrath.remains<10|cooldown.crusade.remains>gcd*3&amp;cooldown.crusade.remains<10|buff.crusade.up&amp;buff.crusade.stack<10))
				if ds_castable and wings_pool then
					_Cast(53385)
				end
				-- actions.finishers+=/templars_verdict,if=variable.wings_pool&amp;(!talent.execution_sentence.enabled|cooldown.execution_sentence.remains>gcd*2|cooldown.avenging_wrath.remains>gcd*3&amp;cooldown.avenging_wrath.remains<10|cooldown.crusade.remains>gcd*3&amp;cooldown.crusade.remains<10|buff.crusade.up&amp;buff.crusade.stack<10)
				if wings_pool then
					_Cast(85256,t,true)
				end
			end

			local HoW
			local function generators()
				if not t then return end
				-- actions.generators=variable,name=HoW,value=(!talent.hammer_of_wrath.enabled|target.health.pct>=20&amp;!(buff.avenging_wrath.up|buff.crusade.up))
				HoW = not hammer_of_wrath_enabled or t_hp >= 20 and not wings_up
				-- actions.generators+=/call_action_list,name=finishers,if=holy_power>=5|buff.memory_of_lucid_dreams.up|buff.seething_rage.up|talent.inquisition.enabled&amp;buff.inquisition.down&amp;holy_power>=3
				if power >= 5 or lucid_dreams_up or seething_rage_up or inquisition_enabled and not inquisition_up and power >= 3 then
					finishers()
				end
				-- actions.generators+=/wake_of_ashes,if=(!raid_event.adds.exists|raid_event.adds.in>15|spell_targets.wake_of_ashes>=2)&amp;(holy_power<=0|holy_power=1&amp;cooldown.blade_of_justice.remains>gcd)&amp;(cooldown.avenging_wrath.remains>10|talent.crusade.enabled&amp;cooldown.crusade.remains>10)
				local woa_targets = 0
				for i=1,#Enemies do if _distance(Enemies[i]) <= 11 and _amIfacing(Enemies[i]) then
					woa_targets = woa_targets + 1
				end end
				if (woa_targets >= 2 or active_enemies <= 1) and (power <= 0 or power == 1 and boj_cd > gcd) and wings_cd > 10 then
					_Cast(255937)
				end
				-- actions.generators+=/blade_of_justice,if=holy_power<=2|(holy_power=3&amp;(cooldown.hammer_of_wrath.remains>gcd*2|variable.HoW))
				if power <= 2 or (power == 3 and (how_cd > gcd * 2 or HoW)) then
					_Cast(184575,t,true)
				end
				-- actions.generators+=/judgment,if=holy_power<=2|(holy_power<=4&amp;(cooldown.blade_of_justice.remains>gcd*2|variable.HoW))
				if power <= 2 or (power <= 4 and (boj_cd > gcd*2 or HoW)) then
					_Cast(20271,t,true)
				end
				-- actions.generators+=/hammer_of_wrath,if=holy_power<=4
				if power <= 4 then
					_Cast(24275,t,true)
				end
				-- actions.generators+=/consecration,if=holy_power<=2|holy_power<=3&amp;cooldown.blade_of_justice.remains>gcd*2|holy_power=4&amp;cooldown.blade_of_justice.remains>gcd*2&amp;cooldown.judgment.remains>gcd*2
				if power <= 2 or power <= 3 and boj_cd > gcd * 2 or power == 4 and boj_cd > gcd * 2 and judgment_cd > gcd * 2 then
					_Cast(26573)
				end
				-- actions.generators+=/call_action_list,name=finishers,if=talent.hammer_of_wrath.enabled&amp;target.health.pct<=20|buff.avenging_wrath.up|buff.crusade.up
				if hammer_of_wrath_enabled and t_hp <= 20 and wings_up then
					finishers()
				end
				-- actions.generators+=/crusader_strike,if=cooldown.crusader_strike.charges_fractional>=1.75&amp;(holy_power<=2|holy_power<=3&amp;cooldown.blade_of_justice.remains>gcd*2|holy_power=4&amp;cooldown.blade_of_justice.remains>gcd*2&amp;cooldown.judgment.remains>gcd*2&amp;cooldown.consecration.remains>gcd*2)
				if cs_charges_frac >= 1.75 and (power <= 2 or power <= 3 and boj_cd > gcd * 2 or power == 4 and boj_cd > gcd * 2 and judgment_cd > gcd * 2 and consecration_cd > gcd * 2) then
					_Cast(35395,t,true)
				end
				-- actions.generators+=/call_action_list,name=finishers
				finishers()
				-- actions.generators+=/concentrated_flame
				-- actions.generators+=/reaping_flames
				-- actions.generators+=/crusader_strike,if=holy_power<=4
				if power <= 4 then
					_Cast(35395,t,true)
				end
				-- actions.generators+=/arcane_torrent,if=holy_power<=4
			end

			-- actions+=/call_action_list,name=cooldowns
			cooldowns()
			-- actions+=/call_action_list,name=generators
			generators()

		--Holy
		elseif spec == 1 then

			if Free_Bag_Slots() > 0 then
				InteractUnit("Refreshment Table")
			end

			local combat = UnitAffectingCombat("player")
			local hpmax = UnitHealthMax("player")
			local mana = (100 * UnitPower("player") / UnitPowerMax("player"));
			local latency = squid_avg_latency
			local groupsize = GetNumGroupMembers()
			local msperframe = 2/GetFramerate()
			local buffer = latency + msperframe + .1
			local player_hp = _HP("player")
			local player_hpdeficit = hpmax-UnitHealth("player")
			local player_mastery = GetMasteryEffect()
			local player_interruptable = PlayerCanBeKicked()

			local avenging_wrath_remains = _buffRemains("player",31884)
			local avenging_wrath = avenging_wrath_remains > 0

			local infusion_up = UnitBuffID("player",54149)

			local holy_shock_cd = _spellCooldown(20473)

			local breaking_dawn = AzeritePowerTaken(394)

			if not holy_shock_value or time-holy_shock_value_checked > .5 then
				holy_shock_value = GetSpellEffect(20473)
				if holy_shock_value then
					holy_shock_value = holy_shock_value*1.5
				end
				if not holy_shock_value then
					holy_shock_value = UnitStat("player",4)*3.3
				end
				holy_shock_value_checked=time
			end

			if Squid_Burst then
				_Cast(31884)
			end

			local player_cast,_,_,_,_,_,_,_,player_cast_id = unit_casting_info("player")
			local player_cast_target = UnitSpellTarget("player")
			local player_cast_time_left = _castTimeLeft("player")

			if player_cast_id == 20066 then
				--premonition
				if premonitionUsed then
					local time_since_prem = time - premonitionUsed
					local time_til_prem_proc = 1.5-time_since_prem
					if player_cast_time_left < time_til_prem_proc then
						if premonitionPointer and UnitIsVisible(premonitionPointer) and unit_is_unit(player_cast_target,premonitionPointer) then
							Squid_Alert_Big("Stopcasting","(Premonition)",4,3,305498)
							SpellStopCasting()
						end
					end
				end
			end

			local rep_cast_time = _castTime(20066)

			local function cc(unit,player_forced)

				--stop if no unit
				if not unit or not UnitIsVisible(unit) then return 69 end

				--do not sheep? (ext. func)
				if DoNotSheep(unit) then return 69 end

				--dist to unit
				local dist = _distance(unit)

				local immunity_remains = max( magic_immunity_remains(unit), cc_immunity_remains(unit) )

				--druid?
				local is_druid = select(2,UnitClass(unit)) == "DRUID"

				--check cc
				local ccr = _CCremains(unit)
				local cc = ccr > 0

				--incap drs
				local idr = _incapacitateDR(unit)
				local idr_remains = _drRemains(unit,"incapacitate")

				--sheep immunities. beast or dummy is all i can think of right now. added in Moonkin Form for resto
				local immune_sheep = _isBeast(unit) or _isDummy(unit)

				--meteor?
				local standing_in_meteor = UnitDebuffID(unit,155158)

				--yea dont cc into it
				if standing_in_meteor then return 69 end

				--banner?
				local banner = UnitBuffID(unit,236321)

				--yea dont cc into it...unless
				if banner then return 69 end

				--incap on unit?
				local incap = _incapacitateCheck(unit)

				--healer?
				local is_healer = _isHealer(unit)

				--lockout?
				local lockout = IsLocked(unit,true)

				--los?
				local los = _LoS(unit)

				--charmed friend?
				local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

				if friendly then return 69 end

				-- friends attacking?
				local friends_attacking = UnitEnemiesAttacking(unit)
				local unit_hp = _HP(unit)
				if unit_hp < lowestEnemy - 15 or friends_attacking > 0 then
					return 69
				end

				--sheep, if drs are available, and the unit is not immune
				local max_overlap = rep_cast_time + (buffer*2.55) + .5 + (not player_interruptable and 1.25 or 0) -- + (idr >= .5 and ring_cd < gcd and ccr > ring_cast_time and ring_cast_time or 0)
				if los then --no sheep into lockout, unless they're casting another school
					if not immune_sheep then

						local sheep_dr_ready = idr == 1 or (idr >= .25 and idr_remains > 17.25 - (ccr >= rep_cast_time and 8 * idr or 0) - (incap and ccr >= rep_cast_time-.2 and 6 * idr or 0) - ((100-lowestEnemy) * .038) + (idr == .25 and 2 or 0) ) or ( idr_remains < rep_cast_time-(buffer/2) and ( idr_remains ~= 0 or idr == 1 ) )

						if sheep_dr_ready then
							if dist < 29 and ccr < max_overlap then
								if immunity_remains <= rep_cast_time+(buffer*.45) then
									--alert when moving, stop casting scorch when not
									if _isMoving("player") then Squid_Alert_Big("Stop Moving","(Rep)",nil,nil,20066) end
									if _Cast(20066,unit) then
										Squid_Alert("Repping",UnitClass(unit),nil,3,20066)
									end
								end
							end
						end
					end
				end

			end

			if cc_healer_key then
				if UnitIsVisible(theirHealer) and not _immuneMagic(theirHealer) and not UnitBuffID(theirHealer,8178) and not UnitDebuffID(theirHealer,33786) then
					-- if _stunDR(theirHealer) == 1 or _stunRemains(theirHealer) > 0 and _stunRemains(theirHealer) < buffer * 1.5 or _drRemains(theirHealer,"stun") > 17.99 then
						if _CCremains(theirHealer) < buffer * 1.5 then
							if _Cast(853,theirHealer,nil,true) then
								Squid_Alert_Big("HoJ " .. UnitClass(theirHealer),"(Manual)",2,3.5,853)
								return
							end
						end
					-- end
					cc(theirHealer)
				end
				return
			end

			if cc_focus_key then
				if UnitIsVisible(current_focus) and not _immuneMagic(current_focus) and not UnitBuffID(current_focus,8178) and not UnitDebuffID(current_focus,33786) then
					-- if _stunDR(current_focus) == 1 or _stunRemains(current_focus) > 0 and _stunRemains(current_focus) < buffer * 1.5 or _drRemains(current_focus,"stun") > 17.99 then
						if _CCremains(current_focus) < buffer * 1.5 then
							if _Cast(853,current_focus,nil,true) then
								Squid_Alert_Big("HoJ " .. UnitClass(current_focus),"(Manual)",2,3.5,853)
								return
							end
						end
					-- end
					cc(current_focus)
				end
				return
			end

			--CC Trinket
			local trinketPointer
			local recentTrinket
			for i=1,#TrinketTracker do
				local pointer = TrinketTracker[i].pointer
				local trinketTime = TrinketTracker[i].time
				if UnitIsVisible(pointer) and _isHealer(pointer) and unit_can_attack("player",pointer) then
					recentTrinket = time-trinketTime <= gcd*2.4
					timeSinceTrinket = time-trinketTime
					trinketPointer = pointer
				end
			end

			if recentTrinket then
				if trinketPointer and not unit_is_unit(trinketPointer,"target") and _LoS(trinketPointer) and gcd_remains <= .25 then
					--HoJ
					if _spellCooldown(853) <= gcd and (_stunDR(trinketPointer) == 1 or _drRemains(trinketPointer,"stun") > 17) then
						if _Cast(853,trinketPointer,nil,true) then
							Squid_Alert_Big("HoJ " .. UnitClass(trinketPointer),"(Trinket)",2,3.5,853)
							return
						end
					end
				end
			end

			local their_healer = theirHealer
			local their_healer_cc
			local their_healer_cc_remains = 0
			local their_healer_incapacitate_dr
			local their_healer_incapacitate_dr_remains = 0
			local their_healer_disorient_dr
			local their_healer_disorient_dr_remains = 0
			if their_healer then
				their_healer_cc_remains = _CCremains(their_healer)
				their_healer_cc = their_healer_cc_remains > 0
				their_healer_incapacitate_dr = _incapacitateDR(their_healer)
				their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
				their_healer_disorient_dr = _disorientDR(their_healer)
				their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")
			end

			if not their_healer then
				their_healer_cc = true
				their_healer_cc_remains = 100 - (lowestEnemy*1.5)
				their_healer_cc_remains = their_healer_cc_remains > 8 and 8 or their_healer_cc_remains
				their_healer_cc_remains = their_healer_cc_remains < 0 and 0 or their_healer_cc_remains
			end

			local kt_stun_remains = 0
			local team_kt
			for i=1,#Enemies do
				local ea = UnitEnemiesAttacking(Enemies[i])
				if ea > 0 then
					local stun = _stunRemains(Enemies[i])
					if stun > kt_stun_remains then
						kt_stun_remains = stun
					end
					team_kt = Enemies[i]
				end
			end

			local load_mode = ( (their_healer and their_healer_cc_remains >= 1.5) or kt_stun_remains > 0 or lowestEnemy < 30 * (their_healer and 1 or 2.85) )

			--Bop Karma
			local MonkWithKarma
			if arena then
				for i=1,#Enemies do if UnitBuffID(Enemies[i],125174) then
					MonkWithKarma=Enemies[i];
				end end
				if MonkWithKarma then
					local FriendWithKarma
					for i=1,#Friends do if UnitDebuffID(Friends[i],122470) then
						FriendWithKarma=Friends[i];
					end end
					if FriendWithKarma then
						local current = _HP(MonkWithKarma)
						local hp = 70
						hp = hp + (their_healer_cc and 25 or 0)
						if unit_is_unit("player",FriendWithKarma) then
							hp=hp-20
						end
						if current < hp and FriendWithKarma then
							if hp < 50 then
								if current < 15 then
									_Cast(642);
								end
								_Cast(1022,FriendWithKarma)
							else
								_Cast(1022,FriendWithKarma)
							end
						end
					end
				end
			end

			-- 294027
			--pets lower prio than players if they need healing heal them
			local glimmers = {}
			local lowfriends = {}
			for i=1,#Friends do
				local e = Friends[i];
				--darkest dephts check
				if not UnitDebuffID(e,292127)
				and not UnitIsDeadOrGhost(e) then

					-- mastery benefit based on distance
					-- local dist = _distance(e)
					-- local distance_benefit = 40-(dist-10)
					-- distance_benefit = (100 * distance_benefit / 40)
					-- if distance_benefit > 100 then distance_benefit = 100 end
					-- if distance_benefit < 0 then distance_benefit = 0 end

					-- local mastery_benefit = (player_mastery*(distance_benefit/100))/100

					--lowGlimmer friend
					local priority = 0;
					local glimmer = _buffRemains(e,287280,"player")
					local hpdeficit = UnitHealthMax(e)-UnitHealth(e)

					priority = priority + (30-glimmer)
					priority = priority + (unit_is_unit("player",e) and 1 or 0)
					priority = priority + (UnitGroupRolesAssigned(e) == "TANK" and 1 or 0)

					if hpdeficit >= hpmax/1.5 and unit_is_unit(e,"player") then
						hpdeficit=hpdeficit*1.5  -- increased healing priority for player below 55%
					end

					if not UnitBuffID(e,53563,"player") and hpdeficit >= hpmax/1.5 then
						hpdeficit=hpdeficit*1.25 -- increase healing priority for units without beacon
					end

					if UnitGroupRolesAssigned(e) == "TANK" then
						hpdeficit = hpdeficit / 1.15 -- slightly reduce healing priority for tank
					end

					--increase hp deficit based on mastery effect (this is not how i want to do this)
					-- hpdeficit = hpdeficit + (hpdeficit * mastery_benefit)

					table.insert(lowfriends,{pointer=e,hpdeficit=hpdeficit,glimmer=glimmer,mastery_benefit=mastery_benefit,hp=_HP(e)})
					table.insert(glimmers,{pointer=e,priority=priority,hpdeficit=hpdeficit,glimmer=glimmer,mastery_benefit=mastery_benefit});
				end
			end
			table.sort(glimmers, function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hpdeficit > y.hpdeficit) end)
			table.sort(lowfriends, function(x,y) return x.hpdeficit > y.hpdeficit end)

			local function _valid(unit)
				return UnitIsVisible(unit)
				and UnitCanAttack("player",unit)
				and not UnitIsDeadOrGhost(unit)
				and not _breakableCC(unit)
				and not _immuneCheck(unit)
				and (arena or UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))
			end

			local beacontarget
			for i=1,#lowfriends do
				if UnitBuffID(lowfriends[i].pointer,53563,"player") then
					beacontarget = lowfriends[i].pointer
				end
			end

			--auto bops in pve
			local bopme = {
			265091, -- savage cleave
			}
			--m+
			if groupsize <= 5 and not arena then
				for i=1,#lowfriends do
					for n=1,#bopme do
						if UnitDebuffID(lowfriends[i].pointer,bopme[n]) then
							if _Cast(1022,lowfriends[i].pointer) then
								Squid_Alert_Big("Bop",GetSpellInfo(bopme[n]))
							end
						end
					end
				end
			end

			local player_locked = IsLocked("player")

			if arena then
				--vitality
				for i=1,#lowfriends do if not _immuneCheck(lowfriends[i].pointer) then
					local units, _, _, cds = EnemiesAttacking(lowfriends[i].pointer)
					local vhp = 30
					vhp = vhp + (cds * 20)
					vhp = vhp + (units * 15)
					vhp = vhp + (player_locked and 20 or 0)
					if lowfriends[i].hp < vhp then
						_Cast(296230,lowfriends[i].pointer)
					end
				end end
			end

			--loh
			if not arena then
				for i=1,#lowfriends do if lowfriends[i].hpdeficit >= hpmax then
					if select(2,UnitClass(lowfriends[i].pointer)) ~= "PALADIN" or UnitGroupRolesAssigned(lowfriends[i].pointer) ~= "TANK" then
						_Cast(633,lowfriends[i].pointer)
					end
				end end
			end



			if arena and lowestFriend > 30 then

				--Freedom
				if lowestFriend > 35 then
					for i=1,#Friends do
						if _shouldFreedom(Friends[i]) then
							_Cast(1044,Friends[i]);
						end
					end
				end

				--Dispel
				for i=1,#Friends do
					local d = _shouldCleanse(Friends[i])
					if d then
						if _Cast(4987,Friends[i]) then
							Squid_Alert("Cleanse",GetSpellInfo(d),4,nil,4987)
							return
						end
					end
				end

			end

			local bestTarget
			local bestTargetAmt = 0
			if arena then
				for i=1,#Enemies do
					local targs = UnitEnemiesAttacking(Enemies[i])
					if targs >= groupsize - 1 and targs > bestTargetAmt then
						bestTarget=Enemies[i];
						bestTargetAmt=targs;
					end
				end
			else
				if lowestEnemyName then
					bestTarget=lowestEnemyName
				end
			end

			--crucible
			if lowestFriend > 45 or lowestEnemy < 6*_buffStacks("player",295378) then
				if arena and bestTarget and not _breakableCC(bestTarget) then
					if load_mode or _buffStacks("player",295378) == 0 then
						if _spellCooldown(295373) <= gcd then
							_Cast(295373,bestTarget,nil,true)
						end
					end
				end
			end

			--Judgment Execute
			-- if arena and ( SQUID.auto_paladin or IsPlayerSpell(198054) ) and bestTarget and not _breakableCC(bestTarget) and _spellCooldown(275773) <= 1.5 and (lowestFriend > 74 or UnitBuffID("player",216331)) then
			-- 	if _valid(bestTarget) and _LoS(bestTarget) then
			-- 		_Cast(275773,bestTarget,nil,true);
			-- 	elseif _valid("target") then
			-- 		_Cast(275773,"target",nil,true);
			-- 	end
			-- end

			-- mastery benefit
			-- (100 * UnitHealth(unit) / UnitHealthMax(unit))

			local raid_hp_deficit = 0
			for i=1,#glimmers do
				raid_hp_deficit = raid_hp_deficit + glimmers[i].hpdeficit
			end

			--blessing of sac tank
			-- for i=1,#lowfriends do if lowfriends[i].hpdeficit > holy_shock_value*3.5 then
			-- 	if UnitGroupRolesAssigned(lowfriends[i].pointer) == "TANK" then
			-- 		_Cast(6940,lowfriends[i].pointer)
			-- 	end
			-- end end

			--wall after sac
			if _spellCooldown(6940) > 110 then
				CastSpellByID(498)
			end

			if not arena or SQUID.auto_paladin then
				if combat then
					if groupsize > 5 then

						--holy avenger
						if SQUID.auto_holy_avenger then
							if raid_hp_deficit > (hpmax*1.5 - (arena and hpmax*1.2 or 0)) or (not arena and avenging_wrath_remains >= 12) then
								_Cast(105809)
							end
						end

						--wingz
						if SQUID.auto_wings then
							if raid_hp_deficit > (hpmax*2.5 - (arena and hpmax*1.7 or 0)) or (_spellCooldown(105809) <= 8 and not arena) then
								if not avenging_wrath then
									_Cast(31884)
								end
							end
						end

						--aura mast
						if avenging_wrath_remains < 4 then
							if SQUID.auto_aura_mastery then
								if raid_hp_deficit > hpmax*4 then
									_Cast(31821)
								end
							end
						end

					else

						--holy avenger
						if SQUID.auto_holy_avenger then
							if raid_hp_deficit > hpmax*3.5 or avenging_wrath_remains >= 12 then
								_Cast(105809)
							end
						end

						--wingz
						if SQUID.auto_wings then
							if raid_hp_deficit > hpmax * 2 or _spellCooldown(105809) <= 8 and raid_hp_deficit < hpmax*1.25 then
								if not avenging_wrath then
									_Cast(31884)
								end
							end
						end

						--aura mast
						if avenging_wrath_remains < 4 then
							if SQUID.auto_aura_mastery then
								if raid_hp_deficit > hpmax then
									_Cast(31821)
								end
							end
						end

					end
				end
			end

			--pvp holy shock offense
			-- local bcconteam
			-- for i=1,#Friends do if select(2,UnitClass(Friends[i])) == "HUNTER" or select(2,UnitClass(Friends[i])) == "MAGE" then
			-- 	bcconteam=true
			-- end end
			-- if lowestFriend > 80 and groupsize <= 2 and not bcconteam then
			-- 	for i=1,#Enemies do if not _breakableCC(Enemies[i]) and _debuffRemains(Enemies[i],287280,"player") < 8 then
			-- 		_Cast(20473,Enemies[i],nil,true)
			-- 	end end
			-- end

			--favor / holy light
			if not arena or SQUID.auto_paladin then
				if groupsize <= 3 then
					if infusion_up then
						if not _isMoving("player") then
							for i=1,#lowfriends do if lowfriends[i].hpdeficit >= holy_shock_value/2 then
								if lowfriends[i].hpdeficit >= holy_shock_value*1.5 and gcd_remains < .3 then
									CastSpellByID(210294)
								end
								_Cast(82326,lowfriends[i].pointer)
							end end
						end
					end
				elseif groupsize <= 5 then
					if infusion_up and holy_shock_cd > gcd_remains then
						if not _isMoving("player") then
							for i=1,#lowfriends do if lowfriends[i].hpdeficit >= holy_shock_value/1.5 then
								if lowfriends[i].hpdeficit >= holy_shock_value*1.5 and gcd_remains < .3 then
									CastSpellByID(210294)
								end
								_Cast(19750,lowfriends[i].pointer)
							end end
						end
					end
				end
			end

			local shortestglimmer = 0
			for i=1,#glimmers do if glimmers[i].glimmer > shortestglimmer then
				shortestglimmer = glimmers[i].glimmer
			end end

			local retard_dmg_mode = healer_dmg_key

			-- judgment
			if not arena then
				if retard_dmg_mode or lowestFriend > 40 and groupsize <= 5 then
					if _valid(current_target) then
						_Cast(275773,current_target,nil,true)
					else
						for i=1,#Enemies do if valid_attackable(Enemies[i]) then
							_Cast(275773,Enemies[i],nil,true)
						end end
					end
				end
			end

			-- cons
			if not arena then
				if groupsize <= 5 and (retard_dmg_mode or lowestFriend > 70) and ( not sq_consecrate or time - sq_consecrate > 4 ) and Enemies_Around_Unit("player",6) >= 2 then
					if _Cast(26573) then
						sq_consecrate = time
					end
				end
			end

			--glimmers out
			local glimmers_out = 0
			for i=1,#glimmers do if glimmers[i].glimmer > 0 then
				glimmers_out = glimmers_out + 1
			end end

			-- --holy shock
			if not arena or SQUID.auto_paladin then
				--holy shock to keep ppl alive
				for i=1,#lowfriends do if _HP(lowfriends[i].pointer) < 55 then
					if _Cast(20473,lowfriends[i].pointer) then return end
				end end
				if instance_type ~= "none" or lowestFriend < 80 then
					--glimmer teammates as long is it is an effective heal
					for i=1,#glimmers do if glimmers[i].hpdeficit > holy_shock_value or glimmers[i].glimmer <= gcd and not retard_dmg_mode and glimmers_out < 8 then
						if _Cast(20473,glimmers[i].pointer) then return end
					end end
				end
				--glimmer teammates as long is it is an effective heal
				for i=1,#lowfriends do if lowfriends[i].hpdeficit > holy_shock_value/1.25 then
					if _Cast(20473,lowfriends[i].pointer) then return end
				end end
				if instance_type ~= "none" or lowestFriend < 80 then
					--target glimmer when no one needs healing
					if groupsize <= 5 then
						if _valid(current_target) and shortestglimmer >= min(groupsize,8) and (_debuffRemains(current_target,287280,"player") < 15 or UnitDebuffID(current_target,214222,"player")) then
							if _Cast(20473,current_target,nil,true) then return end
						end
						--retard dmg mode
						if retard_dmg_mode then
							for i=1,#Enemies do if valid_attackable(Enemies[i]) then
								local e = Enemies[i]
								if _debuffRemains(e,287280,"player") < 12 then
									if _Cast(20473,e,nil,true) then return end
								end
							end end
							for i=1,#Enemies do if valid_attackable(Enemies[i]) then
								local e = Enemies[i]
								if _Cast(20473,e,nil,true) then return end
							end end
						end
					end
					--glimmer teammates to maintain
					if not retard_dmg_mode then
						for i=1,#glimmers do if glimmers[i].hpdeficit > holy_shock_value / 1.45 or glimmers[i].glimmer <= min(groupsize,8) * 1.45 and glimmers_out < 8 then
							if _Cast(20473,glimmers[i].pointer) then return end
						end end
					end
					if groupsize <= 5 then
						--spread glimmer to enemies
						if shortestglimmer >= groupsize or retard_dmg_mode then
							for i=1,#Enemies do if valid_attackable(Enemies[i]) then
								local e = Enemies[i]
								if _debuffRemains(e,287280,"player") < 12 then
									if _Cast(20473,e,nil,true) then return end
								end
							end end
						end
						--target glimmer when no one needs healing
						if _valid(current_target) and (shortestglimmer >= min(groupsize,8) or retard_dmg_mode) then
							if _Cast(20473,current_target,nil,true) then return end
						end
					end
					--smal heal
					for i=1,#lowfriends do if lowfriends[i].hpdeficit > holy_shock_value/2 then
						if _Cast(20473,lowfriends[i].pointer) then return end
					end end
					if holy_shock_cd <= .5 then return end
					--overcharge
					if combat then
						_Cast(296072)
					end
				end
			end

			-- --Crusader Strike
			if UnitBuffID("player",216331) then
				for i=1,#Pets do if not _breakableCC(Pets[i]) then
					if _Cast(35395,Pets[i],nil,true) then return end
				end end
			end

			-- --bestow
			if (not arena or SQUID.auto_paladin) then
				for i=1,#lowfriends do if lowfriends[i].hp < 90 then
					_Cast(223306,lowfriends[i].pointer)
				end end
			end

			-- if (not arena or SQUID.auto_paladin) and IsPlayerSpell(183778) then
			-- 	if groupsize <= 5 then
			-- 		for i=1,#Pets do if UnitAffectingCombat(Pets[i]) and _buffStacks(Pets[i],196941,"player") < 10 then
			-- 			if _Cast(275773,Pets[i],nil,true) then return end
			-- 		end end
			-- 	else
			-- 		for i=1,#Pets do if _buffStacks(Pets[i],196941,"player") < 10 then
			-- 			if _Cast(275773,Pets[i],nil,true) then return end
			-- 		end end
			-- 	end
			-- end

			-- --Crusader Strike
			if not arena or _HP("player") > 35 then
				if ( IsPlayerSpell(196926) or retard_dmg_mode ) and ( holy_shock_cd >= gcd and GetSpellCharges(35395) == 2 or retard_dmg_mode ) then
					for i=1,#Pets do if not _breakableCC(Pets[i]) then
						if _spellCooldown(35395) < .2 and _amIfacing(Pets[i]) then
							CastSpellByID(35395,Pets[i]);
						end
					end end
				end
			end

			-- cons
			if not arena then
				if lowestFriend > 70 and ( not sq_consecrate or time - sq_consecrate > 6 ) and Enemies_Around_Unit("player",6) >= 2 then
					if _Cast(26573) then
						sq_consecrate = time
					end
				end
			end

			local hpdeficit = function(unit)
				return UnitHealthMax(unit)-UnitHealth(unit)
			end

			lod_heal = math.min(holy_shock_value/3,player_hpdeficit)

			if beacontarget then
				lod_heal = lod_heal + math.min(holy_shock_value/3,hpdeficit(beacontarget))
			else
				_Cast(53563,"player")
			end

			--light of dawn
			if combat and (not arena or SQUID.auto_paladin) then

				lod_range = breaking_dawn and 40 or 15
				lod_range = lod_range + (lod_range * (UnitBuffID("player",214202) and .5 or 0))
				for i=1,#lowfriends do
					if _realDistance(lowfriends[i].pointer) < lod_range+.5 and _amIfacing(lowfriends[i].pointer) and lowfriends[i].hpdeficit >= holy_shock_value/3 then
						lod_heal=lod_heal+math.min(holy_shock_value/3,lowfriends[i].hpdeficit)
					end
				end
				if not arena or AutoFollow then
					if lod_heal >= holy_shock_value/2 then
						_Cast(85222)
					end
				end

			end

			-- --shock offense
			-- if lowestFriend > 80 then
			-- 	for i=1,#Enemies do if UnitDebuffID(Enemies[i],214222) then
			-- 		_Cast(20473,Enemies[i])
			-- 	end end
			-- end

			-- --Crusader Strike
			if not arena or _HP("player") > 35 then
				if IsPlayerSpell(196926) and holy_shock_cd >= gcd then
					for i=1,#Pets do if not _breakableCC(Pets[i]) then
						if _spellCooldown(35395) < .2 and _amIfacing(Pets[i]) then
							CastSpellByID(35395,Pets[i]);
						end
					end end
				end
			end

			-- --flash of light
			if not arena then
				if UnitBuffID("player",54149) then
					for i=1,#lowfriends do if lowfriends[i].hpdeficit >= holy_shock_value then
						if IsPlayerSpell(210294) and lowfriends[i].hpdeficit >= holy_shock_value*1.5 and gcd_remains < .3 then
							CastSpellByID(210294)
						end
						_Cast(19750,lowfriends[i].pointer)
					end end
					-- for i=1,#glimmers do if glimmers[i].hp <
				end
			end

			-- --beacons
			-- if not arena or SQUID.auto_paladin then
			-- 	local top = 0
			-- 	local topdog
			-- 	for i=1,#glimmers do
			-- 		local e = EnemiesAttacking(glimmers[i].pointer)
			-- 		if e > top then
			-- 			top = e
			-- 			topdog = glimmers[i].pointer
			-- 		end
			-- 	end
			-- 	if topdog and not UnitBuffID(topdog,53563,"player") then
			-- 		_Cast(53563,topdog)
			-- 	end
			-- end



			--favor / holy light
			if not arena or SQUID.auto_paladin then
				if groupsize <= 3 then
					if UnitBuffID("player",54149) then
						if not _isMoving("player") then
							for i=1,#lowfriends do if lowfriends[i].hpdeficit >= holy_shock_value/2 then
								if lowfriends[i].hpdeficit >= holy_shock_value*1.5 and gcd_remains < .3 then
									CastSpellByID(210294)
								end
								_Cast(82326,lowfriends[i].pointer)
							end end
						end
					end
				elseif groupsize <= 5 then
					if UnitBuffID("player",54149) then
						if not _isMoving("player") then
							for i=1,#lowfriends do if lowfriends[i].hpdeficit >= holy_shock_value/2 then
								if lowfriends[i].hpdeficit >= holy_shock_value*1.5 and gcd_remains < .3 then
									CastSpellByID(210294)
								end
								_Cast(19750,lowfriends[i].pointer)
							end end
						end
					end
				end
			end

			if arena and SQUID.auto_paladin then
				if holy_shock_cd > 1.25 and lowestFriend > 65 - ( not player_interruptable and 20 or 0 ) then
					for i=1,#lowfriends do
						local f = lowfriends[i].pointer
						if _HP(f) < 80 then
							_Cast(82326,f)
						end
					end
				end
			end

			-- judge
			if not arena then
				if lowestFriend > 55 then
					if _valid(current_target) then
						_Cast(275773,current_target,nil,true)
					else
						for i=1,#Enemies do if valid_attackable(Enemies[i]) and not _breakableCC(Enemies[i]) and not _immuneMagic(Enemies[i]) then
							_Cast(275773,Enemies[i],nil,true)
						end end
					end
				end
			end

			-- cons
			if not arena then
				if groupsize <= 5 and lowestFriend > 70 and Enemies_Around_Unit("player",8) >= 2 then
					_Cast(26573)
				end
			end

			if (not arena) then
				for i=1,#lowfriends do
					if lowfriends[i].hpdeficit >= holy_shock_value/1.2 then
						_Cast(19750,lowfriends[i].pointer)
					end
				end
			elseif SQUID.auto_paladin and lowestFriend > 60 - ((IsPlayerSpell(296230) and _spellCooldown(296230) <= 2 or GetItemCD(158320) <= 1) and 30 or 0) and holy_shock_cd > 1.3 then
				for i=1,#lowfriends do
					if lowfriends[i].hpdeficit >= holy_shock_value/1.2 then
						_Cast(82326,lowfriends[i].pointer)
					end
				end
			end

			-- --lotm
			if (not arena or SQUID.auto_paladin) and mana > 15 and (not arena and player_hp > 65 or player_hp > 70) then
				for i=1,#lowfriends do if lowfriends[i].hp <= 65 and not unit_is_unit("player",lowfriends[i].pointer) then
					_Cast(183998,lowfriends[i].pointer)
				end end
			end

			-- --rol
			if not arena or SQUID.auto_paladin then
				if combat and not UnitBuffID("player",214202) then
					_Cast(214202)
				end
			end

			if UnitBuffID("player",216331) and _spellCooldown(275773) <= 1.5 then
				if lowestEnemy and not _immuneMagic(lowestEnemyName) then
					if _Cast(275773,lowestEnemyName,true) then return; end
				end
				for i=1,#Enemies do if not _immuneMagic(Enemies[i]) then
					_Cast(275773,Enemies[i],true);
				end end
			end

		--Prot
		elseif spec == 2 then

			local t="target"
			lowThreat = {};
			for i=1,#Enemies do
				local e=Enemies[i];
				if UnitCreatureType(e) ~= "Critter"
				--Check they're not retard mobs
				and UnitAffectingCombat(e) then
					--lowThreat enemy--
					local priority=0;
					if unit_is_unit(e,"target") then
						priority=priority+1;
					end
					--threat prio
					local threat = UnitThreatSituation("player",e)
					if threat then priority = priority + threat else priority = priority + 4 end
					table.insert(lowThreat,{pointer=e,priority=priority,hp=_HP(e)});
				end
			end
			table.sort(lowThreat, function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hp < y.hp) end)

			local lowFriends = {}
			for i=1,#lowFriends do
				local e = Friends[i];
				if UnitIsPlayer(e) then
					local priority = 0;
					local hp = _HP(e)

					if hp < 65 and unit_is_unit("player",e) then
						priority = priority + 1
					end

					table.insert(lowFriends,{pointer=e,priority=priority,hp=hp});
				end
			end
			table.sort(lowFriends, function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hp < y.hp) end)

			local function _valid(unit) return UnitExists(unit) and UnitCanAttack("player",unit) and not UnitIsDeadOrGhost(unit) and not _breakableCC(unit) and (arena or UnitAffectingCombat(unit) or UnitName(unit) == "Training Dummy" or UnitIsPlayer(unit)); end

			local sotr_charges_frac = _spellChargeFrac(53600)
			local judgment_charges_frac = _spellChargeFrac(275779)
			local judgment_cd = _spellCooldown(275779)
			local judgment_full_recharge_time = (GetSpellCharges(275779)*6) - (judgment_charges_frac*6)
			local avengers_valor_up = UnitBuffID("player",197561)
			local avenging_wrath = UnitBuffID("player",31884)
			local avenging_wrath_remains = _buffRemains("player",31884)
			local consecration_up = UnitBuffID("player",188370)

			if lowThreat[1] then t=lowThreat[1].pointer end

			--dispel poisons
			for i=1,#Friends do
				local poison = cleanse_poisons(Friends[i])
				if poison then
					if _Cast(213644,Friends[i]) then
						Squid_Alert("Dispelled " .. UnitClass(Friends[i]),"("..poison..")",2)
					end
				end
			end

			if _valid(t) then
				-- # Executed every time the actor is available.

				-- actions=auto_attack
				if not auto_attack or GetTime()-auto_attack > 2 then
					StartAttack()
				end

				_Cast(62124,t)

				local function cooldowns(t)
					-- actions.cooldowns=fireblood,if=buff.avenging_wrath.up
					-- actions.cooldowns+=/use_item,name=azsharas_font_of_power,if=cooldown.seraphim.remains<=10|!talent.seraphim.enabled
					-- actions.cooldowns+=/seraphim,if=cooldown.shield_of_the_righteous.charges_fractional>=2
					-- actions.cooldowns+=/avenging_wrath,if=buff.seraphim.up|cooldown.seraphim.remains<2|!talent.seraphim.enabled
					_Cast(31884)
					-- actions.cooldowns+=/bastion_of_light,if=cooldown.shield_of_the_righteous.charges_fractional<=0.5
					if IsPlayerSpell(213652) then
						if _spellCooldown(213652) < 2 then
							local addhp = avenging_wrath and 20 or 0
							for i=1,#lowFriends do
								if lowFriends[i].hp < 70-addhp then
									_Cast(213652,lowFriends[i].pointer)
								end
							end
						end
					else
						if _HP("player") < 85 then
							_Cast(184092)
						end
					end
					-- actions.cooldowns+=/potion,if=buff.avenging_wrath.up
					-- actions.cooldowns+=/use_items,if=buff.seraphim.up|!talent.seraphim.enabled
					-- actions.cooldowns+=/use_item,name=grongs_primal_rage,if=((cooldown.judgment.full_recharge_time>4|(!talent.crusaders_judgment.enabled&amp;prev_gcd.1.judgment))&amp;cooldown.avengers_shield.remains>4&amp;buff.seraphim.remains>4)|(buff.seraphim.remains<4)
					-- actions.cooldowns+=/use_item,name=merekthas_fang,if=!buff.avenging_wrath.up&amp;(buff.seraphim.up|!talent.seraphim.enabled)
					-- actions.cooldowns+=/use_item,name=razdunks_big_red_button
				end
				-- actions+=/call_action_list,name=cooldowns
				cooldowns(t)
				-- # Dumping SotR charges
				-- actions+=/shield_of_the_righteous,if=(buff.avengers_valor.up&amp;cooldown.shield_of_the_righteous.charges_fractional>=2.5)&amp;(cooldown.seraphim.remains>gcd|!talent.seraphim.enabled)
				if avengers_valor_up and sotr_charges_frac >= 2.5 then
					_Cast(53600)
				end
				-- actions+=/shield_of_the_righteous,if=(buff.avenging_wrath.up&amp;!talent.seraphim.enabled)|buff.seraphim.up&amp;buff.avengers_valor.up
				if avengers_valor_up then
					_Cast(53600)
				end
				-- actions+=/shield_of_the_righteous,if=(buff.avenging_wrath.up&amp;buff.avenging_wrath.remains<4&amp;!talent.seraphim.enabled)|(buff.seraphim.remains<4&amp;buff.seraphim.up)
				if avenging_wrath and avenging_wrath_remains < 4 then
					_Cast(53600)
				end
				-- actions+=/lights_judgment,if=buff.seraphim.up&amp;buff.seraphim.remains<3
				-- actions+=/consecration,if=!consecration.up
				if not consecration_up then
					_Cast(26573)
				end
				-- actions+=/judgment,if=(cooldown.judgment.remains<gcd&amp;cooldown.judgment.charges_fractional>1&amp;cooldown_react)|!talent.crusaders_judgment.enabled
				if (judgment_cd < gcd and judgment_charges_frac > 1) or not IsPlayerSpell(204023) then
					_Cast(275779,t,nil,true)
				end
				-- actions+=/avengers_shield,if=cooldown_react
				_Cast(31935,t,nil,true)
				-- actions+=/judgment,if=cooldown_react|!talent.crusaders_judgment.enabled
				if not IsPlayerSpell(204023) then
					_Cast(275779,t,nil,true)
				end
				-- actions+=/lights_judgment,if=!talent.seraphim.enabled|buff.seraphim.up
				-- actions+=/blessed_hammer,strikes=3
				-- actions+=/hammer_of_the_righteous
				_Cast(53595,t,nil,true)
				-- actions+=/consecration
				_Cast(26573)
			end
		end

	end

	function Squid_Shaman()

		if IsMounted() or IsFlying() or IsAoEPending() then return end

		local spec = GetSpecialization()
		local time = GetTime()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100));
		local gcd_remains = GetGCD()

		--Elemental
		if spec == 1 then

			local t = current_target

			local function _valid(unit) return unit and UnitCanAttack("player",unit) and not UnitIsDeadOrGhost(unit) and not _breakableCC(unit) and not _immuneMagic(unit) and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit)))); end

			local flameshocks = {}
			local lowhp = {}
			local mostaround = {}
			for i=1,#Enemies do
				local e = Enemies[i];
				if _valid(e) then
					--low flameshock priority
					local priority = 0;
					local around = Enemies_Around_Unit(e,8)
					local fs = _debuffRemains(e,188389,"player")
					local hp = _HP(e)
					local istarget = unit_is_unit(e,t)

					priority=priority+(24-fs)
					priority=priority+(istarget and 1 or 0)

					table.insert(flameshocks,{pointer=e,priority=priority,hp=hp,fs=fs});

					--low hp priority
					table.insert(lowhp,{pointer=e,hp=hp,fs=fs})

					--most around priority
					around=around+(istarget and 1 or 0)
					table.insert(mostaround,{pointer=e,around=around,hp=hp,fs=fs})
				end
			end
			table.sort(flameshocks, function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hp < y.hp) end)
			table.sort(lowhp, function(x,y) return x.hp < y.hp end)
			table.sort(mostaround, function(x,y) return x.around > y.around end)

			local maelstrom = UnitPower("player")
			local maelstrom_max = UnitPowerMax("player")
			local maelstrom_deficit = maelstrom_max - maelstrom

			local lava_shock_rank = GetNumAzeritePowerTaken(178)
			local lava_shock_enabled = lava_shock_rank > 0
			local tectonic_thunder_rank = GetNumAzeritePowerTaken(417)
			local tectonic_thunder_enabled = tectonic_thunder_rank > 0

			local primal_elementalist = IsPlayerSpell(117013)
			local elemental_blast_enabled = IsPlayerSpell(117014)
			local echo_of_the_elements = IsPlayerSpell(108283)
			local master_of_the_elements = IsPlayerSpell(16166)
			local aftershock = IsPlayerSpell(273221)
			local liquid_magma_totem = IsPlayerSpell(192222)
			local surge_of_power_enabled = IsPlayerSpell(262303)
			local call_the_thunder = IsPlayerSpell(260897)
			local totem_mastery_enabled = IsPlayerSpell(210643)

			local ghost_wolf = UnitBuffID("player",2645)
			local tectonic_thunder_up = UnitBuffID("player",286976)
			local lava_shock_stacks = _buffStacks("player",273453)
			local lava_surge = UnitBuffID("player",77762)
			local lava_surge_remains = _buffRemains("player",77762)
			local stormkeeper = UnitBuffID("player",191634)
			local stormkeeper_stacks = _buffStacks("player",191634)
			local stormkeeper_remains = _buffRemains("player",191634)
			local surge_of_power = UnitBuffID("player",285514)
			local master_of_the_elements_up = UnitBuffID("player",260734)
			local totem_mastery = UnitBuffID("player",202192) and UnitBuffID("player",210652) and UnitBuffID("player",210658) and UnitBuffID("player",210659)
			local flame_shock_remains = 0
			if _valid(t) then flame_shock_remains = _debuffRemains(t,188389,"player") end
			local flame_shock_ticking = flame_shock_remains > 1.6

			local fire_elemental_cd = _spellCooldown(198067)
			local lava_burst_charges = GetSpellCharges(51505)

			local hex_cast_time = _castTime(51514)

			local their_healer = theirHealer
			local their_healer_cc
			local their_healer_cc_remains = 0
			local their_healer_incapacitate_dr
			local their_healer_incapacitate_dr_remains = 0
			if their_healer then
				their_healer_cc_remains = _CCremains(their_healer)
				their_healer_cc = their_healer_cc_remains > 0
				their_healer_incapacitate_dr = _incapacitateDR(their_healer)
				their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
			end

			if ghost_wolf then return end

			--hex healer / off target on cd
			if their_healer then
				if not _isBeast(their_healer) and _CCremains(their_healer) <= hex_cast_time and _drRemains(their_healer,"incapacitate") < hex_cast_time then
					_Cast(51514,their_healer)
				end
			else
				local off_target
				for i=1,#Enemies do if not unit_is_unit(Enemies[i],current_target) then
					off_target=Enemies[i]
				end end
				if off_target then
					if not _isBeast(off_target) and _CCremains(off_target) <= hex_cast_time and _drRemains(off_target,"incapacitate") < hex_cast_time then
						_Cast(51514,off_target)
					end
					--off target cc treated as healer cc when there is no healer
					their_healer_cc_remains = _CCremains(off_target)
				end
			end

			local function get_totem_mastery_remaining ()
				local cd = 0
				if totem_mastery_placed then
					cd = 120 - (time-totem_mastery_placed)
				end
				cd= cd> 0 and cd or 0
				return cd
			end

			local totem_mastery_remains = get_totem_mastery_remaining ()

			local function get_chain_lightning_targets(unit)

				local count = 1
				local already_counted = {ObjectPointer(unit)}

				local nearby = {}
				for i=1,#Enemies do if not tContains(already_counted,Enemies[i]) then
					local e=Enemies[i]
					local d=_distance(unit,e)
					table.insert(nearby,{pointer=e,distance=d})
				end end
				table.sort(nearby, function(x,y) return x.distance < y.distance end)

				if nearby[2] and nearby[2].distance > 5 then
					nearby[2] = nearby[1]
				end

				if not nearby[2] then nearby[2]=nearby[1] end

				if nearby[2] then
					if nearby[2].distance < 9.5 then
						table.insert(already_counted,nearby[2].pointer)
						unit=nearby[2].pointer
					end
				end

				for n=1,3 do

					nearby = {}
					for i=1,#Enemies do if not tContains(already_counted,Enemies[i]) then
						local e=Enemies[i]
						local d=_distance(unit,e)
						table.insert(nearby,{pointer=e,distance=d})
					end end
					table.sort(nearby, function(x,y) return x.distance < y.distance end)

					if nearby[1] then
						if nearby[1].distance < 9.5 then
							table.insert(already_counted,nearby[1].pointer)
							unit=nearby[1].pointer
						end
					end

				end

				return #already_counted

			end

			local spell_targets_chain_lightning = 0

			if _valid(t) then spell_targets_chain_lightning = get_chain_lightning_targets(t) end

			if arena and time_in_combat < 5 then

				local precombat = _valid(t) and _distance(t) < 30

				-- actions.precombat+=/earth_elemental,if=!talent.primal_elementalist.enabled
				if precombat and not primal_elementalist then
					_Cast(198103)
				end
				-- actions.precombat+=/stormkeeper,if=talent.stormkeeper.enabled&amp;(raid_event.adds.count<3|raid_event.adds.in>50)
				if precombat and stormkeeper_enabled then
					if spell_targets_chain_lightning < 3 then
						_Cast(191634)
					end
				end
				-- actions.precombat+=/fire_elemental,if=!talent.storm_elemental.enabled
				if not storm_elemental and precombat then
					_Cast(198067)
				end
				-- actions.precombat+=/storm_elemental,if=talent.storm_elemental.enabled
				-- actions.precombat+=/elemental_blast,if=talent.elemental_blast.enabled
				if precombat and elemental_blast_enabled then
					_Cast(117014)
				end
				-- actions.precombat+=/lava_burst,if=!talent.elemental_blast.enabled&amp;spell_targets.chain_lightning<3
				-- actions.precombat+=/chain_lightning,if=spell_targets.chain_lightning>2

			end

			if _valid(t) then
				-- actions+=/totem_mastery,if=talent.totem_mastery.enabled&amp;buff.resonance_totem.remains<2
				if totem_mastery_remains < 2 then
					_Cast(210643)
				end
				--lasso target
				if their_healer_cc_remains >= 4 then
					RunMacroText("/use 14")
					RunMacroText("/use 13")
					_Cast(305483,t,true)
				end
				--breath of the dying
				if IsPlayerSpell(310690) and _spellCooldown(310690) <= gcd_remains then
					local hp = (100 * (UnitHealth(t)-GetSpellEffect(310690)) / UnitHealthMax(t))
					if hp < 20 or _HP(t) > 80 then
						if _Cast(310690,t,true) then
							Squid_Alert("Breath of the Dying",nil,nil,nil,310690)
						end
					end
				end
				-- actions+=/fire_elemental,if=!talent.storm_elemental.enabled
				if not storm_elemental then
					_Cast(198067)
				end
				-- actions+=/storm_elemental,if=talent.storm_elemental.enabled&amp;(!talent.icefury.enabled|!buff.icefury.up&amp;!cooldown.icefury.up)&amp;(!talent.ascendance.enabled|!cooldown.ascendance.up)
				-- actions+=/earth_elemental,if=!talent.primal_elementalist.enabled|talent.primal_elementalist.enabled&amp;(cooldown.fire_elemental.remains<120&amp;!talent.storm_elemental.enabled|cooldown.storm_elemental.remains<120&amp;talent.storm_elemental.enabled)
				if not primal_elementalist or primal_elementalist and fire_elemental_cd < 120 then
					_Cast(198103)
				end
				-- actions+=/concentrated_flame
				_Cast(295373,t,true)
				-- actions+=/blood_of_the_enemy
				-- actions+=/guardian_of_azeroth
				-- actions+=/focused_azerite_beam
				-- actions+=/purifying_blast
				-- actions+=/the_unbound_force
				-- actions+=/memory_of_lucid_dreams
				-- actions+=/ripple_in_space
				-- actions+=/worldvein_resonance
				-- actions+=/blood_fury,if=!talent.ascendance.enabled|buff.ascendance.up|cooldown.ascendance.remains>50
				-- actions+=/berserking,if=!talent.ascendance.enabled|buff.ascendance.up
				-- actions+=/fireblood,if=!talent.ascendance.enabled|buff.ascendance.up|cooldown.ascendance.remains>50
				-- actions+=/ancestral_call,if=!talent.ascendance.enabled|buff.ascendance.up|cooldown.ascendance.remains>50


				local function aoe(t)
					-- # Multi target action priority list
					-- actions.aoe=stormkeeper,if=talent.stormkeeper.enabled
					if stormkeeper_enabled then
						_Cast(191634)
					end
					-- # Spread Flame Shock in <= 4 target fights, but not during SE uptime,unless you're fighting 3 targets and have less than 14 Wind Gust stacks.
					-- actions.aoe+=/flame_shock,target_if=refreshable&amp;(spell_targets.chain_lightning<(5-!talent.totem_mastery.enabled)|!talent.storm_elemental.enabled&amp;(cooldown.fire_elemental.remains>(120+14*spell_haste)|cooldown.fire_elemental.remains<(24-14*spell_haste)))&amp;(!talent.storm_elemental.enabled|cooldown.storm_elemental.remains<120|spell_targets.chain_lightning=3&amp;buff.wind_gust.stack<14)
					for i=1,#flameshocks do
						local e=flameshocks[i]
						if e.fs < 1.7 then
							_Cast(188389,e.pointer,nil,true)
						end
					end
					-- actions.aoe+=/ascendance,if=talent.ascendance.enabled&amp;(talent.storm_elemental.enabled&amp;cooldown.storm_elemental.remains<120&amp;cooldown.storm_elemental.remains>15|!talent.storm_elemental.enabled)&amp;(!talent.icefury.enabled|!buff.icefury.up&amp;!cooldown.icefury.up)
					-- actions.aoe+=/liquid_magma_totem,if=talent.liquid_magma_totem.enabled
					if liquid_magma_totem then _Cast(192222) end
					-- # Try to game Earthquake with Master of the Elements buff when fighting 3 targets. Don't overcap Maelstrom!
					-- actions.aoe+=/earthquake,if=!talent.master_of_the_elements.enabled|buff.stormkeeper.up|maelstrom>=(100-4*spell_targets.chain_lightning)|buff.master_of_the_elements.up|spell_targets.chain_lightning>3
					if not master_of_the_elements or stormkeeper or maelstrom >= (100-4*spell_targets_chain_lightning) or master_of_the_elements_up or spell_targets_chain_lightning > 3 then
						for i=1,#mostaround do
							local e=mostaround[i]
							if e.around >= 3 and not breakable_cc_around(e.pointer,10) then
								_AeCast(61882,e.pointer,40,8)
							end
						end
					end
					-- # Make sure you don't lose a Stormkeeper.
					-- actions.aoe+=/chain_lightning,if=buff.stormkeeper.remains<3*gcd*buff.stormkeeper.stack
					if stormkeeper and stormkeeper_remains < 3*gcd*stormkeeper_stacks then
						_Cast(188443,t,true)
					end
					-- # Only cast Lava Burst on three targets if it is an instant and Storm Elemental is NOT active.
					-- actions.aoe+=/lava_burst,if=buff.lava_surge.up&amp;spell_targets.chain_lightning<4&amp;(!talent.storm_elemental.enabled|cooldown.storm_elemental.remains<120)&amp;dot.flame_shock.ticking
					if lava_surge and spell_targets_chain_lightning < 4 then
						for i=1,#lowhp do
							local e=lowhp[i]
							if e.fs > 0 then
								_Cast(51505,e.pointer,nil,true)
							end
						end
					end
					-- actions.aoe+=/icefury,if=spell_targets.chain_lightning<4&amp;!buff.ascendance.up
					-- actions.aoe+=/frost_shock,if=spell_targets.chain_lightning<4&amp;buff.icefury.up&amp;!buff.ascendance.up
					-- # Use Elemental Blast against up to 3 targets as long as Storm Elemental is not active.
					-- actions.aoe+=/elemental_blast,if=talent.elemental_blast.enabled&amp;spell_targets.chain_lightning<4&amp;(!talent.storm_elemental.enabled|cooldown.storm_elemental.remains<120)
					if elemental_blast_enabled and spell_targets_chain_lightning < 4 then
						_Cast(117014,t,true)
					end
					-- actions.aoe+=/lava_beam,if=talent.ascendance.enabled
					-- actions.aoe+=/chain_lightning
					_Cast(188443,t,true)
					-- actions.aoe+=/lava_burst,moving=1,if=talent.ascendance.enabled
					if lava_surge then
						for i=1,#lowhp do
							local e=lowhp[i]
							if e.fs > 0 then
								_Cast(51505,e.pointer,nil,true)
							end
						end
					end
					-- actions.aoe+=/flame_shock,moving=1,target_if=refreshable
					for i=1,#flameshocks do
						local e=flameshocks[i]
						if e.fs < 3.4*spell_targets_chain_lightning then
							_Cast(188389,e.pointer,nil,true)
						end
					end
					-- actions.aoe+=/frost_shock,moving=1
					if _spellCooldown(188389) == 0 then
						_Cast(196840,t,true)
					end
				end

				local function single_target(t)
					-- # Single Target Action Priority List
					-- # Ensure FS is active unless you have 14 or more stacks of Wind Gust from Storm Elemental. (Edge case: upcoming Asc but active SE; don't )
					-- actions.single_target=flame_shock,target_if=(!ticking|talent.storm_elemental.enabled&amp;cooldown.storm_elemental.remains<2*gcd|dot.flame_shock.remains<=gcd|talent.ascendance.enabled&amp;dot.flame_shock.remains<(cooldown.ascendance.remains+buff.ascendance.duration)&amp;cooldown.ascendance.remains<4&amp;(!talent.storm_elemental.enabled|talent.storm_elemental.enabled&amp;cooldown.storm_elemental.remains<120))&amp;(buff.wind_gust.stack<14|azerite.igneous_potential.rank>=2|buff.lava_surge.up|!buff.bloodlust.up)&amp;!buff.surge_of_power.up
					if not flame_shock_ticking and not surge_of_power then
						_Cast(188389,t,true)
					end
					-- # Use Ascendance after you've spent all Lava Burst charges and only if neither Storm Elemental nor Icefury are currently active.
					-- actions.single_target+=/ascendance,if=talent.ascendance.enabled&amp;(time>=60|buff.bloodlust.up)&amp;cooldown.lava_burst.remains>0&amp;(cooldown.storm_elemental.remains<120|!talent.storm_elemental.enabled)&amp;(!talent.icefury.enabled|!buff.icefury.up&amp;!cooldown.icefury.up)
					-- # Don't use Elemental Blast if you could cast a Master of the Elements empowered Earth Shock instead. Don't cast Elemental Blast during Storm Elemental unless you have 3x Natural Harmony. But in this case stop using Elemental Blast once you reach 14 stacks of Wind Gust.
					-- actions.single_target+=/elemental_blast,if=talent.elemental_blast.enabled&amp;(talent.master_of_the_elements.enabled&amp;buff.master_of_the_elements.up&amp;maelstrom<60|!talent.master_of_the_elements.enabled)&amp;(!(cooldown.storm_elemental.remains>120&amp;talent.storm_elemental.enabled)|azerite.natural_harmony.rank=3&amp;buff.wind_gust.stack<14)
					-- # Keep SK for large or soon add waves. Unless you have Surge of Power, in which case you want to double buff Lightning Bolt by pooling Maelstrom beforehand. Example sequence: 100MS, ES, SK, LB, LvB, ES, LB
					-- actions.single_target+=/stormkeeper,if=talent.stormkeeper.enabled&amp;(raid_event.adds.count<3|raid_event.adds.in>50)&amp;(!talent.surge_of_power.enabled|buff.surge_of_power.up|maelstrom>=44)
					if _HP(t) < 85 then
						_Cast(191634)
					end
					-- actions.single_target+=/liquid_magma_totem,if=talent.liquid_magma_totem.enabled&amp;(raid_event.adds.count<3|raid_event.adds.in>50)
					if liquid_magma_totem then
						_Cast(192222)
					end
					-- # Combine Stormkeeper with Master of the Elements or Surge of Power unless you have the Lava Shock trait and multiple stacks.
					-- actions.single_target+=/lightning_bolt,if=buff.stormkeeper.up&amp;spell_targets.chain_lightning<2&amp;(azerite.lava_shock.rank*buff.lava_shock.stack)<26&amp;(buff.master_of_the_elements.up&amp;!talent.surge_of_power.enabled|buff.surge_of_power.up)
					if stormkeeper and spell_targets_chain_lightning < 2 and (lava_shock_rank * lava_shock_stacks) < 26 and (master_of_the_elements or surge_of_power) then
						_Cast(188196,t,true)
					end
					-- # Use Earthquake versus 2 targets, unless you have Lava Shock. Use Earthquake versus 1 target if you have Tectonic Thunder 3 times and NO Surge of Power enabled and NO Lava Shock.
					-- actions.single_target+=/earthquake,if=(spell_targets.chain_lightning>1|azerite.tectonic_thunder.rank>=3&amp;!talent.surge_of_power.enabled&amp;azerite.lava_shock.rank<1)&amp;azerite.lava_shock.rank*buff.lava_shock.stack<(36+3*azerite.tectonic_thunder.rank*spell_targets.chain_lightning)&amp;(!talent.surge_of_power.enabled|!dot.flame_shock.refreshable|cooldown.storm_elemental.remains>120)&amp;(!talent.master_of_the_elements.enabled|buff.master_of_the_elements.up|cooldown.lava_burst.remains>0&amp;maelstrom>=92+30*talent.call_the_thunder.enabled)
					if (spell_targets_chain_lightning > 1 or tectonic_thunder_rank >= 3 and not surge_of_power_enabled and lava_shock_rank < 1) and lava_shock_rank*lava_shock_stacks < (36+3*tectonic_thunder_rank*spell_targets_chain_lightning) and (not surge_of_power_enabled or flame_shock_ticking) and (not master_of_the_elements or master_of_the_elements or _spellCooldown(51505) > GetGCD() and maelstrom >= 92+30*(call_the_thunder and 1 or 0)) then
						if not breakable_cc_around(t,10) then
							_AeCast(61882,t,40,8)
						end
					end
					-- # Cast Earth Shock with Master of the Elements talent but no active Surge of Power buff, and active Stormkeeper buff and Lava Burst coming off CD within the next GCD, and either active Master of the Elements buff, or no available Lava Burst while near MS cap, or single target and multiple Lava Shock traits and many stacks.
					-- actions.single_target+=/earth_shock,if=!buff.surge_of_power.up&amp;talent.master_of_the_elements.enabled&amp;(buff.master_of_the_elements.up|cooldown.lava_burst.remains>0&amp;maelstrom>=92+30*talent.call_the_thunder.enabled|spell_targets.chain_lightning<2&amp;(azerite.lava_shock.rank*buff.lava_shock.stack<26)&amp;buff.stormkeeper.up&amp;cooldown.lava_burst.remains<=gcd)
					if not surge_of_power and master_of_the_elements and (master_of_the_elements_up or _spellCooldown(51505) > GetGCD() and maelstrom >= 92+30*(call_the_thunder and 1 or 0) or spell_targets_chain_lightning < 2 and (lava_shock_rank*lava_shock_stacks < 26) and stormkeeper and _spellCooldown(51505) <= gcd) then
						_Cast(8042,t,true)
					end
					-- # You know what? I had some short explanation here once. But then the condition grew, and I had to split the one Earth Shock line into four...so you have to deal with this abomination now: Cast Earth Shock without Master of the Elements talent, and without having triple Igneous Potential and active Ascendance, and active Stormkeeper buff or near MS cap, or Storm Elemental is inactive, and we can't expect to get an additional use of Storm Elemental in the remaining fight from Surge of Power.
					-- actions.single_target+=/earth_shock,if=!talent.master_of_the_elements.enabled&amp;!(azerite.igneous_potential.rank>2&amp;buff.ascendance.up)&amp;(buff.stormkeeper.up|maelstrom>=90+30*talent.call_the_thunder.enabled|!(cooldown.storm_elemental.remains>120&amp;talent.storm_elemental.enabled)&amp;expected_combat_length-time-cooldown.storm_elemental.remains-150*floor((expected_combat_length-time-cooldown.storm_elemental.remains)%150)>=30*(1+(azerite.echo_of_the_elementals.rank>=2)))
					if not master_of_the_elements and (stormkeeper or maelstrom >= 90+30*(call_the_thunder and 1 or 0)) then
						_Cast(8042,t,true)
					end
					-- # Use Earth Shock if Surge of Power is talented, but neither it nor a DPS Elemental is active at the moment, and Lava Burst is ready or will be ready within the next GCD.
					-- actions.single_target+=/earth_shock,if=talent.surge_of_power.enabled&amp;!buff.surge_of_power.up&amp;cooldown.lava_burst.remains<=gcd&amp;(!talent.storm_elemental.enabled&amp;!(cooldown.fire_elemental.remains>120)|talent.storm_elemental.enabled&amp;!(cooldown.storm_elemental.remains>120))
					-- actions.single_target+=/lightning_lasso
					-- # Spam Lightning Bolts during Storm Elemental duration, if you don't have Igneous Potential or have it only once, and don't use Lightning Bolt during Bloodlust if you have a Lava Surge Proc.
					-- actions.single_target+=/lightning_bolt,if=cooldown.storm_elemental.remains>120&amp;talent.storm_elemental.enabled&amp;(azerite.igneous_potential.rank<2|!buff.lava_surge.up&amp;buff.bloodlust.up)
					-- # Cast Lightning Bolt regardless of the previous condition if you'd lose a Stormkeeper stack or have Stormkeeper and Master of the Elements active.
					-- actions.single_target+=/lightning_bolt,if=(buff.stormkeeper.remains<1.1*gcd*buff.stormkeeper.stack|buff.stormkeeper.up&amp;buff.master_of_the_elements.up)
					if stormkeeper and stormkeeper_remains < 1.1*gcd*stormkeeper_stacks or stormkeeper and master_of_the_elements then
						_Cast(188196,t,true)
					end
					-- # Use Frost Shock with Icefury and Master of the Elements.
					-- actions.single_target+=/frost_shock,if=talent.icefury.enabled&amp;talent.master_of_the_elements.enabled&amp;buff.icefury.up&amp;buff.master_of_the_elements.up
					-- actions.single_target+=/lava_burst,if=buff.ascendance.up
					-- # Utilize Surge of Power to spread Flame Shock if multiple enemies are present.
					-- actions.single_target+=/flame_shock,target_if=refreshable&amp;active_enemies>1&amp;buff.surge_of_power.up
					if surge_of_power then
						for i=1,#flameshocks do
							local e=flameshocks[i]
							if e.fs < 4.8 then
								_Cast(188389,e.pointer,nil,true)
							end
						end
					end
					-- # Use Lava Burst with Surge of Power if the last potential usage of Storm Elemental hasn't a full duration OR if you could get another usage of the DPS Elemental if the remaining fight was 16% longer.
					-- actions.single_target+=/lava_burst,if=talent.storm_elemental.enabled&amp;cooldown_react&amp;buff.surge_of_power.up&amp;(expected_combat_length-time-cooldown.storm_elemental.remains-150*floor((expected_combat_length-time-cooldown.storm_elemental.remains)%150)<30*(1+(azerite.echo_of_the_elementals.rank>=2))|(1.16*(expected_combat_length-time)-cooldown.storm_elemental.remains-150*floor((1.16*(expected_combat_length-time)-cooldown.storm_elemental.remains)%150))<(expected_combat_length-time-cooldown.storm_elemental.remains-150*floor((expected_combat_length-time-cooldown.storm_elemental.remains)%150)))
					-- # Use Lava Burst with Surge of Power if the last potential usage of Fire Elemental hasn't a full duration OR if you could get another usage of the DPS Elemental if the remaining fight was 16% longer.
					-- actions.single_target+=/lava_burst,if=!talent.storm_elemental.enabled&amp;cooldown_react&amp;buff.surge_of_power.up&amp;(expected_combat_length-time-cooldown.fire_elemental.remains-150*floor((expected_combat_length-time-cooldown.fire_elemental.remains)%150)<30*(1+(azerite.echo_of_the_elementals.rank>=2))|(1.16*(expected_combat_length-time)-cooldown.fire_elemental.remains-150*floor((1.16*(expected_combat_length-time)-cooldown.fire_elemental.remains)%150))<(expected_combat_length-time-cooldown.fire_elemental.remains-150*floor((expected_combat_length-time-cooldown.fire_elemental.remains)%150)))
					if not storm_elemental and surge_of_power then
						_Cast(51505,t,true)
					end
					-- actions.single_target+=/lightning_bolt,if=buff.surge_of_power.up
					if surge_of_power then
						_Cast(188196,t,true)
					end
					-- actions.single_target+=/lava_burst,if=cooldown_react&amp;!talent.master_of_the_elements.enabled
					if not master_of_the_elements then
						if flame_shock_ticking then
							_Cast(51505,t,true)
						end
					end
					-- # Slightly game Icefury buff to hopefully buff some empowered Frost Shocks with Master of the Elements.
					-- actions.single_target+=/icefury,if=talent.icefury.enabled&amp;!(maelstrom>75&amp;cooldown.lava_burst.remains<=0)&amp;(!talent.storm_elemental.enabled|cooldown.storm_elemental.remains<120)
					-- actions.single_target+=/lava_burst,if=cooldown_react&amp;charges>talent.echo_of_the_elements.enabled
					if flame_shock_ticking and lava_burst_charges > (echo_of_the_elements and 1 or 0) then
						_Cast(51505,t,true)
					end
					-- # Slightly delay using Icefury empowered Frost Shocks to empower them with Master of the Elements too.
					-- actions.single_target+=/frost_shock,if=talent.icefury.enabled&amp;buff.icefury.up&amp;buff.icefury.remains<1.1*gcd*buff.icefury.stack
					-- actions.single_target+=/lava_burst,if=cooldown_react
					if flame_shock_ticking then
						_Cast(51505,t,true)
					end
					-- # Don't accidentally use Surge of Power with Flame Shock during single target.
					-- actions.single_target+=/flame_shock,target_if=refreshable&amp;!buff.surge_of_power.up
					if not surge_of_power and flame_shock_remains <= 6.4 then
						_Cast(188389,t,true)
					end
					-- actions.single_target+=/totem_mastery,if=talent.totem_mastery.enabled&amp;(buff.resonance_totem.remains<6|(buff.resonance_totem.remains<(buff.ascendance.duration+cooldown.ascendance.remains)&amp;cooldown.ascendance.remains<15))
					if totem_mastery_enabled and totem_mastery_remains < 6 then
						_Cast(210643)
					end
					-- actions.single_target+=/frost_shock,if=talent.icefury.enabled&amp;buff.icefury.up&amp;(buff.icefury.remains<gcd*4*buff.icefury.stack|buff.stormkeeper.up|!talent.master_of_the_elements.enabled)
					-- actions.single_target+=/chain_lightning,if=buff.tectonic_thunder.up&amp;!buff.stormkeeper.up&amp;spell_targets.chain_lightning>1
					if tectonic_thunder_up and not stormkeeper and spell_targets_chain_lightning > 1 then
						_Cast(188443,t,true)
					end
					-- actions.single_target+=/lightning_bolt
					_Cast(188196,t,true)
					-- actions.single_target+=/flame_shock,moving=1,target_if=refreshable
					if flame_shock_remains < 11.2 then
						_Cast(188389,t,true)
					end
					-- actions.single_target+=/flame_shock,moving=1,if=movement.distance>6
					-- # Frost Shock is our movement filler.
					-- actions.single_target+=/frost_shock,moving=1
					if _spellCooldown(188389) == 0 then
						if _isMoving("player") then
							_Cast(196840,t,true)
						end
					end
				end

				-- actions+=/run_action_list,name=aoe,if=active_enemies>2&amp;(spell_targets.chain_lightning>2|spell_targets.lava_beam>2)
				if spell_targets_chain_lightning > 2 then
					aoe(t)
				end

				-- actions+=/run_action_list,name=single_target
				single_target(t)

			end

		end

	end

	function Squid_Warrior()

		if UnitIsDeadOrGhost("player") or (IsMounted() and not SQUID.cap_bot) or IsFlying() then return end

		local spec = GetSpecialization()

		--Covenant ids and spells
		local covenant = {
			ids = {
				none = 0,
				kyrian = 1,
				venthyr = 2,
				nightFae = 3,
				necroLord = 4,
			},
			kyrian = {
				spearOfBastian = 307865,
				callSteward = 324739,
			},
			venthyr = {
				condemn = 330325,
				doorOfShadows = 300728,

			},
		}

		--Warrior Skills
		local warrior = {
			battleShout = 6673,
			berserkerRage = 18499,
			challengingShout = 1161,
			charge = 100,
			execute = 163201,
			hamstring = 1715,
			heroicLeap = 6544,
			heroicThrow = 57755,
			ignorePain = 190456,
			intervene = 3411,
			intimidatingShout = 5246,
			pummel = 6552,
			rallyingCry = 316825,
			shatteringThrow = 64382,
			shieldBlock = 2565,
			shieldSlam = 23922,
			slam = 1464,
			spellReflection = 23920,
			taunt = 355,
			victoryRush = 34428,
			whirlwind = 1680,

			buffs = {
				ignorePain = 190456,
				shieldBlock = 132404,
				victorious = 32216,

				--Torghast
				voraciousCullingBlade = 329214, --Execute regardless of health
				umbralEarTrumpet = 329283,
			},
		}
		local arms = {
			avatar = 107574,
			bladestorm = 227847,
			colossusSmash = 167105,
			deadlyCalm = 262228,
			dieByTheSword = 315948,
			mortalStrike = 12294,
			overPower = 7384,
			piercingHowl = 12323,
			ravager = 152277,
			sharpenBlade = 198817,
			skullSplitter = 260643,
			stormBolt = 107570,
			sweepingStrikes = 316433,
			warBreaker = 262161,

			buffs = {
				avatar = 107574,
				deadlyCalm = 262228,
				overPower = 7384,
				suddenDeath = 52437,
			},

			debuffs = {
				colossusSmash = 208086,
				deepWounds = 262115,
				rend = 772,
			},
		}
			local prot = {
				avatar = 107574,
				demoShout = 1160,
				lastStand = 12975,
				revenge = 6572,
				shieldWall = 871,
				shockWave = 46968,
				thunderClap = 6343,

			}

		--Local functions
		local function _valid(unit,immune)
			return unit
			and UnitCanAttack("player",unit)
			and not UnitIsDeadOrGhost(unit)
			and not _breakableCC(unit,true)
			and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
			and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))));
		end
		local function debuff_remains(unit, spellID)
			if not UnitDebuffID(unit, spellID) then
				return 0;
			else
				return _debuffRemains(unit, spellID);
			end
		end
		local function buff_remains(unit, spellID)
			if not UnitBuffID(unit, spellID) then
				return 0;
			else
				return _buffRemains(unit, spellID);
			end
		end
		local function valid_enemies_around(unit, dist)
			local count = 0
			for i = 1, #Enemies do
				if _valid(Enemies[i]) and _distance(Enemies[i], unit) <= dist and not _breakableCC(Enemies[i], false) then
					count = count + 1
				end
			end
			return count;
		end
		local function dynamicTargeting(range)
			--Target enemies above 75% or below 35% preferably
			local bestUnit = bestUnit or nil
			if bestUnit == nil then
				if #Enemies > 0 then
					for i = 1, #Enemies do
						local thisUnit = Enemies[i]
						if _distance('player', thisUnit) <= range and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
							bestUnit = thisUnit
						end
					end
				end
			end
			if not UnitExists("target") and UnitAffectingCombat('player') then
				TargetUnit(bestUnit)
			end
		end
		local function is_instance_boss(unit)
			if IsInInstance() then
				local _, _, encountersTotal = GetInstanceLockTimeRemaining()
				for i = 1, encountersTotal do
					if unit == 'player' then
						local bosses = select(1, GetInstanceLockTimeRemainingEncounter(i))
					end
					if (UnitIsVisible(unit) or false) then
						local boss = GetInstanceLockTimeRemainingEncounter(i)
						local tar = UnitName(unit)
						if tar == boss then return true end
					end
				end
				for j = 1, 5 do
					local num = 'boss' .. j
					if unit_is_unit(num, unit) then return true end
				end
			end
			return false
		end
		local function encounter_name(index)
			--Total of 10 Encounters
			if inInstance and instanceType == 'raid' and instanceName == "Castle Nathria" then
				local boss = GetInstanceLockTimeRemainingEncounter(index)
				return boss
			end
		end
		local function is_boss(unit)
			if unit == nil then
				unit = t
			end
			--Probably needs locales set for totems
			if (UnitIsVisible(unit) or false) and UnitCreatureType(unit) ~= 'Totem' then
				local unitClass = UnitClassification(unit)
				local hMax = UnitHealthMax(unit)
				local pMax = UnitHealthMax('player')
				local instance = select(2, IsInInstance())
				return is_instance_boss(unit)
						or _isDummy(unit)
						or not UnitIsTrivial(unit) and instance ~= 'party' and (unitClass == "rare" and hMax > 4 * pMax) or UnitLevel(unit) < 0
			end
			return false
		end
		function ItemLinkToName(link)
			return gsub(link, "^.*%[(.*)%].*$", "%1");
		end
		local function IsItemInBags(search)
			for bag = 0, 4 do
				for slot = 1, GetContainerNumSlots(bag) do
					local item = GetContainerItemLink(bag, slot)
					if item and item:find(search) then
						return true
					end
				end
			end
			return false
		end
		local function FindItem(item)
			if (not item) then return; end
			item = string.lower(ItemLinkToName(item));
			local link;
			for i = 1, 23 do
				link = GetInventoryItemLink("player", i);
				if (link) then
					if (item == string.lower(ItemLinkToName(link)))then
						return i, nil, GetInventoryItemTexture('player', i), GetInventoryItemCount('player', i);
					end
				end
			end
			local count, bag, slot, texture;
			local totalcount = 0;
			local MAX_CONTAINER_ITEMS = 0;
			for i = 1, 4 do
				MAX_CONTAINER_ITEMS = MAX_CONTAINER_ITEMS + GetContainerNumSlots(i)
			end
			for i = 0, NUM_BAG_FRAMES do
				for j = 1, MAX_CONTAINER_ITEMS do
					link = GetContainerItemLink(i, j);
					if (link) then
						if (item == string.lower(ItemLinkToName(link))) then
							bag, slot = i, j;
							texture, count = GetContainerItemInfo(i, j);
							totalcount = totalcount + count;
						end
					end
				end
			end
			return bag, slot, texture, totalcount;
		end

		local t=current_target
		local covenantID = C_Covenants.GetActiveCovenantID()
		local t_is_boss = (t and is_boss(t) or false)

		local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
		local gcd_remains = GetGCD()
		local rage = UnitPower("player")
		local inInstance, instanceType = IsInInstance()
		local instanceName, instanceType, difficultyID, difficultyName, maxPlayers, dynamicDifficulty, isDynamic, instanceID, instanceGroupSize, LfgDungeonID = GetInstanceInfo()
		local phialInBags = IsItemInBags("Phial of Serenity")
		local phialCountInBags = select(4, FindItem("Phial of Serenity"))


		--All Spec Actions
		---------------------------------------------------------------------------------------------------------
		local auto_target = SQUID.auto_target
		if auto_target then
			dynamicTargeting(10)
		end

		--buff
		for i=1,#Friends do
			if not UnitBuffID(Friends[i],6673) and _distance(Friends[i]) < 40 then
				_Cast(6673)
			end
		end

		--hams
		if not disarm_check('player') and _valid(t, 1) and GetUnitSpeed("player") <= GetUnitSpeed(t) or _rootCheck("player") then
			if UnitIsPlayer(t) and not _slowCheck(t) and not _slowImmuneCheck(t) then
				_Cast(1715,t,true)
			end
		end

		--victory rush
		if not disarm_check('player') and _valid(t, 1) and _meleeRange('player', t) then
			if UnitBuffID('player', warrior.buffs.victorious) and _HP('player') <= 80 then
				_Cast(warrior.victoryRush, t, true)
			end
		end

		--Refresh pots no matter what if we run out
		if not phialInBags and _spellCooldown(covenant.kyrian.callSteward) == 0 then
			_Cast(covenant.kyrian.callSteward)
		--Refresh Pots while not in combat
		elseif phialCountInBags < 3 and _spellCooldown(covenant.kyrian.callSteward) == 0 and not UnitAffectingCombat('player') then
			_Cast(covenant.kyrian.callSteward)
		end
		---------------------------------------------------------------------------------------------------------

		--Torghast Stuff
		local inTorghast = inInstance and instanceType == 'scenario' and instanceName == 'Torghast, Tower of the Damned'
		if inTorghast then
			local torg_reflect_list = {
				[292926] = true, --Eternal Torment .. FUCKING HURTS
			}
			--Spell Reflection
			for i = 1, #Enemies do
				local unitTarget = UnitTarget(Enemies[i])
				local castID = select(9, UnitCastingInfo(Enemies[i]))
				if UnitCastingInfo(Enemies[i]) then
					if unit_is_unit('player', unitTarget) and torg_reflect_list[castID] then
						Squid_Alert("Reflecting this BULLSHIT.")
						_Cast(warrior.spellReflection)
					end
				end
			end
		end
		--Arms
		if spec == 1 then

			local auto_charge = SQUID.auto_charge
			local auto_leap = SQUID.auto_leap

			--zerk
			if _spellCooldown(18499) == 0 and _shouldZerk() then
				if _Cast(18499,_,_,_,true) then
					Squid_Alert("Berserker Rage","(CC)",2)
				end
			end

			local auto_burst = SQUID.auto_burst

			if IsMounted() then return end

			local cs = UnitDebuffID(current_target,208086,"player")
			local cs_remains = _debuffRemains(current_target,208086,"player")
			local Warbreaker = IsPlayerSpell(262161)
			local WarbreakerCD = _spellCooldown(262161)
			local BladestormCD = _spellCooldown(227847)
			local csCD = _spellCooldown(167105)
			local wbCD = _spellCooldown(262161)
			local flame_ticking = UnitDebuffID(current_target,295367,"player")
			local spell_targets_whirlwind = EnemiesAroundMe(8)
			local executeHp = 20 + (IsPlayerSpell(281001) and 15 or 0)
			local deadly_calm_taken = IsPlayerSpell(262228)
			local deadly_calm = UnitBuffID("player",262228)
			local crushing_assault = UnitBuffID("player",278826)
			local overpower = UnitBuffID("player",7384)
			local overpower_stacks = _buffStacks("player",7384)
			local sudden_death = UnitBuffID("player",52437)
			local dreadnaught_taken = IsPlayerSpell(262150)
			local massacre_taken = IsPlayerSpell(281001)
			local executioners_precision_stacks = _buffStacks("player",242188)
			local fervor_of_battle = IsPlayerSpell(202316)
			local rend_remains = _debuffRemains(t,772,"player")
			local defensive_stance = UnitBuffID("player",197690)
			local player_hp = _HP("player")
			local bcc = _bccAM(11)
			local their_healer_cc
			if theirHealer and (_CCcheck(theirHealer) or IsLocked(theirHealer)) then their_healer_cc = true end
			if not theirHealer then their_healer_cc=true end
			local enemies_attacking_me = EnemiesAttacking("player")
			local our_healer_cc = ourHealer and _CCcheck(ourHealer)
			local execute_phase = t ~= nil and (covenantID == covenant.ids.venthyr and (_HP(t) <= executeHp or _HP(t) >= 80)) or (covenantID ~= covenant.ids.venthyr and _HP(t) <= executeHp)
			local melee_range = _valid(t, 1) and _meleeRange(t)

			local should_colossus_smash = melee_range and not bcc and (their_healer_cc or _HP(t) < 90)

			local peel_hp = 45
			for i=1,#Enemies do if _CDcheck(Enemies[i]) then peel_hp = peel_hp + 40 end end
			peel_hp = peel_hp + (our_healer_cc and 40 or 0)

			--banner
			if arena and IsPlayerSpell(236320) then
				if ourHealer then
					local banner = should_banner(ourHealer)
					if banner then
						if banner == "wait" then
							return;
						else
							if _Cast(236320) then
								Squid_Alert("War Banner","("..GetSpellInfo(banner)..")",2)
							end
						end
					end
				else
					for i=1,#Friends do
						local banner = should_banner(Friends[i])
						if banner then
							if banner == "wait" then
								return;
							else
								if _Cast(236320) then
									Squid_Alert("War Banner","("..GetSpellInfo(banner)..")",2)
								end
							end
						end
					end
				end
			end

			--Stomp
			local function Stomp(totem,name)
				if S then return false; end
				local hp = UnitHealth(totem)
				local maxhp = UnitHealthMax(totem)
				if hp <= 1 then return false; end
				if maxhp <= 1000 then
					--Hamstring
					if maxhp <= 2400 then
						if _Cast(1715,totem,nil,true) then
							Squid_Alert(name .. " Stomped","(Hamstring)",1)
							return
						end
					end
					--Heroic Throw
					if _Cast(57755,totem,nil,true) then
						Squid_Alert(name .. " Stomped","(Throw)",1)
						return
					end
				else
					--Overpower
					if _Cast(7384,totem,nil,true) then
						Squid_Alert(name .. " Stomped","(Overpower)",1)
						return
					end
					--Slam
					if _Cast(1464,totem,nil,true) then
						Squid_Alert(name .. " Stomped","(Slam)",1)
						return
					end
				end
			end

			local totems = {
				101398,	--Psyfiend
				119052,	--War Banner
				104818,	--Ancestral Protection Totem
				53006,	--Spirit Link Totem
				2630,	--Earthbind Totem
				60561,	--Earthgrab Totem
				-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
				5925,	--Grounding Totem
				105425,	--Skyfury Totem
				5913,	--Tremor Totem
				105451,	--Counterstrike Totem
			}

			if arena then
				for i=1,#Pets do
					local e = Pets[i]
					local name = UnitName(e);
					local id = UnitCreatureID(e)
					--only kill cap totems when they're casting
					if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
						Stomp(e,name)
					end
				end
			end

			if (arena or instanceType == 'pvp') and IsPlayerSpell(236077) then
				for i=1,#Enemies do if _isMeleeDps(Enemies[i]) and not _CCcheck(Enemies[i]) then
					if UnitBuffID(Enemies[i],184364) and _meleeRange('player', Enemies[i]) then
						if _Cast(236077,Enemies[i],nil,true) then
							Squid_Alert("Disarm " .. UnitClass(Enemies[i]), "(Enraged Regen)",2)
						end
					end
					if unit_is_unit(Enemies[i],current_target) and UnitClass(Enemies[i]) == "Death Knight" and their_healer_cc and _HP(Enemies[i]) < 70 and _meleeRange('player', Enemies[i]) then
						if _Cast(236077,Enemies[i],nil,true) then
							Squid_Alert("Disarm " .. UnitClass(Enemies[i]), "(Offensive)",2)
						end
					end
				end end
			end

			local should_peel = lowestFriend < peel_hp

			if should_peel then
				--disarm
				if (arena or instanceType == 'pvp') and IsPlayerSpell(236077) then
					for i=1,#Enemies do if _isMeleeDps(Enemies[i]) and not _CCcheck(Enemies[i]) then
						if _CDcheck(Enemies[i]) or lowestFriend < 60 and _meleeRange('player', Enemies[i]) then
							if _Cast(236077,Enemies[i],nil,true) then
								Squid_Alert("Disarm " .. UnitClass(Enemies[i]), "(Peel)",2)
							end
						end
					end end
				end
				--piercing howl
				if not (instanceType == 'party' or instanceType == 'raid') then
					for i = 1, #Enemies do if not _slowImmuneCheck(Enemies[i]) and not _isHealer(Enemies[i]) then
						if not _isSlowed(Enemies[i]) and _spellCooldown(arms.piercingHowl) == 0 and _distance('player', Enemies[i]) <= 12 then
							if _Cast(arms.piercingHowl) then
								Squid_Alert("Piercing Howl " .. UnitClass(Enemies[i]), "(Peel)", 2)
							end
						end end
					end
				end
				--hamstring
				if arena or instanceType == 'pvp' then
					for i=1,#Enemies do if not _immunePhysical(Enemies[i]) and not _slowImmuneCheck(Enemies[i]) and not _isHealer(Enemies[i]) then
						if not _isSlowed(Enemies[i]) and _meleeRange('player', Enemies[i]) then
							if _Cast(1715,Enemies[i],nil,true) then
								Squid_Alert("Hamstring " .. UnitClass(Enemies[i]), "(Peel)",2)
							end
						end
					end end
				end
				--rally
				if not instanceType == 'raid' and lowestFriend < 25 then
					if lowestFriendName and _distance(lowestFriendName) < 40 then
						if not _immunePhysical(lowestFriendName) then
							if _Cast(97462) then
								Squid_Alert("Rallying Cry " .. UnitClass(lowestFriendName),"(Danger)",2)
							end
						end
					end
				end
			end

			if bcc and UnitBuffID("player",260708) then
				RunMacroText("/cancelaura sweeping strikes")
			end

			local _, _, _, _, _, _, id = GetSpellInfo("Condemn")

			-- # Executed every time the actor is available.
			if _valid(t, 1) and not disarm_check('player') then

				local time = GetTime()

				local dist = _distance(t)

				local function execute(t)
					--skullsplitter,if=rage<60&amp;(!talent.deadly_calm.enabled|buff.deadly_calm.down)
					if IsPlayerSpell(260643) and rage < 60 and (not deadly_calm_taken or not UnitBuffID('player', arms.buffs.deadlyCalm)) and _spellCooldown(arms.skullSplitter) == 0 then
						_Cast(arms.skullSplitter, t, true)
					end
					--ravager,if=buff.avatar.remains<18&amp;!dot.ravager.remains
					if IsPlayerSpell(152277) and buff_remains('player', arms.buffs.avatar) < 18 and _spellCooldown(arms.ravager) == 0 then
						_AeCast(arms.ravager, t, 40, 8)
					end
					--cleave,if=spell_targets.whirlwind>1&amp;dot.deep_wounds.remains<gcd
					if IsPlayerSpell(845) and valid_enemies_around('player', 8) > 1 and debuff_remains(t, arms.debuffs.deepWounds) < gcd then
						_Cast(arms.cleave, t, true)
					end
					--warbreaker if not on cooldown
					if Warbreaker and WarbreakerCD == 0 then
						_Cast(arms.warbreaker, t, true)
					elseif _spellCooldown(arms.colossusSmash) == 0 then
						_Cast(arms.colossusSmash, t, true)
					end
					--Condemn
					if covenantID == covenant.ids.venthyr and execute_phase then
						if (debuff_remains(t, arms.debuffs.colossusSmash) > 1 and rage >= 40) or (buff_remains('player', arms.buffs.suddenDeath) > 1) or rage > 65 then
							if _amIfacing(t) then
								SQ_CastSpellByName("Execute", t)
							end
						end
					end
					--overpower,if=charges=2
					if _spellChargeFrac(arms.overPower) == 2 then
						_Cast(arms.overPower, t, true)
					end
					--bladestorm,if=buff.deadly_calm.down&amp;rage<50
					if not IsPlayerSpell(152277) and not arena and not UnitBuffID('player', arms.buffs.deadlyCalm) and rage < 50 and _spellCooldown(arms.bladestorm) <= gcd_remains then
						_Cast(arms.bladestorm)
					end
					--mortal_strike,if=dot.deep_wounds.remains<=gcd
					if debuff_remains(t, arms.debuffs.deepWounds) <= gcd and _spellCooldown(arms.mortalStrike) <= gcd_remains then
						if rage >= GetSpellCost(arms.mortalStrike) then
							_Cast(arms.mortalStrike, t, true)
						end
					end
					--skullsplitter,if=rage<40
					if IsPlayerSpell(260643) and rage < 40 and _spellCooldown(arms.skullSplitter) <= gcd_remains then
						_Cast(arms.skullSplitter, t, true)
					end
					--overpower,if=charges=2
					if _spellChargeFrac(arms.overPower) >= 1 then
						_Cast(arms.overPower, t, true)
					end
					--Execute phase for venthyr
					if execute_phase and covenantID == covenant.ids.venthyr then
						if _meleeRange('player', t) and _valid(t, 1) and rage >= GetSpellCost(covenant.venthyr.condemn) then
							if _amIfacing(t) then
								SQ_CastSpellByName("Execute", t)
							end
						end
					--Normal Execute Phase
					elseif rage >= GetSpellCost(warrior.execute) and execute_phase then
						if _meleeRange('player', t) and _valid(t, 1) then
							_Cast(warrior.execute, t, true)
						end
					--Torghast Execute Buff any % of HP
					elseif UnitBuffID('player', warrior.buffs.voraciousCullingBlade) and rage >= GetSpellCost(warrior.execute) then
						if _meleeRange('player', t) and _valid(t, 1) then
							_Cast(warrior.execute, t, true)
						end
					end
				end
				local function single_target(t)
					--cleave,if=spell_targets.whirlwind>1&amp;dot.deep_wounds.remains<gcd
					if IsPlayerSpell(845) and valid_enemies_around('player', 8) > 1 and debuff_remains(t, arms.debuffs.deepWounds) < gcd then
						_Cast(arms.cleave, t, true)
					end
					--warbreaker if not on cooldown
					if Warbreaker and WarbreakerCD <= gcd_remains then
						_Cast(arms.warBreaker, t)
					elseif _spellCooldown(arms.colossusSmash) <= gcd_remains then
						_Cast(arms.colossusSmash, t, true)
					end
					--ravager,if=buff.avatar.remains<18&amp;!dot.ravager.remains
					if IsPlayerSpell(152277) and buff_remains('player', arms.buffs.avatar) < 18 and _spellCooldown(arms.ravager) <= gcd_remains then
						_AeCast(arms.ravager, t, 40, 8)
					end
					--overpower,if=charges=2
					if _spellChargeFrac(arms.overPower) == 2 then
						_Cast(arms.overPower, t, true)
					end
					--	bladestorm,if=buff.deadly_calm.down&amp;(debuff.colossus_smash.up&amp;rage<30|rage<70)
					if not IsPlayerSpell(152277) and not UnitBuffID('player', arms.buffs.deadlyCalm) and (UnitBuffID(t, arms.debuffs.colossusSmash) and rage < 30 or rage < 70) then
						if _spellCooldown(arms.bladestorm) == 0 then
							_Cast(arms.bladestorm)
						end
					end
					--	mortal_strike,if=buff.overpower.stack>=2&amp;buff.deadly_calm.down|(dot.deep_wounds.remains<=gcd&amp;cooldown.colossus_smash.remains>gcd)
					if _buffStacks('player', arms.buffs.overPower) >= 2 and not UnitBuffID('player', arms.buffs.deadlyCalm) or (debuff_remains(t, arms.debuffs.deepWounds) <= gcd) then
						--arena sharpen blade
						if IsPlayerSpell(arms.sharpenBlade) and _spellCooldown(arms.sharpenBlade) <= gcd_remains then
							_Cast(arms.sharpenBlade, t, true)
						end
						--cooldown.colossus_smash.remains>gcd
						if rage >= GetSpellCost(arms.mortalStrike) and WarBreaker and WarbreakerCD > gcd then
							_Cast(arms.mortalStrike, t, true)
						elseif rage >= GetSpellCost(arms.mortalStrike) and not Warbreaker and _spellCooldown(arms.colossusSmash) > gcd then
							_Cast(arms.mortalStrike, t, true)
						end
					end
					--deadly_calm
					--skullsplitter,if=rage<60&amp;buff.deadly_calm.down
					if IsPlayerSpell(260643) and rage < 60 and not UnitBuffID('player', arms.buffs.deadlyCalm) and _spellCooldown(arms.skullSplitter) == 0 then
						_Cast(arms.skullSplitter, t, true)
					end
					--overpower
					if _spellChargeFrac(arms.overPower) >= 1 then
						_Cast(arms.overPower, t, true)
					end
					--Execute phase for venthyr
					if execute_phase and covenantID == covenant.ids.venthyr then
						if _meleeRange('player', t) and _valid(t, 1) and rage >= GetSpellCost(covenant.venthyr.condemn) then
							if _amIfacing(t) then
								SQ_CastSpellByName("Execute", t)
							end
						end
					--Normal Execute Phase
					elseif execute_phase and rage >= GetSpellCost(warrior.execute) then
						if _meleeRange('player', t) and _valid(t, 1) then
							_Cast(warrior.execute, t, true)
						end
					--Torghast Execute Buff any % of HP
					elseif UnitBuffID('player', warrior.buffs.voraciousCullingBlade) and rage >= 40 then
						if _meleeRange('player', t) and _valid(t, 1) then
							_Cast(warrior.execute, t, true)
						end
					end
					--mortal_strike
					if rage >= GetSpellCost(arms.mortalStrike) and _spellCooldown(arms.mortalStrike) <= gcd_remains then
						_Cast(arms.mortalStrike, t, true)
					end
					--whirlwind,if=talent.fervor_of_battle.enabled&amp;rage>60
					if fervor_of_battle and rage > 60 then
						_Cast(warrior.whirlwind)
					end
					if rage >= GetSpellCost(warrior.slam) and _spellCooldown(arms.mortalStrike) > gcd_remains then
						_Cast(warrior.slam, t, true)
					end
				end

				--bladestorm root
				if _rootCheck("player") then
					if UnitRace("player") == "Gnome" and _spellCooldown(20589) == 0 then
						if _Cast(20589) then
							Squid_Alert("Escape Artist","(Rooted)",3)
						end
					elseif not bcc then
						if _Cast(227847) then
							Squid_Alert("Bladestorm","(Rooted)",3)
						end
					end
				end

				if GetUnitSpeed("player") >= 22
				and IsFalling()
				and (not lastGapClose or time-lastGapClose >= .4)
				and dist > 10 then
					NeedsToLeap = time;
				end

				if NeedsToLeap and time - NeedsToLeap < 1 then
					if _AeCast(6544,t,40,3) then
						Squid_Alert("Heroic Leap","(Knocked)",2)
					end
				end

				-- actions=charge
				if not lastGapClose or time-lastGapClose >= 2.5 then
					if dist > 8 then
						if _movingTowards(t,.11) and moving_towards_unit_duration(t,.11) > .2 then
							if _spellCooldown(100) == 0 or _spellCooldown(100) > 18 then
								if auto_charge and _Cast(100,t,true) then
									Squid_Alert("Charge","(Gapclose)")
								end
							else
								if (dist > 10 or _isSlowed("player")) and not breakable_cc_around(t,10) then
									if auto_leap and _aeCastInMovingDirection(6544,t,GetUnitSpeed(t)/3.56,40) then
										Squid_Alert("Heroic Leap","(Gapclose)")
									end
								end
							end
						end
					end
				end

				-- _Cast(100,t);
				-- actions+=/auto_attack
				if not auto_attack or time - auto_attack > 2 then
					StartAttack()
					auto_attack=time
				end

				--UnitCooldown
				--AMS, BLINK

				--stance
				if not defensive_stance then
					if (player_hp < 80 or our_healer_cc) and enemies_attacking_me > 0 then
						_Cast(197690)
					end
				else
					if player_hp > 60 and lowestEnemy < 35 and lowestEnemyName and _meleeRange(lowestEnemyName) then
						_Cast(197690)
					end
					if (player_hp > 85 and not our_healer_cc) or (enemies_attacking_me == 0 and player_hp > 70) then
						_Cast(197690)
					end
				end

				--Sudden Death Procs, lets make sure we got Colossus Smash up or the cd is about to come off cd
				if execute_phase and covenantID == covenant.ids.venthyr then
					if _meleeRange('player', t) and _valid(t, 1) and rage >= GetSpellCost(covenant.venthyr.condemn) then
						if _debuffRemains(t, arms.debuffs.colossusSmash, 'player') > gcd then
							if _amIfacing(t) then
								SQ_CastSpellByName("Execute", t)
							end
						elseif not UnitDebuffID(t, arms.debuffs.colossusSmash, 'player') and (wbCD > _buffRemains('player', arms.buffs.suddenDeath) or csCD > _buffRemains('player', arms.buffs.suddenDeath)) then
							if _amIfacing(t) then
								SQ_CastSpellByName("Execute", t)
							end
						end
					end
				end

				--Solo ignore pain
				if _HP('player') <= 80 and _spellCooldown(warrior.ignorePain) == 0 and rage >= 40 then
					_Cast(warrior.ignorePain)
				end
				--Use Badge for PvE
				if not arena and _meleeRange('player', t) and _valid(t, 1) then
					if (GetInventoryItemID('player', 13) == 175884 or GetInventoryItemID('player', 14) == 175884) and select(2,GetItemCooldown(175884)) == 0 then
						UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
					end
				end
				-- actions+=/avatar,if=cooldown.colossus_smash.remains<8|(talent.warbreaker.enabled&amp;cooldown.warbreaker.remains<8)
				if _meleeRange('player', t) and _valid(t, 1) and is_boss(t) then
					if Warbreaker and WarbreakerCD < 8 then
						_Cast(arms.avatar)
					end
					if not Warbreaker and _spellCooldown(167105) < 8 and is_boss(t) then
						_Cast(arms.avatar)
					end
				end
				--arena burst
				if arena and _meleeRange('player', t) and _valid(t, 1) and auto_burst then
					if Warbreaker and WarbreakerCD < 8 then
						_Cast(arms.avatar)
						--Use Badge with avatar
						if (GetInventoryItemID('player', 13) == 175884 or GetInventoryItemID('player', 14) == 175884) and select(2,GetItemCooldown(175884)) == 0 then
							UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
						end
					end
					if not Warbreaker and _spellCooldown(167105) < 8 then
						_Cast(arms.avatar)
						--Use Badge with avatar
						if (GetInventoryItemID('player', 13) == 175884 or GetInventoryItemID('player', 14) == 175884) and select(2,GetItemCooldown(175884)) == 0 then
							UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
						end
					end
				end

				-- actions+=/sweeping_strikes,if=spell_targets.whirlwind>1&amp;(cooldown.bladestorm.remains>10|cooldown.colossus_smash.remains>8|azerite.test_of_might.enabled)
				if _meleeRange(t) and _valid(t, 1) then
					if not bcc and spell_targets_whirlwind > 1 and (BladestormCD > 15 or IsPlayerSpell(arms.ravager)) then
						_Cast(arms.sweepingStrikes);
					end
				end
				--spear of bastian
				if IsPlayerSpell(covenant.kyrian.spearOfBastian) and time_in_combat > 3 then
					if valid_enemies_around('player', 5) >= 3 or is_boss(t) then
						if _spellCooldown(covenant.kyrian.spearOfBastian) == 0 then
							_AeCast(covenant.kyrian.spearOfBastian, t, 25, 5, false, true)
						end
					end
				end

				--Execute action list
				if _meleeRange('player', t) and _valid(t, 1) then
					if execute_phase then
						execute(t)
					end
				end
				--Single Target
				if not execute_phase and _meleeRange('player', t) and _valid(t, 1) then
					single_target(t)
				end
			end
		end
		--Prot
		if spec == 3 then

			--Tier 1
			local warMachineEnable = IsPlayerSpell(316733)
			local punishEnabled = IsPlayerSpell(275334)
			local devastatorEnabled = IsPlayerSpell(236279)
			--Tier 2
			local doubleTimeEnabled = IsPlayerSpell(103827)
			local rumblingEarthEnabled = IsPlayerSpell(275339)
			local stormBoltEnabled = IsPlayerSpell(107570)
			--Tier 3
			local bestServedColdEnabled = IsPlayerSpell(202560)
			local boomingVoiceEnabled = IsPlayerSpell(202743)
			local dragonRoarEnabled = IsPlayerSpell(118000)
			--Tier 4
			local cracklingThunderEnabled = IsPlayerSpell(2023201)
			local boundingStrideEnabled = IsPlayerSpell(202163)
			local menaceEnabled = IsPlayerSpell(275338)
			--Tier 5
			local neverSurrenderEnabled = IsPlayerSpell(202561)
			local indomitableEnabled = IsPlayerSpell(202095)
			local impendingVictoryEnabled = IsPlayerSpell(202168)
			--Tier 6
			local intoTheFrayEnabled = IsPlayerSpell(202603)
			local unstoppableForceEnabled = IsPlayerSpell(275336)
			local ravagerEnabled = IsPlayerSpell(228920)
			--Tier 7
			local angerManagementEnabled = IsPlayerSpell(152278)
			local heavyRepercussionsEnabled = IsPlayerSpell(203177)
			local bolsterEnabled = IsPlayerSpell(280001)

			local ignore_pain_up = buff_remains('player', warrior.ignorePain) >= 2


			function defaultList(t)

				local time = GetTime()

				--auto attack
				if _valid(current_target) then
					if not auto_atack_sent or time - auto_atack_sent > 1 then
						StartAttack()
						auto_atack_sent = time
					end
				end
				--use_items,if=cooldown.avatar.remains<=gcd|buff.avatar.up

				--auto taunt
				for i = 1, #Enemies do
					if _distance('player', Enemies[i]) <= 30 then
						local taunt = Enemies[i]
						if inInstance and instanceType == 'party' and UnitThreatSituation("player", taunt) ~= nil and UnitThreatSituation("player", taunt) <= 2 and UnitAffectingCombat(taunt) then
							_Cast(warrior.taunt, taunt)
						end
					end
				end

				--ignore_pain,if=buff.ignore_pain.down
				if not UnitBuffID('player', warrior.ignorePain) and rage >= GetSpellCost(warrior.ignorePain) and _spellCooldown(warrior.ignorePain) == 0 then
					_Cast(warrior.ignorePain)
				end

				--avatar on bosses
				if _spellCooldown(prot.avatar) == 0 and _meleeRange('player', t) and _valid(t, 1) then
					if is_boss(t) then
						_Cast(prot.avatar)
					end
				end

				--spear of bastian
				if IsPlayerSpell(covenant.kyrian.spearOfBastian) and time_in_combat > 3 then
					if valid_enemies_around('player', 5) >= 3 or is_boss(t) then
						if _spellCooldown(covenant.kyrian.spearOfBastian) == 0 then
							_AeCast(covenant.kyrian.spearOfBastian, t, 25, 5, false, true)
						end
					end
				end

				--run_action_list,name=aoe,if=spell_targets.thunder_clap>=3
				if valid_enemies_around('player', 8) >= 3 and _meleeRange('player', t) then
					aoe(t)
				elseif _meleeRange('player', t) and _valid(t, 1) then
					st(t)
				end
				--call_action_list,name=st
			end

			function aoe(t)
				--Shockwave
				if _spellCooldown(prot.shockWave) == 0 and valid_enemies_around('player', 6) >= 3 then
					_Cast(prot.shockWave, t, true)
				end
				--thunder clap
				if _spellCooldown(prot.thunderClap) == 0 then
					_Cast(prot.thunderClap)
				end
				--demoralizing_shout,if=talent.booming_voice.enabled
				if boomingVoiceEnabled and _spellCooldown(prot.demoShout) == 0 and rage <= 61 then
					_Cast(prot.demoShout)
				end
				--revenge
				if rage >= GetSpellCost(prot.revenge) and ignore_pain_up or UnitBuffID('player', 5302) then
					_Cast(prot.revenge, t, true)
				end
				--shield_block,if=cooldown.shield_slam.ready&amp;buff.shield_block.down
				if not UnitBuffID('player', warrior.buffs.shieldBlock) and _spellChargeFrac(warrior.shieldBlock) >= 1 then
					if rage >= GetSpellCost(warrior.shieldBlock) then
						_Cast(warrior.shieldBlock)
					end
				end
				--shield slam
				if _spellCooldown(warrior.shieldSlam) == 0 then
					_Cast(warrior.shieldSlam, t, true)
				end
			end

			function st(t)
				--thunder_clap,if=spell_targets.thunder_clap=2&amp;talent.unstoppable_force.enabled&amp;buff.avatar.up
				if valid_enemies_around('player', 8) >= 2 and unstoppableForceEnabled and UnitBuffID('player', prot.avatar) then
					_Cast(prot.thunderClap)
				end
				--shield_block,if=cooldown.shield_slam.ready&amp;buff.shield_block.down
				if not UnitBuffID('player', warrior.buffs.shieldBlock) and _spellChargeFrac(warrior.shieldBlock) >= 1 then
					if rage >= GetSpellCost(warrior.shieldBlock) then
						_Cast(warrior.shieldBlock)
					end
				end
				--shield_slam,if=buff.shield_block.up
				if buff_remains('player', warrior.buffs.shieldBlock) > 0 then
					_Cast(warrior.shieldSlam, t, true)
				end
				--thunder_clap,if=(talent.unstoppable_force.enabled&amp;buff.avatar.up)
				if unstoppableForceEnabled and UnitBuffID('player', prot.avatar) then
					_Cast(prot.thunderClap)
				end
				--demoralizing_shout,if=talent.booming_voice.enabled
				if boomingVoiceEnabled and _spellCooldown(prot.demoShout) == 0 and rage <= 61 then
					_Cast(prot.demoShout)
				end
				--shield slam
				if _spellCooldown(warrior.shieldSlam) == 0 then
					_Cast(warrior.shieldSlam, t, true)
				end
				--execute
				if _HP(t) <= 20 and rage >= GetSpellCost(warrior.execute) and ignore_pain_up then
					_Cast(warrior.execute, t, true)
				end
				--revenge,if=rage>=70
				if rage >= 70 or UnitBuffID('player', 5302) and ignore_pain_up then
					_Cast(prot.revenge, t, true)
				end
				--thunda clap
				if _spellCooldown(prot.thunderClap) == 0 then
					_Cast(prot.thunderClap)
				end
				--revenge
				if rage >= GetSpellCost(prot.revenge) and ignore_pain_up or UnitBuffID('player', 5302) then
					_Cast(prot.revenge, t, true)
				end
				--devastate
				if not devastatorEnabled then
					_Cast(prot.devastate, t, true)
				end
			end

			if _valid(t, 1) and _meleeRange(t) then
				defaultList(t)
			end
		end

	end


	--[[
		ToDO
		Add corruption/agony while moving if < amount we want
		Add blacklist
		Add use covenant damage
		Add use covenant utility
		Shard Sniping -- if non boss is about to die use drain soul on it
		Add important coil interrupts
		solo drain life usage

		if seed of corruption cast time < gcds required to cast corruption on the targets that need it and the targets are in range

		now time - get condition met time >= gcd

		haunt > ua > agony > corruption > siphon > phantom > soul rot
		if PS cd < 10 and

		dump with full dots + PS or soul rot, otherwise hold 3 shards
		redo seed of corruption
		171557 -- shade id
	]]--
	function Squid_Warlock()
		local spec = GetSpecialization()
		local auto_cds = SQUID.warlock_cds
		local inInstance, instanceType = IsInInstance()
		local buffer = ((1000/GetFramerate())/1000)*10 --ms per frame * 10 (10 fps buffer)
		local latency = squid_avg_latency+buffer+.09 --90ms + fps buffer, since latency only updates every 30s, and script only runs once per frame.
		local delay = latency+buffer
		local t_ttd = squid_ttd(t)
		local single_target_only = SQUID.single_target

		--Tables
		local racials = {
			berserking = 26297,
			bloodFury = 33702,
		}

		local covenantID = C_Covenants.GetActiveCovenantID()
		local covenants = {
			ids = {
				none = 0,
				kyrian = 1,
				venthyr = 2,
				nightFae = 3,
				necroLord = 4,
			},
			--Kyrian
			kyrian = {
				scouringTithe = 312321,
			},
			--Venthyr
			venthyr = {
				impendingCatastrophe = 321792,
			},
			--Night Fae
			nightFae = {
				soulRot = 325640,
				soulShape = 310143,
			},
			--Necrolord
			necroLord = {
				decimatingBolt = 325289,
			},
		}

		local warlock = {
			axeToss = 119914,
			banish = 710,
			corruption = 172,
			createHealhstone = 6201,
			createSoulWell = 29893,
			curseOfExhaustion = 334275,
			curseOfTongues = 1714,
			curseOfWeakness = 702,
			demonicCircle = 48018,
			demonicCircleTeleport = 48020,
			demonicGateway = 111771,
			drainLife = 234153,
			eyeOfKillrogg = 126,
			fear = 5782,
			felDomination = 333889,
			healthFunnel = 755,
			ritualOfDoom = 342601,
			ritualOfSummoning = 698,
			shadowBolt = 686,
			shadowFury = 30283,
			soulStone = 20707,
			subjugateDemon = 1098,
			summonImp = 688,
			summonVoidWalker = 697,
			summonFelhunter = 691,
			summonSuccubus = 712,
			summonFelguard = 30146,

			buffs = {

			},

			debuffs = {
				corruption = 146739,
			},

		}

		local aff = {
			agony = 980,
			maleficRapture = 324536,
			seedOfCorruption = 27243,
			summonDarkglare = 205180,
			unstableAffliction = 316099,

			--Talents
			burningRush = 111400,
			darkPact = 108416,
			darkSoulMisery = 113860,
			drainSoul = 198590,
			grimoireOfSacrifice = 108503,
			haunt = 48181,
			howlOfTerror = 5484,
			inevitableDemise = 334319,
			mortalCoil = 6789,
			phantomSingularity = 205179,
			siphonLife = 63106,
			vileTaint = 278350,

			--PvP Talents
			demonArmor = 285933,
			rampantAffliction = 335052,
			rapidContagion = 344566,


			buffs = {
				darkSoulMisery = 113860,
				inevitableDemise = 334320,
			},

			debuffs = {
				agony = 980,
				corruption = 146739,
				haunt = 48181,
				phantomSingularity = 205179,
				seedOfCorruption = 27243,
				shadowEmbrace = 32390,
				siphonLife = 63106,
				unstableAffliction = 316099,
				unstableAfflictionRampantAffliction = 342938,
				vileTaint = 278350,
			},
		}

		local destro = {
			immolate = 348,
		}

		local demo = {

			callDreadStalkers = 104316,
			demonBolt = 264178,
			handOfGuldan = 105174,
			implosion = 196277,
			summonDemonicTyrant = 265187,

			--Talents
			bilescourgeBombers = 267211,
			burningRush = 111400,
			darkPact = 108416,
			demonicStrength = 267171,
			demonSkin = 219272,
			doom = 603,
			grimoireFelguard = 111898,
			howlOfTerror = 5484,
			mortalCoil = 6789,
			netherPortal = 267217,
			powerSiphon = 264130,
			soulStrike = 264057,
			summonVilefiend = 264119,

			buffs = {
				demonicCalling = 205146, --Free Call Dreadstalkers + Instant
				demonicCore = 264173, --Demonbolt buff
				demonicPower = 265273, --Tyrant buff
				netherPortal = 267218,
			},
			debuffs = {
				doom = 603,
			},
		}

		local raid = {
			bossDebuffs = {
				--Sludgefist
				destructiveImpact = 331314, -- Sludgefist Destructive Impact, Damage taken increased by 100%. Stunned.
				--Huntsman
				destabilize = 334695,  --334695 - Destabilize 100% damage taken increased per stack
				brokenBonds = 345902,  -- broken bond
			},
		}

		local dot_blacklist = {

		}


		local function _valid(unit,immune)
			if ObjectID(unit) == 164589 then return true end
			return unit
			and UnitCanAttack("player",unit)
			and not UnitIsDeadOrGhost(unit)
			and not _breakableCC(unit,true)
			and ((not immune and not _immuneCheck(unit)) or (immune == 1 and not _immunePhysical(unit)) or (immune == 2 and not _immuneMagic(unit)) or immune == 3)
			and ((arena and UnitIsPlayer(unit)) or (not arena and (UnitAffectingCombat(unit) or _isDummy(unit) or UnitIsPlayer(unit))));
		end
		local function valid_enemies_around(unit, dist)
			local count = 0
			for i = 1, #Enemies do
				if _valid(Enemies[i]) and _distance(Enemies[i], unit) <= dist and not _breakableCC(Enemies[i], false) then
					count = count + 1
				end
			end
			return count;
		end
		local function debuff_count(spellID, range)
			local count = 0
			for i = 1, #Enemies do
				if _debuffRemains(Enemies[i], spellID) > 0 and _distance('player', Enemies[i]) <= range then
					count = count + 1
				end
			end
			return count
		end
		local function dynamicTargeting(range)
			--Target enemies above 75% or below 35% preferably
			local bestUnit = bestUnit or nil
			if bestUnit == nil then
				if #Enemies > 0 then
					for i = 1, #Enemies do
						local thisUnit = Enemies[i]
						if _distance('player', thisUnit) <= range and not UnitIsDead(thisUnit) and UnitAffectingCombat(Enemies[i]) then
							bestUnit = thisUnit
						end
					end
				end
			end
			if not UnitExists("target") and UnitAffectingCombat('player') then
				TargetUnit(bestUnit)
			end
		end
		local function is_instance_boss(unit)
			if IsInInstance() then
				local _, _, encountersTotal = GetInstanceLockTimeRemaining()
				for i = 1, encountersTotal do
					if unit == 'player' then
						local bosses = select(1, GetInstanceLockTimeRemainingEncounter(i))
					end
					if (UnitIsVisible(unit) or false) then
						local boss = GetInstanceLockTimeRemainingEncounter(i)
						local tar = UnitName(unit)
						if tar == boss then return true end
					end
				end
				for j = 1, 5 do
					local num = 'boss' .. j
					if unit_is_unit(num, unit) then return true end
				end
			end
			return false
		end
		local function encounter_name(index)
			--Total of 10 Encounters
			if inInstance and instanceType == 'raid' and instanceName == "Castle Nathria" then
				local boss = GetInstanceLockTimeRemainingEncounter(index)
				return boss
			end
		end
		local function is_boss(unit)
			if unit == nil then
				unit = t
			end
			--Probably needs locales set for totems
			if (UnitIsVisible(unit) or false) and UnitCreatureType(unit) ~= 'Totem' then
				local unitClass = UnitClassification(unit)
				local hMax = UnitHealthMax(unit)
				local pMax = UnitHealthMax('player')
				local instance = select(2, IsInInstance())
				return is_instance_boss(unit)
						or _isDummy(unit)
						or not UnitIsTrivial(unit) and instance ~= 'party' and (unitClass == "rare" and hMax > 4 * pMax) or UnitLevel(unit) < 0
						or UnitIsPlayer(unit)
			end
			return false
		end
		local function dot_shade(unit)
			local shade_id = 171557
			if ObjectID(unit) ~= shade_id then
				return true
			end
			if ObjectID(unit) == shade_id then
				if not UnitDebuffID(unit, raid.bossDebuffs.destabilize) then
					return false
				elseif UnitDebuffID(unit, raid.bossDebuffs.destabilize) and _debuffStacks(unit, raid.bossDebuffs.destabilize) < 2 and _breakableCC(unit, false) then
					return false
				elseif UnitDebuffID(unit, raid.bossDebuffs.destabilize) and _debuffStacks(unit, raid.bossDebuffs.destabilize) > 2 and _breakableCC(unit, false) then
					return false
				elseif UnitDebuffID(unit, raid.bossDebuffs.destabilize) and _debuffStacks(unit, raid.bossDebuffs.destabilize) > 2 and not _breakableCC(unit, false) then
					return true
				end
			end
		end
		--Player
		local player_hp = _HP('player')
		local shards = UnitPower("player",7)
		local race = UnitRace('player')
		local haste = UnitSpellHaste("player")
		local gcd = 1.5/(1+(haste/100))
		local gcd_remains = GetGCD()
		local combat_time = time_in_combat
		local ttd = squid_ttd
		if not UnitAffectingCombat('player') then
			combat_time = 0
		end
		local solo = #Friends == 1

		local t = current_target
		local t_is_boss = (t and is_boss(t) or false)
		--Warlock Globals
		local fear_cast_time = _castTime(warlock.fear)

		local time = GetTime()
		function warlock_exhaust()
			Curse_Of_Exhaustion = GetTime()
		end
		function warlock_tongues()
			Curse_of_Tongues = GetTime()
		end
		function warlock_weak()
			Curse_Of_Weakness = GetTime()
		end
		function warlock_use_covenant_damage()
			Warlock_Use_Covenant_Damage = GetTime()
		end
		if Curse_Of_Exhaustion and time - Curse_Of_Exhaustion > 2 then
			Curse_Of_Exhaustion = nil
		end
		if Curse_of_Tongues and time - Curse_of_Tongues > 2 then
			Curse_of_Tongues = nil
		end
		if Curse_Of_Weakness and time - Curse_Of_Weakness > 2 then
			Curse_Of_Weakness = nil
		end
		if Warlock_Use_Covenant_Damage and time - Warlock_Use_Covenant_Damage > 2 then
			Warlock_Use_Covenant_Damage = nil
		end

		if Curse_Of_Exhaustion then
			if not SpellRecentlyUsed(warlock.curseOfExhaustion, 2) then
				Squid_Alert("Casting Curse of Exhaustion on the next global.",nil,nil,.35)
				_Cast(warlock.curseOfExhaustion, t, false)
			end
		end
		if Curse_of_Tongues then
			if not SpellRecentlyUsed(warlock.curseOfTongues, 2) then
				Squid_Alert("Casting Curse of Tongues on the next global.",nil,nil,.35)
				_Cast(warlock.curseOfTongues, t, false)
			end
		end
		if Curse_Of_Weakness then
			if not SpellRecentlyUsed(warlock.curseOfWeakness, 2) then
				Squid_Alert("Casting Curse of Weakness on the next global.",nil,nil,.35)
				_Cast(warlock.curseOfWeakness, t, false)
			end
		end
		if Warlock_Use_Covenant_Damage then
			if covenantID == covenants.ids.kyrian then
				Squid_Alert("Casting Scouring Tithe on the next global.",nil,nil,.35)
				_Cast(covenants.kyrian.scouringTithe, t, true)
			elseif covenantID == covenants.ids.venthyr then
				Squid_Alert("Casting Impending Catastrophe on the next global.",nil,nil,.35)
				_Cast(covenants.venthyr.impendingCatastrophe, t, true)
			elseif covenantID == covenants.ids.nightFae then
				Squid_Alert("Casting Soul Rot on the next global.",nil,nil,.35)
				_Cast(covenants.nightFae.soulRot, t, true)
			elseif covenantID == covenants.ids.necroLord then
				Squid_Alert("Casting Decimating Bolt on the next global.",nil,nil,.35)
				_Cast(covenants.necroLord.decimatingBolt, t, true)
			end
		end

		if shadowfury_key then
			RunMacroText("/cast [@cursor] shadowfury")
		end
		if gateway_key then
			RunMacroText("/cast [@cursor] demonic gateway")
		end
		local use_darkmoon_deck = false
		local darkmoon_ids = {
			311468, --5
			311469, --6
			311470, --7
			311471, --8
		}
		for i = 1, #darkmoon_ids do if UnitAffectingCombat('player') and UnitBuffID('player', darkmoon_ids[i]) then use_darkmoon_deck = true end end

		--equipped items
		local equipped_items = {}
		local trinkets = {
			173069, --Darkmoon Deck: Putrescence
		}
		--Use darkmoon if 5+
		for i=1,#trinkets do if IsEquippedItem( trinkets[i] ) then table.insert( equipped_items, trinkets[i] ) end end

		--Arena Pre Combat
		if arena then
			-- drop soulwell
			if GetItemCount(5512) == 0 and UnitBuffID("player",32727) then
				CastSpellByID(29893)
				InteractUnit("Soulwell")
			end
			--Maintain demon armor
			local demon_armor = UnitBuffID("player",285933)
			if not demon_armor and IsPlayerSpell(285933) then
				_Cast(285933)
			end

			if SQUID.cap_bot then
			-- get pet
				if not UnitExists("pet") or UnitIsDeadOrGhost("pet") then
					CastSpellByID(691)
				end
			end
		end

		--Arena Combat
		if arena then
			if theirHealer then
				if not _breakableCC(theirHealer) then
					if not pattack or GetTime() - pattack > 1 then
						PetAttack(theirHealer)
						pattack = GetTime()
					end
				else
					PetFollow()
				end
			end
			--Curses of Weakness on Melee/Hunter
			for i = 1, #Enemies do
				if _LoS(Enemies[i], 'player') and _distance('player', Enemies[i]) <= 40 then
					local class = select(2,UnitClass(Enemies[i]))
					if _valid(Enemies[i], 2) and _isMeleeDps(Enemies[i]) then
						if _debuffRemains(Enemies[i], 702, 'player') == 0 then
							_Cast(warlock.curseOfWeakness, Enemies[i])
						end
					elseif _valid(Enemies[i], 2) and (_isRangedDps(Enemies[i]) and class ~= nil and class == 'HUNTER') then
						if _debuffRemains(Enemies[i], 702, 'player') == 0 then
							_Cast(warlock.curseOfWeakness, Enemies[i], false)
						end
					end
				end
			end

			--Curse of Tongues
			for i = 1, #Enemies do
				if _LoS(Enemies[i], 'player') and _distance('player', Enemies[i]) <= 40 then
					if _valid(Enemies[i], 2) and _isRangedDps(Enemies[i]) then
						if _debuffRemains(Enemies[i], 1714, 'player') == 0 then
							_Cast(warlock.curseOfTongues, Enemies[i], false)
						end
					end
				end
			end
		end

		--Fears
		if arena and spec ~= 1 then
			--feared target
			local feared_target
			local feared_target_remains = 0
			for i=1,#Enemies do
				if UnitDebuffID(Enemies[i],118699,"player") then
					feared_target = Enemies[i]
					feared_target_remains = _debuffRemains(Enemies[i],118699,"player")
				end
			end

			local their_healer = theirHealer
			local their_healer_cc
			local their_healer_cc_remains = 0
			local their_healer_incapacitate_dr
			local their_healer_incapacitate_dr_remains = 0
			local their_healer_disorient_dr
			local their_healer_disorient_dr_remains = 0
			local their_healer_important_lockout
			if their_healer then
				if not UnitIsDeadOrGhost(their_healer) then
					their_healer_cc_remains = _CCremains(their_healer)
					their_healer_cc = their_healer_cc_remains > 0
					their_healer_incapacitate_dr = _incapacitateDR(their_healer)
					their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
					their_healer_disorient_dr = _disorientDR(their_healer)
					their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

					local class = select(2,UnitClass(their_healer))

					local locked,remaining,school = UnitIsLocked(their_healer)

					if locked and remaining > .25 then
						if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
						or ( class == "SHAMAN" and school == "Nature" )
						or ( class == "PALADIN" and school == "Holy" )
						or ( class == "MONK" and school == "Nature" )
						or ( class == "DRUID" and school == "Nature" )  then
							their_healer_important_lockout = true
						end
					end
				else -- no healer if he dead
					their_healer = nil
				end
			end

			local function their_healer_can_dispel(unit,after)
				after = after or 0
				if not UnitIsVisible(their_healer) or not UnitIsVisible(unit) then return false end
				if unit_is_unit(unit,their_healer) then return false end
				local dispels = {
					["DRUID"] = 88423,	--Nature's Cure (Druid)
					["PALADIN"] = 4987,	--Cleanse (Paladin)
					["PRIEST"] = 527,	--Purify (Priest)
					["SHAMAN"] = 77130,	--Purify Spirit (Shaman)
					["MONK"] = 115450,	--Detox (Monk)
				}
				local class = select(2,UnitClass(their_healer))
				local cd = UnitCooldown(their_healer,dispels[class])
				if cd <= after and _distance(unit,their_healer) <= 48 then
					return true
				end
			end

			local fear_range = 30

			--5782
			local function cc(unit,player_forced)

				if not arena and not unit_is_player(unit) and not player_forced then return 69 end

				--stop if no unit
				if not unit or not UnitIsVisible(unit) then return 69 end

				--do not sheep? (ext. func)
				-- if DoNotSheep(unit) then return 69 end

				--dist to unit
				local dist = _distance(unit)

				local immunity_remains = max( magic_immunity_remains(unit), cc_immunity_remains(unit), _buffRemains(unit,48707) )

				--this function should not only cc, but also return the time until cc needs to happen
				--this is to keep it from starting casts that will get in the way of getting perfect cc on dr
				local time_to_cc = 0

				--check cc
				local ccr = _CCremains(unit)
				local cc = ccr > 0

				--incap drs
				local idr = _incapacitateDR(unit)
				local idr_remains = _drRemains(unit,"incapacitate")

				--disorient drs
				local ddr = _disorientDR(unit)
				local ddr_remains = _drRemains(unit,"disorient")

				--banner?
				local banner = UnitBuffID(unit,236321)

				--remaining shep
				local sheep_remains = _debuffRemains(unit,118)

				--remaining fear
				local fear_remains = _debuffRemains(unit,118699)
				local feared = fear_remains > 0

				--yea dont cc into it...unless
				if banner then return 69 end

				--incap on unit?
				local incap = _incapacitateCheck(unit)

				--healer?
				local is_healer = _isHealer(unit)

				--lockout? (only important lockout...)
				-- local lockout = IsLocked(unit,true)
				local locked,lockout_remaining,school = UnitIsLocked(unit)

				local important_lockout_remaining = 0
				if locked and lockout_remaining > 0 then
					if ( class == "PRIEST" and school == "Shadow" )
					or ( class == "SHAMAN" and school == "Nature" )
					or ( class == "PALADIN" and school == "Holy" )
					or ( class == "MONK" and school == "Nature" )
					or ( class == "DRUID" and school == "Nature" )
					or ( class == "MAGE" and school == "Arcane" )
					or ( class == "WARLOCK" and school == "Shadowflame" ) then
						important_lockout_remaining = lockout_remaining
					end
				end

				--los?
				local los = _LoS(unit)

				--charmed friend?
				local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

				if friendly then return 69 end

				-- local feared_and_dispellable = fear_remains > 3 + fear_cast_time and their_healer_can_dispel(unit,fear_cast_time - buffer)

				--fear, if drs are available, and the unit is not immune
				local time_til_fear = 69
				local max_overlap = fear_cast_time + (buffer*2)
				if los then
					if (important_lockout_remaining <= fear_cast_time + 1 + (buffer*2.5) or UnitCastingInfo(unit)) then -- need better logic here to determine if the lockout is worth sheeping over, cause it often is.

						local fear_dr_ready = ddr == 1 or (ddr >= .25 and ddr_remains > 17.25 - (ccr >= fear_cast_time and 8 * ddr or 0) - (feared and ccr >= fear_cast_time-.2 and 4 * ddr or 0) - ((100-lowestEnemy) * .038) + (ddr == .25 and 1 or 0) ) or ( ddr_remains < fear_cast_time-(buffer/2) and ( ddr_remains ~= 0 or ddr == 1 ) )

						-- print(sheep_dr_ready, idr, idr_remains)
						-- local sheep_time_til_ready = idr == 1 and ccr or (idr >= .25 and idr_remains > 17 - (ccr > 1 and 6 * idr or 0)) and ccr or idr_remains
						local no_fears_out = not feared_target or unit_is_unit(unit,feared_target) or _disorientDR(feared_target) < .25 or (is_healer and ddr == 1) or (not _isHealer(feared_target) and _disorientDR(feared_target) <= .25 and _drRemains(feared_target,"disorient") > 3 and _drRemains(feared_target,"disorient") < 16.5)
						if fear_dr_ready and no_fears_out then

							if dist < fear_range and ( ccr < max_overlap or feared_and_dispellable ) then
								if immunity_remains <= fear_cast_time+(buffer*.44) then
									--alert when moving
									if _isMoving("player") then Squid_Alert("Stop Moving","(Fear)",nil,nil,5782) end
									if (not fear_cast_delay or time-fear_cast_delay > .2) and _Cast(5782,unit) then
										Squid_Alert_Big("Fearing",UnitClass(unit),nil,3,5782)
									end
									time_to_cc = 0
								end
							else
								time_to_cc = math.max(ccr,time_to_cc)
							end

							local immune_val = 0
							if immunity_remains > 0 then
								immune_val = max ( immunity_remains - fear_cast_time - (buffer * .44), 0 )
							end

							time_til_fear = dist < fear_range + 3 and math.max(ccr-max_overlap,ddr_remains < 17 and ddr_remains or 0,immune_val) or 69 -- "never" if out of range (applied to ring too)

						end
					end
				end

				local val = time_til_fear-- math.min(time_til_fear,time_til_poly_ready)

				return val

			end

			--designate highest prio to cc on healer (returning 69 will fall back to off dps cc)
			local function healer_cc()

				local healers = {}

				for i=1,#Enemies do if _isHealer(Enemies[i]) then
					local unit = Enemies[i]
					if _distance(unit) < fear_range then
						-- local friends_attacking = UnitEnemiesAttacking(unit)
						local unit_hp = _HP(unit)
						-- if friends_attacking == 0 and not only_ripped_target(unit) then
							table.insert(healers,unit)
						-- end
					end
				end end

				local soonest = 69
				for i=1,#healers do
					local val = cc(healers[i])

					if val < soonest then
						soonest = val
					end

				end

				return soonest

			end

			--cc off dps while waiting for dr on healer, or to secure cc on healer while they have interrupts available
			local function off_cc()

				if only_cc_healers then return 69 end

				local units = {}

				for i=1,#Enemies do
					local e = Enemies[i]
					if unit_is_player(e) then--or (UnitIsHunterPet(e) and combustion_cd <= 2) then
						if _distance(e) < fear_range and _LoS(e) then
							-- local friends_attacking = UnitEnemiesAttacking(e)
							-- local unit_hp = _HP(e)
							-- if friends_attacking == 0 then
								-- local min_hp = 70
								-- min_hp = min_hp - (our_healer_cc and 20 or 0)
								-- min_hp = min_hp - (_CDcheck(e) and 20 or 0)
								-- min_hp = min_hp - (lowestFriend < 40 and 20 or 0)
								-- if unit_hp > min_hp then
									table.insert(units,e)
								-- end
							-- end
						end
					end
				end

				local soonest = 69
				for i=1,#units do
					local val = cc(units[i])

					if val < soonest then
						soonest = val
					end
				end

				return soonest

			end

			--priority cc, and define max cast time here
			local max_cast_time = 69
			max_cast_time = healer_cc()
			if max_cast_time > fear_cast_time * 2 then
				max_cast_time = min ( max_cast_time, off_cc() )
			end

			if max_cast_time < 0 then max_cast_time = 0 end
		end

		--Aff
		if spec == 1 then
			--[[
			**Solo Mode**

			Solo Pet, Party Pet, Raid Pet
			]]--
			local absoluteCorruptionEnabled = IsPlayerSpell(196103)
			local writheInAgonyEnabled = IsPlayerSpell(196102)
			local drainSoulEnabled = IsPlayerSpell(aff.drainSoul)
			local hauntEnabled = IsPlayerSpell(aff.haunt)
			local inevitableDemiseEnabled = IsPlayerSpell(aff.inevitableDemise)
			local phantomSingularityEnabled = IsPlayerSpell(aff.phantomSingularity)
			local siphonLifeEnabled = IsPlayerSpell(63106)
			local sowTheSeedsEnabled = IsPlayerSpell(196226)
			local vileTaintEnabled = IsPlayerSpell(278350)
			local seedExplosionRadius = 9

			--Pvp
			local rampantAfflictionEnabled = IsPlayerSpell(aff.rampantAffliction)
			local ua_aoe = (rampantAfflictionEnabled and debuff_count(aff.unstableAfflictionRampantAffliction, 40) <= 3) or false
			--103673 DarkGlare ID
			local we_are_bursting = UnitBuffID('player', aff.buffs.darkSoulMisery) and SpellRecentlyUsed(aff.summonDarkglare, 20)



			--Aff
			local agony_single_target = debuff_count(aff.agony, 40) <= 3 or false
			local corruption_single_target = ( (not arena and debuff_count(warlock.corruption, 40) <= 2) or (arena and debuff_count(warlock.corruption, 40) <= 3) ) or false
			local siphon_life_single_target = siphonLifeEnabled and debuff_count(aff.siphonLife, 40) <= 3 or false

			local agony_aoe = not absoluteCorruptionEnabled and debuff_count(aff.debuffs.agony, 40) < 3 or false
			if absoluteCorruptionEnabled then
				agony_aoe = debuff_count(aff.debuffs.agony, 40) < 5 or false
			end
			local siphon_aoe = debuff_count(aff.debuffs.siphonLife, 40) <= 3 or false

			local ua_cast_time = _castTime(aff.unstableAffliction)
			local ua_refresh_time = 6 + ua_cast_time
			local corruption_refresh_time = 4 + (gcd * debuff_count(aff.debuffs.corruption, 40))
			local agony_refresh_time = 	5 + (gcd * debuff_count(aff.debuffs.agony, 40) / 3)
			local siphon_life_refresh_time = 4 + (gcd * debuff_count(aff.debuffs.siphonLife, 40))

			local function dots_up_unit(unit)
				local dots_up = false
				if siphonLifeEnabled then
					if (_debuffRemains(unit, aff.debuffs.unstableAffliction, 'player') > 5 or _debuffRemains(unit, aff.debuffs.unstableAfflictionRampantAffliction, 'player') > 5) and _debuffRemains(unit, aff.debuffs.agony, 'player') > 5 and _debuffRemains(unit, aff.debuffs.corruption, 'player') > 5 and _debuffRemains(unit, aff.debuffs.siphonLife, 'player') > 5 and (hauntEnabled and _debuffRemains(unit, aff.debuffs.haunt, 'player') > 5 or not hauntEnabled) then
						dots_up = true;
					end
				elseif absoluteCorruptionEnabled or writheInAgonyEnabled then
					if (_debuffRemains(unit, aff.debuffs.unstableAffliction, 'player') > 5 or _debuffRemains(unit, aff.debuffs.unstableAfflictionRampantAffliction, 'player') > 5) and _debuffRemains(unit, aff.debuffs.agony, 'player') > 5 and ( (not arena and _debuffRemains(unit, aff.debuffs.corruption, 'player') == -1) or (arena and _debuffRemains(unit, aff.debuffs.corruption, 'player') > 5) ) and (hauntEnabled and _debuffRemains(unit, aff.debuffs.haunt, 'player') > 5 or not hauntEnabled) then
						dots_up = true;
					end
				end
				if siphonLifeEnabled then
					if UnitTarget('player') ~= unit then
						if _debuffRemains(unit, aff.debuffs.agony, 'player') > 5 and _debuffRemains(unit, aff.debuffs.corruption, 'player') > 5 and _debuffRemains(unit, aff.debuffs.siphonLife, 'player') > 5 and (hauntEnabled and _debuffRemains(unit, aff.debuffs.haunt, 'player') > 5 or not hauntEnabled) then
							dots_up = true;
						end
					end
				elseif absoluteCorruptionEnabled or writheInAgonyEnabled then
					if UnitTarget('player') ~= unit then
						if _debuffRemains(unit, aff.debuffs.agony, 'player') > 5 and ( (not arena and _debuffRemains(unit, aff.debuffs.corruption, 'player') == -1) or (arena and _debuffRemains(unit, aff.debuffs.corruption, 'player') > 5) ) and (hauntEnabled and _debuffRemains(unit, aff.debuffs.haunt, 'player') > 5 or not hauntEnabled) then
							dots_up = true;
						end
					end
				end
				return dots_up
			end
			local dots_up_t = dots_up_unit(t)

			local function dots_up_count()
				local dotted_units_count = 0
				for i = 1, #Enemies do
					if dots_up_unit(Enemies[i]) then
						dotted_units_count = dotted_units_count + 1
					end
				end
				return dotted_units_count
			end


			local drain_soul_channel_time = 5 / (1 + (haste / 100))
			local drain_soul_tick_rate = drain_soul_channel_time / 5

			local function has_drain_soul_ticked()
				local _, _, _, startTime, _, _, _, spellId = UnitChannelInfo("player")
				if spellId == aff.drainSoul then
					if GetTime() - (startTime / 1000) > drain_soul_tick_rate then
						return true;
					end
				end
				return false;
			end
			local function should_stop_drain_soul()
				--if we are casting drain soul and it ticks
				--if we are not casting drain soul at all it should return nil
				if select(8, UnitChannelInfo('player')) == nil then return true end
				if select(8, UnitChannelInfo('player')) == aff.drainSoul then
					if has_drain_soul_ticked() then
						return true and SpellStopCasting();
					end
				end
				return false
			end
			--if=active_enemies<4-(talent.sow_the_seeds.enabled|talent.siphon_life.enabled)
			local function corruption_talent_counter()
				local seedsEnabled = 4 - (sowTheSeedsEnabled and 1 or 0)
				local siphonEnabled = 4 - (siphonLifeEnabled and 1 or 0)
				if siphonEnabled == 3 then
					return siphonEnabled
				elseif seedsEnabled == 3 then
					return seedsEnabled
				elseif siphonEnabled == 3 and seedsEnabled == 3 then
					return 3
				else
					return 4
				end
			end
			--Rotation
			local function preCombat()
				--flask

				--food

				--augment

				--summon_pet

				--grimoire_of_sacrifice,if=talent.grimoire_of_sacrifice.enabled

				--seed_of_corruption,if=spell_targets.seed_of_corruption_aoe>=3&amp;!equipped.169314

				--haunt

				--shadow_bolt,if=!talent.haunt.enabled&amp;spell_targets.seed_of_corruption_aoe<3&amp;!equipped.169314
			end
			local function covenant()
				if auto_cds then
					--actions.covenant=impending_catastrophe,if=cooldown.summon_darkglare.remains<10|cooldown.summon_darkglare.remains>50
					if covenantID == covenants.ids.venthyr and IsPlayerSpell(covenants.venthyr.impendingCatastrophe) then
						if _spellCooldown(aff.summonDarkglare) < 10 or _spellCooldown(aff.summonDarkglare) > 50 then
							if _spellCooldown(covenants.venthyr.impendingCatastrophe) == 0 then
								if should_stop_drain_soul() then
									if _Cast(covenants.venthyr.impendingCatastrophe, t, true) then return true end
								end
							end
						end
					end
					--actions.covenant+=/decimating_bolt,if=cooldown.summon_darkglare.remains>5&amp;(debuff.haunt.remains>4|!talent.haunt.enabled)
					if covenantID == covenants.ids.necroLord and IsPlayerSpell(covenants.necroLord.decimatingBolt) then
						if _spellCooldown(aff.summonDarkglare) > 5 and (_debuffRemains(t, aff.debuffs.haunt, 'player') > 4 or not hauntEnabled) then
							if _spellCooldown(covenants.necroLord.decimatingBolt) == 0 then
								if should_stop_drain_soul() then
									if _Cast(covenants.necroLord.decimatingBolt, t, true) then return true end
								end
							end
						end
					end
					--actions.covenant+=/soul_rot,if=cooldown.summon_darkglare.remains<5|cooldown.summon_darkglare.remains>50|cooldown.summon_darkglare.remains>25&amp;conduit.corrupting_leer.enabled
					if covenantID == covenants.ids.nightFae and IsPlayerSpell(covenants.nightFae.soulRot) then
						if _spellCooldown(aff.summonDarkglare) < 5 or _spellCooldown(aff.summonDarkglare) > 50 then --add at lvl 60
							if _spellCooldown(covenants.nightFae.soulRot) <= gcd_remains and dots_up_t then
								if should_stop_drain_soul() then
									if _Cast(covenants.nightFae.soulRot, t, false) then return true end
								end
							end
						end
					end
					--actions.covenant+=/scouring_tithe
					if covenantID == covenants.ids.kyrian and IsPlayerSpell(covenants.kyrian.scouringTithe) then
						if _spellCooldown(covenants.kyrian.scouringTithe) == 0 then
							if should_stop_drain_soul() then
								if _Cast(covenants.kyrian.scouringTithe, t, true) then return true end
							end
						end
					end
				end
			end
			local function darkglare_prep()
				if t_is_boss and auto_cds then
					--actions.darkglare_prep=vile_taint,if=cooldown.summon_darkglare.remains<2
					if shards >= 1 and _spellCooldown(aff.summonDarkglare) < 2 and vileTaintEnabled and _spellCooldown(aff.vileTaint) <= gcd_remains then
						if should_stop_drain_soul() then
							--print('return [DGP] - Vile Taint - Should Stop')
							_AeCast(aff.vileTaint, t, 40, 10, true, true)
						end
					end
					--actions.darkglare_prep+=/potion
					--actions.darkglare_prep+=/fireblood
					--actions.darkglare_prep+=/blood_fury
					if race == 'Orc' and _spellCooldown(racials.bloodFury) == 0 then
						if should_stop_drain_soul() then
							--print('return [DGP] - Racial - Should Stop')
							_Cast(racials.bloodFury)
						end
					end
					--actions.darkglare_prep+=/berserking
					if race == 'Troll' and _spellCooldown(racials.berserking) == 0 then
						if should_stop_drain_soul() then
							_Cast(racials.berserking)
						end
					end
					--actions.darkglare_prep+=/call_action_list,name=covenant,if=!covenant.necrolord&amp;cooldown.summon_darkglare.remains<2
					if covenantID ~= covenants.ids.necroLord and _spellCooldown(aff.summonDarkglare) < 2 and dots_up_t and _spellCooldown(aff.phantomSingularity) <= 1 then
						covenant()
					end
					--actions.darkglare_prep+=/dark_soul
					if phantomSingularityEnabled and dots_up_t and covenantID == covenants.ids.nightFae and _debuffRemains(t, covenants.nightFae.soulRot) > 4 and _debuffRemains(t, aff.debuffs.phantomSingularity) > 7 and _spellCooldown(aff.darkSoulMisery) == 0 and _spellCooldown(aff.summonDarkglare) == 0 then
						if should_stop_drain_soul() then
							_Cast(aff.darkSoulMisery)
						end
					elseif not phantomSingularityEnabled and dots_up_t and covenantID == covenants.ids.night_fae and _debuffRemains(t, covenants.nightFae.soulRot) > 4 and _spellCooldown(aff.darkSoulMisery) == 0 and _spellCooldown(aff.summonDarkglare) == 0 then
						if should_stop_drain_soul() then
							_Cast(aff.darkSoulMisery)
						end
					elseif phantomSingularityEnabled and dots_up_t and covenantID ~= covenants.ids.nightFae and _debuffRemains(t, aff.debuffs.phantomSingularity) > 7 and _spellCooldown(aff.darkSoulMisery) == 0 and _spellCooldown(aff.summonDarkglare) == 0 then
						if should_stop_drain_soul() then
							_Cast(aff.darkSoulMisery)
						end
					elseif not phantomSingularityEnabled and dots_up_t and covenantID ~= covenants.ids.night_fae and _spellCooldown(aff.darkSoulMisery) == 0 and _spellCooldown(aff.summonDarkglare) == 0 then
						if should_stop_drain_soul() then
							_Cast(aff.darkSoulMisery)
						end
					end
					--actions.darkglare_prep+=/darkglare
					if phantomSingularityEnabled and dots_up_t and covenantID == covenants.ids.nightFae and _debuffRemains(t, covenants.nightFae.soulRot) > 4 and _debuffRemains(t, aff.debuffs.phantomSingularity) > 7 and (_spellCooldown(aff.darkSoulMisery) == 0 or _buffRemains('player', aff.buffs.darkSoulMisery) > 15) and _spellCooldown(aff.summonDarkglare) == 0 then
						if should_stop_drain_soul() then
							_Cast(aff.summonDarkglare)
						end
					elseif not phantomSingularityEnabled and dots_up_t and covenantID == covenants.ids.night_fae and _debuffRemains(t, covenants.nightFae.soulRot) > 4 and (_spellCooldown(aff.darkSoulMisery) == 0 or _buffRemains('player', aff.buffs.darkSoulMisery) > 15) and _spellCooldown(aff.summonDarkglare) == 0 then
						if should_stop_drain_soul() then
							_Cast(aff.summonDarkglare)
						end
					elseif phantomSingularityEnabled and dots_up_t and covenantID ~= covenants.ids.nightFae and _debuffRemains(t, aff.debuffs.phantomSingularity) > 7 and (_spellCooldown(aff.darkSoulMisery) == 0 or _buffRemains('player', aff.buffs.darkSoulMisery) > 15) and _spellCooldown(aff.summonDarkglare) == 0 then
						if should_stop_drain_soul() then
							_Cast(aff.summonDarkglare)
						end
					elseif not phantomSingularityEnabled and dots_up_t and covenantID ~= covenants.ids.night_fae and (_spellCooldown(aff.darkSoulMisery) == 0 or _buffRemains('player', aff.buffs.darkSoulMisery) > 15) and _spellCooldown(aff.summonDarkglare) == 0 then
						if should_stop_drain_soul() then
							_Cast(aff.summonDarkglare)
						end
					end
				end
			end
			local function use_items()
				if tContains( equipped_items, 173069 ) and GetItemCD ( ( 173069 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 173069 ) ) )
					Squid_Alert( "Darkmoon Deck: Voracity" )
				end
			end
			local function se()
				--actions.se=haunt
				if hauntEnabled and _spellCooldown(aff.haunt) <= gcd_remains and not _isMoving('player') then
					if should_stop_drain_soul() then
						if _Cast(aff.haunt, t, true) then return true end
					end
				end
				--actions.se+=/drain_soul,interrupt_global=1,interrupt_if=debuff.shadow_embrace.stack>=3
				if drainSoulEnabled then
					if select(8, UnitChannelInfo('player')) == aff.drainSoul then
						if UnitDebuffID(t, aff.debuffs.shadowEmbrace, 'player') and _debuffStacks(t, aff.debuffs.shadowEmbrace) >= 3 then
							if should_stop_drain_soul() then return true end
						end
					else
						if _debuffStacks(t, aff.debuffs.shadowEmbrace) < 3 or _debuffRemains(t, aff.debuffs.shadowEmbrace, 'player') <= gcd_remains + drain_soul_tick_rate then
							if _Cast(aff.drainSoul, t, true) then return true end
						end
					end
				end
				--actions.se+=/shadow_bolt
				if not drainSoulEnabled and not arena then
					if _Cast(warlock.shadowBolt, t, true) then return true end
				end
			end
			local function shard_sniper()
				for i = 1, #Enemies do
					if _HP(Enemies[i]) < 6 and shards < 2 then
						if drainSoulEnabled then
							_Cast(aff.drainSoul, Enemies[i], true)
						end
					end
				end
			end
			local function arena_pvp()
				--Rapid Contagion
				if IsPlayerSpell(344566) then
					if dots_up_t then
						if _buffRemains('player', aff.buffs.darkSoulMisery) >= 10 and shards >= 3 then
							_Cast(aff.rapidContagion)
						elseif _spellCooldown(aff.darkSoulMisery) > 15 then
							_Cast(aff.rapidContagion)
						end
					end
				end
				--Get Corruption up first
				for i = 1, #Enemies do
					if ( _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') ~= -1) then
						if should_stop_drain_soul() then
							--print('return [D2] - Corruption - Should Stop')
							if _Cast(warlock.corruption, Enemies[i], false) then return true end
						end
					end
				end
			end
			local function aoe()
				if instanceType ~= 'pvp' or instanceType ~= arena then
					--Solo Behaviors
					if solo and instanceType == 'none' then
						if dots_up_t and player_hp <= 40 and _distance('player', t) <= 20 and _spellCooldown(aff.mortalCoil) <= gcd_remains then
							if _Cast(aff.mortalCoil, t, true) then return true end
						end
						if player_hp <= 50 and _distance('player', t) <= 40 then
							if _Cast(warlock.drainLife, t, true) then return true end
						end
					end
					--actions.aoe=phantom_singularity
					if auto_cds and dots_up_t and phantomSingularityEnabled and _spellCooldown(aff.phantomSingularity) <= gcd_remains then
						if _distance('player', t) <= 40 then
							if should_stop_drain_soul() then
								--print('return [AoE] - Phantom Singularity - Should Stop')
								if _Cast(aff.phantomSingularity, t) then return true end
							end
						end
					end
					--actions.aoe+=/haunt
					if hauntEnabled and _spellCooldown(aff.haunt) == 0 and select(9, UnitCastingInfo('player')) ~= aff.haunt then
						SpellStopCasting()
					end
					if hauntEnabled and _spellCooldown(aff.haunt) <= gcd_remains and not _isMoving('player') then
						if _distance('player', t) <= 40 then
							if should_stop_drain_soul() then
								--print('return [AoE] - Haunt - Should Stop')
								if _Cast(aff.haunt, t, true) then return true end
							end
						end
					end
					--actions.aoe+=/call_action_list,name=darkglare_prep,if=covenant.venthyr&amp;dot.impending_catastrophe_dot.ticking&amp;cooldown.summon_darkglare.remains<2&amp;(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
					if covenantID == covenants.ids.venthyr and _debuffRemains(t, covenants.venthyr.impendingCatastrophe, 'player') > 1 and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
						darkglare_prep()
					end
					--actions.aoe+=/call_action_list,name=darkglare_prep,if=covenant.night_fae&amp;dot.soul_rot.ticking&amp;cooldown.summon_darkglare.remains<2&amp;(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
					if covenantID == covenants.ids.nightFae and _debuffRemains(t, covenants.nightFae.soulRot, 'player') > 1 and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
						darkglare_prep()
					end
					--actions.aoe+=/call_action_list,name=darkglare_prep,if=(covenant.necrolord|covenant.kyrian|covenant.none)&amp;dot.phantom_singularity.ticking&amp;dot.phantom_singularity.remains<2
					if (covenantID == covenants.ids.necroLord or covenantID == covenants.ids.kyrian or covenantID == covenants.ids.none) and _debuffRemains(t, aff.phantomSingularity, 'player') then
						darkglare_prep()
					end
					--actions.aoe+=/seed_of_corruption,if=talent.sow_the_seeds.enabled&amp;can_seed
					if sowTheSeedsEnabled and shards >= 1 and _debuffRemains(t, aff.debuffs.seedOfCorruption, 'player') <= 0 then
						if not SpellRecentlyUsed(aff.seedOfCorruption, gcd) or PlayerSpellCasts[1].id ~= aff.seedOfCorruption then
							if _distance('player', t) <= 40 then
								if should_stop_drain_soul() then
									--print('return [AoE] - Sow Enabled - Seed of Corruption - Agony - Should Stop')
									if _Cast(aff.seedOfCorruption, t, false) then return true end
								end
							end
						end
					end
					--actions.aoe+=/seed_of_corruption,if=!talent.sow_the_seeds.enabled&amp;!dot.seed_of_corruption.ticking&amp;!in_flight&amp;dot.corruption.refreshable
					if not arena and not sowTheSeedsEnabled and shards >= 1 and _debuffRemains(t, aff.debuffs.seedOfCorruption, 'player') <= 0 and (_debuffRemains(t, aff.debuffs.corruption, 'player') ~= -1 and _debuffRemains(t, aff.debuffs.corruption, 'player') <= corruption_refresh_time) then
						if not SpellRecentlyUsed(aff.seedOfCorruption, 1.5) or PlayerSpellCasts[1].id ~= aff.seedOfCorruption then
							if _distance('player', t) <= 40 then
								if should_stop_drain_soul() then
									--print('return [AoE] - Seed of Corruption - Agony - Should Stop')
									if _Cast(aff.seedOfCorruption, t, false) then return true end
								end
							end
						end
					end
					--actions.aoe+=/agony,cycle_targets=1,if=active_dot.agony<4,target_if=!dot.agony.ticking
					if agony_aoe and not single_target_only then
						for i = 1, #Enemies do
							if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
								if should_stop_drain_soul() then
									--print('return [AoE] - Agony AoE - Should Stop')
									if _Cast(aff.agony, Enemies[i], false) then return true end
								end
							end
						end
					--actions.aoe+=/agony,cycle_targets=1,if=active_dot.agony>=4,target_if=refreshable&amp;dot.agony.ticking
					elseif not agony_aoe and not single_target_only then
						for i = 1, #Enemies do
							if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and UnitDebuffID(Enemies[i], aff.debuffs.agony, 'player') and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
								if should_stop_drain_soul() then
									--print('return [AoE] - Agony AoE Refresh - Should Stop')
									if _Cast(aff.agony, Enemies[i], false) then return true end
								end
							end
						end
					end
					--actions+=/unstable_affliction,if=dot.unstable_affliction.remains<4
					if not _isMoving('player') and (not rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAffliction, 'player') < ua_refresh_time) or (rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time) then
						if _distance('player', t) <= 40 then
							if should_stop_drain_soul() then
								if _Cast(aff.unstableAffliction, t, false) then return true end
							end
						end
					elseif (arena or instanceType == 'pvp') and ua_aoe and not _isMoving('player') then
						for i = 1, #Enemies do
							if UnitIsPlayer(Enemies[i]) and _debuffRemains(Enemies[i], aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time and _distance('player', Enemies[i]) <= 40 then
								if should_stop_drain_soul() then
									if _Cast(aff.unstableAffliction, Enemies[i], false) then return true end
								end
							end
						end
					end
					--actions.aoe+=/vile_taint,if=soul_shard>1
					if vileTaintEnabled and auto_cds and shards > 1 and _spellCooldown(aff.vileTaint) == 0 then
						if _distance('player', t) <= 40 then
							if should_stop_drain_soul() then
								--print('return [AoE] - Vile Taint - Should Stop')
								if _AeCast(aff.vileTaint, t, 40, 10, true, true) then return true end
							end
						end
					end
					--actions.aoe+=/call_action_list,name=covenant,if=!covenant.necrolord
					if covenantID ~= covenants.ids.necroLord then
						if covenant() then return true end
					end
					--actions.aoe+=/call_action_list,name=darkglare_prep,if=covenant.venthyr&amp;(cooldown.impending_catastrophe.ready|dot.impending_catastrophe_dot.ticking)&amp;cooldown.summon_darkglare.remains<2&amp;(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
					if covenantID == covenants.ids.venthyr and (_spellCooldown(covenants.venthyr.impendingCatastrophe) == 0 or _debuffRemains(t, covenants.venthyr.impendingCatastrophe) > 0) and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
						darkglare_prep()
					end
					--actions.aoe+=/call_action_list,name=darkglare_prep,if=(covenant.necrolord|covenant.kyrian|covenant.none)&amp;cooldown.summon_darkglare.remains<2&amp;(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
					if (covenantID == covenants.ids.necroLord or covenantID == covenants.ids.kyrian or covenantID == covenants.ids.none) and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
						darkglare_prep()
					end
						--actions.aoe+=/call_action_list,name=darkglare_prep,if=covenant.night_fae&amp;(cooldown.soul_rot.ready|dot.soul_rot.ticking)&amp;cooldown.summon_darkglare.remains<2&amp;(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
					if covenantID == covenants.ids.nightFae and (_spellCooldown(covenants.nightFae.soulRot) <= gcd_remains or _debuffRemains(t, covenants.nightFae.soulRot) > 1) and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
						darkglare_prep()
					end
					--actions.aoe+=/call_action_list,name=item
					if dots_up_t and auto_cds and use_darkmoon_deck then
						if use_items() then return true end
					end
					--actions.aoe+=/malefic_rapture,if=dot.vile_taint.ticking
					if shards >= 1 and vileTaintEnabled and _debuffRemains(t, aff.debuffs.vileTaint) > _castTime(aff.maleficRapture) + gcd_remains and _LoS(t) then
						if _distance('player', t) <= 40 then
							if should_stop_drain_soul() then
								if _Cast(aff.maleficRapture) then return true end
							end
						end
					end
					--actions.aoe+=/malefic_rapture,if=dot.soul_rot.ticking&amp;!talent.sow_the_seeds.enabled
					if shards >= 1 and _debuffRemains(t, covenants.nightFae.soulRot) > 1 and not sowTheSeedsEnabled and _LoS(t) then
						if should_stop_drain_soul() then
							if _Cast(aff.maleficRapture) then return true end
						end
					end
					--actions.aoe+=/malefic_rapture,if=!talent.vile_taint.enabled
					if shards >= 1 and not vileTaintEnabled and _LoS(t) then
						if should_stop_drain_soul() then
							if _Cast(aff.maleficRapture) then return true end
						end
					end
					--actions.aoe+=/malefic_rapture,if=soul_shard>4
					if shards >= 4 and _LoS(t) then
						if should_stop_drain_soul() then
							if _Cast(aff.maleficRapture) then return true end
						end
					end
					--actions.aoe+=/siphon_life,cycle_targets=1,if=active_dot.siphon_life<=3,target_if=!dot.siphon_life.ticking
					if siphon_aoe and siphonLifeEnabled and not single_target_only then
						for i = 1, #Enemies do
							if dot_shade(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and _debuffRemains(Enemies[i], aff.debuffs.siphonLife, 'player') <= 0 then
								if should_stop_drain_soul() then
									if _Cast(aff.siphonLife, Enemies[i], false) then return true end
								end
							end
						end
					end
					--actions.aoe+=/call_action_list,name=covenant
					if covenant() then return true end
					--actions.aoe+=/drain_life,if=buff.inevitable_demise.stack>=50|buff.inevitable_demise.up&amp;time_to_die<5|buff.inevitable_demise.stack>=35&amp;dot.soul_rot.ticking
					if inevitableDemiseEnabled and UnitBuffID('player', aff.buffs.inevitableDemise) and _buffStacks('player', aff.buffs.inevitableDemise) >= 50 or UnitBuffID('player', aff.buffs.inevitableDemise) and squid_ttd < 5 or UnitBuffID('player', aff.buffs.inevitableDemise) and _buffStacks('player', aff.buffs.inevitableDemise) >= 35 and _debuffRemains(t, covenants.nightFae.soulRot, 'player') > 1 then
						if _distance('player', t) <= 40 then
							if should_stop_drain_soul() then
								if _Cast(warlock.drainLife, t, true) then return true end
							end
						end
					end
				end
			end
			local function default()
				--# Executed every time the actor is available.
				--Solo Behaviors
				if solo and instanceType == 'none' then
					if dots_up_t and player_hp <= 40 and _distance('player', t) <= 20 and _spellCooldown(aff.mortalCoil) <= gcd_remains then
						if _Cast(aff.mortalCoil, t, true) then return true end
					end
					if player_hp <= 50 and _distance('player', t) <= 40 then
						if _Cast(warlock.drainLife, t, true) then return true end
					end
				end
				--actions.aoe=phantom_singularity
				if auto_cds and dots_up_t and phantomSingularityEnabled and _spellCooldown(aff.phantomSingularity) <= gcd_remains then
					if _distance('player', t) <= 40 then
						if should_stop_drain_soul() then
							--print('return [AoE] - Phantom Singularity - Should Stop')
							if _Cast(aff.phantomSingularity, t) then return true end
						end
					end
				end
				--actions.aoe+=/haunt
				if hauntEnabled and _spellCooldown(aff.haunt) == 0 and select(9, UnitCastingInfo('player')) ~= aff.haunt then
					SpellStopCasting()
				end
				--actions+=/haunt
				if hauntEnabled and _spellCooldown(aff.haunt) <= gcd_remains and not _isMoving('player') then
					if should_stop_drain_soul() then
						--print('return [D1] - Haunt - Should Stop')
						if _Cast(aff.haunt, t, true) then return true end
					end
				end
				--actions+=/call_action_list,name=darkglare_prep,if=covenant.venthyr&amp;dot.impending_catastrophe_dot.ticking&amp;cooldown.summon_darkglare.remains<2&amp;(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
				if covenantID == covenants.ids.venthyr and _debuffRemains(t, covenants.venthyr.impendingCatastrophe, 'player') and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
				--actions+=/call_action_list,name=darkglare_prep,if=covenant.night_fae&amp;dot.soul_rot.ticking&amp;cooldown.summon_darkglare.remains<2&amp;(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
				if covenantID == covenants.ids.nightFae and _debuffRemains(t, covenants.nightFae.soulRot, 'player') > 1 and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
				--actions+=/call_action_list,name=darkglare_prep,if=(covenant.necrolord|covenant.kyrian|covenant.none)&amp;dot.phantom_singularity.ticking&amp;dot.phantom_singularity.remains<2
				if (covenantID == covenants.ids.necroLord or covenantID == covenants.ids.kyrian or covenantID == covenants.ids.none) and _debuffRemains(t, aff.phantomSingularity, 'player') then
					darkglare_prep()
				end
				--actions+=/agony,if=dot.agony.remains<4
				if _debuffRemains(t, aff.agony, 'player') <= agony_refresh_time then
					if should_stop_drain_soul() then
						if _Cast(aff.agony, t, false) then return true end
					end
				end
				--actions+=/agony,cycle_targets=1,if=active_enemies>1,target_if=dot.agony.remains<4
				if valid_enemies_around('player', 40) > 1 and agony_single_target and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
							if should_stop_drain_soul() then
								--print('return [D1] - Agony - Should Stop')
								if _Cast(aff.agony, Enemies[i], false) then return true end
							end
						end
					end
					--refresh agony on the amount of mobs we want for single target
				elseif valid_enemies_around('player', 40) > 1 and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and UnitDebuffID(Enemies[i], aff.debuffs.agony, 'player') and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
							if should_stop_drain_soul() then
								--print('return [D1] - Agony Refresh - Should Stop')
								if _Cast(aff.agony, Enemies[i], false) then return true end
							end
						end
					end
				end
				--actions+=/call_action_list,name=darkglare_prep,if=active_enemies>2&amp;covenant.venthyr&amp;(cooldown.impending_catastrophe.ready|dot.impending_catastrophe_dot.ticking)&amp;(dot.phantom_singularity.ticking|!talent.phantom_singularity.enabled)
				if valid_enemies_around('player', 10) > 2 and covenantID == covenants.ids.venthyr and (_spellCooldown(covenants.venthyr.impendingCatastrophe) == 0 or _debuffRemains(t, covenants.venthyr.impendingCatastrophe, 'player') > 1) and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 1 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
				--actions+=/call_action_list,name=darkglare_prep,if=active_enemies>2&amp;(covenant.necrolord|covenant.kyrian|covenant.none)&amp;(dot.phantom_singularity.ticking|!talent.phantom_singularity.enabled)
				if valid_enemies_around('player', 10) > 2 and (covenantID == covenants.ids.necroLord or covenantID == covenants.ids.kyrian or covenantID == covenants.ids.none) and _debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 1 or not phantomSingularityEnabled then
					darkglare_prep()
				end
				--actions+=/call_action_list,name=darkglare_prep,if=active_enemies>2&amp;covenant.night_fae&amp;(cooldown.soul_rot.ready|dot.soul_rot.ticking)&amp;(dot.phantom_singularity.ticking|!talent.phantom_singularity.enabled)
				if valid_enemies_around('player', 10) > 2 and covenantID == covenants.ids.nightFae and (_spellCooldown(covenants.nightFae.soulRot) == 0 or _debuffRemains(t, covenants.nightFae.soulRot) > 1) and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
				--actions+=/seed_of_corruption,if=active_enemies>2&amp;talent.sow_the_seeds.enabled&amp;!dot.seed_of_corruption.ticking&amp;!in_flight
				if valid_enemies_around(t, 10) >= 2 and sowTheSeedsEnabled and _debuffRemains(t, aff.debuffs.seedOfCorruption, 'player') <= 0 then
					if not SpellRecentlyUsed(aff.seedOfCorruption, gcd) or PlayerSpellCasts[1].id ~= aff.seedOfCorruption then
						if should_stop_drain_soul() and not arena then
							--print('return [D1] - Seed of Corruption with Sow Enabled - Should Stop')
							if _Cast(aff.seedOfCorruption, t, false) then return true end
						end
					end
				end
				--actions+=/seed_of_corruption,if=active_enemies>2&amp;talent.siphon_life.enabled&amp;!dot.seed_of_corruption.ticking&amp;!in_flight&amp;dot.corruption.remains<4
				if valid_enemies_around(t, 10) >= 2 and siphonLifeEnabled and _debuffRemains(t, aff.debuffs.seedOfCorruption, 'player') <= 0 and ( _debuffRemains(t, warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(t, warlock.debuffs.corruption, 'player') ~= -1) then
					if not SpellRecentlyUsed(aff.seedOfCorruption, gcd) or PlayerSpellCasts[1].id ~= aff.seedOfCorruption then
						if should_stop_drain_soul() and not arena then
							--print('return [D1] - Seed of Corruption with Siphon life - Should Stop')
							if _Cast(aff.seedOfCorruption, t, false) then return true end
						end
					end
				end
				--actions+=/vile_taint,if=(soul_shard>1|active_enemies>2)&amp;cooldown.summon_darkglare.remains>12
				if vileTaintEnabled and (shards > 1 or valid_enemies_around(t, 10) > 2) and _spellCooldown(aff.summonDarkglare) > 12 and _spellCooldown(aff.vileTaint) == 0 then
					if should_stop_drain_soul() then
						--print('return [D1] - Vile Taint Enabled - Should Stop')
						if _AeCast(aff.vileTaint, t, 40, 10, true, true) then return true end
					end
				end
				--actions+=/unstable_affliction,if=dot.unstable_affliction.remains<4
				if not _isMoving('player') then
					if (not rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAffliction, 'player') < ua_refresh_time) or (rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time) then
						if _distance('player', t) <= 40 then
							if should_stop_drain_soul() then
								if _Cast(aff.unstableAffliction, t, false) then return true end
							end
						end
					elseif (arena or instanceType == 'pvp') and ua_aoe then
						for i = 1, #Enemies do
							if UnitIsPlayer(Enemies[i]) and _debuffRemains(Enemies[i], aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time and _distance('player', Enemies[i]) <= 40 then
								if should_stop_drain_soul() then
									if _Cast(aff.unstableAffliction, Enemies[i], false) then return true end
								end
							end
						end
					end
				end
				--actions+=/siphon_life,if=dot.siphon_life.remains<4
				if siphonLifeEnabled and _debuffRemains(t, aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
					if should_stop_drain_soul() then
						--print('return [D1] - Siphon Life - Should Stop')
						if _Cast(aff.siphonLife, t, false) then return true end
					end
				end

				--actions+=/siphon_life,cycle_targets=1,if=active_enemies>1,target_if=dot.siphon_life.remains<4
				if siphonLifeEnabled and valid_enemies_around('player', 40) > 1 and siphon_life_single_target and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _debuffRemains(Enemies[i], aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
							if should_stop_drain_soul() then
								--print('return [D2] - Siphon Life Refresh - Should Stop')
								if _Cast(aff.siphonLife, Enemies[i], false) then return true end
							end
						end
					end
					--refresh siphon life on the amount of mobs we want for single target
				elseif siphonLifeEnabled and valid_enemies_around('player', 40) > 1 and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and UnitDebuffID(Enemies[i], aff.debuffs.siphonLife, 'player') and _debuffRemains(Enemies[i], aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
							if should_stop_drain_soul() then
								--print('return [D2] - Siphon Life Refresh - Should Stop')
								if _Cast(aff.siphonLife, Enemies[i], false) then return true end
							end
						end
					end
				end
				--actions+=/call_action_list,name=covenant,if=!covenant.necrolord
				if covenantID ~= covenants.ids.necroLord then
					if covenant() then return true end
				end
				--actions+=/corruption,if=active_enemies<4-(talent.sow_the_seeds.enabled|talent.siphon_life.enabled)&amp;dot.corruption.remains<2
				if (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and ( _debuffRemains(t, warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(t, warlock.debuffs.corruption, 'player') ~= -1) then
					if should_stop_drain_soul() then
						--print('return [D2] - Corruption - Should Stop')
						if _Cast(warlock.corruption, t, false) then return true end
					end
				end
				--Culprit? Yes it was one.
				--actions+=/corruption,cycle_targets=1,if=active_enemies<4-(talent.sow_the_seeds.enabled|talent.siphon_life.enabled),target_if=dot.corruption.remains<2
				if (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and corruption_single_target and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and ( _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') ~= -1) then
							if should_stop_drain_soul() then
								--print('return [D2] - Corruption Refresh1 - Should Stop')
								if _Cast(warlock.corruption, Enemies[i], false) then return true end
							end
						end
					end
					--refresh corruption on the amount of mobs we want for single target
				elseif (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and UnitDebuffID(Enemies[i], warlock.debuffs.corruption, 'player') and ( _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') ~= -1) then
							if should_stop_drain_soul() then
								--print('return [D2] - Corruption Refresh2 - Should Stop')
								if _Cast(warlock.corruption, Enemies[i], false) then return true end
							end
						end
					end
				end
				--[[
				--actions+=/phantom_singularity,if=covenant.necrolord|covenant.night_fae|covenant.kyrian|covenant.none
				if covenantID == covenants.ids.necroLord or covenantID == covenants.ids.nightFae or covenantID == covenants.ids.kyrian or covenants.ids.none then
					if phantomSingularityEnabled and auto_cds and _spellCooldown(aff.phantomSingularity) == 0 then
						if should_stop_drain_soul() then
							--print('return [D2] - Phantom Singularity Off CD - Should Stop')
							if _Cast(aff.phantomSingularity, t) then return true end
						end
					end
				end
				--]]
				--actions+=/malefic_rapture,if=soul_shard>4
				if shards > 4 and _LoS(t) then
					if should_stop_drain_soul() then
						--print('return [D2] - Malefic Rapture - Shards > 4 - Should Stop')
						if _Cast(aff.maleficRapture, t) then return true end
					end
				end
				--actions+=/call_action_list,name=darkglare_prep,if=covenant.venthyr&amp;(cooldown.impending_catastrophe.ready|dot.impending_catastrophe_dot.ticking)&amp;cooldown.summon_darkglare.remains<2&amp;(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
				if covenantID == covenants.ids.venthyr and (_spellCooldown(covenants.venthyr.impendingCatastrophe) == 0 or _debuffRemains(covenants.venthyr.impendingCatastrophe) > 0) and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
				--actions+=/call_action_list,name=darkglare_prep,if=(covenant.necrolord|covenant.kyrian|covenant.none)&amp;cooldown.summon_darkglare.remains<2&amp;(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
				if (covenantID == covenants.ids.necroLord or covenantID == covenants.ids.kyrian or covenants.ids.none) and _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
				--actions+=/call_action_list,name=darkglare_prep,if=covenant.night_fae&amp;(cooldown.soul_rot.ready|dot.soul_rot.ticking)&amp;cooldown.summon_darkglare.remains<2&amp;(dot.phantom_singularity.remains>2|!talent.phantom_singularity.enabled)
				if covenantID == covenants.ids.nightFae and (_spellCooldown(covenants.nightFae.soulRot) == 0 or _debuffRemains(t, covenants.nightFae.soulRot) > 0 ) and  _spellCooldown(aff.summonDarkglare) < 2 and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > 2 or not phantomSingularityEnabled) then
					darkglare_prep()
				end
				--actions+=/call_action_list,name=item
				if dots_up_t and auto_cds and use_darkmoon_deck then
					if use_items() then return true end
				end
				--actions+=/call_action_list,name=se,if=debuff.shadow_embrace.stack<(2-action.shadow_bolt.in_flight)|debuff.shadow_embrace.remains<3
				if not UnitDebuffID(t, aff.debuffs.shadowEmbrace, 'player') or UnitDebuffID(t, aff.debuffs.shadowEmbrace, 'player') and _debuffStacks(t, aff.debuffs.shadowEmbrace) < 3 then
					if se() then return true end
				end
				--actions+=/malefic_rapture,if=dot.vile_taint.ticking
				if shards >= 1 and _debuffRemains(aff.debuffs.vileTaint) > _castTime(aff.maleficRapture) and _LoS(t) then
					if should_stop_drain_soul() then
						--print('return [D2] - Malefic Rapture - Taint Remains  - Should Stop')
						if _Cast(aff.maleficRapture) then return true end
					end
				end
				--actions+=/malefic_rapture,if=dot.impending_catastrophe_dot.ticking
				if shards >= 1 and covenantID == covenants.ids.venthyr and _debuffRemains(t, ovenants.venthyr.impendingCatastrophe, 'player') > _castTime(aff.maleficRapture) and _LoS(t) then
					if should_stop_drain_soul() then
						--print('return [D2] - Malefic Rapture - Impending Catastrophe Remains - Should Stop')
						if _Cast(aff.maleficRapture) then return true end
					end
				end
				--actions+=/malefic_rapture,if=dot.soul_rot.ticking
				if shards >= 1 and covenantID == covenants.ids.nightFae and _debuffRemains(t, covenants.nightFae.soulRot, 'player') > _castTime(aff.maleficRapture) and _LoS(t) then
					if should_stop_drain_soul() then
						--print('return [D2] - Malefic Rapture - Soul Rot Remains - Should Stop')
						if _Cast(aff.maleficRapture) then return true end
					end
				end

				--actions+=/malefic_rapture,if=talent.phantom_singularity.enabled&amp;(dot.phantom_singularity.ticking|soul_shard>3|time_to_die<cooldown.phantom_singularity.remains)
				if shards >= 1 and phantomSingularityEnabled and (_debuffRemains(t, aff.debuffs.phantomSingularity, 'player') > _castTime(aff.maleficRapture) or shards > 3 ) and _LoS(t) then
					if should_stop_drain_soul() then
						--print('return [D3] - Malefic Rapture - Phantom Singularity Remains - Should Stop')
						if _Cast(aff.maleficRapture) then return true end
					end
				end
				--actions+=/malefic_rapture,if=talent.sow_the_seeds.enabled
				if not _isMoving('player') and shards >= 1 and sowTheSeedsEnabled and _LoS(t) then
					if should_stop_drain_soul() then
						--print('return [D3] - Malefic Rapture - Shards >= 1 and Sow the Seeds Enabled - Should Stop')
						if _Cast(aff.maleficRapture) then return true end
					end
				end
				--actions+=/drain_life,if=buff.inevitable_demise.stack>40|buff.inevitable_demise.up&amp;time_to_die<4
				if not _isMoving('player') and inevitableDemiseEnabled and UnitBuffID('player', aff.buffs.inevitableDemise) and _buffStacks('player', aff.buffs.inevitableDemise) >= 40 then
					if should_stop_drain_soul() then
						if _Cast(warlock.drainLife, t, true) then return true end
					end
				end
				--actions+=/call_action_list,name=covenant
				if covenant() then return true end
				--actions+=/agony,if=refreshable
				if _debuffRemains(t, aff.debuffs.agony) < agony_refresh_time then
					if should_stop_drain_soul() then
						--print('return [D3] - Agony Refresh - Should Stop')
						if _Cast(aff.agony, t, false) then return true end
					end
				end
				--actions+=/agony,cycle_targets=1,if=active_enemies>1,target_if=refreshable
				if valid_enemies_around('player', 40) > 1 and agony_single_target and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
							if should_stop_drain_soul() then
								--print('return [D3] - Agony AoE - Should Stop')
								if _Cast(aff.agony, Enemies[i], false) then return true end
							end
						end
					end
					--refresh agony on the amount of mobs we want for single target
				elseif valid_enemies_around('player', 40) > 1 and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and UnitDebuffID(Enemies[i], aff.debuffs.agony, 'player') and _debuffRemains(Enemies[i], aff.debuffs.agony, 'player') <= agony_refresh_time then
							if should_stop_drain_soul() then
								--print('return [D3] - Agony AoE Refresh - Should Stop')
								if _Cast(aff.agony, Enemies[i], false) then return true end
							end
						end
					end
				end
				--actions+=/corruption,if=refreshable&amp;active_enemies<4-(talent.sow_the_seeds.enabled|talent.siphon_life.enabled)
				if (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and ( _debuffRemains(t, warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(t, warlock.debuffs.corruption, 'player') ~= -1) then
					if should_stop_drain_soul() then
						--print('return [D3] - Corruption Refresh - Should Stop')
						if _Cast(warlock.corruption, t, false) then return true end
					end
				end
				--actions+=/unstable_affliction,if=dot.unstable_affliction.remains<4
				if not _isMoving('player') then
					if (not rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAffliction, 'player') < ua_refresh_time) or (rampantAfflictionEnabled and _debuffRemains(t, aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time) then
						if _distance('player', t) <= 40 then
							if should_stop_drain_soul() then
								if _Cast(aff.unstableAffliction, t, false) then return true end
							end
						end
					elseif (arena or instanceType == 'pvp') and ua_aoe then
						for i = 1, #Enemies do
							if UnitIsPlayer(Enemies[i]) and _debuffRemains(Enemies[i], aff.debuffs.unstableAfflictionRampantAffliction, 'player') < ua_refresh_time and _distance('player', Enemies[i]) <= 40 then
								if should_stop_drain_soul() then
									if _Cast(aff.unstableAffliction, Enemies[i], false) then return true end
								end
							end
						end
					end
				end
				--actions+=/siphon_life,if=refreshable
				if siphonLifeEnabled and _debuffRemains(t, aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
					if should_stop_drain_soul() then
						--print('return [D3] - Malefic Rapture - Phantom Singularity Remains - Should Stop')
						if _Cast(aff.siphonLife, t, false) then return true end
					end
				end
				--actions+=/siphon_life,cycle_targets=1,if=active_enemies>1,target_if=refreshable
				if siphonLifeEnabled and valid_enemies_around('player', 40) > 1 and siphon_life_single_target and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and _debuffRemains(Enemies[i], aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
							if should_stop_drain_soul() then
								--print('return [D3] - Siphon Life AoE - Should Stop')
								if _Cast(aff.siphonLife, Enemies[i], false) then return true end
							end
						end
					end
					--refresh siphon life on the amount of mobs we want for single target
				elseif siphonLifeEnabled and valid_enemies_around('player', 40) > 1 and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and UnitDebuffID(Enemies[i], aff.debuffs.siphonLife, 'player') and _debuffRemains(Enemies[i], aff.debuffs.siphonLife, 'player') < siphon_life_refresh_time then
							if should_stop_drain_soul() then
								--print('return [D3] - Siphon Life Aoe Refresh - Should Stop')
								if _Cast(aff.siphonLife, Enemies[i], false) then return true end
							end
						end
					end
				end
				--actions+=/corruption,cycle_targets=1,if=active_enemies<4-(talent.sow_the_seeds.enabled|talent.siphon_life.enabled),target_if=refreshable
				if (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and corruption_single_target and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and ( _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') ~= -1) then
							if should_stop_drain_soul() then
								--print('return [D3] - Corruption AoE - Should Stop')
								if _Cast(warlock.corruption, Enemies[i], false) then return true end
							end
						end
					end
					--refresh corruption on the amount of mobs we want for single target
				elseif (valid_enemies_around('player', 40) < corruption_talent_counter() or arena) and not single_target_only then
					for i = 1, #Enemies do
						if dot_shade(Enemies[i]) and _valid(Enemies[i]) and _distance('player', Enemies[i]) <= 40 and UnitDebuffID(Enemies[i], warlock.debuffs.corruption, 'player') and ( _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') < corruption_refresh_time and _debuffRemains(Enemies[i], warlock.debuffs.corruption, 'player') ~= -1) then
							if should_stop_drain_soul() then
								--print('return [D3] - Corruption AoE Refresh - Should Stop')
								if _Cast(warlock.corruption, Enemies[i], false) then return true end
							end
						end
					end
				end

				if drainSoulEnabled and not SpellRecentlyUsed(aff.maleficRapture, gcd + delay) then
					_Cast(aff.drainSoul, t, true)
				end
			end

			if not arena then
				dynamicTargeting(40)
			end

			--Fears
			if arena and dots_up_count() >= 2 then
				--feared target
				local feared_target
				local feared_target_remains = 0
				for i=1,#Enemies do
					if UnitDebuffID(Enemies[i],118699,"player") then
						feared_target = Enemies[i]
						feared_target_remains = _debuffRemains(Enemies[i],118699,"player")
					end
				end

				local their_healer = theirHealer
				local their_healer_cc
				local their_healer_cc_remains = 0
				local their_healer_incapacitate_dr
				local their_healer_incapacitate_dr_remains = 0
				local their_healer_disorient_dr
				local their_healer_disorient_dr_remains = 0
				local their_healer_important_lockout
				if their_healer then
					if not UnitIsDeadOrGhost(their_healer) then
						their_healer_cc_remains = _CCremains(their_healer)
						their_healer_cc = their_healer_cc_remains > 0
						their_healer_incapacitate_dr = _incapacitateDR(their_healer)
						their_healer_incapacitate_dr_remains = _drRemains(their_healer,"incapacitate")
						their_healer_disorient_dr = _disorientDR(their_healer)
						their_healer_disorient_dr_remains = _drRemains(their_healer,"disorient")

						local class = select(2,UnitClass(their_healer))

						local locked,remaining,school = UnitIsLocked(their_healer)

						if locked and remaining > .25 then
							if ( class == "PRIEST" and ( school == "Holy" or school == "Shadow" ) )
							or ( class == "SHAMAN" and school == "Nature" )
							or ( class == "PALADIN" and school == "Holy" )
							or ( class == "MONK" and school == "Nature" )
							or ( class == "DRUID" and school == "Nature" )  then
								their_healer_important_lockout = true
							end
						end
					else -- no healer if he dead
						their_healer = nil
					end
				end

				local function their_healer_can_dispel(unit,after)
					after = after or 0
					if not UnitIsVisible(their_healer) or not UnitIsVisible(unit) then return false end
					if unit_is_unit(unit,their_healer) then return false end
					local dispels = {
						["DRUID"] = 88423,	--Nature's Cure (Druid)
						["PALADIN"] = 4987,	--Cleanse (Paladin)
						["PRIEST"] = 527,	--Purify (Priest)
						["SHAMAN"] = 77130,	--Purify Spirit (Shaman)
						["MONK"] = 115450,	--Detox (Monk)
					}
					local class = select(2,UnitClass(their_healer))
					local cd = UnitCooldown(their_healer,dispels[class])
					if cd <= after and _distance(unit,their_healer) <= 48 then
						return true
					end
				end

				local fear_range = 30

				--5782
				local function cc(unit,player_forced)

					if not arena and not unit_is_player(unit) and not player_forced then return 69 end

					--stop if no unit
					if not unit or not UnitIsVisible(unit) then return 69 end

					--do not sheep? (ext. func)
					-- if DoNotSheep(unit) then return 69 end

					--dist to unit
					local dist = _distance(unit)

					local immunity_remains = max( magic_immunity_remains(unit), cc_immunity_remains(unit), _buffRemains(unit,48707) )

					--this function should not only cc, but also return the time until cc needs to happen
					--this is to keep it from starting casts that will get in the way of getting perfect cc on dr
					local time_to_cc = 0

					--check cc
					local ccr = _CCremains(unit)
					local cc = ccr > 0

					--incap drs
					local idr = _incapacitateDR(unit)
					local idr_remains = _drRemains(unit,"incapacitate")

					--disorient drs
					local ddr = _disorientDR(unit)
					local ddr_remains = _drRemains(unit,"disorient")

					--banner?
					local banner = UnitBuffID(unit,236321)

					--remaining shep
					local sheep_remains = _debuffRemains(unit,118)

					--remaining fear
					local fear_remains = _debuffRemains(unit,118699)
					local feared = fear_remains > 0

					--yea dont cc into it...unless
					if banner then return 69 end

					--incap on unit?
					local incap = _incapacitateCheck(unit)

					--healer?
					local is_healer = _isHealer(unit)

					--lockout? (only important lockout...)
					-- local lockout = IsLocked(unit,true)
					local locked,lockout_remaining,school = UnitIsLocked(unit)

					local important_lockout_remaining = 0
					if locked and lockout_remaining > 0 then
						if ( class == "PRIEST" and school == "Shadow" )
						or ( class == "SHAMAN" and school == "Nature" )
						or ( class == "PALADIN" and school == "Holy" )
						or ( class == "MONK" and school == "Nature" )
						or ( class == "DRUID" and school == "Nature" )
						or ( class == "MAGE" and school == "Arcane" )
						or ( class == "WARLOCK" and school == "Shadowflame" ) then
							important_lockout_remaining = lockout_remaining
						end
					end

					--los?
					local los = _LoS(unit)

					--charmed friend?
					local friendly = UnitIsCharmed(unit) and UnitIsFriend("player",unit)

					if friendly then return 69 end

					-- local feared_and_dispellable = fear_remains > 3 + fear_cast_time and their_healer_can_dispel(unit,fear_cast_time - buffer)

					--fear, if drs are available, and the unit is not immune
					local time_til_fear = 69
					local max_overlap = fear_cast_time + (buffer*2)
					if los then
						if (important_lockout_remaining <= fear_cast_time + 1 + (buffer*2.5) or UnitCastingInfo(unit)) then -- need better logic here to determine if the lockout is worth sheeping over, cause it often is.

							local fear_dr_ready = ddr == 1 or (ddr >= .25 and ddr_remains > 17.25 - (ccr >= fear_cast_time and 8 * ddr or 0) - (feared and ccr >= fear_cast_time-.2 and 4 * ddr or 0) - ((100-lowestEnemy) * .038) + (ddr == .25 and 1 or 0) ) or ( ddr_remains < fear_cast_time-(buffer/2) and ( ddr_remains ~= 0 or ddr == 1 ) )

							-- print(sheep_dr_ready, idr, idr_remains)
							-- local sheep_time_til_ready = idr == 1 and ccr or (idr >= .25 and idr_remains > 17 - (ccr > 1 and 6 * idr or 0)) and ccr or idr_remains
							local no_fears_out = not feared_target or unit_is_unit(unit,feared_target) or _disorientDR(feared_target) < .25 or (is_healer and ddr == 1) or (not _isHealer(feared_target) and _disorientDR(feared_target) <= .25 and _drRemains(feared_target,"disorient") > 3 and _drRemains(feared_target,"disorient") < 16.5)
							if fear_dr_ready and no_fears_out then

								if dist < fear_range and ( ccr < max_overlap or feared_and_dispellable ) then
									if immunity_remains <= fear_cast_time+(buffer*.44) then
										--alert when moving
										if _isMoving("player") then Squid_Alert("Stop Moving","(Fear)",nil,nil,5782) end
										if (not fear_cast_delay or time-fear_cast_delay > .2) and _Cast(5782,unit) then
											Squid_Alert_Big("Fearing",UnitClass(unit),nil,3,5782)
										end
										time_to_cc = 0
									end
								else
									time_to_cc = math.max(ccr,time_to_cc)
								end

								local immune_val = 0
								if immunity_remains > 0 then
									immune_val = max ( immunity_remains - fear_cast_time - (buffer * .44), 0 )
								end

								time_til_fear = dist < fear_range + 3 and math.max(ccr-max_overlap,ddr_remains < 17 and ddr_remains or 0,immune_val) or 69 -- "never" if out of range (applied to ring too)

							end
						end
					end

					local val = time_til_fear-- math.min(time_til_fear,time_til_poly_ready)

					return val

				end

				--designate highest prio to cc on healer (returning 69 will fall back to off dps cc)
				local function healer_cc()

					local healers = {}

					for i=1,#Enemies do if _isHealer(Enemies[i]) then
						local unit = Enemies[i]
						if _distance(unit) < fear_range then
							-- local friends_attacking = UnitEnemiesAttacking(unit)
							local unit_hp = _HP(unit)
							-- if friends_attacking == 0 and not only_ripped_target(unit) then
								table.insert(healers,unit)
							-- end
						end
					end end

					local soonest = 69
					for i=1,#healers do
						local val = cc(healers[i])

						if val < soonest then
							soonest = val
						end

					end

					return soonest

				end

				--cc off dps while waiting for dr on healer, or to secure cc on healer while they have interrupts available
				local function off_cc()

					if only_cc_healers then return 69 end

					local units = {}

					for i=1,#Enemies do
						local e = Enemies[i]
						if unit_is_player(e) then--or (UnitIsHunterPet(e) and combustion_cd <= 2) then
							if _distance(e) < fear_range and _LoS(e) then
								-- local friends_attacking = UnitEnemiesAttacking(e)
								-- local unit_hp = _HP(e)
								-- if friends_attacking == 0 then
									-- local min_hp = 70
									-- min_hp = min_hp - (our_healer_cc and 20 or 0)
									-- min_hp = min_hp - (_CDcheck(e) and 20 or 0)
									-- min_hp = min_hp - (lowestFriend < 40 and 20 or 0)
									-- if unit_hp > min_hp then
										table.insert(units,e)
									-- end
								-- end
							end
						end
					end

					local soonest = 69
					for i=1,#units do
						local val = cc(units[i])

						if val < soonest then
							soonest = val
						end
					end

					return soonest

				end

				--priority cc, and define max cast time here
				local max_cast_time = 69
				max_cast_time = healer_cc()
				if max_cast_time > fear_cast_time * 2 then
					max_cast_time = min ( max_cast_time, off_cc() )
				end

				if max_cast_time < 0 then max_cast_time = 0 end
			end
			--Run
			if not IsMounted() then
				if Squid_Burst then
					_Cast(aff.darkSoulMisery)
					--Use Badge with avatar
					if (GetInventoryItemID('player', 13) == 175884 or GetInventoryItemID('player', 14) == 175884) and select(2,GetItemCooldown(175884)) == 0 then
						UseItemByName( tostring( GetItemInfo ( 175884 ) ) )
					end
					if dots_up_t then
						_Cast(aff.summonDarkglare)
					end
				end
				if arena then
					arena_pvp()
				end
				if valid_enemies_around(t, 10) > 3 and not arena then
					aoe()
				elseif _valid(t) then
					default()
				end
			end
		end

		if spec == 2 then
			--Don't cast demonic strength while felguard is bladestorming
			--Talents Row 1
			bilescourgeBombersEnabled = IsPlayerSpell(267211)
			demonicStrengthEnabled = IsPlayerSpell(267171)
			dreadlashEnabled = IsPlayerSpell(264078)
			--Talents Row 2
			demonicCallingEnabled = IsPlayerSpell(205145)
			powerSiphonEnabled = IsPlayerSpell(264130)
			doomEnabled = IsPlayerSpell(603)
			--Talents Row 3
			burningRushEnabled = IsPlayerSpell(111400)
			darkPactEnabled = IsPlayerSpell(108416)
			demonSkinEnabled = IsPlayerSpell(219272)
			--Talents Row 4
			fromTheShadowsEnabled = IsPlayerSpell(267170)
			soulStrikeEnabled = IsPlayerSpell(264057)
			summonVileFiendEnabled = IsPlayerSpell(264119)
			---Talents Row 5
			darkFuryEnabled = IsPlayerSpell(264874)
			mortalCoilEnabled = IsPlayerSpell(6789)
			howlOfTerrorEnabled = IsPlayerSpell(5484)
			--Talents Row 6
			soulConduitEnabled = IsPlayerSpell(215941)
			innerDemonsEnabled = IsPlayerSpell(267216)
			grimoireFelguardEnabled = IsPlayerSpell(111898)
			--Talents Row 7
			sacrificedSoulsEnabled = IsPlayerSpell(267214)
			demonicConsumptionEnabled = IsPlayerSpell(267215)
			netherPortalEnabled = IsPlayerSpell(267217)

			--Player Stuff
			demonic_tyrant_cd = _spellCooldown(demo.summonDemonicTyrant)
			--variable,name=tyrant_ready,value=0
			local tyrant_ready = 0

			local function minion_count(id)
				local count = 0
				--55659 Wild Imp Object ID
				--98035 Dread Stalker Object ID
				--135002 Tyrant Object ID
				--135816 Vile Fiend Object ID
				--17252 Grimoire Felguard Object ID
				for i = 1, #Squid_OM do
					if ObjectID(Squid_OM[i]) == id then
						count = count + 1
					end
				end
				return count
			end
			local function minion_time_left(name)
				local haveTotem, totemName, startTime, duration, icon
				for index = 1, MAX_TOTEMS do
					haveTotem, totemName, startTime, duration, icon = GetTotemInfo(index)
					if totemName == name then
						return startTime + duration - GetTime()
					end
				end
			end

			vileFiendRemains = minion_time_left('Vilefiend') or 0
			gimoireFelguardRemains = minion_time_left('Felguard') or 0

			local function use_items()
				if tContains( equipped_items, 173069 ) and GetItemCD ( ( 173069 ) ) == 0 then
					UseItemByName( tostring( GetItemInfo ( 173069 ) ) )
					Squid_Alert( "Darkmoon Deck: Voracity" )
				end
			end

			local function precombat()
				--actions.precombat=flask
				--actions.precombat+=/food
				--actions.precombat+=/augmentation
				--actions.precombat+=/summon_pet
				--actions.precombat+=/inner_demons,if=talent.inner_demons.enabled
				--actions.precombat+=/snapshot_stats
				--actions.precombat+=/demonbolt
				--actions.precombat+=/variable,name=tyrant_ready,value=0
			end

			local function covenant()
				--actions.covenant=impending_catastrophe,if=!talent.sacrificed_souls.enabled|active_enemies>1
				if covenantID == covenants.ids.venthyr and _spellCooldown(covenants.venthyr.impendingCatastrophe) <= gcd_remains and not sacrificedSoulsEnabled or valid_enemies_around(t, 10) > 1 then
					_Cast(covenants.venthyr.impendingCatastrophe, t, true)
				end
				--actions.covenant+=/scouring_tithe,if=talent.sacrificed_souls.enabled&amp;active_enemies=1
				if covenantID == covenants.ids.kyrian and _spellCooldown(covenants.kyrian.scouringTithe) <= gcd_remains and sacrificedSoulsEnabled and valid_enemies_around(t, 10) == 1 then
					_Cast(covenants.kyrian.scouringTithe, t, true)
				end
				--actions.covenant+=/scouring_tithe,if=!talent.sacrificed_souls.enabled&amp;active_enemies<4
				if covenantID == covenants.ids.kyrian and _spellCooldown(covenants.kyrian.scouringTithe) <= gcd_remains and not sacrificedSoulsEnabled and valid_enemies_around(t, 10) < 4 then
					_Cast(covenants.kyrian.scouringTithe, t, true)
				end
				--actions.covenant+=/soul_rot
				if covenantID == covenants.ids.nightFae and _spellCooldown(covenants.nightFae.soulRot) <= gcd_remains and auto_cds then
					_Cast(covenants.nightFae.soulRot, t, true)
				end
				--actions.covenant+=/decimating_bolt
				if covenantID == covenants.ids.necroLord and _spellCooldown(covenants.necroLord.decimatingBolt) <= gcd_remains then
					_Cast(covenants.necroLord.decimatingBolt, t, true)
				end
			end

			local function off_gcd()
				if auto_cds then
				--actions.off_gcd+=/potion,if=buff.berserking.up|pet.demonic_tyrant.active&amp;!race.troll
				--actions.off_gcd+=/fireblood,if=pet.demonic_tyrant.active
				--actions.off_gcd+=/blood_fury
					if race == 'Orc' and _spellCooldown(racials.bloodFury) == 0 then
						--print('return [DGP] - Racial - Should Stop')
						_Cast(racials.bloodFury)
					end
					--actions.off_gcd+=/berserking
					if race == 'Troll' and _spellCooldown(racials.berserking) == 0 then
						_Cast(racials.berserking)
					end
				end
			end

			local function summon_tyrant()
				--actions.summon_tyrant=hand_of_guldan,if=soul_shard=5,line_cd=20
				if shards == 5 and not SpellRecentlyUsed(demo.handOfGuldan, 20) then
					_Cast(demo.handOfGuldan, t, true)
				end
				--actions.summon_tyrant+=/demonbolt,if=buff.demonic_core.up&amp;(talent.demonic_consumption.enabled|buff.nether_portal.down),line_cd=20
				if UnitBuffID('player', demo.buffs.demonicCore) and (demonicConsumptionEnabled or _buffRemains('player', demo.buffs.netherPortal) == 0) and not SpellRecentlyUsed(demo.demonBolt, 20) then
					_Cast(demo.demonBolt, t, true)
				end
				--actions.summon_tyrant+=/shadow_bolt,if=buff.wild_imps.stack+incoming_imps<4&amp;(talent.demonic_consumption.enabled|buff.nether_portal.down),line_cd=20
				if minion_count(55659) < 4 and (demonicConsumptionEnabled or _buffRemains('player', demo.buffs.netherPortal) == 0) and not SpellRecentlyUsed(warlock.shadowBolt, 20) then
					_Cast(warlock.shadowBolt, t, true)
				end
				--actions.summon_tyrant+=/call_dreadstalkers
				if (shards >= 2 or UnitBuffID('player', demo.buffs.demonicCalling)) and _spellCooldown(demo.callDreadStalkers) <= gcd_remains then
					_Cast(demo.callDreadStalkers, t, true)
				end
				--actions.summon_tyrant+=/hand_of_guldan
				if shards >= 3 then
					_Cast(demo.handOfGuldan, t, true)
				end
				--actions.summon_tyrant+=/demonbolt,if=buff.demonic_core.up&amp;buff.nether_portal.up&amp;((buff.vilefiend.remains>5|!talent.summon_vilefiend.enabled)&amp;(buff.grimoire_felguard.remains>5|buff.grimoire_felguard.down))
				if UnitBuffID('player', demo.buffs.demonicCore) and UnitBuffID('player', demo.buffs.netherPortal) and ( (vileFiendRemains > 5 or not summonVileFiendEnabled) and (gimoireFelguardRemains > 5 or gimoireFelguardRemains <= 0)) then
					_Cast(demo.demonBolt, t, true)
				end
				--actions.summon_tyrant+=/shadow_bolt,if=buff.nether_portal.up&amp;((buff.vilefiend.remains>5|!talent.summon_vilefiend.enabled)&amp;(buff.grimoire_felguard.remains>5|buff.grimoire_felguard.down))
				if UnitBuffID('player', demo.buffs.netherPortal) and ((vileFiendRemains > 5 or not summonVileFiendEnabled) and (gimoireFelguardRemains > 5 or gimoireFelguardRemains <= 0)) then
					_Cast(warlock.shadowBolt, t, true)
				end
				--actions.summon_tyrant+=/variable,name=tyrant_ready,value=!cooldown.summon_demonic_tyrant.ready
				tyrant_ready = (demonic_tyrant_cd ~= 0 and 1 or 0)
				--actions.summon_tyrant+=/summon_demonic_tyrant
				if demonic_tyrant_cd <= gcd_remains and auto_cds then
					_Cast(demo.summonDemonicTyrant)
				end
				--actions.summon_tyrant+=/shadow_bolt
				if shards ~= 5 then
					_Cast(warlock.shadowBolt, t, true)
				end
			end

			local function tyrant_prep()
				--actions.tyrant_prep=doom,line_cd=30
				if doomEnabled and not UnitDebuffID(t, demo.debuffs.doom, 'player') and not SpellRecentlyUsed(demo.doom, 30) then
					_Cast(demo.doom, t, true)
				end
				--actions.tyrant_prep+=/demonic_strength,if=!talent.demonic_consumption.enabled
				if not demonicConsumptionEnabled and _spellCooldown(demo.demonicStrength) <= gcd_remains then
					_Cast(demo.demonicStrength, t, true)
				end
				--actions.tyrant_prep+=/nether_portal
				if netherPortalEnabled and _spellCooldown(demo.netherPortal) <= gcd_remains and shards >= 1 then
					_Cast(demo.netherPortal)
				end
				--actions.tyrant_prep+=/grimoire_felguard
				if grimoireFelguardEnabled and _spellCooldown(demo.grimoireFelguard) <= gcd_remains and shards >= 1 and auto_cds then
					_Cast(demo.grimoireFelguard, t, true)
				end
				--actions.tyrant_prep+=/summon_vilefiend
				if summonVileFiendEnabled and _spellCooldown(demo.summonVilefiend) <= gcd_remains and shards >= 1 then
					_Cast(demo.summonVilefiend)
				end
				--actions.tyrant_prep+=/call_dreadstalkers
				if _spellCooldown(demo.callDreadStalkers) <= gcd_remains and (shards >= 2 or UnitBuffID('player', demo.buffs.demonicCalling)) then
					_Cast(demo.callDreadStalkers, t, false)
				end
				--actions.tyrant_prep+=/demonbolt,if=buff.demonic_core.up&amp;soul_shard<4&amp;(talent.demonic_consumption.enabled|buff.nether_portal.down)
				if UnitBuffID('player', demo.buffs.demonicCore) and shards < 4 and (demonicConsumptionEnabled or _buffRemains('player', demo.buffs.netherPortal) == 0) then
					_Cast(demo.demonBolt, t, true)
				end
				--actions.tyrant_prep+=/shadow_bolt,if=soul_shard<5-4*buff.nether_portal.up
				if shards < 5 - 4 * (UnitBuffID('player', demo.buffs.netherPortal) and 1 or 0) then
					_Cast(demo.shadowBolt, t, true)
				end
				--actions.tyrant_prep+=/variable,name=tyrant_ready,value=1
				tyrant_ready = 1
				--actions.tyrant_prep+=/hand_of_guldan
				if shards >= 3 then
					_Cast(demo.handOfGuldan, t, true)
				end
			end

			local function actor()
				--# Executed every time the actor is available.
				--actions=call_action_list,name=off_gcd
				off_gcd()
				--actions+=/run_action_list,name=tyrant_prep,if=cooldown.summon_demonic_tyrant.remains<4&amp;!variable.tyrant_ready
				if demonic_tyrant_cd < 4 and tyrant_ready then
					tyrant_prep()
				end
				--actions+=/run_action_list,name=summon_tyrant,if=variable.tyrant_ready
				if tyrant_ready then
					summon_tyrant()
				end
				--actions+=/summon_vilefiend,if=cooldown.summon_demonic_tyrant.remains>40|time_to_die<cooldown.summon_demonic_tyrant.remains+25
				if demonic_tyrant_cd > 40 or t_ttd < demonic_tyrant_cd + 25 and shards >= 1 then
					_Cast(demo.summonVilefiend, t, true)
				end
				--actions+=/call_dreadstalkers
				if (shards >= 2 or UnitBuffID('player', demo.buffs.demonicCalling)) and _spellCooldown(demo.callDreadStalkers) <= gcd_remains then
					_Cast(demo.callDreadStalkers, t, true)
				end
				--actions+=/doom,if=refreshable
				if doomEnabled and _debuffRemains(t, demo.debuffs.doom, 'player') == 0 then
					_Cast(demo.doom, t, true)
				end
				--actions+=/demonic_strength
				if demonicStrengthEnabled and _spellCooldown(demo.demonicStrength) <= gcd_remains then
					_Cast(demo.demonicStrength, t, true)
				end
				--actions+=/bilescourge_bombers
				if bilescourgeBombersEnabled and _spellCooldown(demo.bilescourgeBombers) <= gcd_remains and shards >= 2 then
					_Cast(demo.bilescourgeBombers, t, true)
				end
				--actions+=/implosion,if=active_enemies>1&amp;!talent.sacrificed_souls.enabled&amp;buff.wild_imps.stack>=8&amp;buff.tyrant.down&amp;cooldown.summon_demonic_tyrant.remains>5
				if valid_enemies_around(t, 8) > 1 and not sacrificedSoulsEnabled and minion_count(55659) >= 3 and _buffRemains('player', demo.buffs.demonicPower) == 0 and _spellCooldown(demo.summonDemonicTyrant) > 5 then
					_Cast(demo.implosion, t, false)
				end
				--actions+=/implosion,if=active_enemies>2&amp;buff.wild_imps.stack>=8&amp;buff.tyrant.down
				if valid_enemies_around(t, 8) > 2 and minion_count(55659) >= 3 and _buffRemains('player', demo.buffs.demonicPower) == 0 then
					_Cast(demo.implosion, t, false)
				end
				--actions+=/hand_of_guldan,if=soul_shard=5|buff.nether_portal.up
				if shards == 5 or UnitBuffID('player', demo.buffs.netherPortal) and shards >= 1 then
					_Cast(demo.handOfGuldan, t, true)
				end
				--actions+=/hand_of_guldan,if=soul_shard>=3&amp;cooldown.summon_demonic_tyrant.remains>20&amp;(cooldown.summon_vilefiend.remains>5|!talent.summon_vilefiend.enabled)&amp;cooldown.call_dreadstalkers.remains>2
				if shards >= 3 and _spellCooldown(demo.summonDemonicTyrant) > 20 and (_spellCooldown(demo.summonVilefiend) > 5 or not summonVileFiendEnabled) and _spellCooldown(demo.callDreadStalkers) > 2 then
					_Cast(demo.handOfGuldan, t, true)
				end
				--actions+=/call_action_list,name=covenant,if=(covenant.necrolord|covenant.night_fae)&amp;!talent.nether_portal.enabled
				if covenant() then return true end
				--actions+=/demonbolt,if=buff.demonic_core.react&amp;soul_shard<4
				if UnitBuffID('player', demo.buffs.demonicCore) and shards < 4 then
					_Cast(demo.demonBolt, t, true)
				end
				--actions+=/grimoire_felguard,if=cooldown.summon_demonic_tyrant.remains+cooldown.summon_demonic_tyrant.duration>time_to_die|time_to_die<cooldown.summon_demonic_tyrant.remains+15
				if demonic_tyrant_cd + 90 > t_ttd or t_ttd < demonic_tyrant_cd + 15 and shards >= 1 then
					_Cast(demo.grimoireFelguard)
				end
				--actions+=/use_items
				if use_items() then return true end
				--actions+=/power_siphon,if=buff.wild_imps.stack>1&amp;buff.demonic_core.stack<3
				if powerSiphonEnabled and _spellCooldown(demo.powerSiphon) <= gcd_remains and minion_count(55659) > 1 and _buffStacks('player', demo.buffs.demonicCore) < 3 then
					_Cast(demo.powerSiphon, t, true)
				end
				--actions+=/soul_strike
				if soulStrikeEnabled and _spellCooldown(demo.soulStrike) <= gcd_remains then
					_Cast(demo.soulStrike, t, true)
				end
				--actions+=/call_action_list,name=covenant
				if covenant() then return true end
				--actions+=/shadow_bolt
				if shards ~= 5 then
					if _Cast(warlock.shadowBolt, t, true) then return true end
				end
			end
			if _valid(t) then
				if actor() then return true end
			end
		end

		--destruction
		if spec == 3 then
			--get felhunter if no pet

			-- pool shards when infernals nearly ready, pool to 4 when playing vision
			-- go for cata / maintain immo if not capped on shards
			-- pool 1 conflag charge

			-- stop casting bolt into immune targets
			-- delay on casting same ability twice

			-- add infernal key
			-- add auto cc
			-- add double coil key
			-- prioritzie bolts over immolates when important

			--maybe the best way to perform the rotation is
			--calculating how much damage we can do in a 'go' then just
			--unleashing the dick + committing to the best target in LoS
			-- ++ use shadowfury / conflag root to keep this target in LoS -- - - - - - --

			--maybe shadowfuries like cata works (if it even works lol)

			--havoc coils (check both targets are LoS before sending it)
			-- get 4x backdraft with conflag during havoc

			--dark soul before infernal good to have gcd avail

			--fear enemy that can kick you before doing a go. better to get kicked on fear.
			--after u cant fear dps with kick any more (or u have a shit ton of pressure / no shards) then fear heals

			--banish pets

			--auto infernal 3 targets when shards + shadowfury are available?z

			local time = GetTime()
			local latency = select(4,GetNetStats())/1000
			local msperframe = (2/GetFramerate())
			local buffer = latency + msperframe + .1
			local haste = UnitSpellHaste("player")
			local gcd = 1.5/(1+(haste/100))
			local hp = _HP("player")
			local mana = (100 * UnitPower("player") / UnitPowerMax("player"));
			local shards = UnitPower("player",7)
			local groupsize = GetNumGroupMembers()

			local immolate_cast_time = _castTime(destro.immolate)

			if infernal_key then
				RunMacroText("/cast [@cursor] summon infernal")
			end
			if cataclysm_key then
				RunMacroText("/cast [@cursor] cataclysm")
			end

			-- get pet
			if not UnitExists("pet") or UnitIsDeadOrGhost("pet") then
				CastSpellByID(691)
			end

			--buffs &amp; debuffs
			local backdraft = UnitBuff("player",117828)
			local backdraft_stacks = _buffStacks("player",117828)
			local backdraft_remains = _buffRemains("player",117828)

			local dark_soul = UnitBuffID("player",113858)
			local dark_soul_remains = _buffRemains("player",113858)

			--maintain demon armor
			local demon_armor = UnitBuffID("player",285933)
			if not demon_armor and IsPlayerSpell(285933) then
				_Cast(285933)
			end

			local supremacy_stacks = _buffStacks("player",266091)
			local supremacy_effect = supremacy_stacks * 8

			local conflag_charges = GetSpellCharges(17962)

			--chaotic inferno = instant incinerate azerite trait proc on bolt cast
			local chaotic_inferno = UnitBuffID("player",279673)

			--remaining infernal "x s"
			local infernals_remain = 0
			for i=1,4 do
				local totem = _G["TotemFrameTotem"..i]
				if totem:IsShown() then
					local duration_text = totem.duration:GetText()
					duration_text = duration_text:gsub(" s", "")
					local duration = tonumber(duration_text)
					if duration > infernals_remain then
						infernals_remain = duration
					end
				end
			end
			local infernals_up = infernals_remain > 0

			--CATACLYSM SPITBALLING--
			--[[ Once cata is available and two players are within 8 yards of eachother, determine the center point between them,
			then determine whether or not they will both still be within the radius of that center point after the cast time of cataclysm
			(based on moving speed &amp; direction, we already created this dynamic prediction with mage) --]]

			local valid_magic = _valid(t,2)

			local function cataclysm()
				if valid_magic and _spellCooldown(152108) <= gcd then

					local cata_targets = {}

					for i=1,#Enemies do if not unit_is_unit(Enemies[i],t) then
						local e = Enemies[i]
						if _distance(e,t) < 15 then
							table.insert(cata_targets,e)
						end
					end end

					table.insert(cata_targets,t)

					--point between all units here
					if #cata_targets >= 2 then
						local x,y,z = point_between_units(cata_targets)

						--determine whether each target will be within cata radius after cast time, otherwise eliminate them from the table
						--note: considering the way our movement prediction works, it may be best to reduce the time of prediction here,
						--maybe even increase the distance check from the centerpoint, which may 'reduce accuracy', but result in more casts.
						local prediction_time = _castTime(152108) / 3.25

						if not x or not y or not z then squid_print("Warlock: Couldn't determine position between units for cataclysm.") return false end

						for i=1,#cata_targets do
							local t = cata_targets[i]
							local tx,ty,tz = PredictUnitPosition(t,prediction_time)
							if GetDistanceBetweenPositions(tx,ty,tz,x,y,z) > 6.5 then table.remove(cata_targets,i) end
						end

						if #cata_targets >= 2 then
							_AeCastPosition(152108,x,y,z,40)
						end

					end

				end
			end

			cataclysm()

			local load_mode = lowestEnemy < 60

			--reflect
			-- if IsPlayerSpell(216890) then
			-- 	local reflect = _shouldReflect()
			-- 	if reflect then
			-- 		if _Cast(216890) then
			-- 			Squid_Alert("Reflect","("..reflect..")",2)
			-- 		end
			-- 	end
			-- end

			--maintain immolate prio
			if not infernals_up and shards <= 4 - (infernals_up and 2 or 0) then
				for i=1,#Pets do
					local e = Pets[i]
					if (UnitIsPet(e) or unit_is_player(e) or _isDummy(e)) and _debuffRemains(e,157736,"player") < 6 and magic_immunity_remains(e) < immolate_cast_time then
						_Cast(348,e,true)
					end
				end
			end

			if valid_magic then
				--priority bolts
				if shards >= 3 or infernals_up or _spellCooldown(1122) > 10 or load_mode then
					--conflag
					-- if (conflag_charges == 2 or shards <= 2) and shards <= 4 then
					-- 	_Cast(17962,t,nil,true)
					-- end
					_Cast(116858,t,true)
				end
			end

			--maintain immolate
			for i=1,#Pets do
				local e = Pets[i]
				if (UnitIsPet(e) or unit_is_player(e) or _isDummy(e)) and _debuffRemains(e,157736,"player") < 6 and magic_immunity_remains(e) < immolate_cast_time then
					_Cast(348,e,true)
				end
			end

			if valid_magic then
				if shards >= 4 then
					_Cast(116858,t,true)
				end
				--conflag
				if (conflag_charges > 1 or inferals_up or shards >= 4) and (shards >= 2 or chaotic_inferno) then
					_Cast(17962,t,nil,true)
				end
				--incinerate
				if chaotic_inferno or shards < 2 or _spellCooldown(116858) >= 1.5 then
					_Cast(29722,t,true)
				end
			end

		end




	end

	function Squid_Priest()

		if IsAoEPending() or IsMounted() or IsFlying() or UnitBuffID("player",199483) then return true end

		--General
		local time = GetTime()
		local gcd = 1.5/(1+(UnitSpellHaste("player")/100))
		local gcd_remains = GetGCD()
		local gcdMax = 1.5
		local moving = _isMoving("player")
		local totalHaste = UnitSpellHaste("player") / 100
		local latency = select(4,GetNetStats())/1000
		local inCombat = UnitAffectingCombat("player")
		local groupCheck = select(2, IsInInstance())
		local spec = GetSpecialization()
		local groupsize = GetNumGroupMembers()
		local tinsert = table.insert
		if groupsize == 0 then groupsize = 1 end

		local function healing_immune(unit)
			return UnitDebuffID(unit,33786)
			or UnitDebuffID(unit,221527)
			or UnitDebuffID(unit,217832)
			or UnitCanAttack("player",unit)
		end

		--Target Checks
		local function _valid(unit)
			if UnitExists(unit)
			and UnitCanAttack("player",unit)
			and not UnitIsDeadOrGhost(unit)
			and not _breakableCC(unit)
			and not _immuneMagic(unit)
			and (arena or UnitAffectingCombat(unit) or UnitName(unit) == "Training Dummy" or UnitIsPlayer(unit)) then
				return true
			end
		end

		--Target
		local t = current_target
		local focus = current_focus

		if UnitLevel("player") < 30 then
			no_combat_debug = true
			if _HP("player") < 60 and not UnitDebuffID("player",6788) then
				_Cast(17,"player")
			end
			if _HP("player") < 30 then
				_Cast(2061,"player")
			end
			for i=1,#Enemies do if _debuffRemains(Enemies[i],589,"player") < 4 then
				_Cast(589,Enemies[i])
			end end
			for i=1,#Enemies do
				_Cast(589,Enemies[i])
			end
			return
		end

		----------------
		-- Discipline ---
		----------------
		if spec == 1 then

			--talents
			local schism_enabled = IsPlayerSpell(214621)
			local twist_of_fate_enabled = IsPlayerSpell(265259)
			local angelic_feather_enabled = IsPlayerSpell(121536)
			local body_and_soul_enabled = IsPlayerSpell(64129)
			local solace_enabled = IsPlayerSpell(129250)
			local shining_force_enabled = IsPlayerSpell(204263)
			local masochism_enabled = IsPlayerSpell(193063)

			--pvp talents
			local dark_archangel_enabled = IsPlayerSpell(197871)
			local ultimate_radiance_enabled = IsPlayerSpell(236499)
			local trinity_enabled = IsPlayerSpell(214205)
			local searing_light_enabled = IsPlayerSpell(215768)
			local premonition_enabled = IsPlayerSpell(305498)

			--buffs
			local rapture_remains = _buffRemains("player",47536)
			local rapture_up = rapture_remains > 0
			local power_of_the_dark_side_remains = _buffRemains("player",198069)
			local potds_remains = power_of_the_dark_side_remains
			local power_of_the_dark_side = potds_remains > 0
			local potds = power_of_the_dark_side
			local preparation = UnitBuffID("player",32727)
			local masochism_remains = _buffRemains("player",193065)

			--cds
			local purify_cd = _spellCooldown(527)
			local md_cd = _spellCooldown(32375)
			local shadow_cd = _spellCooldown(605)
			local holy_cd = _spellCooldown(585)

			--cast times
			local md_cast_time = _castTime(32375)

			--stats, healing spell effects
			local mana = (100 * UnitPower("player") / UnitPowerMax("player"));
			local intellect = UnitStat("player",4)		--pws effect rapture mod
			local pws_effect = (intellect * 1.6282) * (rapture and 3 or 1)
			local sm_effect = intellect * 2.6645

			local holy_locked = _spellCooldown(585) > gcd_remains

			local fr_cast

			local player_cast,_,_,_,_,_,_,_,player_cast_id = UnitCastingInfo("player")
			local player_cast_target = UnitSpellTarget("player")
			local player_cast_time_left = _castTimeLeft("player")
			local player_cast_percent_complete = _castPctDone("player")

			--smite, schism
			local facing_required_casts = {585,214621}
			local active_dmg_casts = {585,214621,47540}

			if tContains(facing_required_casts,player_cast_id) then
				fr_cast = true
			end

			--face dest at end of cast
			if player_cast and fr_cast then
				if player_cast_time_left <= latency+.235 then
					local dest = UnitSpellTarget("player")
					--no forced facing if we're already facing
					if dest then
						FaceDirection(GetAnglesBetweenObjects("player",dest),true)
					end
				end
			end

			if player_cast and tContains(active_dmg_casts,player_cast_id) then
				local dest = UnitSpellTarget("player")
				if dest and _breakableCC(dest) then
					Squid_Alert("Stop casting dmg","(Breakable CC)",nil,nil,player_cast_id)
					SpellStopCasting()
				end
			end

			--hpdeficit
			--returns, hp missing from unit
			local function hp_deficit(unit)
				return UnitHealthMax(unit) - UnitHealth(unit)
			end

			--atonement
			--returns, up, whether atonement is up on the unit or not
			--returns, remains, how long atonement remains on the unit
			local function atonement(unit)
				local remains = _buffRemains(unit,194384,"player")
				return remains > 0 , remains
			end

			--pws
			--returns, up, whether pws is up on the unit or not
			--returns, remains, how long pws remains on the unit
			--returns, absorb, the amount of shield remaining on unit
			local function pws(unit)
				local buff,_,_,_,_,_,_,_,_,_,_,_,_,_,_,absorb = UnitBuffID(unit,17,"player")
				local remains = _buffRemains(unit,17,"player")
				return buff, remains, absorb or 0
			end

			--purge the wicked
			--returns, up, whether or not purge the wicked is up or not
			--returns, remains, how long purge the wicked remains on the unit
			local function purge_the_wicked(unit)
				local remains = _debuffRemains(unit,204213,"player")
				return remains > 0 , remains
			end

			--weakened soul
			--returns, up, whether or not the unit has weakened soul
			local function weakened_soul(unit)
				return UnitDebuffID(unit,6788,"player")
			end

			--enemies sorted
			local p_enemies = {}
			local ptw_enemies = {}
			for i=1,#Pets do
				local e = Pets[i]
				if not _breakableCC(e)
				and not _immuneMagic(e)
				and (UnitIsPlayer(e) or UnitIsPet(e) or _isDummy(e)) then

					local priority = 0

					--general
					priority = priority + (unit_is_unit(e,"target") and 1 or 0)
					priority = priority + (UnitIsPlayer(e) and 1 or 0)
					table.insert(p_enemies,{pointer = e, priority = priority, hp = _HP(e)})

					--ptw
					local up,remains = purge_the_wicked(e)
					priority = priority + (20 - remains)
					table.insert(ptw_enemies,{pointer = e, priority = priority, hp = _HP(e)})

				end
			end
			table.sort(p_enemies,function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hp < y.hp) end)
			table.sort(ptw_enemies,function(x,y) return x.priority > y.priority or (x.priority == y.priority and x.hp < y.hp) end)

			--friends sorted
			local p_friends = {}
			for i=1,#Friends do if UnitIsPlayer(Friends[i]) then
				local e = Friends[i]
				local hp = _HP(e)
				local prio = 0
				local ea = EnemiesAttacking(Friends[i])

				if hp < 50 then
					prio = hp
				else
					prio = 100 - ea
				end

				--general
				table.insert(p_friends,{pointer = e, prio = prio, hp = hp})
			end end
			table.sort(p_friends,function(x,y) return x.prio < y.prio end)

			local their_healer = theirHealer
			local their_healer_cc_remains = 0
			local their_healer_cc
			if their_healer then
				their_healer_cc_remains = _CCremains(their_healer)
				their_healer_cc = their_healer_cc_remains > 0
			elseif not arena then
				their_healer_cc = true
				their_healer_cc_remains = 3
			end

			--deaths
			if premonition_enabled then
				local death = should_death()
				if death == "wait" then
					Squid_Alert("Holding GCD for Prem",nil,nil,nil,305498)
					return
				elseif death then
					local spell = GetSpellInfo(death)
					SpellStopCasting()
					SpellStopCasting()
					if _Cast(305498) then
						Squid_Alert_Big("Premonition","("..spell..")",1,3.5,305498)
					end
				end
			end

			--purge mc
			for i=1,#Friends do
				if UnitDebuffID(Friends[i],605) then
					if _Cast(528,Friends[i]) then
						Squid_Alert_Big("Purge","(Mind Control)",1,3.5,528)
						return
					end
				end
			end

			--dispels
			for i=1,#Friends do
				local f = Friends[i]
				local purify = should_purify(f)
				if purify and _Cast(527,f) then
					Squid_Alert_Big("Dispel " .. UnitClass(f),"("..GetSpellInfo(purify)..")",nil,nil,527)
				end
			end

			--mass dispel enemies
			for i=1,#Enemies do
				local e = Enemies[i]
				if should_md(e) then
					if md_cd <= gcd and mana > 20 then
						if _AeCast(32375,e,30,28) then
							if _isMoving("player") then
								Squid_Alert_Big("Stop Moving","(Mass Dispel)",2,3,32375)
							else
								Squid_Alert("Mass Dispel " .. UnitClass(e),nil,nil,nil,32375)
							end
							return
						end
					end
				end
			end

			--mc gpy
			for i=1,#Enemies do if UnitCastingInfo(Enemies[i]) == "Greater Pyroblast" then
				if _castTimeLeft(Enemies[i]) > _castTime(605) + .5 then
					if _isMoving("player") then
						Squid_Alert_Big("Stop Moving","(Mind Control)",2,3,605)
					else
						if _Cast(605,Enemies[i],true) then
							Squid_Alert_Big("Mind Control","(Greater Pyroblast)",2,3,605)
						end
					end
				end
			end end

			--mass dispel friends
			if purify_cd > gcd_remains + md_cast_time then
				for i=1,#Friends do
					local f = Friends[i]
					local purify = should_purify(f)
					if purify then
						if md_cd <= gcd_remains and _CCremains(f) > md_cast_time+2 and mana > 20 then
							if _AeCast(32375,f,30,28) then
								if _isMoving("player") then
									Squid_Alert_Big("Stop Moving","(Mass Dispel)",2,3,32375)
								else
									Squid_Alert("Mass Dispel " .. UnitClass(f),"("..purify..")",nil,nil,32375)
								end
								return
							end
						end
					end
				end
			end

			--purge
			for i=1,#Enemies do
				local e = Enemies[i]
				local d = dispel_magic(e)
				if d and _Cast(528,e) then
					Squid_Alert("Purge","("..GetSpellInfo(d)..")",nil,nil,528)
				end
			end

			--atonements out
			local atonements_out = 0
			for i=1,#Friends do if atonement(Friends[i]) then
				atonements_out = atonements_out + 1
			end end

			--group cds with atonement
			local group_cds_atoned = 0
			for i=1,#Friends do if atonement(Friends[i]) and _CDcheck(Friends[i]) then
				group_cds_atoned = group_cds_atoned + 1
			end end

			--purge the wickeds out
			local ptw_out = 0
			for i=1,#Pets do if purge_the_wicked(Pets[i]) then
				ptw_out = ptw_out + 1
			end end

			--dark arch
			if UnitAffectingCombat("player") then
				if their_healer_cc or group_cds_atoned > 0 or lowestEnemy < 70 then
					if atonements_out == groupsize or group_cds_atoned > 0 then
						if _Cast(197871) then Squid_Alert_Big("Dark Archangel",nil,nil,nil,197871) end
					end
				end
			end

			--totem stomp
			local function Stomp(totem,name)
				local hp = UnitHealth(totem)
				local maxhp = UnitHealthMax(totem)
				if hp <= 1 then return false; end
				--ptw
				if hp <= 2000 then
					if _Cast(204197,totem,nil,true) then
						Squid_Alert_Big(name .. " Stomped","(PTW)",1,4,5221)
						return
					end
				end
			end

			local totems = {
			101398,	--Psyfiend
			119052,	--War Banner
			104818,	--Ancestral Protection Totem
			53006,	--Spirit Link Totem
			2630,	--Earthbind Totem
			60561,	--Earthgrab Totem
			-- 61245,	--Capacitor Totem (Only Whilmst Casting Brethren)
			5925,	--Grounding Totem
			105425,	--Skyfury Totem
			5913,	--Tremor Totem
			105451,	--Counterstrike Totem
			}

			if arena then
				for i=1,#Pets do
					local e = Pets[i]
					local name = UnitName(e);
					local id = UnitCreatureID(e)
					--only kill cap totems when they're casting
					if tContains(totems,id) or (id == 61245 and UnitCastingInfo(e)) then
						Stomp(e,name)
					end
				end
			end

			--ultimate radiance pw:radiance
			if ultimate_radiance_enabled then
				if _spellCooldown(194509) <= gcd_remains then
					if lowestFriend < 55 and _distance(lowestFriendName) < 40 and _LoS(lowestFriendName) then
						if _Cast(194509) then return end
					end
				end
			end

			--with trinity, maintain atonement on all party members
			if not preparation and (trinity and groupsize >= 3 or _spellCooldown(197871) < 3) then
				for i=1,#Friends do if not weakened_soul(Friends[i]) and not healing_immune(Friends[i]) then
					local f = Friends[i]
					local up,remains = atonement(f)
					if remains < gcd*groupsize then
						if _Cast(17,f) then return end
					end
				end end
			end


			--crucible (essence)
			-- if IsPlayerSpell(295373) then
				for i=1,#p_enemies do
					local e = p_enemies[i].pointer
					if not schism_enabled or UnitDebuffID(e,214621,"player") or _buffStacks("player",295378) == 0 or _HP(e) < 20 then
						if _Cast(295373,e) then return end
					end
				end
			-- end

			--pws
			if rapture_up then
				for i=1,#p_friends do
					local f = p_friends[i].pointer
					local up,remains,absorb = pws(f)
					if (not weakened_soul(f) or rapture_up) and _HP(f) < 80 and not healing_immune(f) then
						if not up or absorb < 4000 or not atonement(f) then
							if _Cast(17,f) then return end
						end
					end
				end
			end

			--enemy mage or hunter
			local mendComp
			if arena then
				for i=1,GetNumArenaOpponents() do
					if UnitIsPlayer("arena"..i) then
						local class = select(2,UnitClass("arena"..i))
						if class == "MAGE" or class == "HUNTER" or class == "ROGUE" or class == "DEMONHUNTER" or class == "DEATHKNIGHT" then
							mendComp=true
						end
					end
				end
			end

			if GetNumGroupMembers() == 3 then
				--shadow mend priority
				local mendhp = 50
				for i=1,#Enemies do if _CDcheck(Enemies[i]) then
					mendhp = mendhp + 30
				end end
				mendhp = mendhp + (mendComp and 25 or 0)
				if mendhp > 92 then mendhp = 92 end

				--shadow mend
				for i=1,#p_friends do
					local f = p_friends[i].pointer
					if _HP(f) < mendhp or holy_locked then
						if _Cast(2061,f) then return end
					end
				end
			end

			--penance to spread ptw
			for i=1,#p_enemies do
				local e = p_enemies[i].pointer
				local up,remains = purge_the_wicked(e)
				if up and Enemies_Around_Unit(e,8) > 0 then
					if _Cast(47540,e,nil,true) then return end
				end
			end

			--pws
			if not preparation then
				for i=1,#p_friends do
					local f = p_friends[i].pointer
					local up,remains,absorb = pws(f)
					if (not weakened_soul(f) or rapture_up) and _HP(f) < 85 and not healing_immune(f) then
						if not atonement(f) or (_HP(f) < 80 and EnemiesAttacking(f) > 0 and absorb < pws_effect / 3) then
							if _Cast(17,f) then return end
						end
					end
				end
			end

			--shadowfiend
			if (their_healer_cc or lowestEnemy < 70 or not arena) and _spellCooldown(34433) <= gcd_remains then
				for i=1,#p_enemies do
					local e = p_enemies[i].pointer
					if UnitEnemiesAttacking(e) > 0 then
						if _Cast(34433,e) then Squid_Alert("Shadowfiend",nil,nil,nil,34433) return end
					end
				end
			end

			--118699

			--schism prio
			if _valid(t) and _spellChargeFrac(295373) >= .88 then
				if _Cast(214621,t,true) then Squid_Alert("Schism",nil,nil,nil,214621) return end
			end

			--masochism shadow mends
			if masochism_enabled and _spellCooldown(605) <= gcd_remains then
				if _HP("player") < 65 or masochism_remains < 3 then
					if EnemiesAttacking("player") > 0 or _HP("player") < 45 then
						if _Cast(2061,"player") then return end
					end
				end
			end

			--solace on cd
			if solace_enabled then
				for i=1,#p_enemies do
					local e = p_enemies[i].pointer
					if _Cast(129250,e,nil,true) then return end
				end
			end

			--cast shadow when locked in holy
			if holy_cd > gcd_remains then
				--schism
				if _valid(t) then
					if _Cast(214621,t,true) then Squid_Alert("Schism",nil,nil,nil,214621) return end
				end
				--autoschism team's target
				if their_healer_cc then
					for i=1,#Enemies do if UnitIsPlayer(Enemies[i]) then
						local e = Enemies[i]

					end end
				end
				--shadow mend
				for i=1,#p_friends do if UnitIsPlayer(p_friends[i]) then
					local f = p_friends[i]
					if _HP(f) < 88 then
						_Cast(2061,f)
					end
				end end
			end

			--cast holy when locked shadow
			if shadow_cd > gcd_remains then
				--penance enemies on cd
				for i=1,#p_enemies do
					local e = p_enemies[i].pointer
					if _Cast(47540,e,nil,true) then return end
				end

				--penance self
				if _HP("player") < 70 then
					if _Cast(47540,"player") then return end
				end

				--smite enemies
				for i=1,#p_enemies do
					local e = p_enemies[i].pointer
					if _Cast(585,e,true) then return end
				end

			end

			--schism
			if _valid(t) then
				if _Cast(214621,t,true) then Squid_Alert("Schism",nil,nil,nil,214621) return end
			end

			--masochism shadow mends
			if masochism_enabled then
				if _HP("player") < 65 or masochism_remains < 3 then
					if EnemiesAttacking("player") > 0 then
						if _Cast(2061,"player") then return end
					end
				end
			end

			--maintain purge the wicked on all enemies
			if ptw_out < 4 then
				for i=1,#ptw_enemies do
					local e = ptw_enemies[i].pointer
					local up,remains = purge_the_wicked(e)
					if remains < gcd * (4 - ptw_out) then
						if _Cast(204197,e,nil,true) then return end
					end
				end
			end

			--priority penance friends
			for i=1,#p_friends do if not healing_immune(p_friends[i].pointer) then
				local e = p_friends[i].pointer
				if _HP(e) < 60 or unit_is_unit(e,"player") and _HP(e) < 75 then
					if _Cast(47540,e,nil,true) then return end
				end
			end end

			-- shadow mend priority
			if _spellCooldown(585) > gcd_remains or lowestFriend <= 40 then
				for i=1,#p_friends do
					local f = p_friends[i].pointer
					if _HP(f) < 80 then
						if _Cast(2061,f) then return end
					end
				end
			end

			--penance enemies on cd
			for i=1,#p_enemies do
				local e = p_enemies[i].pointer
				if _Cast(47540,e,nil,true) then return end
			end

			--shadow mend
			for i=1,#p_friends do
				local f = p_friends[i].pointer
				if _HP(f) < 82 then
					if _Cast(2061,f) then return end
				end
			end

			--smite enemies
			for i=1,#p_enemies do
				local e = p_enemies[i].pointer
				if _Cast(585,e,true) then return end
			end

			--rebuff / buff
			for i=1,#Friends do if not UnitBuffID(Friends[i],21562,"player") and _distance(Friends[i]) < 40 and not healing_immune(Friends[i]) then
				if _Cast(21562) then
					Squid_Alert("Rebuff",nil,nil,nil,21562)
				end
			end end

		end

	end
end

local hasLoaded = false
local frame = CreateFrame("Frame")
frame:SetScript("OnUpdate",
	function()
		if (hasLoaded == false) then
			squidFn()
			hasLoaded = true
		end
	end
)
